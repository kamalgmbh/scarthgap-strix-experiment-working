From d0bbfdbfb881e5407911d84c12899bd5b442a130 Mon Sep 17 00:00:00 2001
From: Pierre Wendling <50808272+FtZPetruska@users.noreply.github.com>
Date: Thu, 1 Dec 2022 16:07:03 -0500
Subject: [PATCH 063/458] Clang-Tidy fixes (#6725)

(cherry picked from commit 3c501b963dd8f0605a6ce7978882df39ba76f9cd)
---
 include/SDL_audio.h                           |  12 +-
 include/SDL_mutex.h                           |   4 +-
 include/SDL_power.h                           |   7 +-
 include/SDL_surface.h                         |   2 +-
 src/SDL_assert.c                              |   4 +-
 src/SDL_error.c                               |   2 +-
 src/SDL_log.c                                 |  20 +-
 src/audio/SDL_audio.c                         |  59 ++++--
 src/audio/SDL_audiocvt.c                      |  45 ++---
 src/audio/SDL_audiodev.c                      |  11 +-
 src/audio/SDL_audiotypecvt.c                  |   2 +-
 src/audio/SDL_wave.c                          |   8 +-
 src/audio/alsa/SDL_alsa_audio.c               |  19 +-
 src/audio/coreaudio/SDL_coreaudio.m           |  40 ++--
 src/audio/dsp/SDL_dspaudio.c                  |   4 +-
 src/audio/jack/SDL_jackaudio.c                |  14 +-
 src/audio/pipewire/SDL_pipewire.c             |  23 +--
 src/audio/sndio/SDL_sndioaudio.c              |  35 ++--
 src/core/android/SDL_android.c                |   1 -
 src/core/linux/SDL_evdev.c                    |  12 +-
 src/core/linux/SDL_evdev_capabilities.c       |   8 +-
 src/core/linux/SDL_evdev_capabilities.h       |   8 +-
 src/core/linux/SDL_evdev_kbd.c                |  98 +++++-----
 src/core/linux/SDL_fcitx.c                    |   4 +-
 src/core/linux/SDL_ibus.c                     |  10 +-
 src/core/windows/SDL_windows.c                |   8 +-
 src/events/SDL_events.c                       | 180 +++++++++---------
 src/events/SDL_keyboard.c                     |   7 +-
 src/events/SDL_keyboard_c.h                   |   2 +-
 src/events/SDL_mouse.c                        |   2 +-
 src/events/SDL_quit.c                         |   2 +-
 src/file/SDL_rwops.c                          |   2 +-
 src/file/cocoa/SDL_rwopsbundlesupport.m       |   2 +-
 src/filesystem/unix/SDL_sysfilesystem.c       |   4 +-
 src/haptic/SDL_haptic.c                       |   9 +-
 src/haptic/android/SDL_syshaptic.c            |   5 +-
 src/haptic/darwin/SDL_syshaptic.c             |   3 +-
 src/haptic/linux/SDL_syshaptic.c              |   7 +-
 src/haptic/windows/SDL_dinputhaptic.c         |  41 ++--
 src/haptic/windows/SDL_xinputhaptic.c         |   4 +-
 src/hidapi/SDL_hidapi.c                       |  59 +++---
 src/joystick/SDL_gamecontroller.c             |  76 ++++----
 src/joystick/SDL_joystick.c                   |   6 +-
 src/joystick/darwin/SDL_iokitjoystick.c       |   5 +-
 src/joystick/hidapi/SDL_hidapi_gamecube.c     |   2 +-
 src/joystick/hidapi/SDL_hidapi_ps3.c          |  11 +-
 src/joystick/hidapi/SDL_hidapi_ps4.c          |  20 +-
 src/joystick/hidapi/SDL_hidapi_ps5.c          |  12 +-
 src/joystick/hidapi/SDL_hidapi_shield.c       |   2 +-
 src/joystick/hidapi/SDL_hidapi_steam.c        |  27 +--
 src/joystick/hidapi/SDL_hidapi_switch.c       |  23 +--
 src/joystick/hidapi/SDL_hidapi_xboxone.c      |  10 +-
 src/joystick/hidapi/SDL_hidapijoystick.c      |  10 +-
 src/joystick/iphoneos/SDL_mfijoystick.m       |  31 +--
 src/joystick/linux/SDL_sysjoystick.c          |   6 +-
 src/joystick/virtual/SDL_virtualjoystick.c    |   1 -
 src/joystick/windows/SDL_dinputjoystick.c     |  14 +-
 src/joystick/windows/SDL_rawinputjoystick.c   |   8 +-
 .../windows/SDL_windows_gaming_input.c        |   6 +-
 src/joystick/windows/SDL_windowsjoystick.c    |   6 +-
 src/joystick/windows/SDL_xinputjoystick.c     |  28 +--
 src/locale/macosx/SDL_syslocale.m             |   3 +-
 src/locale/windows/SDL_syslocale.c            |   2 +-
 src/main/windows/SDL_windows_main.c           |   4 +-
 src/misc/SDL_url.c                            |   2 -
 src/power/linux/SDL_syspower.c                |   2 +-
 src/render/SDL_render.c                       |  20 +-
 src/render/SDL_yuv_sw.c                       |   8 +-
 src/render/direct3d/SDL_render_d3d.c          |  29 +--
 src/render/direct3d11/SDL_render_d3d11.c      |  16 +-
 src/render/direct3d12/SDL_render_d3d12.c      |  18 +-
 src/render/metal/SDL_render_metal.m           |   2 +-
 src/render/opengl/SDL_render_gl.c             |  11 +-
 src/render/opengl/SDL_shaders_gl.c            |   2 +-
 src/render/opengles2/SDL_render_gles2.c       |  11 +-
 src/render/software/SDL_render_sw.c           |   8 +-
 src/render/software/SDL_rotate.c              |   2 +-
 src/render/software/SDL_triangle.c            |  27 ++-
 src/stdlib/SDL_mslibc.c                       |   4 +
 src/stdlib/SDL_string.c                       |  21 +-
 src/test/SDL_test_assert.c                    |   6 +-
 src/test/SDL_test_common.c                    | 100 +++++-----
 src/test/SDL_test_compare.c                   |  10 +-
 src/test/SDL_test_font.c                      |   2 +-
 src/test/SDL_test_harness.c                   |   6 +-
 src/test/SDL_test_log.c                       |  13 +-
 src/test/SDL_test_memory.c                    |  10 +-
 src/thread/SDL_thread.c                       |  10 +-
 src/thread/pthread/SDL_syscond.c              |   2 +-
 src/video/SDL_RLEaccel.c                      |  60 +++---
 src/video/SDL_blit.c                          |   2 +-
 src/video/SDL_blit_A.c                        |  12 +-
 src/video/SDL_blit_N.c                        |   6 +-
 src/video/SDL_bmp.c                           |  69 +++----
 src/video/SDL_egl.c                           |   2 +-
 src/video/SDL_fillrect.c                      |   2 +-
 src/video/SDL_pixels.c                        |  12 +-
 src/video/SDL_shape.c                         |  31 ++-
 src/video/SDL_video.c                         |  25 ++-
 src/video/SDL_vulkan_utils.c                  |   4 +-
 src/video/SDL_yuv.c                           |  12 +-
 src/video/android/SDL_androidmouse.c          |   2 +-
 src/video/cocoa/SDL_cocoaevents.m             |   6 +-
 src/video/cocoa/SDL_cocoakeyboard.m           |   3 +-
 src/video/cocoa/SDL_cocoametalview.m          |   3 +-
 src/video/dummy/SDL_nullframebuffer.c         |   4 +-
 src/video/kmsdrm/SDL_kmsdrmdyn.c              |   3 -
 src/video/kmsdrm/SDL_kmsdrmmouse.c            |   4 +-
 src/video/kmsdrm/SDL_kmsdrmvideo.c            |  16 +-
 .../offscreen/SDL_offscreenframebuffer.c      |   4 +-
 src/video/wayland/SDL_waylanddatamanager.c    |  33 ++--
 src/video/wayland/SDL_waylandevents.c         |  14 +-
 src/video/wayland/SDL_waylandmessagebox.c     |   2 +-
 src/video/wayland/SDL_waylandvideo.c          |   9 +-
 src/video/windows/SDL_windowsevents.c         |  17 +-
 src/video/windows/SDL_windowsframebuffer.c    |   2 +-
 src/video/windows/SDL_windowskeyboard.c       |  31 +--
 src/video/windows/SDL_windowsmessagebox.c     |   8 +-
 src/video/windows/SDL_windowsmodes.c          |   1 +
 src/video/windows/SDL_windowsmouse.c          |   4 +-
 src/video/windows/SDL_windowsshape.c          |   3 +-
 src/video/windows/SDL_windowsvulkan.c         |   2 +-
 src/video/windows/SDL_windowswindow.c         |  20 +-
 src/video/windows/SDL_windowswindow.h         |   4 +-
 src/video/x11/SDL_x11events.c                 |   8 +-
 src/video/x11/SDL_x11framebuffer.c            |  11 +-
 src/video/x11/SDL_x11keyboard.c               |  13 +-
 src/video/x11/SDL_x11messagebox.c             |   7 +-
 src/video/x11/SDL_x11modes.c                  |   2 +-
 src/video/x11/SDL_x11mouse.c                  |  10 +-
 src/video/x11/SDL_x11shape.h                  |   2 +-
 src/video/x11/SDL_x11video.c                  |   5 +-
 src/video/x11/SDL_x11window.c                 |  16 +-
 src/video/x11/SDL_x11window.h                 |   2 +-
 test/checkkeys.c                              |   2 +-
 test/checkkeysthreads.c                       |  28 ++-
 test/controllermap.c                          |  13 +-
 test/loopwavequeue.c                          |   8 +-
 test/testatomic.c                             |  12 +-
 test/testaudiohotplug.c                       |  12 +-
 test/testaudioinfo.c                          |  11 +-
 test/testautomation.c                         |   2 +-
 test/testautomation_audio.c                   |  14 +-
 test/testautomation_clipboard.c               |   8 +-
 test/testautomation_keyboard.c                |   4 +-
 test/testautomation_math.c                    |   2 +-
 test/testautomation_platform.c                |   8 +-
 test/testautomation_rect.c                    |  28 +--
 test/testautomation_rwops.c                   |  10 +-
 test/testautomation_sdltest.c                 |  55 +++---
 test/testautomation_stdlib.c                  |   2 +-
 test/testautomation_video.c                   |   6 +-
 test/testcustomcursor.c                       |   5 +-
 test/testdisplayinfo.c                        |   2 +-
 test/testfile.c                               |  16 +-
 test/testgamecontroller.c                     |   2 +-
 test/testgles2.c                              |   2 +-
 test/testiconv.c                              |   4 +-
 test/testime.c                                |  43 +++--
 test/testintersections.c                      |  16 +-
 test/testloadso.c                             |   2 -
 test/testlock.c                               |  20 +-
 test/testmultiaudio.c                         |   1 -
 test/testnative.c                             |   2 +-
 test/testoverlay2.c                           |   1 +
 test/testpower.c                              |   3 +-
 test/testqsort.c                              |   5 +-
 test/testresample.c                           |   2 +-
 test/testsem.c                                |  16 +-
 test/testsensor.c                             |   2 +-
 test/testshader.c                             |   6 +-
 test/testshape.c                              |   4 +-
 test/testthread.c                             |   4 +-
 test/testutils.c                              |   2 +-
 test/testvulkan.c                             |   4 +-
 test/testwm2.c                                |   8 +-
 test/testyuv.c                                |   2 +-
 test/testyuv_cvt.c                            |   2 +-
 test/torturethread.c                          |   6 +-
 179 files changed, 1259 insertions(+), 1100 deletions(-)

diff --git a/include/SDL_audio.h b/include/SDL_audio.h
index c42de3ed9..4b2147bb8 100644
--- a/include/SDL_audio.h
+++ b/include/SDL_audio.h
@@ -1008,12 +1008,12 @@ typedef struct _SDL_AudioStream SDL_AudioStream;
  * \sa SDL_AudioStreamClear
  * \sa SDL_FreeAudioStream
  */
-extern DECLSPEC SDL_AudioStream * SDLCALL SDL_NewAudioStream(const SDL_AudioFormat src_format,
-                                           const Uint8 src_channels,
-                                           const int src_rate,
-                                           const SDL_AudioFormat dst_format,
-                                           const Uint8 dst_channels,
-                                           const int dst_rate);
+extern DECLSPEC SDL_AudioStream *SDLCALL SDL_NewAudioStream(SDL_AudioFormat src_format,
+                                                            Uint8 src_channels,
+                                                            int src_rate,
+                                                            SDL_AudioFormat dst_format,
+                                                            Uint8 dst_channels,
+                                                            int dst_rate);
 
 /**
  * Add data to be converted/resampled to the stream.
diff --git a/include/SDL_mutex.h b/include/SDL_mutex.h
index 173468f6a..d4d55a4bf 100644
--- a/include/SDL_mutex.h
+++ b/include/SDL_mutex.h
@@ -276,7 +276,7 @@ extern DECLSPEC int SDLCALL SDL_SemTryWait(SDL_sem * sem);
  * successful it will atomically decrement the semaphore value.
  *
  * \param sem the semaphore to wait on
- * \param ms the length of the timeout, in milliseconds
+ * \param timeout the length of the timeout, in milliseconds
  * \returns 0 if the wait succeeds, `SDL_MUTEX_TIMEDOUT` if the wait does not
  *          succeed in the allotted time, or a negative error code on failure;
  *          call SDL_GetError() for more information.
@@ -290,7 +290,7 @@ extern DECLSPEC int SDLCALL SDL_SemTryWait(SDL_sem * sem);
  * \sa SDL_SemValue
  * \sa SDL_SemWait
  */
-extern DECLSPEC int SDLCALL SDL_SemWaitTimeout(SDL_sem * sem, Uint32 ms);
+extern DECLSPEC int SDLCALL SDL_SemWaitTimeout(SDL_sem *sem, Uint32 timeout);
 
 /**
  * Atomically increment a semaphore's value and wake waiting threads.
diff --git a/include/SDL_power.h b/include/SDL_power.h
index ecb3f4b02..09684e98a 100644
--- a/include/SDL_power.h
+++ b/include/SDL_power.h
@@ -48,7 +48,6 @@ typedef enum
     SDL_POWERSTATE_CHARGED       /**< Plugged in, battery charged */
 } SDL_PowerState;
 
-
 /**
  * Get the current power supply details.
  *
@@ -65,17 +64,17 @@ typedef enum
  * It's possible a platform can only report battery percentage or time left
  * but not both.
  *
- * \param secs seconds of battery life left, you can pass a NULL here if you
+ * \param seconds seconds of battery life left, you can pass a NULL here if you
  *             don't care, will return -1 if we can't determine a value, or
  *             we're not running on a battery
- * \param pct percentage of battery life left, between 0 and 100, you can pass
+ * \param percent percentage of battery life left, between 0 and 100, you can pass
  *            a NULL here if you don't care, will return -1 if we can't
  *            determine a value, or we're not running on a battery
  * \returns an SDL_PowerState enum representing the current battery state.
  *
  * \since This function is available since SDL 2.0.0.
  */
-extern DECLSPEC SDL_PowerState SDLCALL SDL_GetPowerInfo(int *secs, int *pct);
+extern DECLSPEC SDL_PowerState SDLCALL SDL_GetPowerInfo(int *seconds, int *percent);
 
 /* Ends C function definitions when using C++ */
 #ifdef __cplusplus
diff --git a/include/SDL_surface.h b/include/SDL_surface.h
index 838de654e..561b2be18 100644
--- a/include/SDL_surface.h
+++ b/include/SDL_surface.h
@@ -683,7 +683,7 @@ extern DECLSPEC SDL_Surface *SDLCALL SDL_ConvertSurface
  * it might be easier to call but it doesn't have access to palette
  * information for the destination surface, in case that would be important.
  *
- * \param src the existing SDL_Surface structure to convert
+ * \param surface the existing SDL_Surface structure to convert
  * \param pixel_format the SDL_PixelFormatEnum that the new surface is
  *                     optimized for
  * \param flags the flags are unused and should be set to 0; this is a
diff --git a/src/SDL_assert.c b/src/SDL_assert.c
index c4ca82407..a689a550b 100644
--- a/src/SDL_assert.c
+++ b/src/SDL_assert.c
@@ -288,8 +288,8 @@ static SDL_assert_state SDLCALL SDL_PromptAssertion(const SDL_assert_data *data,
         /* this is a little hacky. */
         for (;;) {
             char buf[32];
-            fprintf(stderr, "Abort/Break/Retry/Ignore/AlwaysIgnore? [abriA] : ");
-            fflush(stderr);
+            (void)fprintf(stderr, "Abort/Break/Retry/Ignore/AlwaysIgnore? [abriA] : ");
+            (void)fflush(stderr);
             if (fgets(buf, sizeof(buf), stdin) == NULL) {
                 break;
             }
diff --git a/src/SDL_error.c b/src/SDL_error.c
index be3160c5d..fc9a490c6 100644
--- a/src/SDL_error.c
+++ b/src/SDL_error.c
@@ -46,7 +46,7 @@ int SDL_SetError(SDL_PRINTF_FORMAT_STRING const char *fmt, ...)
                 error->str = str;
                 error->len = len;
                 va_start(ap, fmt);
-                SDL_vsnprintf(error->str, error->len, fmt, ap);
+                (void)SDL_vsnprintf(error->str, error->len, fmt, ap);
                 va_end(ap);
             }
         }
diff --git a/src/SDL_log.c b/src/SDL_log.c
index 59f763820..e9199cc2e 100644
--- a/src/SDL_log.c
+++ b/src/SDL_log.c
@@ -415,7 +415,7 @@ static void SDLCALL SDL_LogOutput(void *userdata, int category, SDL_LogPriority
 
         length = SDL_strlen(SDL_priority_prefixes[priority]) + 2 + SDL_strlen(message) + 1 + 1 + 1;
         output = SDL_small_alloc(char, length, &isstack);
-        SDL_snprintf(output, length, "%s: %s\r\n", SDL_priority_prefixes[priority], message);
+        (void)SDL_snprintf(output, length, "%s: %s\r\n", SDL_priority_prefixes[priority], message);
         tstr = WIN_UTF8ToString(output);
 
         /* Output to debugger */
@@ -460,22 +460,28 @@ static void SDLCALL SDL_LogOutput(void *userdata, int category, SDL_LogPriority
     {
         FILE *pFile;
         pFile = fopen("SDL_Log.txt", "a");
-        fprintf(pFile, "%s: %s\n", SDL_priority_prefixes[priority], message);
-        fclose(pFile);
+        if (pFile != NULL) {
+            (void)fprintf(pFile, "%s: %s\n", SDL_priority_prefixes[priority], message);
+            (void)fclose(pFile);
+        }
     }
 #elif defined(__VITA__)
     {
         FILE *pFile;
         pFile = fopen("ux0:/data/SDL_Log.txt", "a");
-        fprintf(pFile, "%s: %s\n", SDL_priority_prefixes[priority], message);
-        fclose(pFile);
+        if (pFile != NULL) {
+            (void)fprintf(pFile, "%s: %s\n", SDL_priority_prefixes[priority], message);
+            (void)fclose(pFile);
+        }
     }
 #elif defined(__3DS__)
     {
         FILE *pFile;
         pFile = fopen("sdmc:/3ds/SDL_Log.txt", "a");
-        fprintf(pFile, "%s: %s\n", SDL_priority_prefixes[priority], message);
-        fclose(pFile);
+        if (pFile != NULL) {
+            (void)fprintf(pFile, "%s: %s\n", SDL_priority_prefixes[priority], message);
+            (void)fclose(pFile);
+        }
     }
 #endif
 #if HAVE_STDIO_H && \
diff --git a/src/audio/SDL_audio.c b/src/audio/SDL_audio.c
index 52ed79271..959ce0d7a 100644
--- a/src/audio/SDL_audio.c
+++ b/src/audio/SDL_audio.c
@@ -394,7 +394,7 @@ static int add_audio_device(const char *name, SDL_AudioSpec *spec, void *handle,
             return SDL_OutOfMemory();
         }
 
-        SDL_snprintf(replacement, len, "%s (%d)", name, dupenum + 1);
+        (void)SDL_snprintf(replacement, len, "%s (%d)", name, dupenum + 1);
         item->dupenum = dupenum;
         item->name = replacement;
     }
@@ -658,6 +658,10 @@ void SDL_ClearQueuedAudio(SDL_AudioDeviceID devid)
     current_audio.impl.UnlockDevice(device);
 }
 
+#if SDL_AUDIO_DRIVER_ANDROID
+extern void Android_JNI_AudioSetThreadPriority(int, int);
+#endif
+
 /* The general mixing thread function */
 static int SDLCALL SDL_RunAudio(void *devicep)
 {
@@ -672,7 +676,6 @@ static int SDLCALL SDL_RunAudio(void *devicep)
 #if SDL_AUDIO_DRIVER_ANDROID
     {
         /* Set thread priority to THREAD_PRIORITY_AUDIO */
-        extern void Android_JNI_AudioSetThreadPriority(int, int);
         Android_JNI_AudioSetThreadPriority(device->iscapture, device->id);
     }
 #else
@@ -773,7 +776,6 @@ static int SDLCALL SDL_CaptureAudio(void *devicep)
 #if SDL_AUDIO_DRIVER_ANDROID
     {
         /* Set thread priority to THREAD_PRIORITY_AUDIO */
-        extern void Android_JNI_AudioSetThreadPriority(int, int);
         Android_JNI_AudioSetThreadPriority(device->iscapture, device->id);
     }
 #else
@@ -1187,6 +1189,19 @@ static void close_audio_device(SDL_AudioDevice *device)
     SDL_free(device);
 }
 
+static Uint16
+GetDefaultSamplesFromFreq(int freq)
+{
+    /* Pick a default of ~46 ms at desired frequency */
+    /* !!! FIXME: remove this when the non-Po2 resampling is in. */
+    const Uint16 max_sample = (freq / 1000) * 46;
+    Uint16 current_sample = 1;
+    while (current_sample < max_sample) {
+        current_sample *= 2;
+    }
+    return current_sample;
+}
+
 /*
  * Sanity check desired AudioSpec for SDL_OpenAudio() in (orig).
  *  Fills in a sanitized copy in (prepared).
@@ -1197,23 +1212,33 @@ static int prepare_audiospec(const SDL_AudioSpec *orig, SDL_AudioSpec *prepared)
     SDL_copyp(prepared, orig);
 
     if (orig->freq == 0) {
+        static const int DEFAULT_FREQ = 22050;
         const char *env = SDL_getenv("SDL_AUDIO_FREQUENCY");
-        if ((!env) || ((prepared->freq = SDL_atoi(env)) == 0)) {
-            prepared->freq = 22050; /* a reasonable default */
+        if (env != NULL) {
+            int freq = SDL_atoi(env);
+            prepared->freq = freq != 0 ? freq : DEFAULT_FREQ;
+        } else {
+            prepared->freq = DEFAULT_FREQ;
         }
     }
 
     if (orig->format == 0) {
         const char *env = SDL_getenv("SDL_AUDIO_FORMAT");
-        if ((!env) || ((prepared->format = SDL_ParseAudioFormat(env)) == 0)) {
-            prepared->format = AUDIO_S16; /* a reasonable default */
+        if (env != NULL) {
+            const SDL_AudioFormat format = SDL_ParseAudioFormat(env);
+            prepared->format = format != 0 ? format : AUDIO_S16;
+        } else {
+            prepared->format = AUDIO_S16;
         }
     }
 
     if (orig->channels == 0) {
         const char *env = SDL_getenv("SDL_AUDIO_CHANNELS");
-        if ((!env) || ((prepared->channels = (Uint8)SDL_atoi(env)) == 0)) {
-            prepared->channels = 2; /* a reasonable default */
+        if (env != NULL) {
+            Uint8 channels = (Uint8)SDL_atoi(env);
+            prepared->channels = channels != 0 ? channels : 2;
+        } else {
+            prepared->channels = 2;
         }
     } else if (orig->channels > 8) {
         SDL_SetError("Unsupported number of audio channels.");
@@ -1222,15 +1247,11 @@ static int prepare_audiospec(const SDL_AudioSpec *orig, SDL_AudioSpec *prepared)
 
     if (orig->samples == 0) {
         const char *env = SDL_getenv("SDL_AUDIO_SAMPLES");
-        if ((!env) || ((prepared->samples = (Uint16)SDL_atoi(env)) == 0)) {
-            /* Pick a default of ~46 ms at desired frequency */
-            /* !!! FIXME: remove this when the non-Po2 resampling is in. */
-            const int samples = (prepared->freq / 1000) * 46;
-            int power2 = 1;
-            while (power2 < samples) {
-                power2 *= 2;
-            }
-            prepared->samples = power2;
+        if (env != NULL) {
+            Uint16 samples = (Uint16)SDL_atoi(env);
+            prepared->samples = samples != 0 ? samples : GetDefaultSamplesFromFreq(prepared->freq);
+        } else {
+            prepared->samples = GetDefaultSamplesFromFreq(prepared->freq);
         }
     }
 
@@ -1488,7 +1509,7 @@ static SDL_AudioDeviceID open_audio_device(const char *devname, int iscapture,
         const size_t stacksize = is_internal_thread ? 64 * 1024 : 0;
         char threadname[64];
 
-        SDL_snprintf(threadname, sizeof(threadname), "SDLAudio%c%d", (iscapture) ? 'C' : 'P', (int)device->id);
+        (void)SDL_snprintf(threadname, sizeof threadname, "SDLAudio%c%" SDL_PRIu32, (iscapture) ? 'C' : 'P', device->id);
         device->thread = SDL_CreateThreadInternal(iscapture ? SDL_CaptureAudio : SDL_RunAudio, threadname, stacksize, device);
 
         if (device->thread == NULL) {
diff --git a/src/audio/SDL_audiocvt.c b/src/audio/SDL_audiocvt.c
index b0a8a7072..a687aec19 100644
--- a/src/audio/SDL_audiocvt.c
+++ b/src/audio/SDL_audiocvt.c
@@ -208,7 +208,7 @@ static int SDL_ResampleAudio(const int chans, const int inrate, const int outrat
     const int paddinglen = ResamplerPadding(inrate, outrate);
     const int framelen = chans * (int)sizeof(float);
     const int inframes = inbuflen / framelen;
-    const int wantedoutframes = (int)((inbuflen / framelen) * ratio); /* outbuflen isn't total to write, it's total available. */
+    const int wantedoutframes = (int)(inframes * ratio); /* outbuflen isn't total to write, it's total available. */
     const int maxoutframes = outbuflen / framelen;
     const int outframes = SDL_min(wantedoutframes, maxoutframes);
     ResampleFloatType outtime = 0.0f;
@@ -233,7 +233,7 @@ static int SDL_ResampleAudio(const int chans, const int inrate, const int outrat
                 const int srcframe = srcindex - j;
                 /* !!! FIXME: we can bubble this conditional out of here by doing a pre loop. */
                 const float insample = (srcframe < 0) ? lpadding[((paddinglen + srcframe) * chans) + chan] : inbuf[(srcframe * chans) + chan];
-                outsample += (float)(insample * (ResamplerFilter[filterindex1 + (j * RESAMPLER_SAMPLES_PER_ZERO_CROSSING)] + (interpolation1 * ResamplerFilterDifference[filterindex1 + (j * RESAMPLER_SAMPLES_PER_ZERO_CROSSING)])));
+                outsample += (insample * (ResamplerFilter[filterindex1 + (j * RESAMPLER_SAMPLES_PER_ZERO_CROSSING)] + (interpolation1 * ResamplerFilterDifference[filterindex1 + (j * RESAMPLER_SAMPLES_PER_ZERO_CROSSING)])));
             }
 
             /* Do the right wing! */
@@ -242,7 +242,7 @@ static int SDL_ResampleAudio(const int chans, const int inrate, const int outrat
                 const int srcframe = srcindex + 1 + j;
                 /* !!! FIXME: we can bubble this conditional out of here by doing a post loop. */
                 const float insample = (srcframe >= inframes) ? rpadding[((srcframe - inframes) * chans) + chan] : inbuf[(srcframe * chans) + chan];
-                outsample += (float)(insample * (ResamplerFilter[filterindex2 + jsamples] + (interpolation2 * ResamplerFilterDifference[filterindex2 + jsamples])));
+                outsample += (insample * (ResamplerFilter[filterindex2 + jsamples] + (interpolation2 * ResamplerFilterDifference[filterindex2 + jsamples])));
             }
 
             *(dst++) = outsample;
@@ -316,7 +316,7 @@ static void SDLCALL SDL_Convert_Byteswap(SDL_AudioCVT *cvt, SDL_AudioFormat form
     }
 }
 
-static int SDL_AddAudioCVTFilter(SDL_AudioCVT *cvt, const SDL_AudioFilter filter)
+static int SDL_AddAudioCVTFilter(SDL_AudioCVT *cvt, SDL_AudioFilter filter)
 {
     if (cvt->filter_index >= SDL_AUDIOCVT_MAX_FILTERS) {
         return SDL_SetError("Too many filters needed for conversion, exceeded maximum of %d", SDL_AUDIOCVT_MAX_FILTERS);
@@ -376,7 +376,8 @@ static int SDL_BuildAudioTypeCVTToFloat(SDL_AudioCVT *cvt, const SDL_AudioFormat
             cvt->len_mult *= mult;
             cvt->len_ratio *= mult;
         } else if (src_bitsize > dst_bitsize) {
-            cvt->len_ratio /= (src_bitsize / dst_bitsize);
+            const int div = (src_bitsize / dst_bitsize);
+            cvt->len_ratio /= div;
         }
 
         retval = 1; /* added a converter. */
@@ -674,8 +675,8 @@ static SDL_bool SDL_SupportedChannelCount(const int channels)
 */
 
 int SDL_BuildAudioCVT(SDL_AudioCVT *cvt,
-                      SDL_AudioFormat src_fmt, Uint8 src_channels, int src_rate,
-                      SDL_AudioFormat dst_fmt, Uint8 dst_channels, int dst_rate)
+                      SDL_AudioFormat src_format, Uint8 src_channels, int src_rate,
+                      SDL_AudioFormat dst_format, Uint8 dst_channels, int dst_rate)
 {
     SDL_AudioFilter channel_converter = NULL;
 
@@ -687,10 +688,10 @@ int SDL_BuildAudioCVT(SDL_AudioCVT *cvt,
     /* Make sure we zero out the audio conversion before error checking */
     SDL_zerop(cvt);
 
-    if (!SDL_SupportedAudioFormat(src_fmt)) {
+    if (!SDL_SupportedAudioFormat(src_format)) {
         return SDL_SetError("Invalid source format");
     }
-    if (!SDL_SupportedAudioFormat(dst_fmt)) {
+    if (!SDL_SupportedAudioFormat(dst_format)) {
         return SDL_SetError("Invalid destination format");
     }
     if (!SDL_SupportedChannelCount(src_channels)) {
@@ -714,12 +715,12 @@ int SDL_BuildAudioCVT(SDL_AudioCVT *cvt,
 
 #if DEBUG_CONVERT
     SDL_Log("SDL_AUDIO_CONVERT: Build format %04x->%04x, channels %u->%u, rate %d->%d\n",
-            src_fmt, dst_fmt, src_channels, dst_channels, src_rate, dst_rate);
+            src_format, dst_format, src_channels, dst_channels, src_rate, dst_rate);
 #endif
 
     /* Start off with no conversion necessary */
-    cvt->src_format = src_fmt;
-    cvt->dst_format = dst_fmt;
+    cvt->src_format = src_format;
+    cvt->dst_format = dst_format;
     cvt->needed = 0;
     cvt->filter_index = 0;
     SDL_zeroa(cvt->filters);
@@ -746,13 +747,13 @@ int SDL_BuildAudioCVT(SDL_AudioCVT *cvt,
 
     /* see if we can skip float conversion entirely. */
     if (src_rate == dst_rate && src_channels == dst_channels) {
-        if (src_fmt == dst_fmt) {
+        if (src_format == dst_format) {
             return 0;
         }
 
         /* just a byteswap needed? */
-        if ((src_fmt & ~SDL_AUDIO_MASK_ENDIAN) == (dst_fmt & ~SDL_AUDIO_MASK_ENDIAN)) {
-            if (SDL_AUDIO_BITSIZE(dst_fmt) == 8) {
+        if ((src_format & ~SDL_AUDIO_MASK_ENDIAN) == (dst_format & ~SDL_AUDIO_MASK_ENDIAN)) {
+            if (SDL_AUDIO_BITSIZE(dst_format) == 8) {
                 return 0;
             }
             if (SDL_AddAudioCVTFilter(cvt, SDL_Convert_Byteswap) < 0) {
@@ -764,7 +765,7 @@ int SDL_BuildAudioCVT(SDL_AudioCVT *cvt,
     }
 
     /* Convert data types, if necessary. Updates (cvt). */
-    if (SDL_BuildAudioTypeCVTToFloat(cvt, src_fmt) < 0) {
+    if (SDL_BuildAudioTypeCVTToFloat(cvt, src_format) < 0) {
         return -1; /* shouldn't happen, but just in case... */
     }
 
@@ -820,7 +821,7 @@ int SDL_BuildAudioCVT(SDL_AudioCVT *cvt,
     }
 
     /* Move to final data type. */
-    if (SDL_BuildAudioTypeCVTFromFloat(cvt, dst_fmt) < 0) {
+    if (SDL_BuildAudioTypeCVTFromFloat(cvt, dst_format) < 0) {
         return -1; /* shouldn't happen, but just in case... */
     }
 
@@ -862,7 +863,7 @@ struct _SDL_AudioStream
     SDL_CleanupAudioStreamResamplerFunc cleanup_resampler_func;
 };
 
-static Uint8 *EnsureStreamBufferSize(SDL_AudioStream *stream, const int newlen)
+static Uint8 *EnsureStreamBufferSize(SDL_AudioStream *stream, int newlen)
 {
     Uint8 *ptr;
     size_t offset;
@@ -870,7 +871,7 @@ static Uint8 *EnsureStreamBufferSize(SDL_AudioStream *stream, const int newlen)
     if (stream->work_buffer_len >= newlen) {
         ptr = stream->work_buffer_base;
     } else {
-        ptr = (Uint8 *)SDL_realloc(stream->work_buffer_base, newlen + 32);
+        ptr = (Uint8 *)SDL_realloc(stream->work_buffer_base, (size_t)newlen + 32);
         if (ptr == NULL) {
             SDL_OutOfMemory();
             return NULL;
@@ -1006,7 +1007,7 @@ SDL_NewAudioStream(const SDL_AudioFormat src_format,
                    const Uint8 dst_channels,
                    const int dst_rate)
 {
-    const int packetlen = 4096; /* !!! FIXME: good enough for now. */
+    int packetlen = 4096; /* !!! FIXME: good enough for now. */
     Uint8 pre_resample_channels;
     SDL_AudioStream *retval;
 
@@ -1092,7 +1093,7 @@ SDL_NewAudioStream(const SDL_AudioFormat src_format,
         }
     }
 
-    retval->queue = SDL_NewDataQueue(packetlen, packetlen * 2);
+    retval->queue = SDL_NewDataQueue(packetlen, (size_t)packetlen * 2);
     if (!retval->queue) {
         SDL_FreeAudioStream(retval);
         return NULL; /* SDL_NewDataQueue should have called SDL_SetError. */
@@ -1384,7 +1385,7 @@ void SDL_AudioStreamClear(SDL_AudioStream *stream)
     if (stream == NULL) {
         SDL_InvalidParamError("stream");
     } else {
-        SDL_ClearDataQueue(stream->queue, stream->packetlen * 2);
+        SDL_ClearDataQueue(stream->queue, (size_t)stream->packetlen * 2);
         if (stream->reset_resampler_func) {
             stream->reset_resampler_func(stream);
         }
diff --git a/src/audio/SDL_audiodev.c b/src/audio/SDL_audiodev.c
index d5c61d84d..930e900a7 100644
--- a/src/audio/SDL_audiodev.c
+++ b/src/audio/SDL_audiodev.c
@@ -86,8 +86,11 @@ static void SDL_EnumUnixAudioDevices_Internal(const int iscapture, const int cla
     }
 
     /* Figure out what our audio device is */
-    if (((audiodev = SDL_getenv("SDL_PATH_DSP")) == NULL) &&
-        ((audiodev = SDL_getenv("AUDIODEV")) == NULL)) {
+    audiodev = SDL_getenv("SDL_PATH_DSP");
+    if (audiodev == NULL) {
+        audiodev = SDL_getenv("AUDIODEV");
+    }
+    if (audiodev == NULL) {
         if (classic) {
             audiodev = _PATH_DEV_AUDIO;
         } else {
@@ -106,8 +109,8 @@ static void SDL_EnumUnixAudioDevices_Internal(const int iscapture, const int cla
     if (SDL_strlen(audiodev) < (sizeof(audiopath) - 3)) {
         int instance = 0;
         while (instance <= 64) {
-            SDL_snprintf(audiopath, SDL_arraysize(audiopath),
-                         "%s%d", audiodev, instance);
+            (void)SDL_snprintf(audiopath, SDL_arraysize(audiopath),
+                               "%s%d", audiodev, instance);
             instance++;
             test_device(iscapture, audiopath, flags, test);
         }
diff --git a/src/audio/SDL_audiotypecvt.c b/src/audio/SDL_audiotypecvt.c
index 75eb5f45b..d8c224ab8 100644
--- a/src/audio/SDL_audiotypecvt.c
+++ b/src/audio/SDL_audiotypecvt.c
@@ -1198,7 +1198,7 @@ static void SDLCALL SDL_Convert_F32_to_S8_NEON(SDL_AudioCVT *cvt, SDL_AudioForma
 static void SDLCALL SDL_Convert_F32_to_U8_NEON(SDL_AudioCVT *cvt, SDL_AudioFormat format)
 {
     const float *src = (const float *)cvt->buf;
-    Uint8 *dst = (Uint8 *)cvt->buf;
+    Uint8 *dst = cvt->buf;
     int i;
 
     LOG_DEBUG_CONVERT("AUDIO_F32", "AUDIO_U8 (using NEON)");
diff --git a/src/audio/SDL_wave.c b/src/audio/SDL_wave.c
index a9c0dc2a1..bb517a840 100644
--- a/src/audio/SDL_wave.c
+++ b/src/audio/SDL_wave.c
@@ -549,20 +549,20 @@ static int MS_ADPCM_DecodeBlockHeader(ADPCM_DecoderState *state)
         cstate[c].coeff2 = ddata->coeff[coeffindex * 2 + 1];
 
         /* Initial delta value. */
-        o = channels + c * 2;
+        o = (size_t)channels + c * 2;
         cstate[c].delta = state->block.data[o] | ((Uint16)state->block.data[o + 1] << 8);
 
         /* Load the samples from the header. Interestingly, the sample later in
          * the output stream comes first.
          */
-        o = channels * 3 + c * 2;
+        o = (size_t)channels * 3 + c * 2;
         sample = state->block.data[o] | ((Sint32)state->block.data[o + 1] << 8);
         if (sample >= 0x8000) {
             sample -= 0x10000;
         }
         state->output.data[state->output.pos + channels] = (Sint16)sample;
 
-        o = channels * 5 + c * 2;
+        o = (size_t)channels * 5 + c * 2;
         sample = state->block.data[o] | ((Sint32)state->block.data[o + 1] << 8);
         if (sample >= 0x8000) {
             sample -= 0x10000;
@@ -965,7 +965,7 @@ static int IMA_ADPCM_DecodeBlockData(ADPCM_DecoderState *state)
     size_t i;
     int retval = 0;
     const Uint32 channels = state->channels;
-    const size_t subblockframesize = channels * 4;
+    const size_t subblockframesize = (size_t)channels * 4;
     Uint64 bytesrequired;
     Uint32 c;
 
diff --git a/src/audio/alsa/SDL_alsa_audio.c b/src/audio/alsa/SDL_alsa_audio.c
index 0d3a57813..d93abb0b9 100644
--- a/src/audio/alsa/SDL_alsa_audio.c
+++ b/src/audio/alsa/SDL_alsa_audio.c
@@ -379,8 +379,9 @@ static void ALSA_PlayDevice(_THIS)
             status = ALSA_snd_pcm_recover(this->hidden->pcm_handle, status, 0);
             if (status < 0) {
                 /* Hmm, not much we can do - abort */
-                fprintf(stderr, "ALSA write failed (unrecoverable): %s\n",
-                        ALSA_snd_strerror(status));
+                SDL_LogError(SDL_LOG_CATEGORY_AUDIO,
+                             "ALSA write failed (unrecoverable): %s\n",
+                             ALSA_snd_strerror(status));
                 SDL_OpenedAudioDeviceDisconnected(this);
                 return;
             }
@@ -427,8 +428,9 @@ static int ALSA_CaptureFromDevice(_THIS, void *buffer, int buflen)
             status = ALSA_snd_pcm_recover(this->hidden->pcm_handle, status, 0);
             if (status < 0) {
                 /* Hmm, not much we can do - abort */
-                fprintf(stderr, "ALSA read failed (unrecoverable): %s\n",
-                        ALSA_snd_strerror(status));
+                SDL_LogError(SDL_LOG_CATEGORY_AUDIO,
+                             "ALSA read failed (unrecoverable): %s\n",
+                             ALSA_snd_strerror(status));
                 return -1;
             }
             continue;
@@ -511,9 +513,9 @@ static int ALSA_set_buffer_size(_THIS, snd_pcm_hw_params_t *params)
 
         ALSA_snd_pcm_hw_params_get_buffer_size(hwparams, &bufsize);
 
-        fprintf(stderr,
-                "ALSA: period size = %ld, periods = %u, buffer size = %lu\n",
-                persize, periods, bufsize);
+        SDL_LogError(SDL_LOG_CATEGORY_AUDIO,
+                     "ALSA: period size = %ld, periods = %u, buffer size = %lu\n",
+                     persize, periods, bufsize);
     }
 
     return 0;
@@ -739,7 +741,8 @@ static void add_device(const int iscapture, const char *name, void *hint, ALSA_D
     /* some strings have newlines, like "HDA NVidia, HDMI 0\nHDMI Audio Output".
        just chop the extra lines off, this seems to get a reasonable device
        name without extra details. */
-    if ((ptr = SDL_strchr(desc, '\n')) != NULL) {
+    ptr = SDL_strchr(desc, '\n');
+    if (ptr != NULL) {
         *ptr = '\0';
     }
 
diff --git a/src/audio/coreaudio/SDL_coreaudio.m b/src/audio/coreaudio/SDL_coreaudio.m
index 3ef0a7f79..9e35fefbb 100644
--- a/src/audio/coreaudio/SDL_coreaudio.m
+++ b/src/audio/coreaudio/SDL_coreaudio.m
@@ -102,17 +102,20 @@ static void build_device_list(int iscapture, addDevFn addfn, void *addfndata)
 
     result = AudioObjectGetPropertyDataSize(kAudioObjectSystemObject,
                                             &devlist_address, 0, NULL, &size);
-    if (result != kAudioHardwareNoError)
+    if (result != kAudioHardwareNoError) {
         return;
+    }
 
     devs = (AudioDeviceID *)alloca(size);
-    if (devs == NULL)
+    if (devs == NULL) {
         return;
+    }
 
     result = AudioObjectGetPropertyData(kAudioObjectSystemObject,
                                         &devlist_address, 0, NULL, &size, devs);
-    if (result != kAudioHardwareNoError)
+    if (result != kAudioHardwareNoError) {
         return;
+    }
 
     max = size / sizeof(AudioDeviceID);
     for (i = 0; i < max; i++) {
@@ -141,12 +144,14 @@ static void build_device_list(int iscapture, addDevFn addfn, void *addfndata)
         };
 
         result = AudioObjectGetPropertyDataSize(dev, &addr, 0, NULL, &size);
-        if (result != noErr)
+        if (result != noErr) {
             continue;
+        }
 
         buflist = (AudioBufferList *)SDL_malloc(size);
-        if (buflist == NULL)
+        if (buflist == NULL) {
             continue;
+        }
 
         result = AudioObjectGetPropertyData(dev, &addr, 0, NULL,
                                             &size, buflist);
@@ -161,8 +166,9 @@ static void build_device_list(int iscapture, addDevFn addfn, void *addfndata)
 
         SDL_free(buflist);
 
-        if (spec.channels == 0)
+        if (spec.channels == 0) {
             continue;
+        }
 
         size = sizeof(sampleRate);
         result = AudioObjectGetPropertyData(dev, &freqaddr, 0, NULL, &size, &sampleRate);
@@ -172,8 +178,9 @@ static void build_device_list(int iscapture, addDevFn addfn, void *addfndata)
 
         size = sizeof(CFStringRef);
         result = AudioObjectGetPropertyData(dev, &nameaddr, 0, NULL, &size, &cfstr);
-        if (result != kAudioHardwareNoError)
+        if (result != kAudioHardwareNoError) {
             continue;
+        }
 
         len = CFStringGetMaximumSizeForEncoding(CFStringGetLength(cfstr),
                                                 kCFStringEncodingUTF8);
@@ -540,8 +547,9 @@ static void outputCallback(void *inUserData, AudioQueueRef inAQ, AudioQueueBuffe
             if (SDL_AudioStreamAvailable(this->stream) > 0) {
                 int got;
                 UInt32 len = SDL_AudioStreamAvailable(this->stream);
-                if (len > remaining)
+                if (len > remaining) {
                     len = remaining;
+                }
                 got = SDL_AudioStreamGet(this->stream, ptr, len);
                 SDL_assert((got < 0) || (got == len));
                 if (got != len) {
@@ -985,7 +993,7 @@ static int audioqueue_thread(void *arg)
     }
 
     if (!this->iscapture) { /* Drain off any pending playback. */
-        const CFTimeInterval secs = (((this->spec.size / (SDL_AUDIO_BITSIZE(this->spec.format) / 8)) / this->spec.channels) / ((CFTimeInterval)this->spec.freq)) * 2.0;
+        const CFTimeInterval secs = (((this->spec.size / (SDL_AUDIO_BITSIZE(this->spec.format) / 8.0)) / this->spec.channels) / ((CFTimeInterval)this->spec.freq)) * 2.0;
         CFRunLoopRunInMode(kCFRunLoopDefaultMode, secs, 0);
     }
 
@@ -1084,13 +1092,15 @@ static int COREAUDIO_OpenDevice(_THIS, const char *devname)
     }
     this->spec.format = test_format;
     strdesc->mBitsPerChannel = SDL_AUDIO_BITSIZE(test_format);
-    if (SDL_AUDIO_ISBIGENDIAN(test_format))
+    if (SDL_AUDIO_ISBIGENDIAN(test_format)) {
         strdesc->mFormatFlags |= kLinearPCMFormatFlagIsBigEndian;
+    }
 
-    if (SDL_AUDIO_ISFLOAT(test_format))
+    if (SDL_AUDIO_ISFLOAT(test_format)) {
         strdesc->mFormatFlags |= kLinearPCMFormatFlagIsFloat;
-    else if (SDL_AUDIO_ISSIGNED(test_format))
+    } else if (SDL_AUDIO_ISSIGNED(test_format)) {
         strdesc->mFormatFlags |= kLinearPCMFormatFlagIsSignedInteger;
+    }
 
     strdesc->mBytesPerFrame = strdesc->mChannelsPerFrame * strdesc->mBitsPerChannel / 8;
     strdesc->mBytesPerPacket = strdesc->mBytesPerFrame * strdesc->mFramesPerPacket;
@@ -1230,12 +1240,14 @@ static int COREAUDIO_GetDefaultAudioInfo(char **name, SDL_AudioSpec *spec, int i
     spec->freq = (int)sampleRate;
 
     result = AudioObjectGetPropertyDataSize(devid, &bufaddr, 0, NULL, &size);
-    if (result != noErr)
+    if (result != noErr) {
         return SDL_SetError("%s: Default Device Data Size not found", "coreaudio");
+    }
 
     buflist = (AudioBufferList *)SDL_malloc(size);
-    if (buflist == NULL)
+    if (buflist == NULL) {
         return SDL_SetError("%s: Default Device Buffer List not found", "coreaudio");
+    }
 
     result = AudioObjectGetPropertyData(devid, &bufaddr, 0, NULL,
                                         &size, buflist);
diff --git a/src/audio/dsp/SDL_dspaudio.c b/src/audio/dsp/SDL_dspaudio.c
index 77705fc27..4f97d2de8 100644
--- a/src/audio/dsp/SDL_dspaudio.c
+++ b/src/audio/dsp/SDL_dspaudio.c
@@ -199,8 +199,8 @@ static int DSP_OpenDevice(_THIS, const char *devname)
     SDL_CalculateAudioSpec(&this->spec);
 
     /* Determine the power of two of the fragment size */
-    for (frag_spec = 0; (0x01U << frag_spec) < this->spec.size; ++frag_spec)
-        ;
+    for (frag_spec = 0; (0x01U << frag_spec) < this->spec.size; ++frag_spec) {
+    }
     if ((0x01U << frag_spec) != this->spec.size) {
         return SDL_SetError("Fragment size must be a power of two");
     }
diff --git a/src/audio/jack/SDL_jackaudio.c b/src/audio/jack/SDL_jackaudio.c
index 41949b8f5..99de0efb0 100644
--- a/src/audio/jack/SDL_jackaudio.c
+++ b/src/audio/jack/SDL_jackaudio.c
@@ -162,7 +162,7 @@ static int jackProcessPlaybackCallback(jack_nframes_t nframes, void *arg)
     for (channelsi = 0; channelsi < total_channels; channelsi++) {
         float *dst = (float *)JACK_jack_port_get_buffer(ports[channelsi], nframes);
         if (dst) {
-            const float *src = ((float *)this->hidden->iobuffer) + channelsi;
+            const float *src = this->hidden->iobuffer + channelsi;
             int framesi;
             for (framesi = 0; framesi < total_frames; framesi++) {
                 *(dst++) = *src;
@@ -202,7 +202,7 @@ static int jackProcessCaptureCallback(jack_nframes_t nframes, void *arg)
         for (channelsi = 0; channelsi < total_channels; channelsi++) {
             const float *src = (const float *)JACK_jack_port_get_buffer(ports[channelsi], nframes);
             if (src) {
-                float *dst = ((float *)this->hidden->iobuffer) + channelsi;
+                float *dst = this->hidden->iobuffer + channelsi;
                 int framesi;
                 for (framesi = 0; framesi < total_frames; framesi++) {
                     *dst = *(src++);
@@ -312,6 +312,7 @@ static int JACK_OpenDevice(_THIS, const char *devname)
         }
     }
     if (channels == 0) {
+        SDL_free(audio_ports);
         return SDL_SetError("No physical JACK ports available");
     }
 
@@ -327,36 +328,42 @@ static int JACK_OpenDevice(_THIS, const char *devname)
 
     this->hidden->iosem = SDL_CreateSemaphore(0);
     if (!this->hidden->iosem) {
+        SDL_free(audio_ports);
         return -1; /* error was set by SDL_CreateSemaphore */
     }
 
     this->hidden->iobuffer = (float *)SDL_calloc(1, this->spec.size);
     if (!this->hidden->iobuffer) {
+        SDL_free(audio_ports);
         return SDL_OutOfMemory();
     }
 
     /* Build SDL's ports, which we will connect to the device ports. */
     this->hidden->sdlports = (jack_port_t **)SDL_calloc(channels, sizeof(jack_port_t *));
     if (this->hidden->sdlports == NULL) {
+        SDL_free(audio_ports);
         return SDL_OutOfMemory();
     }
 
     for (i = 0; i < channels; i++) {
         char portname[32];
-        SDL_snprintf(portname, sizeof(portname), "sdl_jack_%s_%d", sdlportstr, i);
+        (void)SDL_snprintf(portname, sizeof(portname), "sdl_jack_%s_%d", sdlportstr, i);
         this->hidden->sdlports[i] = JACK_jack_port_register(client, portname, JACK_DEFAULT_AUDIO_TYPE, sdlportflags, 0);
         if (this->hidden->sdlports[i] == NULL) {
+            SDL_free(audio_ports);
             return SDL_SetError("jack_port_register failed");
         }
     }
 
     if (JACK_jack_set_process_callback(client, callback, this) != 0) {
+        SDL_free(audio_ports);
         return SDL_SetError("JACK: Couldn't set process callback");
     }
 
     JACK_jack_on_shutdown(client, jackShutdownCallback, this);
 
     if (JACK_jack_activate(client) != 0) {
+        SDL_free(audio_ports);
         return SDL_SetError("Failed to activate JACK client");
     }
 
@@ -366,6 +373,7 @@ static int JACK_OpenDevice(_THIS, const char *devname)
         const char *srcport = iscapture ? devports[audio_ports[i]] : sdlport;
         const char *dstport = iscapture ? sdlport : devports[audio_ports[i]];
         if (JACK_jack_connect(client, srcport, dstport) != 0) {
+            SDL_free(audio_ports);
             return SDL_SetError("Couldn't connect JACK ports: %s => %s", srcport, dstport);
         }
     }
diff --git a/src/audio/pipewire/SDL_pipewire.c b/src/audio/pipewire/SDL_pipewire.c
index 00bff48f1..b32be91a2 100644
--- a/src/audio/pipewire/SDL_pipewire.c
+++ b/src/audio/pipewire/SDL_pipewire.c
@@ -144,11 +144,8 @@ static int pipewire_dlsym(const char *fn, void **addr)
 
 static int load_pipewire_library()
 {
-    if ((pipewire_handle = SDL_LoadObject(pipewire_library))) {
-        return 0;
-    }
-
-    return -1;
+    pipewire_handle = SDL_LoadObject(pipewire_library);
+    return pipewire_handle != NULL ? 0 : -1;
 }
 
 static void unload_pipewire_library()
@@ -966,7 +963,8 @@ static void output_callback(void *data)
     }
 
     /* See if a buffer is available */
-    if ((pw_buf = PIPEWIRE_pw_stream_dequeue_buffer(stream)) == NULL) {
+    pw_buf = PIPEWIRE_pw_stream_dequeue_buffer(stream);
+    if (pw_buf == NULL) {
         return;
     }
 
@@ -1035,8 +1033,8 @@ static void input_callback(void *data)
     }
 
     spa_buf = pw_buf->buffer;
-
-    if ((src = (Uint8 *)spa_buf->datas[0].data) == NULL) {
+    (src = (Uint8 *)spa_buf->datas[0].data);
+    if (src == NULL) {
         return;
     }
 
@@ -1179,7 +1177,9 @@ static int PIPEWIRE_OpenDevice(_THIS, const char *devname)
         return SDL_SetError("Pipewire: Failed to set audio format parameters");
     }
 
-    if ((this->hidden = priv = SDL_calloc(1, sizeof(struct SDL_PrivateAudioData))) == NULL) {
+    priv = SDL_calloc(1, sizeof(struct SDL_PrivateAudioData));
+    this->hidden = priv;
+    if (priv == NULL) {
         return SDL_OutOfMemory();
     }
 
@@ -1191,7 +1191,7 @@ static int PIPEWIRE_OpenDevice(_THIS, const char *devname)
         this->spec.size = this->spec.samples * priv->stride;
     }
 
-    SDL_snprintf(thread_name, sizeof(thread_name), "SDLAudio%c%ld", (iscapture) ? 'C' : 'P', (long)this->handle);
+    (void)SDL_snprintf(thread_name, sizeof(thread_name), "SDLAudio%c%ld", (iscapture) ? 'C' : 'P', (long)this->handle);
     priv->loop = PIPEWIRE_pw_thread_loop_new(thread_name, NULL);
     if (priv->loop == NULL) {
         return SDL_SetError("Pipewire: Failed to create stream loop (%i)", errno);
@@ -1234,7 +1234,8 @@ static int PIPEWIRE_OpenDevice(_THIS, const char *devname)
             const struct io_node *node;
 
             PIPEWIRE_pw_thread_loop_lock(hotplug_loop);
-            if ((node = io_list_get_by_id(node_id))) {
+            node = io_list_get_by_id(node_id);
+            if (node != NULL) {
                 PIPEWIRE_pw_properties_set(props, PW_KEY_TARGET_OBJECT, node->path);
             }
             PIPEWIRE_pw_thread_loop_unlock(hotplug_loop);
diff --git a/src/audio/sndio/SDL_sndioaudio.c b/src/audio/sndio/SDL_sndioaudio.c
index e0c7b8785..6a73440b8 100644
--- a/src/audio/sndio/SDL_sndioaudio.c
+++ b/src/audio/sndio/SDL_sndioaudio.c
@@ -180,7 +180,8 @@ static int SNDIO_CaptureFromDevice(_THIS, void *buffer, int buflen)
     /* Emulate a blocking read */
     r = SNDIO_sio_read(this->hidden->dev, buffer, buflen);
     while (r == 0 && !SNDIO_sio_eof(this->hidden->dev)) {
-        if ((nfds = SNDIO_sio_pollfd(this->hidden->dev, this->hidden->pfd, POLLIN)) <= 0 || poll(this->hidden->pfd, nfds, INFTIM) < 0) {
+        nfds = SNDIO_sio_pollfd(this->hidden->dev, this->hidden->pfd, POLLIN);
+        if (nfds <= 0 || poll(this->hidden->pfd, nfds, INFTIM) < 0) {
             return -1;
         }
         revents = SNDIO_sio_revents(this->hidden->dev, this->hidden->pfd);
@@ -237,16 +238,18 @@ static int SNDIO_OpenDevice(_THIS, const char *devname)
     this->hidden->mixlen = this->spec.size;
 
     /* Capture devices must be non-blocking for SNDIO_FlushCapture */
-    if ((this->hidden->dev =
-             SNDIO_sio_open(devname != NULL ? devname : SIO_DEVANY,
-                            iscapture ? SIO_REC : SIO_PLAY, iscapture)) == NULL) {
+    this->hidden->dev = SNDIO_sio_open(devname != NULL ? devname : SIO_DEVANY,
+                                       iscapture ? SIO_REC : SIO_PLAY, iscapture);
+    if (this->hidden->dev == NULL) {
         return SDL_SetError("sio_open() failed");
     }
 
     /* Allocate the pollfd array for capture devices */
-    if (iscapture && (this->hidden->pfd =
-                          SDL_malloc(sizeof(struct pollfd) * SNDIO_sio_nfds(this->hidden->dev))) == NULL) {
-        return SDL_OutOfMemory();
+    if (iscapture) {
+        this->hidden->pfd = SDL_malloc(sizeof(struct pollfd) * SNDIO_sio_nfds(this->hidden->dev));
+        if (this->hidden->pfd == NULL) {
+            return SDL_OutOfMemory();
+        }
     }
 
     SNDIO_sio_initpar(&par);
@@ -282,23 +285,23 @@ static int SNDIO_OpenDevice(_THIS, const char *devname)
         return SDL_SetError("%s: Unsupported audio format", "sndio");
     }
 
-    if ((par.bps == 4) && (par.sig) && (par.le))
+    if ((par.bps == 4) && (par.sig) && (par.le)) {
         this->spec.format = AUDIO_S32LSB;
-    else if ((par.bps == 4) && (par.sig) && (!par.le))
+    } else if ((par.bps == 4) && (par.sig) && (!par.le)) {
         this->spec.format = AUDIO_S32MSB;
-    else if ((par.bps == 2) && (par.sig) && (par.le))
+    } else if ((par.bps == 2) && (par.sig) && (par.le)) {
         this->spec.format = AUDIO_S16LSB;
-    else if ((par.bps == 2) && (par.sig) && (!par.le))
+    } else if ((par.bps == 2) && (par.sig) && (!par.le)) {
         this->spec.format = AUDIO_S16MSB;
-    else if ((par.bps == 2) && (!par.sig) && (par.le))
+    } else if ((par.bps == 2) && (!par.sig) && (par.le)) {
         this->spec.format = AUDIO_U16LSB;
-    else if ((par.bps == 2) && (!par.sig) && (!par.le))
+    } else if ((par.bps == 2) && (!par.sig) && (!par.le)) {
         this->spec.format = AUDIO_U16MSB;
-    else if ((par.bps == 1) && (par.sig))
+    } else if ((par.bps == 1) && (par.sig)) {
         this->spec.format = AUDIO_S8;
-    else if ((par.bps == 1) && (!par.sig))
+    } else if ((par.bps == 1) && (!par.sig)) {
         this->spec.format = AUDIO_U8;
-    else {
+    } else {
         return SDL_SetError("sndio: Got unsupported hardware audio format.");
     }
 
diff --git a/src/core/android/SDL_android.c b/src/core/android/SDL_android.c
index 83d378c53..7df8a6946 100644
--- a/src/core/android/SDL_android.c
+++ b/src/core/android/SDL_android.c
@@ -2480,7 +2480,6 @@ void Android_JNI_DestroyCustomCursor(int cursorID)
 {
     JNIEnv *env = Android_JNI_GetEnv();
     (*env)->CallStaticVoidMethod(env, mActivityClass, midDestroyCustomCursor, cursorID);
-    return;
 }
 
 SDL_bool Android_JNI_SetCustomCursor(int cursorID)
diff --git a/src/core/linux/SDL_evdev.c b/src/core/linux/SDL_evdev.c
index 9940d6fa7..8afca6a9e 100644
--- a/src/core/linux/SDL_evdev.c
+++ b/src/core/linux/SDL_evdev.c
@@ -128,8 +128,7 @@ static int SDL_EVDEV_device_removed(const char *dev_path);
 
 static int SDL_EVDEV_device_added(const char *dev_path, int udev_class);
 #if SDL_USE_LIBUDEV
-static void SDL_EVDEV_udev_callback(SDL_UDEV_deviceevent udev_type, int udev_class,
-                                    const char *dev_path);
+static void SDL_EVDEV_udev_callback(SDL_UDEV_deviceevent udev_event, int udev_class, const char *dev_path);
 #endif /* SDL_USE_LIBUDEV */
 
 static Uint8 EVDEV_MouseButtons[] = {
@@ -319,10 +318,11 @@ void SDL_EVDEV_Poll(void)
                        next finger after earlist is released) */
                     if (item->is_touchscreen && events[i].code == BTN_TOUCH) {
                         if (item->touchscreen_data->max_slots == 1) {
-                            if (events[i].value)
+                            if (events[i].value) {
                                 item->touchscreen_data->slots[0].delta = EVDEV_TOUCH_SLOTDELTA_DOWN;
-                            else
+                            } else {
                                 item->touchscreen_data->slots[0].delta = EVDEV_TOUCH_SLOTDELTA_UP;
+                            }
                         }
                         break;
                     }
@@ -820,8 +820,8 @@ static int SDL_EVDEV_device_added(const char *dev_path, int udev_class)
     /* For now, we just treat a touchpad like a touchscreen */
     if (udev_class & (SDL_UDEV_DEVICE_TOUCHSCREEN | SDL_UDEV_DEVICE_TOUCHPAD)) {
         item->is_touchscreen = SDL_TRUE;
-
-        if ((ret = SDL_EVDEV_init_touchscreen(item, udev_class)) < 0) {
+        ret = SDL_EVDEV_init_touchscreen(item, udev_class);
+        if (ret < 0) {
             close(item->fd);
             SDL_free(item->path);
             SDL_free(item);
diff --git a/src/core/linux/SDL_evdev_capabilities.c b/src/core/linux/SDL_evdev_capabilities.c
index cc9784302..34841532b 100644
--- a/src/core/linux/SDL_evdev_capabilities.c
+++ b/src/core/linux/SDL_evdev_capabilities.c
@@ -37,10 +37,10 @@
 #endif
 
 extern int
-SDL_EVDEV_GuessDeviceClass(unsigned long bitmask_ev[NBITS(EV_MAX)],
-                           unsigned long bitmask_abs[NBITS(ABS_MAX)],
-                           unsigned long bitmask_key[NBITS(KEY_MAX)],
-                           unsigned long bitmask_rel[NBITS(REL_MAX)])
+SDL_EVDEV_GuessDeviceClass(const unsigned long bitmask_ev[NBITS(EV_MAX)],
+                           const unsigned long bitmask_abs[NBITS(ABS_MAX)],
+                           const unsigned long bitmask_key[NBITS(KEY_MAX)],
+                           const unsigned long bitmask_rel[NBITS(REL_MAX)])
 {
     struct range
     {
diff --git a/src/core/linux/SDL_evdev_capabilities.h b/src/core/linux/SDL_evdev_capabilities.h
index 1b12f3824..cb49b807e 100644
--- a/src/core/linux/SDL_evdev_capabilities.h
+++ b/src/core/linux/SDL_evdev_capabilities.h
@@ -47,10 +47,10 @@ typedef enum
 #define EVDEV_LONG(x)        ((x) / BITS_PER_LONG)
 #define test_bit(bit, array) ((array[EVDEV_LONG(bit)] >> EVDEV_OFF(bit)) & 1)
 
-extern int SDL_EVDEV_GuessDeviceClass(unsigned long bitmask_ev[NBITS(EV_MAX)],
-                                      unsigned long bitmask_abs[NBITS(ABS_MAX)],
-                                      unsigned long bitmask_key[NBITS(KEY_MAX)],
-                                      unsigned long bitmask_rel[NBITS(REL_MAX)]);
+extern int SDL_EVDEV_GuessDeviceClass(const unsigned long bitmask_ev[NBITS(EV_MAX)],
+                                      const unsigned long bitmask_abs[NBITS(ABS_MAX)],
+                                      const unsigned long bitmask_key[NBITS(KEY_MAX)],
+                                      const unsigned long bitmask_rel[NBITS(REL_MAX)]);
 
 #endif /* HAVE_LINUX_INPUT_H */
 
diff --git a/src/core/linux/SDL_evdev_kbd.c b/src/core/linux/SDL_evdev_kbd.c
index 42b634a92..1f54c67db 100644
--- a/src/core/linux/SDL_evdev_kbd.c
+++ b/src/core/linux/SDL_evdev_kbd.c
@@ -218,7 +218,7 @@ static void kbd_cleanup(void)
 
 static void SDL_EVDEV_kbd_reraise_signal(int sig)
 {
-    raise(sig);
+    (void)raise(sig);
 }
 
 siginfo_t *SDL_EVDEV_kdb_cleanup_siginfo = NULL;
@@ -303,7 +303,7 @@ static void kbd_register_emerg_cleanup(SDL_EVDEV_keyboard_state *kbd)
          * functions that are called when the shared library is unloaded.
          * -- man atexit(3)
          */
-        atexit(kbd_cleanup_atexit);
+        (void)atexit(kbd_cleanup_atexit);
         kbd_cleanup_atexit_installed = 1;
     }
 
@@ -407,33 +407,33 @@ SDL_EVDEV_kbd_init(void)
     return kbd;
 }
 
-void SDL_EVDEV_kbd_quit(SDL_EVDEV_keyboard_state *kbd)
+void SDL_EVDEV_kbd_quit(SDL_EVDEV_keyboard_state *state)
 {
-    if (kbd == NULL) {
+    if (state == NULL) {
         return;
     }
 
     kbd_unregister_emerg_cleanup();
 
-    if (kbd->console_fd >= 0) {
+    if (state->console_fd >= 0) {
         /* Restore the original keyboard mode */
-        ioctl(kbd->console_fd, KDSKBMODE, kbd->old_kbd_mode);
+        ioctl(state->console_fd, KDSKBMODE, state->old_kbd_mode);
 
-        close(kbd->console_fd);
-        kbd->console_fd = -1;
+        close(state->console_fd);
+        state->console_fd = -1;
     }
 
-    if (kbd->key_maps && kbd->key_maps != default_key_maps) {
+    if (state->key_maps && state->key_maps != default_key_maps) {
         int i;
         for (i = 0; i < MAX_NR_KEYMAPS; ++i) {
-            if (kbd->key_maps[i]) {
-                SDL_free(kbd->key_maps[i]);
+            if (state->key_maps[i]) {
+                SDL_free(state->key_maps[i]);
             }
         }
-        SDL_free(kbd->key_maps);
+        SDL_free(state->key_maps);
     }
 
-    SDL_free(kbd);
+    SDL_free(state);
 }
 
 /*
@@ -449,10 +449,9 @@ static void put_queue(SDL_EVDEV_keyboard_state *kbd, uint c)
 
 static void put_utf8(SDL_EVDEV_keyboard_state *kbd, uint c)
 {
-    if (c < 0x80)
-        /*  0******* */
-        put_queue(kbd, c);
-    else if (c < 0x800) {
+    if (c < 0x80) {
+        put_queue(kbd, c); /*  0******* */
+    } else if (c < 0x800) {
         /* 110***** 10****** */
         put_queue(kbd, 0xc0 | (c >> 6));
         put_queue(kbd, 0x80 | (c & 0x3f));
@@ -626,8 +625,9 @@ static void k_self(SDL_EVDEV_keyboard_state *kbd, unsigned char value, char up_f
 
 static void k_deadunicode(SDL_EVDEV_keyboard_state *kbd, unsigned int value, char up_flag)
 {
-    if (up_flag)
+    if (up_flag) {
         return;
+    }
 
     kbd->diacr = (kbd->diacr ? handle_diacr(kbd, value) : value);
 }
@@ -660,8 +660,9 @@ static void k_pad(SDL_EVDEV_keyboard_state *kbd, unsigned char value, char up_fl
 {
     static const char pad_chars[] = "0123456789+-*/\015,.?()#";
 
-    if (up_flag)
+    if (up_flag) {
         return; /* no action, if this is a key release */
+    }
 
     if (!vc_kbd_led(kbd, K_NUMLOCK)) {
         /* unprintable action */
@@ -675,8 +676,9 @@ static void k_shift(SDL_EVDEV_keyboard_state *kbd, unsigned char value, char up_
 {
     int old_state = kbd->shift_state;
 
-    if (kbd->rep)
+    if (kbd->rep) {
         return;
+    }
     /*
      * Mimic typewriter:
      * a CapsShift key acts like Shift but undoes CapsLock
@@ -696,13 +698,15 @@ static void k_shift(SDL_EVDEV_keyboard_state *kbd, unsigned char value, char up_
         if (kbd->shift_down[value]) {
             kbd->shift_down[value]--;
         }
-    } else
+    } else {
         kbd->shift_down[value]++;
+    }
 
-    if (kbd->shift_down[value])
+    if (kbd->shift_down[value]) {
         kbd->shift_state |= (1 << value);
-    else
+    } else {
         kbd->shift_state &= ~(1 << value);
+    }
 
     /* kludge */
     if (up_flag && kbd->shift_state != old_state && kbd->npadch != -1) {
@@ -719,8 +723,9 @@ static void k_ascii(SDL_EVDEV_keyboard_state *kbd, unsigned char value, char up_
 {
     int base;
 
-    if (up_flag)
+    if (up_flag) {
         return;
+    }
 
     if (value < 10) {
         /* decimal input of code, while Alt depressed */
@@ -731,16 +736,18 @@ static void k_ascii(SDL_EVDEV_keyboard_state *kbd, unsigned char value, char up_
         base = 16;
     }
 
-    if (kbd->npadch == -1)
+    if (kbd->npadch == -1) {
         kbd->npadch = value;
-    else
+    } else {
         kbd->npadch = kbd->npadch * base + value;
+    }
 }
 
 static void k_lock(SDL_EVDEV_keyboard_state *kbd, unsigned char value, char up_flag)
 {
-    if (up_flag || kbd->rep)
+    if (up_flag || kbd->rep) {
         return;
+    }
 
     chg_vc_kbd_lock(kbd, value);
 }
@@ -748,8 +755,9 @@ static void k_lock(SDL_EVDEV_keyboard_state *kbd, unsigned char value, char up_f
 static void k_slock(SDL_EVDEV_keyboard_state *kbd, unsigned char value, char up_flag)
 {
     k_shift(kbd, value, up_flag);
-    if (up_flag || kbd->rep)
+    if (up_flag || kbd->rep) {
         return;
+    }
 
     chg_vc_kbd_slock(kbd, value);
     /* try to make Alt, oops, AltGr and such work */
@@ -763,26 +771,26 @@ static void k_brl(SDL_EVDEV_keyboard_state *kbd, unsigned char value, char up_fl
 {
 }
 
-void SDL_EVDEV_kbd_keycode(SDL_EVDEV_keyboard_state *kbd, unsigned int keycode, int down)
+void SDL_EVDEV_kbd_keycode(SDL_EVDEV_keyboard_state *state, unsigned int keycode, int down)
 {
     unsigned char shift_final;
     unsigned char type;
     unsigned short *key_map;
     unsigned short keysym;
 
-    if (kbd == NULL) {
+    if (state == NULL) {
         return;
     }
 
-    kbd->rep = (down == 2);
+    state->rep = (down == 2);
 
-    shift_final = (kbd->shift_state | kbd->slockstate) ^ kbd->lockstate;
-    key_map = kbd->key_maps[shift_final];
+    shift_final = (state->shift_state | state->slockstate) ^ state->lockstate;
+    key_map = state->key_maps[shift_final];
     if (key_map == NULL) {
         /* Unsupported shift state (e.g. ctrl = 4, alt = 8), just reset to the default state */
-        kbd->shift_state = 0;
-        kbd->slockstate = 0;
-        kbd->lockstate = 0;
+        state->shift_state = 0;
+        state->slockstate = 0;
+        state->lockstate = 0;
         return;
     }
 
@@ -796,7 +804,7 @@ void SDL_EVDEV_kbd_keycode(SDL_EVDEV_keyboard_state *kbd, unsigned int keycode,
 
     if (type < 0xf0) {
         if (down) {
-            put_utf8(kbd, keysym);
+            put_utf8(state, keysym);
         }
     } else {
         type -= 0xf0;
@@ -805,25 +813,25 @@ void SDL_EVDEV_kbd_keycode(SDL_EVDEV_keyboard_state *kbd, unsigned int keycode,
         if (type == KT_LETTER) {
             type = KT_LATIN;
 
-            if (vc_kbd_led(kbd, K_CAPSLOCK)) {
-                key_map = kbd->key_maps[shift_final ^ (1 << KG_SHIFT)];
+            if (vc_kbd_led(state, K_CAPSLOCK)) {
+                key_map = state->key_maps[shift_final ^ (1 << KG_SHIFT)];
                 if (key_map) {
                     keysym = key_map[keycode];
                 }
             }
         }
 
-        (*k_handler[type])(kbd, keysym & 0xff, !down);
+        (*k_handler[type])(state, keysym & 0xff, !down);
 
         if (type != KT_SLOCK) {
-            kbd->slockstate = 0;
+            state->slockstate = 0;
         }
     }
 
-    if (kbd->text_len > 0) {
-        kbd->text[kbd->text_len] = '\0';
-        SDL_SendKeyboardText(kbd->text);
-        kbd->text_len = 0;
+    if (state->text_len > 0) {
+        state->text[state->text_len] = '\0';
+        SDL_SendKeyboardText(state->text);
+        state->text_len = 0;
     }
 }
 
diff --git a/src/core/linux/SDL_fcitx.c b/src/core/linux/SDL_fcitx.c
index aebe4db1f..888990b81 100644
--- a/src/core/linux/SDL_fcitx.c
+++ b/src/core/linux/SDL_fcitx.c
@@ -64,9 +64,9 @@ static char *GetAppName()
     int linksize;
 
 #if defined(__LINUX__)
-    SDL_snprintf(procfile, sizeof(procfile), "/proc/%d/exe", getpid());
+    (void)SDL_snprintf(procfile, sizeof procfile, "/proc/%d/exe", getpid());
 #elif defined(__FREEBSD__)
-    SDL_snprintf(procfile, sizeof(procfile), "/proc/%d/file", getpid());
+    (void)SDL_snprintf(procfile, sizeof procfile, "/proc/%d/file", getpid());
 #endif
     linksize = readlink(procfile, linkfile, sizeof(linkfile) - 1);
     if (linksize > 0) {
diff --git a/src/core/linux/SDL_ibus.c b/src/core/linux/SDL_ibus.c
index 1f270c726..dfb7c8637 100644
--- a/src/core/linux/SDL_ibus.c
+++ b/src/core/linux/SDL_ibus.c
@@ -324,7 +324,7 @@ static char *IBus_ReadAddressFromFile(const char *file_path)
         }
     }
 
-    fclose(addr_file);
+    (void)fclose(addr_file);
 
     if (success) {
         return SDL_strdup(addr_buf + (sizeof("IBUS_ADDRESS=") - 1));
@@ -407,14 +407,14 @@ static char *IBus_GetDBusAddressFilename(void)
             SDL_free(display);
             return NULL;
         }
-        SDL_snprintf(config_dir, sizeof(config_dir), "%s/.config", home_env);
+        (void)SDL_snprintf(config_dir, sizeof config_dir, "%s/.config", home_env);
     }
 
     key = dbus->get_local_machine_id();
 
     SDL_memset(file_path, 0, sizeof(file_path));
-    SDL_snprintf(file_path, sizeof(file_path), "%s/ibus/bus/%s-%s-%s",
-                 config_dir, key, host, disp_num);
+    (void)SDL_snprintf(file_path, sizeof file_path, "%s/ibus/bus/%s-%s-%s",
+                       config_dir, key, host, disp_num);
     dbus->free(key);
     SDL_free(display);
 
@@ -488,7 +488,7 @@ static SDL_bool IBus_SetupConnection(SDL_DBusContext *dbus, const char *addr)
 
     if (result) {
         char matchstr[128];
-        SDL_snprintf(matchstr, sizeof(matchstr), "type='signal',interface='%s'", ibus_input_interface);
+        (void)SDL_snprintf(matchstr, sizeof matchstr, "type='signal',interface='%s'", ibus_input_interface);
         SDL_free(input_ctx_path);
         input_ctx_path = SDL_strdup(path);
         SDL_AddHintCallback(SDL_HINT_IME_INTERNAL_EDITING, IBus_SetCapabilities, NULL);
diff --git a/src/core/windows/SDL_windows.c b/src/core/windows/SDL_windows.c
index 2dff2f7ff..452e0164a 100644
--- a/src/core/windows/SDL_windows.c
+++ b/src/core/windows/SDL_windows.c
@@ -268,10 +268,10 @@ WIN_LookupAudioDeviceName(const WCHAR *name, const GUID *guid)
     }
 
     ptr = (const unsigned char *)guid;
-    SDL_snprintf(keystr, sizeof(keystr),
-                 "System\\CurrentControlSet\\Control\\MediaCategories\\{%02X%02X%02X%02X-%02X%02X-%02X%02X-%02X%02X-%02X%02X%02X%02X%02X%02X}",
-                 ptr[3], ptr[2], ptr[1], ptr[0], ptr[5], ptr[4], ptr[7], ptr[6],
-                 ptr[8], ptr[9], ptr[10], ptr[11], ptr[12], ptr[13], ptr[14], ptr[15]);
+    (void)SDL_snprintf(keystr, sizeof keystr,
+                       "System\\CurrentControlSet\\Control\\MediaCategories\\{%02X%02X%02X%02X-%02X%02X-%02X%02X-%02X%02X-%02X%02X%02X%02X%02X%02X}",
+                       ptr[3], ptr[2], ptr[1], ptr[0], ptr[5], ptr[4], ptr[7], ptr[6],
+                       ptr[8], ptr[9], ptr[10], ptr[11], ptr[12], ptr[13], ptr[14], ptr[15]);
 
     strw = WIN_UTF8ToString(keystr);
     rc = (RegOpenKeyExW(HKEY_LOCAL_MACHINE, strw, 0, KEY_QUERY_VALUE, &hkey) == ERROR_SUCCESS);
diff --git a/src/events/SDL_events.c b/src/events/SDL_events.c
index cf22f547a..ec1835bd3 100644
--- a/src/events/SDL_events.c
+++ b/src/events/SDL_events.c
@@ -179,7 +179,7 @@ static void SDL_LogEvent(const SDL_Event *event)
         return;
     }
 
-/* this is to make SDL_snprintf() calls cleaner. */
+/* this is to make (void)SDL_snprintf() calls cleaner. */
 #define uint unsigned int
 
     name[0] = '\0';
@@ -191,13 +191,13 @@ static void SDL_LogEvent(const SDL_Event *event)
         char plusstr[16];
         SDL_strlcpy(name, "SDL_USEREVENT", sizeof(name));
         if (event->type > SDL_USEREVENT) {
-            SDL_snprintf(plusstr, sizeof(plusstr), "+%u", ((uint)event->type) - SDL_USEREVENT);
+            (void)SDL_snprintf(plusstr, sizeof(plusstr), "+%u", ((uint)event->type) - SDL_USEREVENT);
         } else {
             plusstr[0] = '\0';
         }
-        SDL_snprintf(details, sizeof(details), "%s (timestamp=%u windowid=%u code=%d data1=%p data2=%p)",
-                     plusstr, (uint)event->user.timestamp, (uint)event->user.windowID,
-                     (int)event->user.code, event->user.data1, event->user.data2);
+        (void)SDL_snprintf(details, sizeof(details), "%s (timestamp=%u windowid=%u code=%d data1=%p data2=%p)",
+                           plusstr, (uint)event->user.timestamp, (uint)event->user.windowID,
+                           (int)event->user.code, event->user.data1, event->user.data2);
     }
 
     switch (event->type) {
@@ -208,7 +208,7 @@ static void SDL_LogEvent(const SDL_Event *event)
         SDL_strlcpy(details, " (THIS IS PROBABLY A BUG!)", sizeof(details));
         break;
         SDL_EVENT_CASE(SDL_QUIT)
-        SDL_snprintf(details, sizeof(details), " (timestamp=%u)", (uint)event->quit.timestamp);
+        (void)SDL_snprintf(details, sizeof(details), " (timestamp=%u)", (uint)event->quit.timestamp);
         break;
         SDL_EVENT_CASE(SDL_APP_TERMINATING)
         break;
@@ -252,8 +252,8 @@ static void SDL_LogEvent(const SDL_Event *event)
                 SDL_strlcpy(name2, "UNKNOWN (bug? fixme?)", sizeof(name2));
                 break;
             }
-            SDL_snprintf(details, sizeof(details), " (timestamp=%u display=%u event=%s data1=%d)",
-                         (uint)event->display.timestamp, (uint)event->display.display, name2, (int)event->display.data1);
+            (void)SDL_snprintf(details, sizeof(details), " (timestamp=%u display=%u event=%s data1=%d)",
+                               (uint)event->display.timestamp, (uint)event->display.display, name2, (int)event->display.data1);
             break;
         }
 
@@ -291,24 +291,24 @@ static void SDL_LogEvent(const SDL_Event *event)
                 SDL_strlcpy(name2, "UNKNOWN (bug? fixme?)", sizeof(name2));
                 break;
             }
-            SDL_snprintf(details, sizeof(details), " (timestamp=%u windowid=%u event=%s data1=%d data2=%d)",
-                         (uint)event->window.timestamp, (uint)event->window.windowID, name2, (int)event->window.data1, (int)event->window.data2);
+            (void)SDL_snprintf(details, sizeof(details), " (timestamp=%u windowid=%u event=%s data1=%d data2=%d)",
+                               (uint)event->window.timestamp, (uint)event->window.windowID, name2, (int)event->window.data1, (int)event->window.data2);
             break;
         }
 
         SDL_EVENT_CASE(SDL_SYSWMEVENT)
         /* !!! FIXME: we don't delve further at the moment. */
-        SDL_snprintf(details, sizeof(details), " (timestamp=%u)", (uint)event->syswm.timestamp);
+        (void)SDL_snprintf(details, sizeof(details), " (timestamp=%u)", (uint)event->syswm.timestamp);
         break;
 
-#define PRINT_KEY_EVENT(event)                                                                                             \
-    SDL_snprintf(details, sizeof(details), " (timestamp=%u windowid=%u state=%s repeat=%s scancode=%u keycode=%u mod=%u)", \
-                 (uint)event->key.timestamp, (uint)event->key.windowID,                                                    \
-                 event->key.state == SDL_PRESSED ? "pressed" : "released",                                                 \
-                 event->key.repeat ? "true" : "false",                                                                     \
-                 (uint)event->key.keysym.scancode,                                                                         \
-                 (uint)event->key.keysym.sym,                                                                              \
-                 (uint)event->key.keysym.mod)
+#define PRINT_KEY_EVENT(event)                                                                                                   \
+    (void)SDL_snprintf(details, sizeof(details), " (timestamp=%u windowid=%u state=%s repeat=%s scancode=%u keycode=%u mod=%u)", \
+                       (uint)event->key.timestamp, (uint)event->key.windowID,                                                    \
+                       event->key.state == SDL_PRESSED ? "pressed" : "released",                                                 \
+                       event->key.repeat ? "true" : "false",                                                                     \
+                       (uint)event->key.keysym.scancode,                                                                         \
+                       (uint)event->key.keysym.sym,                                                                              \
+                       (uint)event->key.keysym.mod)
         SDL_EVENT_CASE(SDL_KEYDOWN)
         PRINT_KEY_EVENT(event);
         break;
@@ -318,29 +318,29 @@ static void SDL_LogEvent(const SDL_Event *event)
 #undef PRINT_KEY_EVENT
 
         SDL_EVENT_CASE(SDL_TEXTEDITING)
-        SDL_snprintf(details, sizeof(details), " (timestamp=%u windowid=%u text='%s' start=%d length=%d)",
-                     (uint)event->edit.timestamp, (uint)event->edit.windowID,
-                     event->edit.text, (int)event->edit.start, (int)event->edit.length);
+        (void)SDL_snprintf(details, sizeof(details), " (timestamp=%u windowid=%u text='%s' start=%d length=%d)",
+                           (uint)event->edit.timestamp, (uint)event->edit.windowID,
+                           event->edit.text, (int)event->edit.start, (int)event->edit.length);
         break;
 
         SDL_EVENT_CASE(SDL_TEXTINPUT)
-        SDL_snprintf(details, sizeof(details), " (timestamp=%u windowid=%u text='%s')", (uint)event->text.timestamp, (uint)event->text.windowID, event->text.text);
+        (void)SDL_snprintf(details, sizeof(details), " (timestamp=%u windowid=%u text='%s')", (uint)event->text.timestamp, (uint)event->text.windowID, event->text.text);
         break;
 
         SDL_EVENT_CASE(SDL_MOUSEMOTION)
-        SDL_snprintf(details, sizeof(details), " (timestamp=%u windowid=%u which=%u state=%u x=%d y=%d xrel=%d yrel=%d)",
-                     (uint)event->motion.timestamp, (uint)event->motion.windowID,
-                     (uint)event->motion.which, (uint)event->motion.state,
-                     (int)event->motion.x, (int)event->motion.y,
-                     (int)event->motion.xrel, (int)event->motion.yrel);
+        (void)SDL_snprintf(details, sizeof(details), " (timestamp=%u windowid=%u which=%u state=%u x=%d y=%d xrel=%d yrel=%d)",
+                           (uint)event->motion.timestamp, (uint)event->motion.windowID,
+                           (uint)event->motion.which, (uint)event->motion.state,
+                           (int)event->motion.x, (int)event->motion.y,
+                           (int)event->motion.xrel, (int)event->motion.yrel);
         break;
 
-#define PRINT_MBUTTON_EVENT(event)                                                                                        \
-    SDL_snprintf(details, sizeof(details), " (timestamp=%u windowid=%u which=%u button=%u state=%s clicks=%u x=%d y=%d)", \
-                 (uint)event->button.timestamp, (uint)event->button.windowID,                                             \
-                 (uint)event->button.which, (uint)event->button.button,                                                   \
-                 event->button.state == SDL_PRESSED ? "pressed" : "released",                                             \
-                 (uint)event->button.clicks, (int)event->button.x, (int)event->button.y)
+#define PRINT_MBUTTON_EVENT(event)                                                                                              \
+    (void)SDL_snprintf(details, sizeof(details), " (timestamp=%u windowid=%u which=%u button=%u state=%s clicks=%u x=%d y=%d)", \
+                       (uint)event->button.timestamp, (uint)event->button.windowID,                                             \
+                       (uint)event->button.which, (uint)event->button.button,                                                   \
+                       event->button.state == SDL_PRESSED ? "pressed" : "released",                                             \
+                       (uint)event->button.clicks, (int)event->button.x, (int)event->button.y)
         SDL_EVENT_CASE(SDL_MOUSEBUTTONDOWN)
         PRINT_MBUTTON_EVENT(event);
         break;
@@ -350,35 +350,35 @@ static void SDL_LogEvent(const SDL_Event *event)
 #undef PRINT_MBUTTON_EVENT
 
         SDL_EVENT_CASE(SDL_MOUSEWHEEL)
-        SDL_snprintf(details, sizeof(details), " (timestamp=%u windowid=%u which=%u x=%d y=%d preciseX=%f preciseY=%f direction=%s)",
-                     (uint)event->wheel.timestamp, (uint)event->wheel.windowID,
-                     (uint)event->wheel.which, (int)event->wheel.x, (int)event->wheel.y,
-                     event->wheel.preciseX, event->wheel.preciseY,
-                     event->wheel.direction == SDL_MOUSEWHEEL_NORMAL ? "normal" : "flipped");
+        (void)SDL_snprintf(details, sizeof(details), " (timestamp=%u windowid=%u which=%u x=%d y=%d preciseX=%f preciseY=%f direction=%s)",
+                           (uint)event->wheel.timestamp, (uint)event->wheel.windowID,
+                           (uint)event->wheel.which, (int)event->wheel.x, (int)event->wheel.y,
+                           event->wheel.preciseX, event->wheel.preciseY,
+                           event->wheel.direction == SDL_MOUSEWHEEL_NORMAL ? "normal" : "flipped");
         break;
 
         SDL_EVENT_CASE(SDL_JOYAXISMOTION)
-        SDL_snprintf(details, sizeof(details), " (timestamp=%u which=%d axis=%u value=%d)",
-                     (uint)event->jaxis.timestamp, (int)event->jaxis.which,
-                     (uint)event->jaxis.axis, (int)event->jaxis.value);
+        (void)SDL_snprintf(details, sizeof(details), " (timestamp=%u which=%d axis=%u value=%d)",
+                           (uint)event->jaxis.timestamp, (int)event->jaxis.which,
+                           (uint)event->jaxis.axis, (int)event->jaxis.value);
         break;
 
         SDL_EVENT_CASE(SDL_JOYBALLMOTION)
-        SDL_snprintf(details, sizeof(details), " (timestamp=%u which=%d ball=%u xrel=%d yrel=%d)",
-                     (uint)event->jball.timestamp, (int)event->jball.which,
-                     (uint)event->jball.ball, (int)event->jball.xrel, (int)event->jball.yrel);
+        (void)SDL_snprintf(details, sizeof(details), " (timestamp=%u which=%d ball=%u xrel=%d yrel=%d)",
+                           (uint)event->jball.timestamp, (int)event->jball.which,
+                           (uint)event->jball.ball, (int)event->jball.xrel, (int)event->jball.yrel);
         break;
 
         SDL_EVENT_CASE(SDL_JOYHATMOTION)
-        SDL_snprintf(details, sizeof(details), " (timestamp=%u which=%d hat=%u value=%u)",
-                     (uint)event->jhat.timestamp, (int)event->jhat.which,
-                     (uint)event->jhat.hat, (uint)event->jhat.value);
+        (void)SDL_snprintf(details, sizeof(details), " (timestamp=%u which=%d hat=%u value=%u)",
+                           (uint)event->jhat.timestamp, (int)event->jhat.which,
+                           (uint)event->jhat.hat, (uint)event->jhat.value);
         break;
 
-#define PRINT_JBUTTON_EVENT(event)                                                        \
-    SDL_snprintf(details, sizeof(details), " (timestamp=%u which=%d button=%u state=%s)", \
-                 (uint)event->jbutton.timestamp, (int)event->jbutton.which,               \
-                 (uint)event->jbutton.button, event->jbutton.state == SDL_PRESSED ? "pressed" : "released")
+#define PRINT_JBUTTON_EVENT(event)                                                              \
+    (void)SDL_snprintf(details, sizeof(details), " (timestamp=%u which=%d button=%u state=%s)", \
+                       (uint)event->jbutton.timestamp, (int)event->jbutton.which,               \
+                       (uint)event->jbutton.button, event->jbutton.state == SDL_PRESSED ? "pressed" : "released")
         SDL_EVENT_CASE(SDL_JOYBUTTONDOWN)
         PRINT_JBUTTON_EVENT(event);
         break;
@@ -387,7 +387,7 @@ static void SDL_LogEvent(const SDL_Event *event)
         break;
 #undef PRINT_JBUTTON_EVENT
 
-#define PRINT_JOYDEV_EVENT(event) SDL_snprintf(details, sizeof(details), " (timestamp=%u which=%d)", (uint)event->jdevice.timestamp, (int)event->jdevice.which)
+#define PRINT_JOYDEV_EVENT(event) (void)SDL_snprintf(details, sizeof(details), " (timestamp=%u which=%d)", (uint)event->jdevice.timestamp, (int)event->jdevice.which)
         SDL_EVENT_CASE(SDL_JOYDEVICEADDED)
         PRINT_JOYDEV_EVENT(event);
         break;
@@ -397,15 +397,15 @@ static void SDL_LogEvent(const SDL_Event *event)
 #undef PRINT_JOYDEV_EVENT
 
         SDL_EVENT_CASE(SDL_CONTROLLERAXISMOTION)
-        SDL_snprintf(details, sizeof(details), " (timestamp=%u which=%d axis=%u value=%d)",
-                     (uint)event->caxis.timestamp, (int)event->caxis.which,
-                     (uint)event->caxis.axis, (int)event->caxis.value);
+        (void)SDL_snprintf(details, sizeof(details), " (timestamp=%u which=%d axis=%u value=%d)",
+                           (uint)event->caxis.timestamp, (int)event->caxis.which,
+                           (uint)event->caxis.axis, (int)event->caxis.value);
         break;
 
-#define PRINT_CBUTTON_EVENT(event)                                                        \
-    SDL_snprintf(details, sizeof(details), " (timestamp=%u which=%d button=%u state=%s)", \
-                 (uint)event->cbutton.timestamp, (int)event->cbutton.which,               \
-                 (uint)event->cbutton.button, event->cbutton.state == SDL_PRESSED ? "pressed" : "released")
+#define PRINT_CBUTTON_EVENT(event)                                                              \
+    (void)SDL_snprintf(details, sizeof(details), " (timestamp=%u which=%d button=%u state=%s)", \
+                       (uint)event->cbutton.timestamp, (int)event->cbutton.which,               \
+                       (uint)event->cbutton.button, event->cbutton.state == SDL_PRESSED ? "pressed" : "released")
         SDL_EVENT_CASE(SDL_CONTROLLERBUTTONDOWN)
         PRINT_CBUTTON_EVENT(event);
         break;
@@ -414,7 +414,7 @@ static void SDL_LogEvent(const SDL_Event *event)
         break;
 #undef PRINT_CBUTTON_EVENT
 
-#define PRINT_CONTROLLERDEV_EVENT(event) SDL_snprintf(details, sizeof(details), " (timestamp=%u which=%d)", (uint)event->cdevice.timestamp, (int)event->cdevice.which)
+#define PRINT_CONTROLLERDEV_EVENT(event) (void)SDL_snprintf(details, sizeof(details), " (timestamp=%u which=%d)", (uint)event->cdevice.timestamp, (int)event->cdevice.which)
         SDL_EVENT_CASE(SDL_CONTROLLERDEVICEADDED)
         PRINT_CONTROLLERDEV_EVENT(event);
         break;
@@ -426,11 +426,11 @@ static void SDL_LogEvent(const SDL_Event *event)
         break;
 #undef PRINT_CONTROLLERDEV_EVENT
 
-#define PRINT_CTOUCHPAD_EVENT(event)                                                                               \
-    SDL_snprintf(details, sizeof(details), " (timestamp=%u which=%d touchpad=%d finger=%d x=%f y=%f pressure=%f)", \
-                 (uint)event->ctouchpad.timestamp, (int)event->ctouchpad.which,                                    \
-                 (int)event->ctouchpad.touchpad, (int)event->ctouchpad.finger,                                     \
-                 event->ctouchpad.x, event->ctouchpad.y, event->ctouchpad.pressure)
+#define PRINT_CTOUCHPAD_EVENT(event)                                                                                     \
+    (void)SDL_snprintf(details, sizeof(details), " (timestamp=%u which=%d touchpad=%d finger=%d x=%f y=%f pressure=%f)", \
+                       (uint)event->ctouchpad.timestamp, (int)event->ctouchpad.which,                                    \
+                       (int)event->ctouchpad.touchpad, (int)event->ctouchpad.finger,                                     \
+                       event->ctouchpad.x, event->ctouchpad.y, event->ctouchpad.pressure)
         SDL_EVENT_CASE(SDL_CONTROLLERTOUCHPADDOWN)
         PRINT_CTOUCHPAD_EVENT(event);
         break;
@@ -443,16 +443,16 @@ static void SDL_LogEvent(const SDL_Event *event)
 #undef PRINT_CTOUCHPAD_EVENT
 
         SDL_EVENT_CASE(SDL_CONTROLLERSENSORUPDATE)
-        SDL_snprintf(details, sizeof(details), " (timestamp=%u which=%d sensor=%d data[0]=%f data[1]=%f data[2]=%f)",
-                     (uint)event->csensor.timestamp, (int)event->csensor.which, (int)event->csensor.sensor,
-                     event->csensor.data[0], event->csensor.data[1], event->csensor.data[2]);
+        (void)SDL_snprintf(details, sizeof(details), " (timestamp=%u which=%d sensor=%d data[0]=%f data[1]=%f data[2]=%f)",
+                           (uint)event->csensor.timestamp, (int)event->csensor.which, (int)event->csensor.sensor,
+                           event->csensor.data[0], event->csensor.data[1], event->csensor.data[2]);
         break;
 
-#define PRINT_FINGER_EVENT(event)                                                                                                                \
-    SDL_snprintf(details, sizeof(details), " (timestamp=%u touchid=%" SDL_PRIs64 " fingerid=%" SDL_PRIs64 " x=%f y=%f dx=%f dy=%f pressure=%f)", \
-                 (uint)event->tfinger.timestamp, (long long)event->tfinger.touchId,                                                              \
-                 (long long)event->tfinger.fingerId, event->tfinger.x, event->tfinger.y,                                                         \
-                 event->tfinger.dx, event->tfinger.dy, event->tfinger.pressure)
+#define PRINT_FINGER_EVENT(event)                                                                                                                      \
+    (void)SDL_snprintf(details, sizeof(details), " (timestamp=%u touchid=%" SDL_PRIs64 " fingerid=%" SDL_PRIs64 " x=%f y=%f dx=%f dy=%f pressure=%f)", \
+                       (uint)event->tfinger.timestamp, (long long)event->tfinger.touchId,                                                              \
+                       (long long)event->tfinger.fingerId, event->tfinger.x, event->tfinger.y,                                                         \
+                       event->tfinger.dx, event->tfinger.dy, event->tfinger.pressure)
         SDL_EVENT_CASE(SDL_FINGERDOWN)
         PRINT_FINGER_EVENT(event);
         break;
@@ -464,11 +464,11 @@ static void SDL_LogEvent(const SDL_Event *event)
         break;
 #undef PRINT_FINGER_EVENT
 
-#define PRINT_DOLLAR_EVENT(event)                                                                                                                \
-    SDL_snprintf(details, sizeof(details), " (timestamp=%u touchid=%" SDL_PRIs64 " gestureid=%" SDL_PRIs64 " numfingers=%u error=%f x=%f y=%f)", \
-                 (uint)event->dgesture.timestamp, (long long)event->dgesture.touchId,                                                            \
-                 (long long)event->dgesture.gestureId, (uint)event->dgesture.numFingers,                                                         \
-                 event->dgesture.error, event->dgesture.x, event->dgesture.y)
+#define PRINT_DOLLAR_EVENT(event)                                                                                                                      \
+    (void)SDL_snprintf(details, sizeof(details), " (timestamp=%u touchid=%" SDL_PRIs64 " gestureid=%" SDL_PRIs64 " numfingers=%u error=%f x=%f y=%f)", \
+                       (uint)event->dgesture.timestamp, (long long)event->dgesture.touchId,                                                            \
+                       (long long)event->dgesture.gestureId, (uint)event->dgesture.numFingers,                                                         \
+                       event->dgesture.error, event->dgesture.x, event->dgesture.y)
         SDL_EVENT_CASE(SDL_DOLLARGESTURE)
         PRINT_DOLLAR_EVENT(event);
         break;
@@ -478,13 +478,13 @@ static void SDL_LogEvent(const SDL_Event *event)
 #undef PRINT_DOLLAR_EVENT
 
         SDL_EVENT_CASE(SDL_MULTIGESTURE)
-        SDL_snprintf(details, sizeof(details), " (timestamp=%u touchid=%" SDL_PRIs64 " dtheta=%f ddist=%f x=%f y=%f numfingers=%u)",
-                     (uint)event->mgesture.timestamp, (long long)event->mgesture.touchId,
-                     event->mgesture.dTheta, event->mgesture.dDist,
-                     event->mgesture.x, event->mgesture.y, (uint)event->mgesture.numFingers);
+        (void)SDL_snprintf(details, sizeof(details), " (timestamp=%u touchid=%" SDL_PRIs64 " dtheta=%f ddist=%f x=%f y=%f numfingers=%u)",
+                           (uint)event->mgesture.timestamp, (long long)event->mgesture.touchId,
+                           event->mgesture.dTheta, event->mgesture.dDist,
+                           event->mgesture.x, event->mgesture.y, (uint)event->mgesture.numFingers);
         break;
 
-#define PRINT_DROP_EVENT(event) SDL_snprintf(details, sizeof(details), " (file='%s' timestamp=%u windowid=%u)", event->drop.file, (uint)event->drop.timestamp, (uint)event->drop.windowID)
+#define PRINT_DROP_EVENT(event) (void)SDL_snprintf(details, sizeof(details), " (file='%s' timestamp=%u windowid=%u)", event->drop.file, (uint)event->drop.timestamp, (uint)event->drop.windowID)
         SDL_EVENT_CASE(SDL_DROPFILE)
         PRINT_DROP_EVENT(event);
         break;
@@ -499,7 +499,7 @@ static void SDL_LogEvent(const SDL_Event *event)
         break;
 #undef PRINT_DROP_EVENT
 
-#define PRINT_AUDIODEV_EVENT(event) SDL_snprintf(details, sizeof(details), " (timestamp=%u which=%u iscapture=%s)", (uint)event->adevice.timestamp, (uint)event->adevice.which, event->adevice.iscapture ? "true" : "false")
+#define PRINT_AUDIODEV_EVENT(event) (void)SDL_snprintf(details, sizeof(details), " (timestamp=%u which=%u iscapture=%s)", (uint)event->adevice.timestamp, (uint)event->adevice.which, event->adevice.iscapture ? "true" : "false")
         SDL_EVENT_CASE(SDL_AUDIODEVICEADDED)
         PRINT_AUDIODEV_EVENT(event);
         break;
@@ -509,10 +509,10 @@ static void SDL_LogEvent(const SDL_Event *event)
 #undef PRINT_AUDIODEV_EVENT
 
         SDL_EVENT_CASE(SDL_SENSORUPDATE)
-        SDL_snprintf(details, sizeof(details), " (timestamp=%u which=%d data[0]=%f data[1]=%f data[2]=%f data[3]=%f data[4]=%f data[5]=%f)",
-                     (uint)event->sensor.timestamp, (int)event->sensor.which,
-                     event->sensor.data[0], event->sensor.data[1], event->sensor.data[2],
-                     event->sensor.data[3], event->sensor.data[4], event->sensor.data[5]);
+        (void)SDL_snprintf(details, sizeof(details), " (timestamp=%u which=%d data[0]=%f data[1]=%f data[2]=%f data[3]=%f data[4]=%f data[5]=%f)",
+                           (uint)event->sensor.timestamp, (int)event->sensor.which,
+                           event->sensor.data[0], event->sensor.data[1], event->sensor.data[2],
+                           event->sensor.data[3], event->sensor.data[4], event->sensor.data[5]);
         break;
 
 #undef SDL_EVENT_CASE
@@ -524,7 +524,7 @@ static void SDL_LogEvent(const SDL_Event *event)
     default:
         if (!name[0]) {
             SDL_strlcpy(name, "UNKNOWN", sizeof(name));
-            SDL_snprintf(details, sizeof(details), " #%u! (Bug? FIXME?)", (uint)event->type);
+            (void)SDL_snprintf(details, sizeof(details), " #%u! (Bug? FIXME?)", (uint)event->type);
         }
         break;
     }
diff --git a/src/events/SDL_keyboard.c b/src/events/SDL_keyboard.c
index 94b9be538..c89dd9c8b 100644
--- a/src/events/SDL_keyboard.c
+++ b/src/events/SDL_keyboard.c
@@ -1154,10 +1154,11 @@ SDL_GetScancodeName(SDL_Scancode scancode)
     }
 
     name = SDL_scancode_names[scancode];
-    if (name)
+    if (name != NULL) {
         return name;
-    else
-        return "";
+    }
+
+    return "";
 }
 
 SDL_Scancode SDL_GetScancodeFromName(const char *name)
diff --git a/src/events/SDL_keyboard_c.h b/src/events/SDL_keyboard_c.h
index d81571210..65a3ee9b1 100644
--- a/src/events/SDL_keyboard_c.h
+++ b/src/events/SDL_keyboard_c.h
@@ -70,7 +70,7 @@ extern SDL_bool SDL_HardwareKeyboardKeyPressed(void);
 extern int SDL_SendKeyboardText(const char *text);
 
 /* Send editing text for selected range from start to end */
-extern int SDL_SendEditingText(const char *text, int start, int end);
+extern int SDL_SendEditingText(const char *text, int start, int length);
 
 /* Shutdown the keyboard subsystem */
 extern void SDL_KeyboardQuit(void);
diff --git a/src/events/SDL_mouse.c b/src/events/SDL_mouse.c
index e6b54d2fa..603c0981e 100644
--- a/src/events/SDL_mouse.c
+++ b/src/events/SDL_mouse.c
@@ -381,7 +381,7 @@ static int GetScaledMouseDelta(float scale, int value, float *accum)
     return value;
 }
 
-static float CalculateSystemScale(SDL_Mouse *mouse, int *x, int *y)
+static float CalculateSystemScale(SDL_Mouse *mouse, const int *x, const int *y)
 {
     int i;
     int n = mouse->num_system_scale_values;
diff --git a/src/events/SDL_quit.c b/src/events/SDL_quit.c
index a56f7e909..894a15a7e 100644
--- a/src/events/SDL_quit.c
+++ b/src/events/SDL_quit.c
@@ -50,7 +50,7 @@ static SDL_bool send_foregrounding_pending = SDL_FALSE;
 static void SDL_HandleSIG(int sig)
 {
     /* Reset the signal handler */
-    signal(sig, SDL_HandleSIG);
+    (void)signal(sig, SDL_HandleSIG);
 
     /* Send a quit event next time the event loop pumps. */
     /* We can't send it in signal handler; SDL_malloc() might be interrupted! */
diff --git a/src/file/SDL_rwops.c b/src/file/SDL_rwops.c
index 6f95881e6..4990a5518 100644
--- a/src/file/SDL_rwops.c
+++ b/src/file/SDL_rwops.c
@@ -722,7 +722,7 @@ void SDL_FreeRW(SDL_RWops *area)
 void *
 SDL_LoadFile_RW(SDL_RWops *src, size_t *datasize, int freesrc)
 {
-    const int FILE_CHUNK_SIZE = 1024;
+    static const Sint64 FILE_CHUNK_SIZE = 1024;
     Sint64 size;
     size_t size_read, size_total;
     void *data = NULL, *newdata;
diff --git a/src/file/cocoa/SDL_rwopsbundlesupport.m b/src/file/cocoa/SDL_rwopsbundlesupport.m
index 55104a47b..fc2cbb0e5 100644
--- a/src/file/cocoa/SDL_rwopsbundlesupport.m
+++ b/src/file/cocoa/SDL_rwopsbundlesupport.m
@@ -42,7 +42,7 @@ FILE *SDL_OpenFPFromBundleOrFallback(const char *file, const char *mode)
         NSString *full_path_with_file_to_try;
 
         /* If the file mode is writable, skip all the bundle stuff because generally the bundle is read-only. */
-        if (strcmp("r", mode) && strcmp("rb", mode)) {
+        if (SDL_strchr(mode, 'r') == NULL) {
             return fopen(file, mode);
         }
 
diff --git a/src/filesystem/unix/SDL_sysfilesystem.c b/src/filesystem/unix/SDL_sysfilesystem.c
index d4e4ae5ff..7d57a7e97 100644
--- a/src/filesystem/unix/SDL_sysfilesystem.c
+++ b/src/filesystem/unix/SDL_sysfilesystem.c
@@ -321,9 +321,9 @@ SDL_GetPrefPath(const char *org, const char *app)
     }
 
     if (*org) {
-        SDL_snprintf(retval, len, "%s%s%s/%s/", envr, append, org, app);
+        (void)SDL_snprintf(retval, len, "%s%s%s/%s/", envr, append, org, app);
     } else {
-        SDL_snprintf(retval, len, "%s%s%s/", envr, append, app);
+        (void)SDL_snprintf(retval, len, "%s%s%s/", envr, append, app);
     }
 
     for (ptr = retval + 1; *ptr; ptr++) {
diff --git a/src/haptic/SDL_haptic.c b/src/haptic/SDL_haptic.c
index 604ba7cb3..c20962cae 100644
--- a/src/haptic/SDL_haptic.c
+++ b/src/haptic/SDL_haptic.c
@@ -240,12 +240,13 @@ int SDL_JoystickIsHaptic(SDL_Joystick *joystick)
 
     ret = SDL_SYS_JoystickIsHaptic(joystick);
 
-    if (ret > 0)
+    if (ret > 0) {
         return SDL_TRUE;
-    else if (ret == 0)
+    } else if (ret == 0) {
         return SDL_FALSE;
-    else
-        return -1;
+    }
+
+    return -1;
 }
 
 /*
diff --git a/src/haptic/android/SDL_syshaptic.c b/src/haptic/android/SDL_syshaptic.c
index 13a16bd9d..de42dca07 100644
--- a/src/haptic/android/SDL_syshaptic.c
+++ b/src/haptic/android/SDL_syshaptic.c
@@ -167,7 +167,6 @@ void SDL_SYS_HapticClose(SDL_Haptic *haptic)
 {
     ((SDL_hapticlist_item *)haptic->hwdata)->haptic = NULL;
     haptic->hwdata = NULL;
-    return;
 }
 
 void SDL_SYS_HapticQuit(void)
@@ -223,11 +222,9 @@ int SDL_SYS_HapticStopEffect(SDL_Haptic *haptic, struct haptic_effect *effect)
 
 void SDL_SYS_HapticDestroyEffect(SDL_Haptic *haptic, struct haptic_effect *effect)
 {
-    return;
 }
 
-int SDL_SYS_HapticGetEffectStatus(SDL_Haptic *haptic,
-                                  struct haptic_effect *effect)
+int SDL_SYS_HapticGetEffectStatus(SDL_Haptic *haptic, struct haptic_effect *effect)
 {
     return 0;
 }
diff --git a/src/haptic/darwin/SDL_syshaptic.c b/src/haptic/darwin/SDL_syshaptic.c
index 23410bac6..915364c80 100644
--- a/src/haptic/darwin/SDL_syshaptic.c
+++ b/src/haptic/darwin/SDL_syshaptic.c
@@ -1204,8 +1204,9 @@ int SDL_SYS_HapticRunEffect(SDL_Haptic *haptic, struct haptic_effect *effect,
     /* Check if it's infinite. */
     if (iterations == SDL_HAPTIC_INFINITY) {
         iter = FF_INFINITE;
-    } else
+    } else {
         iter = iterations;
+    }
 
     /* Run the effect. */
     ret = FFEffectStart(effect->hweffect->ref, iter, 0);
diff --git a/src/haptic/linux/SDL_syshaptic.c b/src/haptic/linux/SDL_syshaptic.c
index 6a0713d44..bc409159d 100644
--- a/src/haptic/linux/SDL_syshaptic.c
+++ b/src/haptic/linux/SDL_syshaptic.c
@@ -160,8 +160,7 @@ int SDL_SYS_HapticInit(void)
      */
     i = 0;
     for (j = 0; j < MAX_HAPTICS; ++j) {
-
-        SDL_snprintf(path, PATH_MAX, joydev_pattern, i++);
+        (void)SDL_snprintf(path, PATH_MAX, joydev_pattern, i++);
         MaybeAddDevice(path);
     }
 
@@ -673,9 +672,9 @@ static int SDL_SYS_ToDirection(Uint16 *dest, SDL_HapticDirection *src)
         break;
 
     case SDL_HAPTIC_CARTESIAN:
-        if (!src->dir[1])
+        if (!src->dir[1]) {
             *dest = (src->dir[0] >= 0 ? 0x4000 : 0xC000);
-        else if (!src->dir[0])
+        } else if (!src->dir[0]) {
             *dest = (src->dir[1] >= 0 ? 0x8000 : 0);
         else {
             float f = SDL_atan2(src->dir[1], src->dir[0]);    /* Ideally we'd use fixed point math instead of floats... */
diff --git a/src/haptic/windows/SDL_dinputhaptic.c b/src/haptic/windows/SDL_dinputhaptic.c
index 7af3de9a1..5dc90ac76 100644
--- a/src/haptic/windows/SDL_dinputhaptic.c
+++ b/src/haptic/windows/SDL_dinputhaptic.c
@@ -664,10 +664,10 @@ static int SDL_SYS_ToDIEFFECT(SDL_Haptic *haptic, DIEFFECT *dest,
         dest->lpvTypeSpecificParams = constant;
 
         /* Generics */
-        dest->dwDuration = hap_constant->length * 1000; /* In microseconds. */
+        dest->dwDuration = hap_constant->length * 1000UL; /* In microseconds. */
         dest->dwTriggerButton = DIGetTriggerButton(hap_constant->button);
         dest->dwTriggerRepeatInterval = hap_constant->interval;
-        dest->dwStartDelay = hap_constant->delay * 1000; /* In microseconds. */
+        dest->dwStartDelay = hap_constant->delay * 1000UL; /* In microseconds. */
 
         /* Direction. */
         if (SDL_SYS_SetDirection(dest, &hap_constant->direction, dest->cAxes) < 0) {
@@ -680,9 +680,9 @@ static int SDL_SYS_ToDIEFFECT(SDL_Haptic *haptic, DIEFFECT *dest,
             dest->lpEnvelope = NULL;
         } else {
             envelope->dwAttackLevel = CCONVERT(hap_constant->attack_level);
-            envelope->dwAttackTime = hap_constant->attack_length * 1000;
+            envelope->dwAttackTime = hap_constant->attack_length * 1000UL;
             envelope->dwFadeLevel = CCONVERT(hap_constant->fade_level);
-            envelope->dwFadeTime = hap_constant->fade_length * 1000;
+            envelope->dwFadeTime = hap_constant->fade_length * 1000UL;
         }
 
         break;
@@ -710,10 +710,10 @@ static int SDL_SYS_ToDIEFFECT(SDL_Haptic *haptic, DIEFFECT *dest,
         dest->lpvTypeSpecificParams = periodic;
 
         /* Generics */
-        dest->dwDuration = hap_periodic->length * 1000; /* In microseconds. */
+        dest->dwDuration = hap_periodic->length * 1000UL; /* In microseconds. */
         dest->dwTriggerButton = DIGetTriggerButton(hap_periodic->button);
         dest->dwTriggerRepeatInterval = hap_periodic->interval;
-        dest->dwStartDelay = hap_periodic->delay * 1000; /* In microseconds. */
+        dest->dwStartDelay = hap_periodic->delay * 1000UL; /* In microseconds. */
 
         /* Direction. */
         if (SDL_SYS_SetDirection(dest, &hap_periodic->direction, dest->cAxes) < 0) {
@@ -726,9 +726,9 @@ static int SDL_SYS_ToDIEFFECT(SDL_Haptic *haptic, DIEFFECT *dest,
             dest->lpEnvelope = NULL;
         } else {
             envelope->dwAttackLevel = CCONVERT(hap_periodic->attack_level);
-            envelope->dwAttackTime = hap_periodic->attack_length * 1000;
+            envelope->dwAttackTime = hap_periodic->attack_length * 1000UL;
             envelope->dwFadeLevel = CCONVERT(hap_periodic->fade_level);
-            envelope->dwFadeTime = hap_periodic->fade_length * 1000;
+            envelope->dwFadeTime = hap_periodic->fade_length * 1000UL;
         }
 
         break;
@@ -761,10 +761,10 @@ static int SDL_SYS_ToDIEFFECT(SDL_Haptic *haptic, DIEFFECT *dest,
         dest->lpvTypeSpecificParams = condition;
 
         /* Generics */
-        dest->dwDuration = hap_condition->length * 1000; /* In microseconds. */
+        dest->dwDuration = hap_condition->length * 1000UL; /* In microseconds. */
         dest->dwTriggerButton = DIGetTriggerButton(hap_condition->button);
         dest->dwTriggerRepeatInterval = hap_condition->interval;
-        dest->dwStartDelay = hap_condition->delay * 1000; /* In microseconds. */
+        dest->dwStartDelay = hap_condition->delay * 1000UL; /* In microseconds. */
 
         /* Direction. */
         if (SDL_SYS_SetDirection(dest, &hap_condition->direction, dest->cAxes) < 0) {
@@ -792,10 +792,10 @@ static int SDL_SYS_ToDIEFFECT(SDL_Haptic *haptic, DIEFFECT *dest,
         dest->lpvTypeSpecificParams = ramp;
 
         /* Generics */
-        dest->dwDuration = hap_ramp->length * 1000; /* In microseconds. */
+        dest->dwDuration = hap_ramp->length * 1000UL; /* In microseconds. */
         dest->dwTriggerButton = DIGetTriggerButton(hap_ramp->button);
         dest->dwTriggerRepeatInterval = hap_ramp->interval;
-        dest->dwStartDelay = hap_ramp->delay * 1000; /* In microseconds. */
+        dest->dwStartDelay = hap_ramp->delay * 1000UL; /* In microseconds. */
 
         /* Direction. */
         if (SDL_SYS_SetDirection(dest, &hap_ramp->direction, dest->cAxes) < 0) {
@@ -808,9 +808,9 @@ static int SDL_SYS_ToDIEFFECT(SDL_Haptic *haptic, DIEFFECT *dest,
             dest->lpEnvelope = NULL;
         } else {
             envelope->dwAttackLevel = CCONVERT(hap_ramp->attack_level);
-            envelope->dwAttackTime = hap_ramp->attack_length * 1000;
+            envelope->dwAttackTime = hap_ramp->attack_length * 1000UL;
             envelope->dwFadeLevel = CCONVERT(hap_ramp->fade_level);
-            envelope->dwFadeTime = hap_ramp->fade_length * 1000;
+            envelope->dwFadeTime = hap_ramp->fade_length * 1000UL;
         }
 
         break;
@@ -825,7 +825,7 @@ static int SDL_SYS_ToDIEFFECT(SDL_Haptic *haptic, DIEFFECT *dest,
 
         /* Specifics */
         custom->cChannels = hap_custom->channels;
-        custom->dwSamplePeriod = hap_custom->period * 1000;
+        custom->dwSamplePeriod = hap_custom->period * 1000UL;
         custom->cSamples = hap_custom->samples;
         custom->rglForceData =
             SDL_malloc(sizeof(LONG) * custom->cSamples * custom->cChannels);
@@ -836,10 +836,10 @@ static int SDL_SYS_ToDIEFFECT(SDL_Haptic *haptic, DIEFFECT *dest,
         dest->lpvTypeSpecificParams = custom;
 
         /* Generics */
-        dest->dwDuration = hap_custom->length * 1000; /* In microseconds. */
+        dest->dwDuration = hap_custom->length * 1000UL; /* In microseconds. */
         dest->dwTriggerButton = DIGetTriggerButton(hap_custom->button);
         dest->dwTriggerRepeatInterval = hap_custom->interval;
-        dest->dwStartDelay = hap_custom->delay * 1000; /* In microseconds. */
+        dest->dwStartDelay = hap_custom->delay * 1000UL; /* In microseconds. */
 
         /* Direction. */
         if (SDL_SYS_SetDirection(dest, &hap_custom->direction, dest->cAxes) < 0) {
@@ -852,9 +852,9 @@ static int SDL_SYS_ToDIEFFECT(SDL_Haptic *haptic, DIEFFECT *dest,
             dest->lpEnvelope = NULL;
         } else {
             envelope->dwAttackLevel = CCONVERT(hap_custom->attack_level);
-            envelope->dwAttackTime = hap_custom->attack_length * 1000;
+            envelope->dwAttackTime = hap_custom->attack_length * 1000UL;
             envelope->dwFadeLevel = CCONVERT(hap_custom->fade_level);
-            envelope->dwFadeTime = hap_custom->fade_length * 1000;
+            envelope->dwFadeTime = hap_custom->fade_length * 1000UL;
         }
 
         break;
@@ -893,6 +893,7 @@ static void SDL_SYS_HapticFreeDIEFFECT(DIEFFECT *effect, int type)
 /*
  * Gets the effect type from the generic SDL haptic effect wrapper.
  */
+/* NOLINTNEXTLINE(readability-const-return-type): Can't fix Windows' headers */
 static REFGUID SDL_SYS_HapticEffectType(SDL_HapticEffect *effect)
 {
     switch (effect->type) {
@@ -1088,7 +1089,7 @@ int SDL_DINPUT_HapticSetGain(SDL_Haptic *haptic, int gain)
     dipdw.diph.dwHeaderSize = sizeof(DIPROPHEADER);
     dipdw.diph.dwObj = 0;
     dipdw.diph.dwHow = DIPH_DEVICE;
-    dipdw.dwData = gain * 100; /* 0 to 10,000 */
+    dipdw.dwData = (DWORD)gain * 100; /* 0 to 10,000 */
 
     /* Try to set the autocenter. */
     ret = IDirectInputDevice8_SetProperty(haptic->hwdata->device,
diff --git a/src/haptic/windows/SDL_xinputhaptic.c b/src/haptic/windows/SDL_xinputhaptic.c
index 81d8f1faf..dd42861b4 100644
--- a/src/haptic/windows/SDL_xinputhaptic.c
+++ b/src/haptic/windows/SDL_xinputhaptic.c
@@ -93,7 +93,7 @@ int SDL_XINPUT_HapticMaybeAddDevice(const DWORD dwUserid)
     /* !!! FIXME: I'm not bothering to query for a real name right now (can we even?) */
     {
         char buf[64];
-        SDL_snprintf(buf, sizeof(buf), "XInput Controller #%u", (unsigned int)(userid + 1));
+        (void)SDL_snprintf(buf, sizeof buf, "XInput Controller #%u", userid + 1);
         item->name = SDL_strdup(buf);
     }
 
@@ -204,7 +204,7 @@ static int SDL_XINPUT_HapticOpenFromUserIndex(SDL_Haptic *haptic, const Uint8 us
         return SDL_SetError("Couldn't create XInput haptic mutex");
     }
 
-    SDL_snprintf(threadName, sizeof(threadName), "SDLXInputDev%d", (int)userid);
+    (void)SDL_snprintf(threadName, sizeof threadName, "SDLXInputDev%u", userid);
     haptic->hwdata->thread = SDL_CreateThreadInternal(SDL_RunXInputHaptic, threadName, 64 * 1024, haptic->hwdata);
 
     if (haptic->hwdata->thread == NULL) {
diff --git a/src/hidapi/SDL_hidapi.c b/src/hidapi/SDL_hidapi.c
index dd7963009..ccaf958e7 100644
--- a/src/hidapi/SDL_hidapi.c
+++ b/src/hidapi/SDL_hidapi.c
@@ -57,7 +57,6 @@
 #include "../core/linux/SDL_udev.h"
 #ifdef SDL_USE_LIBUDEV
 #include <poll.h>
-#include <unistd.h>
 #include "../core/linux/SDL_sandbox.h"
 #endif
 
@@ -69,6 +68,10 @@
 #include <sys/inotify.h>
 #endif
 
+#if defined(SDL_USE_LIBUDEV) || defined(HAVE_INOTIFY)
+#include <unistd.h>
+#endif
+
 #if defined(SDL_USE_LIBUDEV)
 typedef enum
 {
@@ -316,15 +319,15 @@ HIDAPI_InitializeDiscovery()
         SDL_HIDAPI_discovery.m_nUdevFd = -1;
 
         usyms = SDL_UDEV_GetUdevSyms();
-        if (usyms) {
+        if (usyms != NULL) {
             SDL_HIDAPI_discovery.m_pUdev = usyms->udev_new();
-        }
-        if (SDL_HIDAPI_discovery.m_pUdev) {
-            SDL_HIDAPI_discovery.m_pUdevMonitor = usyms->udev_monitor_new_from_netlink(SDL_HIDAPI_discovery.m_pUdev, "udev");
-            if (SDL_HIDAPI_discovery.m_pUdevMonitor) {
-                usyms->udev_monitor_enable_receiving(SDL_HIDAPI_discovery.m_pUdevMonitor);
-                SDL_HIDAPI_discovery.m_nUdevFd = usyms->udev_monitor_get_fd(SDL_HIDAPI_discovery.m_pUdevMonitor);
-                SDL_HIDAPI_discovery.m_bCanGetNotifications = SDL_TRUE;
+            if (SDL_HIDAPI_discovery.m_pUdev != NULL) {
+                SDL_HIDAPI_discovery.m_pUdevMonitor = usyms->udev_monitor_new_from_netlink(SDL_HIDAPI_discovery.m_pUdev, "udev");
+                if (SDL_HIDAPI_discovery.m_pUdevMonitor != NULL) {
+                    usyms->udev_monitor_enable_receiving(SDL_HIDAPI_discovery.m_pUdevMonitor);
+                    SDL_HIDAPI_discovery.m_nUdevFd = usyms->udev_monitor_get_fd(SDL_HIDAPI_discovery.m_pUdevMonitor);
+                    SDL_HIDAPI_discovery.m_bCanGetNotifications = SDL_TRUE;
+                }
             }
         }
     } else
@@ -1378,22 +1381,27 @@ SDL_hid_device *SDL_hid_open(unsigned short vendor_id, unsigned short product_id
     }
 
 #if HAVE_PLATFORM_BACKEND
-    if (udev_ctx &&
-        (pDevice = PLATFORM_hid_open(vendor_id, product_id, serial_number)) != NULL) {
-        return CreateHIDDeviceWrapper(pDevice, &PLATFORM_Backend);
+    if (udev_ctx) {
+        pDevice = PLATFORM_hid_open(vendor_id, product_id, serial_number);
+        if (pDevice != NULL) {
+            return CreateHIDDeviceWrapper(pDevice, &PLATFORM_Backend);
+        }
     }
 #endif /* HAVE_PLATFORM_BACKEND */
 
 #if HAVE_DRIVER_BACKEND
-    if ((pDevice = DRIVER_hid_open(vendor_id, product_id, serial_number)) != NULL) {
+    pDevice = DRIVER_hid_open(vendor_id, product_id, serial_number);
+    if (pDevice != NULL) {
         return CreateHIDDeviceWrapper(pDevice, &DRIVER_Backend);
     }
 #endif /* HAVE_DRIVER_BACKEND */
 
 #ifdef HAVE_LIBUSB
-    if (libusb_ctx.libhandle &&
-        (pDevice = LIBUSB_hid_open(vendor_id, product_id, serial_number)) != NULL) {
-        return CreateHIDDeviceWrapper(pDevice, &LIBUSB_Backend);
+    if (libusb_ctx.libhandle != NULL) {
+        pDevice = LIBUSB_hid_open(vendor_id, product_id, serial_number);
+        if (pDevice != NULL) {
+            return CreateHIDDeviceWrapper(pDevice, &LIBUSB_Backend);
+        }
     }
 #endif /* HAVE_LIBUSB */
 
@@ -1412,22 +1420,27 @@ SDL_hid_device *SDL_hid_open_path(const char *path, int bExclusive /* = false */
     }
 
 #if HAVE_PLATFORM_BACKEND
-    if (udev_ctx &&
-        (pDevice = PLATFORM_hid_open_path(path, bExclusive)) != NULL) {
-        return CreateHIDDeviceWrapper(pDevice, &PLATFORM_Backend);
+    if (udev_ctx) {
+        pDevice = PLATFORM_hid_open_path(path, bExclusive);
+        if (pDevice != NULL) {
+            return CreateHIDDeviceWrapper(pDevice, &PLATFORM_Backend);
+        }
     }
 #endif /* HAVE_PLATFORM_BACKEND */
 
 #if HAVE_DRIVER_BACKEND
-    if ((pDevice = DRIVER_hid_open_path(path, bExclusive)) != NULL) {
+    pDevice = DRIVER_hid_open_path(path, bExclusive);
+    if (pDevice != NULL) {
         return CreateHIDDeviceWrapper(pDevice, &DRIVER_Backend);
     }
 #endif /* HAVE_DRIVER_BACKEND */
 
 #ifdef HAVE_LIBUSB
-    if (libusb_ctx.libhandle &&
-        (pDevice = LIBUSB_hid_open_path(path, bExclusive)) != NULL) {
-        return CreateHIDDeviceWrapper(pDevice, &LIBUSB_Backend);
+    if (libusb_ctx.libhandle != NULL) {
+        pDevice = LIBUSB_hid_open_path(path, bExclusive);
+        if (pDevice != NULL) {
+            return CreateHIDDeviceWrapper(pDevice, &LIBUSB_Backend);
+        }
     }
 #endif /* HAVE_LIBUSB */
 
diff --git a/src/joystick/SDL_gamecontroller.c b/src/joystick/SDL_gamecontroller.c
index 6b538c952..d5dddd6f6 100644
--- a/src/joystick/SDL_gamecontroller.c
+++ b/src/joystick/SDL_gamecontroller.c
@@ -825,20 +825,21 @@ static const char *map_StringForControllerAxis[] = {
 /*
  * convert a string to its enum equivalent
  */
-SDL_GameControllerAxis SDL_GameControllerGetAxisFromString(const char *pchString)
+SDL_GameControllerAxis
+SDL_GameControllerGetAxisFromString(const char *str)
 {
     int entry;
 
-    if (pchString && (*pchString == '+' || *pchString == '-')) {
-        ++pchString;
+    if (str == NULL || str[0] == '\0') {
+        return SDL_CONTROLLER_AXIS_INVALID;
     }
 
-    if (pchString == NULL || !pchString[0]) {
-        return SDL_CONTROLLER_AXIS_INVALID;
+    if (*str == '+' || *str == '-') {
+        ++str;
     }
 
     for (entry = 0; map_StringForControllerAxis[entry]; ++entry) {
-        if (!SDL_strcasecmp(pchString, map_StringForControllerAxis[entry])) {
+        if (SDL_strcasecmp(str, map_StringForControllerAxis[entry]) == 0) {
             return (SDL_GameControllerAxis)entry;
         }
     }
@@ -884,15 +885,16 @@ static const char *map_StringForControllerButton[] = {
 /*
  * convert a string to its enum equivalent
  */
-SDL_GameControllerButton SDL_GameControllerGetButtonFromString(const char *pchString)
+SDL_GameControllerButton
+SDL_GameControllerGetButtonFromString(const char *str)
 {
     int entry;
-    if (pchString == NULL || !pchString[0]) {
+    if (str == NULL || str[0] == '\0') {
         return SDL_CONTROLLER_BUTTON_INVALID;
     }
 
     for (entry = 0; map_StringForControllerButton[entry]; ++entry) {
-        if (SDL_strcasecmp(pchString, map_StringForControllerButton[entry]) == 0) {
+        if (SDL_strcasecmp(str, map_StringForControllerButton[entry]) == 0) {
             return (SDL_GameControllerButton)entry;
         }
     }
@@ -902,10 +904,10 @@ SDL_GameControllerButton SDL_GameControllerGetButtonFromString(const char *pchSt
 /*
  * convert an enum to its string equivalent
  */
-const char *SDL_GameControllerGetStringForButton(SDL_GameControllerButton axis)
+const char *SDL_GameControllerGetStringForButton(SDL_GameControllerButton button)
 {
-    if (axis > SDL_CONTROLLER_BUTTON_INVALID && axis < SDL_CONTROLLER_BUTTON_MAX) {
-        return map_StringForControllerButton[axis];
+    if (button > SDL_CONTROLLER_BUTTON_INVALID && button < SDL_CONTROLLER_BUTTON_MAX) {
+        return map_StringForControllerButton[button];
     }
     return NULL;
 }
@@ -1071,7 +1073,7 @@ static void SDL_PrivateLoadButtonMapping(SDL_GameController *gamecontroller, Con
     gamecontroller->name = pControllerMapping->name;
     gamecontroller->num_bindings = 0;
     gamecontroller->mapping = pControllerMapping;
-    if (gamecontroller->joystick->naxes) {
+    if (gamecontroller->joystick->naxes != 0 && gamecontroller->last_match_axis != NULL) {
         SDL_memset(gamecontroller->last_match_axis, 0, gamecontroller->joystick->naxes * sizeof(*gamecontroller->last_match_axis));
     }
 
@@ -1351,13 +1353,13 @@ static void SDL_PrivateAppendToMappingString(char *mapping_string,
     SDL_strlcat(mapping_string, ":", mapping_string_len);
     switch (mapping->kind) {
     case EMappingKind_Button:
-        SDL_snprintf(buffer, sizeof(buffer), "b%i", mapping->target);
+        (void)SDL_snprintf(buffer, sizeof buffer, "b%i", mapping->target);
         break;
     case EMappingKind_Axis:
-        SDL_snprintf(buffer, sizeof(buffer), "a%i", mapping->target);
+        (void)SDL_snprintf(buffer, sizeof buffer, "a%i", mapping->target);
         break;
     case EMappingKind_Hat:
-        SDL_snprintf(buffer, sizeof(buffer), "h%i.%i", mapping->target >> 4, mapping->target & 0x0F);
+        (void)SDL_snprintf(buffer, sizeof buffer, "h%i.%i", mapping->target >> 4, mapping->target & 0x0F);
         break;
     default:
         SDL_assert(SDL_FALSE);
@@ -1385,7 +1387,7 @@ static ControllerMapping_t *SDL_PrivateGenerateAutomaticControllerMapping(const
             }
         }
     }
-    SDL_snprintf(mapping, sizeof(mapping), "none,%s,", name_string);
+    (void)SDL_snprintf(mapping, sizeof mapping, "none,%s,", name_string);
     SDL_PrivateAppendToMappingString(mapping, sizeof(mapping), "a", &raw_map->a);
     SDL_PrivateAppendToMappingString(mapping, sizeof(mapping), "b", &raw_map->b);
     SDL_PrivateAppendToMappingString(mapping, sizeof(mapping), "x", &raw_map->x);
@@ -1677,7 +1679,7 @@ static char *CreateMappingString(ControllerMapping_t *mapping, SDL_JoystickGUID
         return NULL;
     }
 
-    SDL_snprintf(pMappingString, needed, "%s,%s,%s", pchGUID, mapping->name, mapping->mapping);
+    (void)SDL_snprintf(pMappingString, needed, "%s,%s,%s", pchGUID, mapping->name, mapping->mapping);
 
     if (!SDL_strstr(mapping->mapping, SDL_CONTROLLER_PLATFORM_FIELD)) {
         if (mapping->mapping[SDL_strlen(mapping->mapping) - 1] != ',') {
@@ -1848,12 +1850,12 @@ int SDL_GameControllerInit(void)
  * Get the implementation dependent name of a controller
  */
 const char *
-SDL_GameControllerNameForIndex(int device_index)
+SDL_GameControllerNameForIndex(int joystick_index)
 {
-    ControllerMapping_t *pSupportedController = SDL_PrivateGetControllerMapping(device_index);
-    if (pSupportedController) {
+    ControllerMapping_t *pSupportedController = SDL_PrivateGetControllerMapping(joystick_index);
+    if (pSupportedController != NULL) {
         if (SDL_strcmp(pSupportedController->name, "*") == 0) {
-            return SDL_JoystickNameForIndex(device_index);
+            return SDL_JoystickNameForIndex(joystick_index);
         } else {
             return pSupportedController->name;
         }
@@ -1865,11 +1867,11 @@ SDL_GameControllerNameForIndex(int device_index)
  * Get the implementation dependent path of a controller
  */
 const char *
-SDL_GameControllerPathForIndex(int device_index)
+SDL_GameControllerPathForIndex(int joystick_index)
 {
-    ControllerMapping_t *pSupportedController = SDL_PrivateGetControllerMapping(device_index);
-    if (pSupportedController) {
-        return SDL_JoystickPathForIndex(device_index);
+    ControllerMapping_t *pSupportedController = SDL_PrivateGetControllerMapping(joystick_index);
+    if (pSupportedController != NULL) {
+        return SDL_JoystickPathForIndex(joystick_index);
     }
     return NULL;
 }
@@ -1910,7 +1912,7 @@ SDL_GameControllerMappingForDeviceIndex(int joystick_index)
             SDL_UnlockJoysticks();
             return NULL;
         }
-        SDL_snprintf(pMappingString, needed, "%s,%s,%s", pchGUID, mapping->name, mapping->mapping);
+        (void)SDL_snprintf(pMappingString, needed, "%s,%s,%s", pchGUID, mapping->name, mapping->mapping);
     }
     SDL_UnlockJoysticks();
     return pMappingString;
@@ -1933,10 +1935,10 @@ SDL_IsGameControllerNameAndGUID(const char *name, SDL_JoystickGUID guid)
  * Return 1 if the joystick at this device index is a supported controller
  */
 SDL_bool
-SDL_IsGameController(int device_index)
+SDL_IsGameController(int joystick_index)
 {
-    ControllerMapping_t *pSupportedController = SDL_PrivateGetControllerMapping(device_index);
-    if (pSupportedController) {
+    ControllerMapping_t *pSupportedController = SDL_PrivateGetControllerMapping(joystick_index);
+    if (pSupportedController != NULL) {
         return SDL_TRUE;
     }
     return SDL_FALSE;
@@ -2042,7 +2044,7 @@ SDL_bool SDL_ShouldIgnoreGameController(const char *name, SDL_JoystickGUID guid)
  * This function returns a controller identifier, or NULL if an error occurred.
  */
 SDL_GameController *
-SDL_GameControllerOpen(int device_index)
+SDL_GameControllerOpen(int joystick_index)
 {
     SDL_JoystickID instance_id;
     SDL_GameController *gamecontroller;
@@ -2053,8 +2055,8 @@ SDL_GameControllerOpen(int device_index)
 
     gamecontrollerlist = SDL_gamecontrollers;
     /* If the controller is already open, return it */
-    instance_id = SDL_JoystickGetDeviceInstanceID(device_index);
-    while (gamecontrollerlist) {
+    instance_id = SDL_JoystickGetDeviceInstanceID(joystick_index);
+    while (gamecontrollerlist != NULL) {
         if (instance_id == gamecontrollerlist->joystick->instance_id) {
             gamecontroller = gamecontrollerlist;
             ++gamecontroller->ref_count;
@@ -2065,9 +2067,9 @@ SDL_GameControllerOpen(int device_index)
     }
 
     /* Find a controller mapping */
-    pSupportedController = SDL_PrivateGetControllerMapping(device_index);
+    pSupportedController = SDL_PrivateGetControllerMapping(joystick_index);
     if (pSupportedController == NULL) {
-        SDL_SetError("Couldn't find mapping for device (%d)", device_index);
+        SDL_SetError("Couldn't find mapping for device (%d)", joystick_index);
         SDL_UnlockJoysticks();
         return NULL;
     }
@@ -2081,8 +2083,8 @@ SDL_GameControllerOpen(int device_index)
     }
     gamecontroller->magic = &gamecontroller_magic;
 
-    gamecontroller->joystick = SDL_JoystickOpen(device_index);
-    if (!gamecontroller->joystick) {
+    gamecontroller->joystick = SDL_JoystickOpen(joystick_index);
+    if (gamecontroller->joystick == NULL) {
         SDL_free(gamecontroller);
         SDL_UnlockJoysticks();
         return NULL;
diff --git a/src/joystick/SDL_joystick.c b/src/joystick/SDL_joystick.c
index a309c553c..8a7d22b40 100644
--- a/src/joystick/SDL_joystick.c
+++ b/src/joystick/SDL_joystick.c
@@ -1881,7 +1881,7 @@ SDL_CreateJoystickName(Uint16 vendor, Uint16 product, const char *vendor_name, c
         len = (SDL_strlen(vendor_name) + 1 + SDL_strlen(product_name) + 1);
         name = (char *)SDL_malloc(len);
         if (name) {
-            SDL_snprintf(name, len, "%s %s", vendor_name, product_name);
+            (void)SDL_snprintf(name, len, "%s %s", vendor_name, product_name);
         }
     } else if (*product_name) {
         name = SDL_strdup(product_name);
@@ -1909,8 +1909,8 @@ SDL_CreateJoystickName(Uint16 vendor, Uint16 product, const char *vendor_name, c
         default:
             len = (6 + 1 + 6 + 1);
             name = (char *)SDL_malloc(len);
-            if (name) {
-                SDL_snprintf(name, len, "0x%.4x/0x%.4x", vendor, product);
+            if (name != NULL) {
+                (void)SDL_snprintf(name, len, "0x%.4x/0x%.4x", vendor, product);
             }
             break;
         }
diff --git a/src/joystick/darwin/SDL_iokitjoystick.c b/src/joystick/darwin/SDL_iokitjoystick.c
index 5d5d70211..6f74b11b3 100644
--- a/src/joystick/darwin/SDL_iokitjoystick.c
+++ b/src/joystick/darwin/SDL_iokitjoystick.c
@@ -519,7 +519,6 @@ static SDL_bool JoystickAlreadyKnown(IOHIDDeviceRef ioHIDDeviceObject)
 static void JoystickDeviceWasAddedCallback(void *ctx, IOReturn res, void *sender, IOHIDDeviceRef ioHIDDeviceObject)
 {
     recDevice *device;
-    int device_index = 0;
     io_service_t ioservice;
 
     if (res != kIOReturnSuccess) {
@@ -570,12 +569,10 @@ static void JoystickDeviceWasAddedCallback(void *ctx, IOReturn res, void *sender
         recDevice *curdevice;
 
         curdevice = gpDeviceList;
-        while (curdevice->pNext) {
-            ++device_index;
+        while (curdevice->pNext != NULL) {
             curdevice = curdevice->pNext;
         }
         curdevice->pNext = device;
-        ++device_index; /* bump by one since we counted by pNext. */
     }
 
     SDL_PrivateJoystickAdded(device->instance_id);
diff --git a/src/joystick/hidapi/SDL_hidapi_gamecube.c b/src/joystick/hidapi/SDL_hidapi_gamecube.c
index 56ddaa9dd..7e6abba73 100644
--- a/src/joystick/hidapi/SDL_hidapi_gamecube.c
+++ b/src/joystick/hidapi/SDL_hidapi_gamecube.c
@@ -233,7 +233,7 @@ static void HIDAPI_DriverGameCube_SetDevicePlayerIndex(SDL_HIDAPI_Device *device
 {
 }
 
-static void HIDAPI_DriverGameCube_HandleJoystickPacket(SDL_HIDAPI_Device *device, SDL_DriverGameCube_Context *ctx, Uint8 *packet, int size)
+static void HIDAPI_DriverGameCube_HandleJoystickPacket(SDL_HIDAPI_Device *device, SDL_DriverGameCube_Context *ctx, const Uint8 *packet, int size)
 {
     SDL_Joystick *joystick;
     Uint8 i, v;
diff --git a/src/joystick/hidapi/SDL_hidapi_ps3.c b/src/joystick/hidapi/SDL_hidapi_ps3.c
index 4d08303f2..6c4fcd82b 100644
--- a/src/joystick/hidapi/SDL_hidapi_ps3.c
+++ b/src/joystick/hidapi/SDL_hidapi_ps3.c
@@ -158,9 +158,9 @@ static SDL_bool HIDAPI_DriverPS3_InitDevice(SDL_HIDAPI_Device *device)
     /* Set the controller into report mode over USB */
     {
         Uint8 data[USB_PACKET_LENGTH];
-        int size;
 
-        if ((size = ReadFeatureReport(device->dev, 0xf2, data, 17)) < 0) {
+        int size = ReadFeatureReport(device->dev, 0xf2, data, 17);
+        if (size < 0) {
             SDL_LogDebug(SDL_LOG_CATEGORY_INPUT,
                          "HIDAPI_DriverPS3_InitDevice(): Couldn't read feature report 0xf2");
             return SDL_FALSE;
@@ -168,7 +168,8 @@ static SDL_bool HIDAPI_DriverPS3_InitDevice(SDL_HIDAPI_Device *device)
 #ifdef DEBUG_PS3_PROTOCOL
         HIDAPI_DumpPacket("PS3 0xF2 packet: size = %d", data, size);
 #endif
-        if ((size = ReadFeatureReport(device->dev, 0xf5, data, 8)) < 0) {
+        size = ReadFeatureReport(device->dev, 0xf5, data, 8);
+        if (size < 0) {
             SDL_LogDebug(SDL_LOG_CATEGORY_INPUT,
                          "HIDAPI_DriverPS3_InitDevice(): Couldn't read feature report 0xf5");
             return SDL_FALSE;
@@ -583,8 +584,8 @@ static SDL_bool HIDAPI_DriverPS3ThirdParty_IsSupportedDevice(SDL_HIDAPI_Device *
 
     if (SONY_THIRDPARTY_VENDOR(vendor_id)) {
         if (device && device->dev) {
-            if ((size = ReadFeatureReport(device->dev, 0x03, data, sizeof(data))) == 8 &&
-                data[2] == 0x26) {
+            size = ReadFeatureReport(device->dev, 0x03, data, sizeof data);
+            if (size == 8 && data[2] == 0x26) {
                 /* Supported third party controller */
                 return SDL_TRUE;
             } else {
diff --git a/src/joystick/hidapi/SDL_hidapi_ps4.c b/src/joystick/hidapi/SDL_hidapi_ps4.c
index 647822a18..36280a64e 100644
--- a/src/joystick/hidapi/SDL_hidapi_ps4.c
+++ b/src/joystick/hidapi/SDL_hidapi_ps4.c
@@ -189,8 +189,8 @@ static SDL_bool HIDAPI_DriverPS4_IsSupportedDevice(SDL_HIDAPI_Device *device, co
 
     if (SONY_THIRDPARTY_VENDOR(vendor_id)) {
         if (device && device->dev) {
-            if ((size = ReadFeatureReport(device->dev, k_ePS4FeatureReportIdCapabilities, data, sizeof(data))) == 48 &&
-                data[2] == 0x27) {
+            size = ReadFeatureReport(device->dev, k_ePS4FeatureReportIdCapabilities, data, sizeof data);
+            if (size == 48 && data[2] == 0x27) {
                 /* Supported third party controller */
                 return SDL_TRUE;
             } else {
@@ -268,8 +268,8 @@ static SDL_bool HIDAPI_DriverPS4_InitDevice(SDL_HIDAPI_Device *device)
     if (ctx->is_dongle) {
         size = ReadFeatureReport(device->dev, k_ePS4FeatureReportIdSerialNumber, data, sizeof(data));
         if (size >= 7 && (data[1] || data[2] || data[3] || data[4] || data[5] || data[6])) {
-            SDL_snprintf(serial, sizeof(serial), "%.2x-%.2x-%.2x-%.2x-%.2x-%.2x",
-                         data[6], data[5], data[4], data[3], data[2], data[1]);
+            (void)SDL_snprintf(serial, sizeof serial, "%.2x-%.2x-%.2x-%.2x-%.2x-%.2x",
+                               data[6], data[5], data[4], data[3], data[2], data[1]);
         }
         device->is_bluetooth = SDL_FALSE;
         ctx->enhanced_mode = SDL_TRUE;
@@ -277,8 +277,8 @@ static SDL_bool HIDAPI_DriverPS4_InitDevice(SDL_HIDAPI_Device *device)
         /* This will fail if we're on Bluetooth */
         size = ReadFeatureReport(device->dev, k_ePS4FeatureReportIdSerialNumber, data, sizeof(data));
         if (size >= 7 && (data[1] || data[2] || data[3] || data[4] || data[5] || data[6])) {
-            SDL_snprintf(serial, sizeof(serial), "%.2x-%.2x-%.2x-%.2x-%.2x-%.2x",
-                         data[6], data[5], data[4], data[3], data[2], data[1]);
+            (void)SDL_snprintf(serial, sizeof serial, "%.2x-%.2x-%.2x-%.2x-%.2x-%.2x",
+                               data[6], data[5], data[4], data[3], data[2], data[1]);
             device->is_bluetooth = SDL_FALSE;
             ctx->enhanced_mode = SDL_TRUE;
         } else {
@@ -308,6 +308,7 @@ static SDL_bool HIDAPI_DriverPS4_InitDevice(SDL_HIDAPI_Device *device)
     SDL_Log("PS4 dongle = %s, bluetooth = %s\n", ctx->is_dongle ? "TRUE" : "FALSE", device->is_bluetooth ? "TRUE" : "FALSE");
 #endif
 
+    size = ReadFeatureReport(device->dev, k_ePS4FeatureReportIdCapabilities, data, sizeof data);
     /* Get the device capabilities */
     if (device->vendor_id == USB_VENDOR_SONY) {
         ctx->official_controller = SDL_TRUE;
@@ -315,8 +316,7 @@ static SDL_bool HIDAPI_DriverPS4_InitDevice(SDL_HIDAPI_Device *device)
         ctx->lightbar_supported = SDL_TRUE;
         ctx->vibration_supported = SDL_TRUE;
         ctx->touchpad_supported = SDL_TRUE;
-    } else if ((size = ReadFeatureReport(device->dev, k_ePS4FeatureReportIdCapabilities, data, sizeof(data))) == 48 &&
-               data[2] == 0x27) {
+    } else if (size == 48 && data[2] == 0x27) {
         Uint8 capabilities = data[4];
         Uint8 device_type = data[5];
 
@@ -1119,8 +1119,8 @@ static SDL_bool HIDAPI_DriverPS4_UpdateDevice(SDL_HIDAPI_Device *device)
                 char serial[18];
                 size = ReadFeatureReport(device->dev, k_ePS4FeatureReportIdSerialNumber, data, sizeof(data));
                 if (size >= 7 && (data[1] || data[2] || data[3] || data[4] || data[5] || data[6])) {
-                    SDL_snprintf(serial, sizeof(serial), "%.2x-%.2x-%.2x-%.2x-%.2x-%.2x",
-                                 data[6], data[5], data[4], data[3], data[2], data[1]);
+                    (void)SDL_snprintf(serial, sizeof serial, "%.2x-%.2x-%.2x-%.2x-%.2x-%.2x",
+                                       data[6], data[5], data[4], data[3], data[2], data[1]);
                     HIDAPI_SetDeviceSerial(device, serial);
                 }
                 HIDAPI_JoystickConnected(device, NULL);
diff --git a/src/joystick/hidapi/SDL_hidapi_ps5.c b/src/joystick/hidapi/SDL_hidapi_ps5.c
index 807ebab60..1ab71a2e6 100644
--- a/src/joystick/hidapi/SDL_hidapi_ps5.c
+++ b/src/joystick/hidapi/SDL_hidapi_ps5.c
@@ -275,8 +275,8 @@ static SDL_bool HIDAPI_DriverPS5_IsSupportedDevice(SDL_HIDAPI_Device *device, co
 
     if (SONY_THIRDPARTY_VENDOR(vendor_id)) {
         if (device && device->dev) {
-            if ((size = ReadFeatureReport(device->dev, k_EPS5FeatureReportIdCapabilities, data, sizeof(data))) == 48 &&
-                data[2] == 0x28) {
+            size = ReadFeatureReport(device->dev, k_EPS5FeatureReportIdCapabilities, data, sizeof data);
+            if (size == 48 && data[2] == 0x28) {
                 /* Supported third party controller */
                 return SDL_TRUE;
             } else {
@@ -400,8 +400,8 @@ static SDL_bool HIDAPI_DriverPS5_InitDevice(SDL_HIDAPI_Device *device)
            This will also enable enhanced reports over Bluetooth
         */
         if (ReadFeatureReport(device->dev, k_EPS5FeatureReportIdSerialNumber, data, sizeof(data)) >= 7) {
-            SDL_snprintf(serial, sizeof(serial), "%.2x-%.2x-%.2x-%.2x-%.2x-%.2x",
-                         data[6], data[5], data[4], data[3], data[2], data[1]);
+            (void)SDL_snprintf(serial, sizeof serial, "%.2x-%.2x-%.2x-%.2x-%.2x-%.2x",
+                               data[6], data[5], data[4], data[3], data[2], data[1]);
         }
 
         /* Read the firmware version
@@ -412,6 +412,7 @@ static SDL_bool HIDAPI_DriverPS5_InitDevice(SDL_HIDAPI_Device *device)
         }
     }
 
+    size = ReadFeatureReport(device->dev, k_EPS5FeatureReportIdCapabilities, data, sizeof data);
     /* Get the device capabilities */
     if (device->vendor_id == USB_VENDOR_SONY) {
         ctx->sensors_supported = SDL_TRUE;
@@ -419,8 +420,7 @@ static SDL_bool HIDAPI_DriverPS5_InitDevice(SDL_HIDAPI_Device *device)
         ctx->vibration_supported = SDL_TRUE;
         ctx->playerled_supported = SDL_TRUE;
         ctx->touchpad_supported = SDL_TRUE;
-    } else if ((size = ReadFeatureReport(device->dev, k_EPS5FeatureReportIdCapabilities, data, sizeof(data))) == 48 &&
-               data[2] == 0x28) {
+    } else if (size == 48 && data[2] == 0x28) {
         Uint8 capabilities = data[4];
         Uint8 capabilities2 = data[20];
         Uint8 device_type = data[5];
diff --git a/src/joystick/hidapi/SDL_hidapi_shield.c b/src/joystick/hidapi/SDL_hidapi_shield.c
index e3fc9686b..4fea8a80c 100644
--- a/src/joystick/hidapi/SDL_hidapi_shield.c
+++ b/src/joystick/hidapi/SDL_hidapi_shield.c
@@ -368,7 +368,7 @@ static void HIDAPI_DriverShield_HandleStatePacketV103(SDL_Joystick *joystick, SD
 #undef clamp
 #define clamp(val, min, max) (((val) > (max)) ? (max) : (((val) < (min)) ? (min) : (val)))
 
-static void HIDAPI_DriverShield_HandleTouchPacketV103(SDL_Joystick *joystick, SDL_DriverShield_Context *ctx, Uint8 *data, int size)
+static void HIDAPI_DriverShield_HandleTouchPacketV103(SDL_Joystick *joystick, SDL_DriverShield_Context *ctx, const Uint8 *data, int size)
 {
     Uint8 touchpad_state;
     float touchpad_x, touchpad_y;
diff --git a/src/joystick/hidapi/SDL_hidapi_steam.c b/src/joystick/hidapi/SDL_hidapi_steam.c
index 433c7ca72..a7a4acb79 100644
--- a/src/joystick/hidapi/SDL_hidapi_steam.c
+++ b/src/joystick/hidapi/SDL_hidapi_steam.c
@@ -244,7 +244,7 @@ static int WriteSegmentToSteamControllerPacketAssembler(SteamControllerPacketAss
         }
 
         if (nSegmentLength != MAX_REPORT_SEGMENT_SIZE) {
-            printf("Bad segment size! %d\n", (int)nSegmentLength);
+            printf("Bad segment size! %d\n", nSegmentLength);
             hexdump(pSegment, nSegmentLength);
             ResetSteamControllerPacketAssembler(pAssembler);
             return -1;
@@ -365,10 +365,11 @@ static int GetFeatureReport(SDL_hid_device *dev, unsigned char uBuffer[65])
             HEXDUMP(uSegmentBuffer, nRet);
 
             // Zero retry counter if we got data
-            if (nRet > 2 && (uSegmentBuffer[ucDataStartOffset + 1] & REPORT_SEGMENT_DATA_FLAG))
+            if (nRet > 2 && (uSegmentBuffer[ucDataStartOffset + 1] & REPORT_SEGMENT_DATA_FLAG)) {
                 nRetries = 0;
-            else
+            } else {
                 nRetries++;
+            }
 
             if (nRet > 0) {
                 int nPacketLength = WriteSegmentToSteamControllerPacketAssembler(&assembler,
@@ -752,19 +753,21 @@ static void FormatStatePacketUntilGyro(SteamControllerStateInternal_t *pState, V
     RotatePad(&nLeftPadX, &nLeftPadY, -flRotationAngle);
     RotatePad(&nRightPadX, &nRightPadY, flRotationAngle);
 
-    if (pState->ulButtons & STEAM_LEFTPAD_FINGERDOWN_MASK)
+    if (pState->ulButtons & STEAM_LEFTPAD_FINGERDOWN_MASK) {
         nPadOffset = 1000;
-    else
+    } else {
         nPadOffset = 0;
+    }
 
     pState->sLeftPadX = clamp(nLeftPadX + nPadOffset, SDL_MIN_SINT16, SDL_MAX_SINT16);
     pState->sLeftPadY = clamp(nLeftPadY + nPadOffset, SDL_MIN_SINT16, SDL_MAX_SINT16);
 
     nPadOffset = 0;
-    if (pState->ulButtons & STEAM_RIGHTPAD_FINGERDOWN_MASK)
+    if (pState->ulButtons & STEAM_RIGHTPAD_FINGERDOWN_MASK) {
         nPadOffset = 1000;
-    else
+    } else {
         nPadOffset = 0;
+    }
 
     pState->sRightPadX = clamp(nRightPadX + nPadOffset, SDL_MIN_SINT16, SDL_MAX_SINT16);
     pState->sRightPadY = clamp(nRightPadY + nPadOffset, SDL_MIN_SINT16, SDL_MAX_SINT16);
@@ -811,10 +814,11 @@ static bool UpdateBLESteamControllerState(const uint8_t *pData, int nDataSize, S
         int nLength = sizeof(pState->sLeftPadX) + sizeof(pState->sLeftPadY);
         int nPadOffset;
         SDL_memcpy(&pState->sLeftPadX, pData, nLength);
-        if (pState->ulButtons & STEAM_LEFTPAD_FINGERDOWN_MASK)
+        if (pState->ulButtons & STEAM_LEFTPAD_FINGERDOWN_MASK) {
             nPadOffset = 1000;
-        else
+        } else {
             nPadOffset = 0;
+        }
 
         RotatePadShort(&pState->sLeftPadX, &pState->sLeftPadY, -flRotationAngle);
         pState->sLeftPadX = clamp(pState->sLeftPadX + nPadOffset, SDL_MIN_SINT16, SDL_MAX_SINT16);
@@ -827,10 +831,11 @@ static bool UpdateBLESteamControllerState(const uint8_t *pData, int nDataSize, S
 
         SDL_memcpy(&pState->sRightPadX, pData, nLength);
 
-        if (pState->ulButtons & STEAM_RIGHTPAD_FINGERDOWN_MASK)
+        if (pState->ulButtons & STEAM_RIGHTPAD_FINGERDOWN_MASK) {
             nPadOffset = 1000;
-        else
+        } else {
             nPadOffset = 0;
+        }
 
         RotatePadShort(&pState->sRightPadX, &pState->sRightPadY, flRotationAngle);
         pState->sRightPadX = clamp(pState->sRightPadX + nPadOffset, SDL_MIN_SINT16, SDL_MAX_SINT16);
diff --git a/src/joystick/hidapi/SDL_hidapi_switch.c b/src/joystick/hidapi/SDL_hidapi_switch.c
index e66bd73e8..a287ca09c 100644
--- a/src/joystick/hidapi/SDL_hidapi_switch.c
+++ b/src/joystick/hidapi/SDL_hidapi_switch.c
@@ -829,9 +829,9 @@ static SDL_bool LoadIMUCalibration(SDL_DriverSwitch_Context *ctx)
     }
 
     /* Accelerometer scale */
-    ctx->m_IMUScaleData.fAccelScaleX = SWITCH_ACCEL_SCALE_MULT / (float)(SWITCH_ACCEL_SCALE_OFFSET - (float)sAccelRawX) * SDL_STANDARD_GRAVITY;
-    ctx->m_IMUScaleData.fAccelScaleY = SWITCH_ACCEL_SCALE_MULT / (float)(SWITCH_ACCEL_SCALE_OFFSET - (float)sAccelRawY) * SDL_STANDARD_GRAVITY;
-    ctx->m_IMUScaleData.fAccelScaleZ = SWITCH_ACCEL_SCALE_MULT / (float)(SWITCH_ACCEL_SCALE_OFFSET - (float)sAccelRawZ) * SDL_STANDARD_GRAVITY;
+    ctx->m_IMUScaleData.fAccelScaleX = SWITCH_ACCEL_SCALE_MULT / (SWITCH_ACCEL_SCALE_OFFSET - (float)sAccelRawX) * SDL_STANDARD_GRAVITY;
+    ctx->m_IMUScaleData.fAccelScaleY = SWITCH_ACCEL_SCALE_MULT / (SWITCH_ACCEL_SCALE_OFFSET - (float)sAccelRawY) * SDL_STANDARD_GRAVITY;
+    ctx->m_IMUScaleData.fAccelScaleZ = SWITCH_ACCEL_SCALE_MULT / (SWITCH_ACCEL_SCALE_OFFSET - (float)sAccelRawZ) * SDL_STANDARD_GRAVITY;
 
     /* Gyro scale */
     ctx->m_IMUScaleData.fGyroScaleX = SWITCH_GYRO_SCALE_MULT / (float)(SWITCH_GYRO_SCALE_OFFSET - (float)sGyroRawX) * (float)M_PI / 180.0f;
@@ -1177,13 +1177,13 @@ static void UpdateDeviceIdentity(SDL_HIDAPI_Device *device)
     }
     device->guid.data[15] = ctx->m_eControllerType;
 
-    SDL_snprintf(serial, sizeof(serial), "%.2x-%.2x-%.2x-%.2x-%.2x-%.2x",
-                 ctx->m_rgucMACAddress[0],
-                 ctx->m_rgucMACAddress[1],
-                 ctx->m_rgucMACAddress[2],
-                 ctx->m_rgucMACAddress[3],
-                 ctx->m_rgucMACAddress[4],
-                 ctx->m_rgucMACAddress[5]);
+    (void)SDL_snprintf(serial, sizeof serial, "%.2x-%.2x-%.2x-%.2x-%.2x-%.2x",
+                       ctx->m_rgucMACAddress[0],
+                       ctx->m_rgucMACAddress[1],
+                       ctx->m_rgucMACAddress[2],
+                       ctx->m_rgucMACAddress[3],
+                       ctx->m_rgucMACAddress[4],
+                       ctx->m_rgucMACAddress[5]);
     HIDAPI_SetDeviceSerial(device, serial);
 }
 
@@ -1717,7 +1717,8 @@ static void HandleSimpleControllerState(SDL_Joystick *joystick, SDL_DriverSwitch
     ctx->m_lastSimpleState = *packet;
 }
 
-static void SendSensorUpdate(SDL_Joystick *joystick, SDL_DriverSwitch_Context *ctx, SDL_SensorType type, Uint64 timestamp_us, Sint16 *values)
+static void
+SendSensorUpdate(SDL_Joystick *joystick, SDL_DriverSwitch_Context *ctx, SDL_SensorType type, Uint64 timestamp_us, const Sint16 *values)
 {
     float data[3];
 
diff --git a/src/joystick/hidapi/SDL_hidapi_xboxone.c b/src/joystick/hidapi/SDL_hidapi_xboxone.c
index 7e19417d2..1f6f90763 100644
--- a/src/joystick/hidapi/SDL_hidapi_xboxone.c
+++ b/src/joystick/hidapi/SDL_hidapi_xboxone.c
@@ -214,7 +214,7 @@ static void SetInitState(SDL_DriverXboxOne_Context *ctx, SDL_XboxOneInitState st
     ctx->init_state = state;
 }
 
-static void SendAckIfNeeded(SDL_HIDAPI_Device *device, Uint8 *data, int size)
+static void SendAckIfNeeded(SDL_HIDAPI_Device *device, const Uint8 *data, int size)
 {
 #if defined(__WIN32__) || defined(__WINGDK__)
     /* The Windows driver is taking care of acks */
@@ -812,7 +812,7 @@ static void HIDAPI_DriverXboxOne_HandleStatusPacket(SDL_Joystick *joystick, SDL_
     }
 }
 
-static void HIDAPI_DriverXboxOne_HandleModePacket(SDL_Joystick *joystick, SDL_DriverXboxOne_Context *ctx, Uint8 *data, int size)
+static void HIDAPI_DriverXboxOne_HandleModePacket(SDL_Joystick *joystick, SDL_DriverXboxOne_Context *ctx, const Uint8 *data, int size)
 {
     SDL_PrivateJoystickButton(joystick, SDL_CONTROLLER_BUTTON_GUIDE, (data[4] & 0x01) ? SDL_PRESSED : SDL_RELEASED);
 }
@@ -820,7 +820,7 @@ static void HIDAPI_DriverXboxOne_HandleModePacket(SDL_Joystick *joystick, SDL_Dr
 /*
  * Xbox One S with firmware 3.1.1221 uses a 16 byte packet and the GUIDE button in a separate packet
  */
-static void HIDAPI_DriverXboxOneBluetooth_HandleButtons16(SDL_Joystick *joystick, SDL_DriverXboxOne_Context *ctx, Uint8 *data, int size)
+static void HIDAPI_DriverXboxOneBluetooth_HandleButtons16(SDL_Joystick *joystick, SDL_DriverXboxOne_Context *ctx, const Uint8 *data, int size)
 {
     if (ctx->last_state[14] != data[14]) {
         SDL_PrivateJoystickButton(joystick, SDL_CONTROLLER_BUTTON_A, (data[14] & 0x01) ? SDL_PRESSED : SDL_RELEASED);
@@ -1022,13 +1022,13 @@ static void HIDAPI_DriverXboxOneBluetooth_HandleStatePacket(SDL_Joystick *joysti
     SDL_memcpy(ctx->last_state, data, SDL_min(size, sizeof(ctx->last_state)));
 }
 
-static void HIDAPI_DriverXboxOneBluetooth_HandleGuidePacket(SDL_Joystick *joystick, SDL_DriverXboxOne_Context *ctx, Uint8 *data, int size)
+static void HIDAPI_DriverXboxOneBluetooth_HandleGuidePacket(SDL_Joystick *joystick, SDL_DriverXboxOne_Context *ctx, const Uint8 *data, int size)
 {
     ctx->has_guide_packet = SDL_TRUE;
     SDL_PrivateJoystickButton(joystick, SDL_CONTROLLER_BUTTON_GUIDE, (data[1] & 0x01) ? SDL_PRESSED : SDL_RELEASED);
 }
 
-static void HIDAPI_DriverXboxOneBluetooth_HandleBatteryPacket(SDL_Joystick *joystick, SDL_DriverXboxOne_Context *ctx, Uint8 *data, int size)
+static void HIDAPI_DriverXboxOneBluetooth_HandleBatteryPacket(SDL_Joystick *joystick, SDL_DriverXboxOne_Context *ctx, const Uint8 *data, int size)
 {
     Uint8 flags = data[1];
     SDL_bool on_usb = (((flags & 0x0C) >> 2) == 0);
diff --git a/src/joystick/hidapi/SDL_hidapijoystick.c b/src/joystick/hidapi/SDL_hidapijoystick.c
index d0f7595bf..3e35997ac 100644
--- a/src/joystick/hidapi/SDL_hidapijoystick.c
+++ b/src/joystick/hidapi/SDL_hidapijoystick.c
@@ -105,12 +105,13 @@ void HIDAPI_DumpPacket(const char *prefix, const Uint8 *data, int size)
     int start = 0, amount = size;
 
     buffer = (char *)SDL_malloc(length);
-    SDL_snprintf(buffer, length, prefix, size);
+    (void)SDL_snprintf(buffer, length, prefix, size);
     for (i = start; i < start + amount; ++i) {
+        size_t current_len = SDL_strlen(buffer);
         if ((i % 8) == 0) {
-            SDL_snprintf(&buffer[SDL_strlen(buffer)], length - SDL_strlen(buffer), "\n%.2d:      ", i);
+            (void)SDL_snprintf(&buffer[current_len], length - current_len, "\n%.2d:      ", i);
         }
-        SDL_snprintf(&buffer[SDL_strlen(buffer)], length - SDL_strlen(buffer), " 0x%.2x", data[i]);
+        (void)SDL_snprintf(&buffer[current_len], length - current_len, " 0x%.2x", data[i]);
     }
     SDL_strlcat(buffer, "\n", length);
     SDL_Log("%s", buffer);
@@ -384,7 +385,6 @@ static void HIDAPI_SetupDeviceDriver(SDL_HIDAPI_Device *device, SDL_bool *remove
 
             /* Make sure the device didn't get removed while opening the HID path */
             for (curr = SDL_HIDAPI_devices; curr && curr != device; curr = curr->next) {
-                continue;
             }
             if (curr == NULL) {
                 *removed = SDL_TRUE;
@@ -718,7 +718,6 @@ static SDL_HIDAPI_Device *HIDAPI_AddDevice(const struct SDL_hid_device_info *inf
     SDL_bool removed;
 
     for (curr = SDL_HIDAPI_devices, last = NULL; curr; last = curr, curr = curr->next) {
-        continue;
     }
 
     device = (SDL_HIDAPI_Device *)SDL_calloc(1, sizeof(*device));
@@ -985,7 +984,6 @@ check_removed:
 
     /* See if we can create any combined Joy-Con controllers */
     while (HIDAPI_CreateCombinedJoyCons()) {
-        continue;
     }
 
     SDL_UnlockJoysticks();
diff --git a/src/joystick/iphoneos/SDL_mfijoystick.m b/src/joystick/iphoneos/SDL_mfijoystick.m
index a8a74b04f..9646b241f 100644
--- a/src/joystick/iphoneos/SDL_mfijoystick.m
+++ b/src/joystick/iphoneos/SDL_mfijoystick.m
@@ -1310,10 +1310,10 @@ static void IOS_MFIJoystickUpdate(SDL_Joystick *joystick)
 @end
 
 @interface SDL_RumbleContext : NSObject
-@property(nonatomic, strong) SDL_RumbleMotor *m_low_frequency_motor;
-@property(nonatomic, strong) SDL_RumbleMotor *m_high_frequency_motor;
-@property(nonatomic, strong) SDL_RumbleMotor *m_left_trigger_motor;
-@property(nonatomic, strong) SDL_RumbleMotor *m_right_trigger_motor;
+@property(nonatomic, strong) SDL_RumbleMotor *lowFrequencyMotor;
+@property(nonatomic, strong) SDL_RumbleMotor *highFrequencyMotor;
+@property(nonatomic, strong) SDL_RumbleMotor *leftTriggerMotor;
+@property(nonatomic, strong) SDL_RumbleMotor *rightTriggerMotor;
 @end
 
 @implementation SDL_RumbleContext
@@ -1326,10 +1326,10 @@ static void IOS_MFIJoystickUpdate(SDL_Joystick *joystick)
               RightTriggerMotor:(SDL_RumbleMotor *)right_trigger_motor
 {
     self = [super init];
-    self.m_low_frequency_motor = low_frequency_motor;
-    self.m_high_frequency_motor = high_frequency_motor;
-    self.m_left_trigger_motor = left_trigger_motor;
-    self.m_right_trigger_motor = right_trigger_motor;
+    self.lowFrequencyMotor = low_frequency_motor;
+    self.highFrequencyMotor = high_frequency_motor;
+    self.leftTriggerMotor = left_trigger_motor;
+    self.rightTriggerMotor = right_trigger_motor;
     return self;
 }
 
@@ -1337,8 +1337,8 @@ static void IOS_MFIJoystickUpdate(SDL_Joystick *joystick)
 {
     int result = 0;
 
-    result += [self.m_low_frequency_motor setIntensity:((float)low_frequency_rumble / 65535.0f)];
-    result += [self.m_high_frequency_motor setIntensity:((float)high_frequency_rumble / 65535.0f)];
+    result += [self.lowFrequencyMotor setIntensity:((float)low_frequency_rumble / 65535.0f)];
+    result += [self.highFrequencyMotor setIntensity:((float)high_frequency_rumble / 65535.0f)];
     return ((result < 0) ? -1 : 0);
 }
 
@@ -1346,9 +1346,9 @@ static void IOS_MFIJoystickUpdate(SDL_Joystick *joystick)
 {
     int result = 0;
 
-    if (self.m_left_trigger_motor && self.m_right_trigger_motor) {
-        result += [self.m_left_trigger_motor setIntensity:((float)left_rumble / 65535.0f)];
-        result += [self.m_right_trigger_motor setIntensity:((float)right_rumble / 65535.0f)];
+    if (self.leftTriggerMotor && self.rightTriggerMotor) {
+        result += [self.leftTriggerMotor setIntensity:((float)left_rumble / 65535.0f)];
+        result += [self.rightTriggerMotor setIntensity:((float)right_rumble / 65535.0f)];
     } else {
         result = SDL_Unsupported();
     }
@@ -1357,8 +1357,8 @@ static void IOS_MFIJoystickUpdate(SDL_Joystick *joystick)
 
 - (void)cleanup
 {
-    [self.m_low_frequency_motor cleanup];
-    [self.m_high_frequency_motor cleanup];
+    [self.lowFrequencyMotor cleanup];
+    [self.highFrequencyMotor cleanup];
 }
 
 @end
@@ -1675,6 +1675,7 @@ SDL_bool IOS_SupportedHIDDevice(IOHIDDeviceRef device)
 #endif
 
 #if defined(SDL_JOYSTICK_MFI) && defined(ENABLE_PHYSICAL_INPUT_PROFILE)
+/* NOLINTNEXTLINE(readability-non-const-parameter): getCString takes a non-const char* */
 static void GetAppleSFSymbolsNameForElement(GCControllerElement *element, char *name)
 {
     if (@available(macOS 10.16, iOS 14.0, tvOS 14.0, *)) {
diff --git a/src/joystick/linux/SDL_sysjoystick.c b/src/joystick/linux/SDL_sysjoystick.c
index 922af2851..50dd3b51c 100644
--- a/src/joystick/linux/SDL_sysjoystick.c
+++ b/src/joystick/linux/SDL_sysjoystick.c
@@ -565,7 +565,7 @@ static void LINUX_InotifyJoystickDetect(void)
     while (remain > 0) {
         if (buf.event.len > 0) {
             if (IsJoystickDeviceNode(buf.event.name)) {
-                SDL_snprintf(path, SDL_arraysize(path), "/dev/input/%s", buf.event.name);
+                (void)SDL_snprintf(path, SDL_arraysize(path), "/dev/input/%s", buf.event.name);
 
                 if (buf.event.mask & (IN_CREATE | IN_MOVED_TO | IN_ATTRIB)) {
                     MaybeAddDevice(path);
@@ -592,7 +592,7 @@ static int get_event_joystick_index(int event)
     struct dirent **entries = NULL;
     char path[PATH_MAX];
 
-    SDL_snprintf(path, SDL_arraysize(path), "/sys/class/input/event%d/device", event);
+    (void)SDL_snprintf(path, SDL_arraysize(path), "/sys/class/input/event%d/device", event);
     count = scandir(path, &entries, NULL, alphasort);
     for (i = 0; i < count; ++i) {
         if (SDL_strncmp(entries[i]->d_name, "js", 2) == 0) {
@@ -665,7 +665,7 @@ static void LINUX_FallbackJoystickDetect(void)
                 qsort(entries, count, sizeof(*entries), sort_entries);
             }
             for (i = 0; i < count; ++i) {
-                SDL_snprintf(path, SDL_arraysize(path), "/dev/input/%s", entries[i]->d_name);
+                (void)SDL_snprintf(path, SDL_arraysize(path), "/dev/input/%s", entries[i]->d_name);
                 MaybeAddDevice(path);
 
                 free(entries[i]); /* This should NOT be SDL_free() */
diff --git a/src/joystick/virtual/SDL_virtualjoystick.c b/src/joystick/virtual/SDL_virtualjoystick.c
index a7a16c05e..a6c9140fb 100644
--- a/src/joystick/virtual/SDL_virtualjoystick.c
+++ b/src/joystick/virtual/SDL_virtualjoystick.c
@@ -228,7 +228,6 @@ int SDL_JoystickAttachVirtualInner(const SDL_VirtualJoystickDesc *desc)
         joystick_hwdata *last;
 
         for (last = g_VJoys; last->next; last = last->next) {
-            continue;
         }
         last->next = hwdata;
     } else {
diff --git a/src/joystick/windows/SDL_dinputjoystick.c b/src/joystick/windows/SDL_dinputjoystick.c
index b911164e8..0ba524d82 100644
--- a/src/joystick/windows/SDL_dinputjoystick.c
+++ b/src/joystick/windows/SDL_dinputjoystick.c
@@ -623,19 +623,19 @@ static BOOL CALLBACK EnumDevObjectsCallback(LPCDIDEVICEOBJECTINSTANCE pDeviceObj
 
         in->type = AXIS;
         in->num = joystick->naxes;
-        if (!SDL_memcmp(&pDeviceObject->guidType, &GUID_XAxis, sizeof(pDeviceObject->guidType)))
+        if (SDL_memcmp(&pDeviceObject->guidType, &GUID_XAxis, sizeof pDeviceObject->guidType) == 0) {
             in->ofs = DIJOFS_X;
-        else if (!SDL_memcmp(&pDeviceObject->guidType, &GUID_YAxis, sizeof(pDeviceObject->guidType)))
+        } else if (SDL_memcmp(&pDeviceObject->guidType, &GUID_YAxis, sizeof pDeviceObject->guidType) == 0) {
             in->ofs = DIJOFS_Y;
-        else if (!SDL_memcmp(&pDeviceObject->guidType, &GUID_ZAxis, sizeof(pDeviceObject->guidType)))
+        } else if (SDL_memcmp(&pDeviceObject->guidType, &GUID_ZAxis, sizeof pDeviceObject->guidType) == 0) {
             in->ofs = DIJOFS_Z;
-        else if (!SDL_memcmp(&pDeviceObject->guidType, &GUID_RxAxis, sizeof(pDeviceObject->guidType)))
+        } else if (SDL_memcmp(&pDeviceObject->guidType, &GUID_RxAxis, sizeof pDeviceObject->guidType) == 0) {
             in->ofs = DIJOFS_RX;
-        else if (!SDL_memcmp(&pDeviceObject->guidType, &GUID_RyAxis, sizeof(pDeviceObject->guidType)))
+        } else if (SDL_memcmp(&pDeviceObject->guidType, &GUID_RyAxis, sizeof pDeviceObject->guidType) == 0) {
             in->ofs = DIJOFS_RY;
-        else if (!SDL_memcmp(&pDeviceObject->guidType, &GUID_RzAxis, sizeof(pDeviceObject->guidType)))
+        } else if (SDL_memcmp(&pDeviceObject->guidType, &GUID_RzAxis, sizeof pDeviceObject->guidType) == 0) {
             in->ofs = DIJOFS_RZ;
-        else if (!SDL_memcmp(&pDeviceObject->guidType, &GUID_Slider, sizeof(pDeviceObject->guidType))) {
+        } else if (SDL_memcmp(&pDeviceObject->guidType, &GUID_Slider, sizeof pDeviceObject->guidType) == 0) {
             in->ofs = DIJOFS_SLIDER(joystick->hwdata->NumSliders);
             ++joystick->hwdata->NumSliders;
         } else {
diff --git a/src/joystick/windows/SDL_rawinputjoystick.c b/src/joystick/windows/SDL_rawinputjoystick.c
index 18558e17c..8421ef476 100644
--- a/src/joystick/windows/SDL_rawinputjoystick.c
+++ b/src/joystick/windows/SDL_rawinputjoystick.c
@@ -730,8 +730,8 @@ static void RAWINPUT_AddDevice(HANDLE hDevice)
     /* Don't take devices handled by HIDAPI */
     CHECK(!HIDAPI_IsDevicePresent((Uint16)rdi.hid.dwVendorId, (Uint16)rdi.hid.dwProductId, (Uint16)rdi.hid.dwVersionNumber, ""));
 #endif
-
-    CHECK(device = (SDL_RAWINPUT_Device *)SDL_calloc(1, sizeof(SDL_RAWINPUT_Device)));
+    device = (SDL_RAWINPUT_Device *)SDL_calloc(1, sizeof(SDL_RAWINPUT_Device));
+    CHECK(device);
     device->hDevice = hDevice;
     device->vendor_id = (Uint16)rdi.hid.dwVendorId;
     device->product_id = (Uint16)rdi.hid.dwProductId;
@@ -742,7 +742,8 @@ static void RAWINPUT_AddDevice(HANDLE hDevice)
     /* Get HID Top-Level Collection Preparsed Data */
     size = 0;
     CHECK(GetRawInputDeviceInfoA(hDevice, RIDI_PREPARSEDDATA, NULL, &size) != (UINT)-1);
-    CHECK(device->preparsed_data = (PHIDP_PREPARSED_DATA)SDL_calloc(size, sizeof(BYTE)));
+    device->preparsed_data = (PHIDP_PREPARSED_DATA)SDL_calloc(size, sizeof(BYTE));
+    CHECK(device->preparsed_data);
     CHECK(GetRawInputDeviceInfoA(hDevice, RIDI_PREPARSEDDATA, device->preparsed_data, &size) != (UINT)-1);
 
     hFile = CreateFileA(dev_name, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);
@@ -786,7 +787,6 @@ static void RAWINPUT_AddDevice(HANDLE hDevice)
     /* Add it to the list */
     RAWINPUT_AcquireDevice(device);
     for (curr = SDL_RAWINPUT_devices, last = NULL; curr; last = curr, curr = curr->next) {
-        continue;
     }
     if (last) {
         last->next = device;
diff --git a/src/joystick/windows/SDL_windows_gaming_input.c b/src/joystick/windows/SDL_windows_gaming_input.c
index 1b2d3746c..02ec81fef 100644
--- a/src/joystick/windows/SDL_windows_gaming_input.c
+++ b/src/joystick/windows/SDL_windows_gaming_input.c
@@ -189,7 +189,7 @@ static SDL_bool SDL_IsXInputDevice(Uint16 vendor, Uint16 product)
             continue;
         }
 
-        SDL_snprintf(devVidPidString, sizeof(devVidPidString), "VID_%04X&PID_%04X", vendor, product);
+        (void)SDL_snprintf(devVidPidString, sizeof devVidPidString, "VID_%04X&PID_%04X", vendor, product);
 
         while (CM_Get_Parent(&devNode, devNode, 0) == CR_SUCCESS) {
             char deviceId[MAX_DEVICE_ID_LEN];
@@ -237,7 +237,7 @@ static HRESULT STDMETHODCALLTYPE IEventHandler_CRawGameControllerVtbl_QueryInter
 static ULONG STDMETHODCALLTYPE IEventHandler_CRawGameControllerVtbl_AddRef(__FIEventHandler_1_Windows__CGaming__CInput__CRawGameController *This)
 {
     RawGameControllerDelegate *self = (RawGameControllerDelegate *)This;
-    return SDL_AtomicAdd(&self->refcount, 1) + 1;
+    return SDL_AtomicAdd(&self->refcount, 1) + 1UL;
 }
 
 static ULONG STDMETHODCALLTYPE IEventHandler_CRawGameControllerVtbl_Release(__FIEventHandler_1_Windows__CGaming__CInput__CRawGameController *This)
@@ -393,6 +393,8 @@ static HRESULT STDMETHODCALLTYPE IEventHandler_CRawGameControllerVtbl_InvokeAdde
                 wgi.controllers = controllers;
 
                 SDL_PrivateJoystickAdded(joystickID);
+            } else {
+                SDL_free(name);
             }
         }
 
diff --git a/src/joystick/windows/SDL_windowsjoystick.c b/src/joystick/windows/SDL_windowsjoystick.c
index b54038408..d05d7ab5e 100644
--- a/src/joystick/windows/SDL_windowsjoystick.c
+++ b/src/joystick/windows/SDL_windowsjoystick.c
@@ -177,7 +177,7 @@ static DWORD CALLBACK SDL_DeviceNotificationFunc(HCMNOTIFICATION hNotify, PVOID
 static void SDL_CleanupDeviceNotificationFunc(void)
 {
     if (cfgmgr32_lib_handle) {
-        if (s_DeviceNotificationFuncHandle) {
+        if (s_DeviceNotificationFuncHandle != NULL && CM_Unregister_Notification != NULL) {
             CM_Unregister_Notification(s_DeviceNotificationFuncHandle);
             s_DeviceNotificationFuncHandle = NULL;
         }
@@ -294,8 +294,8 @@ static int SDL_CreateDeviceNotification(SDL_DeviceNotificationData *data)
         return -1;
     }
 
-    data->messageWindow = (HWND)CreateWindowEx(0, TEXT("Message"), NULL, 0, 0, 0, 0, 0, HWND_MESSAGE, NULL, NULL, NULL);
-    if (!data->messageWindow) {
+    data->messageWindow = CreateWindowEx(0, TEXT("Message"), NULL, 0, 0, 0, 0, 0, HWND_MESSAGE, NULL, NULL, NULL);
+    if (data->messageWindow == NULL) {
         WIN_SetError("Failed to create message window for joystick autodetect");
         SDL_CleanupDeviceNotification(data);
         return -1;
diff --git a/src/joystick/windows/SDL_xinputjoystick.c b/src/joystick/windows/SDL_xinputjoystick.c
index 3190930b0..4657ef4c0 100644
--- a/src/joystick/windows/SDL_xinputjoystick.c
+++ b/src/joystick/windows/SDL_xinputjoystick.c
@@ -86,37 +86,37 @@ static const char *GetXInputName(const Uint8 userid, BYTE SubType)
     static char name[32];
 
     if (SDL_XInputUseOldJoystickMapping()) {
-        SDL_snprintf(name, sizeof(name), "X360 Controller #%u", 1 + userid);
+        (void)SDL_snprintf(name, sizeof name, "X360 Controller #%u", 1 + userid);
     } else {
         switch (SubType) {
         case XINPUT_DEVSUBTYPE_GAMEPAD:
-            SDL_snprintf(name, sizeof(name), "XInput Controller #%u", 1 + userid);
+            (void)SDL_snprintf(name, sizeof name, "XInput Controller #%u", 1 + userid);
             break;
         case XINPUT_DEVSUBTYPE_WHEEL:
-            SDL_snprintf(name, sizeof(name), "XInput Wheel #%u", 1 + userid);
+            (void)SDL_snprintf(name, sizeof name, "XInput Wheel #%u", 1 + userid);
             break;
         case XINPUT_DEVSUBTYPE_ARCADE_STICK:
-            SDL_snprintf(name, sizeof(name), "XInput ArcadeStick #%u", 1 + userid);
+            (void)SDL_snprintf(name, sizeof name, "XInput ArcadeStick #%u", 1 + userid);
             break;
         case XINPUT_DEVSUBTYPE_FLIGHT_STICK:
-            SDL_snprintf(name, sizeof(name), "XInput FlightStick #%u", 1 + userid);
+            (void)SDL_snprintf(name, sizeof name, "XInput FlightStick #%u", 1 + userid);
             break;
         case XINPUT_DEVSUBTYPE_DANCE_PAD:
-            SDL_snprintf(name, sizeof(name), "XInput DancePad #%u", 1 + userid);
+            (void)SDL_snprintf(name, sizeof name, "XInput DancePad #%u", 1 + userid);
             break;
         case XINPUT_DEVSUBTYPE_GUITAR:
         case XINPUT_DEVSUBTYPE_GUITAR_ALTERNATE:
         case XINPUT_DEVSUBTYPE_GUITAR_BASS:
-            SDL_snprintf(name, sizeof(name), "XInput Guitar #%u", 1 + userid);
+            (void)SDL_snprintf(name, sizeof name, "XInput Guitar #%u", 1 + userid);
             break;
         case XINPUT_DEVSUBTYPE_DRUM_KIT:
-            SDL_snprintf(name, sizeof(name), "XInput DrumKit #%u", 1 + userid);
+            (void)SDL_snprintf(name, sizeof name, "XInput DrumKit #%u", 1 + userid);
             break;
         case XINPUT_DEVSUBTYPE_ARCADE_PAD:
-            SDL_snprintf(name, sizeof(name), "XInput ArcadePad #%u", 1 + userid);
+            (void)SDL_snprintf(name, sizeof name, "XInput ArcadePad #%u", 1 + userid);
             break;
         default:
-            SDL_snprintf(name, sizeof(name), "XInput Device #%u", 1 + userid);
+            (void)SDL_snprintf(name, sizeof name, "XInput Device #%u", 1 + userid);
             break;
         }
     }
@@ -207,7 +207,7 @@ static void GuessXInputDevice(Uint8 userid, Uint16 *pVID, Uint16 *pPID, Uint16 *
                     /* Steam encodes the real device in the path */
                     int realVID = rdi.hid.dwVendorId;
                     int realPID = rdi.hid.dwProductId;
-                    SDL_sscanf(devName, "\\\\.\\pipe\\HID#VID_045E&PID_028E&IG_00#%x&%x&", &realVID, &realPID);
+                    (void)SDL_sscanf(devName, "\\\\.\\pipe\\HID#VID_045E&PID_028E&IG_00#%x&%x&", &realVID, &realPID);
                     *pVID = (Uint16)realVID;
                     *pPID = (Uint16)realPID;
                     *pVersion = 0;
@@ -279,7 +279,7 @@ static void AddXInputDevice(Uint8 userid, BYTE SubType, JoyStick_DeviceData **pC
         SDL_free(pNewJoystick);
         return; /* better luck next time? */
     }
-    SDL_snprintf(pNewJoystick->path, sizeof(pNewJoystick->path), "XInput#%d", userid);
+    (void)SDL_snprintf(pNewJoystick->path, sizeof pNewJoystick->path, "XInput#%d", userid);
     if (!SDL_XInputUseOldJoystickMapping()) {
         GuessXInputDevice(userid, &vendor, &product, &version);
 
@@ -434,7 +434,7 @@ static void UpdateXInputJoystickState_OLD(SDL_Joystick *joystick, XINPUT_STATE_E
     SDL_PrivateJoystickAxis(joystick, 4, (Sint16)(((int)pXInputState->Gamepad.bLeftTrigger * 65535 / 255) - 32768));
     SDL_PrivateJoystickAxis(joystick, 5, (Sint16)(((int)pXInputState->Gamepad.bRightTrigger * 65535 / 255) - 32768));
 
-    for (button = 0; button < SDL_arraysize(s_XInputButtons); ++button) {
+    for (button = 0; button < (Uint8)SDL_arraysize(s_XInputButtons); ++button) {
         SDL_PrivateJoystickButton(joystick, button, (wButtons & s_XInputButtons[button]) ? SDL_PRESSED : SDL_RELEASED);
     }
 
@@ -460,7 +460,7 @@ static void UpdateXInputJoystickState(SDL_Joystick *joystick, XINPUT_STATE_EX *p
     SDL_PrivateJoystickAxis(joystick, 4, ~pXInputState->Gamepad.sThumbRY);
     SDL_PrivateJoystickAxis(joystick, 5, ((int)pXInputState->Gamepad.bRightTrigger * 257) - 32768);
 
-    for (button = 0; button < SDL_arraysize(s_XInputButtons); ++button) {
+    for (button = 0; button < (Uint8)SDL_arraysize(s_XInputButtons); ++button) {
         SDL_PrivateJoystickButton(joystick, button, (wButtons & s_XInputButtons[button]) ? SDL_PRESSED : SDL_RELEASED);
     }
 
diff --git a/src/locale/macosx/SDL_syslocale.m b/src/locale/macosx/SDL_syslocale.m
index ef8eabab2..53e03ecfc 100644
--- a/src/locale/macosx/SDL_syslocale.m
+++ b/src/locale/macosx/SDL_syslocale.m
@@ -48,7 +48,8 @@ void SDL_SYS_GetPreferredLocales(char *buf, size_t buflen)
             // convert '-' to '_'...
             //  These are always full lang-COUNTRY, so we search from the back,
             //  so things like zh-Hant-CN find the right '-' to convert.
-            if ((ptr = SDL_strrchr(buf, '-')) != NULL) {
+            ptr = SDL_strrchr(buf, '-');
+            if (ptr != NULL) {
                 *ptr = '_';
             }
 
diff --git a/src/locale/windows/SDL_syslocale.c b/src/locale/windows/SDL_syslocale.c
index 8373ab9e2..7c543a845 100644
--- a/src/locale/windows/SDL_syslocale.c
+++ b/src/locale/windows/SDL_syslocale.c
@@ -49,7 +49,7 @@ static void SDL_SYS_GetPreferredLocales_winxp(char *buf, size_t buflen)
     if (langrc == 0) {
         SDL_SetError("Couldn't obtain language info");
     } else {
-        SDL_snprintf(buf, buflen, "%s%s%s", lang, ctryrc ? "_" : "", ctryrc ? country : "");
+        (void)SDL_snprintf(buf, buflen, "%s%s%s", lang, ctryrc ? "_" : "", ctryrc ? country : "");
     }
 }
 
diff --git a/src/main/windows/SDL_windows_main.c b/src/main/windows/SDL_windows_main.c
index 1ed9e35d5..e2725edd1 100644
--- a/src/main/windows/SDL_windows_main.c
+++ b/src/main/windows/SDL_windows_main.c
@@ -64,7 +64,7 @@ static int main_getcmdline(void)
             return OutOfMemory();
         }
         len = (DWORD)SDL_strlen(arg);
-        argv[i] = (char *)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, len + 1);
+        argv[i] = (char *)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, (size_t)len + 1);
         if (!argv[i]) {
             return OutOfMemory();
         }
@@ -104,7 +104,7 @@ int console_wmain(int argc, wchar_t *wargv[], wchar_t *wenvp)
 
 /* This is where execution begins [windowed apps] */
 int WINAPI
-WinMain(HINSTANCE hInst, HINSTANCE hPrev, LPSTR szCmdLine, int sw)
+WinMain(HINSTANCE hInst, HINSTANCE hPrev, LPSTR szCmdLine, int sw) /* NOLINT(readability-inconsistent-declaration-parameter-name) */
 {
     return main_getcmdline();
 }
diff --git a/src/misc/SDL_url.c b/src/misc/SDL_url.c
index d3672d65c..9da1d22ee 100644
--- a/src/misc/SDL_url.c
+++ b/src/misc/SDL_url.c
@@ -21,8 +21,6 @@
 
 #include "SDL_sysurl.h"
 
-extern int SDL_SYS_OpenURL(const char *url);
-
 int SDL_OpenURL(const char *url)
 {
     if (url == NULL) {
diff --git a/src/power/linux/SDL_syspower.c b/src/power/linux/SDL_syspower.c
index dbf5b525a..165048e56 100644
--- a/src/power/linux/SDL_syspower.c
+++ b/src/power/linux/SDL_syspower.c
@@ -50,7 +50,7 @@ static int open_power_file(const char *base, const char *node, const char *key)
         return -1; /* oh well. */
     }
 
-    SDL_snprintf(path, pathlen, "%s/%s/%s", base, node, key);
+    (void)SDL_snprintf(path, pathlen, "%s/%s/%s", base, node, key);
     fd = open(path, O_RDONLY | O_CLOEXEC);
     SDL_stack_free(path);
     return fd;
diff --git a/src/render/SDL_render.c b/src/render/SDL_render.c
index 75aa59268..008fb288e 100644
--- a/src/render/SDL_render.c
+++ b/src/render/SDL_render.c
@@ -1340,7 +1340,7 @@ SDL_CreateTexture(SDL_Renderer *renderer, Uint32 format, int access, int w, int
         } else if (access == SDL_TEXTUREACCESS_STREAMING) {
             /* The pitch is 4 byte aligned */
             texture->pitch = (((w * SDL_BYTESPERPIXEL(format)) + 3) & ~3);
-            texture->pixels = SDL_calloc(1, texture->pitch * h);
+            texture->pixels = SDL_calloc(1, (size_t)texture->pitch * h);
             if (!texture->pixels) {
                 SDL_DestroyTexture(texture);
                 return NULL;
@@ -1687,7 +1687,7 @@ static int SDL_UpdateTextureYUV(SDL_Texture *texture, const SDL_Rect *rect,
     } else {
         /* Use a temporary buffer for updating */
         const int temp_pitch = (((rect->w * SDL_BYTESPERPIXEL(native->format)) + 3) & ~3);
-        const size_t alloclen = rect->h * temp_pitch;
+        const size_t alloclen = (size_t)rect->h * temp_pitch;
         if (alloclen > 0) {
             void *temp_pixels = SDL_malloc(alloclen);
             if (temp_pixels == NULL) {
@@ -1727,7 +1727,7 @@ static int SDL_UpdateTextureNative(SDL_Texture *texture, const SDL_Rect *rect,
     } else {
         /* Use a temporary buffer for updating */
         const int temp_pitch = (((rect->w * SDL_BYTESPERPIXEL(native->format)) + 3) & ~3);
-        const size_t alloclen = rect->h * temp_pitch;
+        const size_t alloclen = (size_t)rect->h * temp_pitch;
         if (alloclen > 0) {
             void *temp_pixels = SDL_malloc(alloclen);
             if (temp_pixels == NULL) {
@@ -1821,7 +1821,7 @@ static int SDL_UpdateTextureYUVPlanar(SDL_Texture *texture, const SDL_Rect *rect
     } else {
         /* Use a temporary buffer for updating */
         const int temp_pitch = (((rect->w * SDL_BYTESPERPIXEL(native->format)) + 3) & ~3);
-        const size_t alloclen = rect->h * temp_pitch;
+        const size_t alloclen = (size_t)rect->h * temp_pitch;
         if (alloclen > 0) {
             void *temp_pixels = SDL_malloc(alloclen);
             if (temp_pixels == NULL) {
@@ -1871,7 +1871,7 @@ static int SDL_UpdateTextureNVPlanar(SDL_Texture *texture, const SDL_Rect *rect,
     } else {
         /* Use a temporary buffer for updating */
         const int temp_pitch = (((rect->w * SDL_BYTESPERPIXEL(native->format)) + 3) & ~3);
-        const size_t alloclen = rect->h * temp_pitch;
+        const size_t alloclen = (size_t)rect->h * temp_pitch;
         if (alloclen > 0) {
             void *temp_pixels = SDL_malloc(alloclen);
             if (temp_pixels == NULL) {
@@ -2313,9 +2313,9 @@ static int UpdateLogicalSize(SDL_Renderer *renderer, SDL_bool flush_viewport_cmd
 
     if (renderer->integer_scale) {
         if (want_aspect > real_aspect) {
-            scale = (float)(w / renderer->logical_w);
+            scale = (float)(w) / renderer->logical_w;
         } else {
-            scale = (float)(h / renderer->logical_h);
+            scale = (float)(h) / renderer->logical_h;
         }
 
         if (scale < 1.0f) {
@@ -2452,10 +2452,12 @@ int SDL_RenderSetViewport(SDL_Renderer *renderer, const SDL_Rect *rect)
         if (SDL_GetRendererOutputSize(renderer, &w, &h) < 0) {
             return -1;
         }
-        renderer->viewport.x = (double)0;
-        renderer->viewport.y = (double)0;
+        renderer->viewport.x = 0.0;
+        renderer->viewport.y = 0.0;
+        /* NOLINTBEGIN(clang-analyzer-core.uninitialized.Assign): SDL_GetRendererOutputSize cannot fail */
         renderer->viewport.w = (double)w;
         renderer->viewport.h = (double)h;
+        /* NOLINTEND(clang-analyzer-core.uninitialized.Assign) */
     }
     retval = QueueCmdSetViewport(renderer);
     return retval < 0 ? retval : FlushRenderCommandsIfNotBatching(renderer);
diff --git a/src/render/SDL_yuv_sw.c b/src/render/SDL_yuv_sw.c
index 30a0b6da6..ced9d4b53 100644
--- a/src/render/SDL_yuv_sw.c
+++ b/src/render/SDL_yuv_sw.c
@@ -142,7 +142,7 @@ int SDL_SW_UpdateYUVTexture(SDL_SW_YUVTexture *swdata, const SDL_Rect *rect,
         if (rect->x == 0 && rect->y == 0 &&
             rect->w == swdata->w && rect->h == swdata->h) {
             SDL_memcpy(swdata->pixels, pixels,
-                       (swdata->h * swdata->w) + 2 * ((swdata->h + 1) / 2) * ((swdata->w + 1) / 2));
+                       (size_t)(swdata->h * swdata->w) + 2 * ((swdata->h + 1) / 2) * ((swdata->w + 1) / 2));
         } else {
             Uint8 *src, *dst;
             int row;
@@ -194,7 +194,7 @@ int SDL_SW_UpdateYUVTexture(SDL_SW_YUVTexture *swdata, const SDL_Rect *rect,
         dst =
             swdata->planes[0] + rect->y * swdata->pitches[0] +
             rect->x * 2;
-        length = 4 * ((rect->w + 1) / 2);
+        length = 4 * (((size_t)rect->w + 1) / 2);
         for (row = 0; row < rect->h; ++row) {
             SDL_memcpy(dst, src, length);
             src += pitch;
@@ -206,7 +206,7 @@ int SDL_SW_UpdateYUVTexture(SDL_SW_YUVTexture *swdata, const SDL_Rect *rect,
     {
         if (rect->x == 0 && rect->y == 0 && rect->w == swdata->w && rect->h == swdata->h) {
             SDL_memcpy(swdata->pixels, pixels,
-                       (swdata->h * swdata->w) + 2 * ((swdata->h + 1) / 2) * ((swdata->w + 1) / 2));
+                       (size_t)(swdata->h * swdata->w) + 2 * ((swdata->h + 1) / 2) * ((swdata->w + 1) / 2));
         } else {
 
             Uint8 *src, *dst;
@@ -227,7 +227,7 @@ int SDL_SW_UpdateYUVTexture(SDL_SW_YUVTexture *swdata, const SDL_Rect *rect,
             src = (Uint8 *)pixels + rect->h * pitch;
             dst = swdata->pixels + swdata->h * swdata->w;
             dst += 2 * ((rect->y + 1) / 2) * ((swdata->w + 1) / 2) + 2 * (rect->x / 2);
-            length = 2 * ((rect->w + 1) / 2);
+            length = 2 * (((size_t)rect->w + 1) / 2);
             for (row = 0; row < (rect->h + 1) / 2; ++row) {
                 SDL_memcpy(dst, src, length);
                 src += 2 * ((pitch + 1) / 2);
diff --git a/src/render/direct3d/SDL_render_d3d.c b/src/render/direct3d/SDL_render_d3d.c
index 4518428ed..412cd4b34 100644
--- a/src/render/direct3d/SDL_render_d3d.c
+++ b/src/render/direct3d/SDL_render_d3d.c
@@ -480,9 +480,9 @@ static int D3D_UpdateTextureRep(IDirect3DDevice9 *device, D3D_TextureRep *textur
     }
 
     d3drect.left = x;
-    d3drect.right = x + w;
+    d3drect.right = (LONG)x + w;
     d3drect.top = y;
-    d3drect.bottom = y + h;
+    d3drect.bottom = (LONG)y + h;
 
     result = IDirect3DTexture9_LockRect(texture->staging, 0, &locked, &d3drect, 0);
     if (FAILED(result)) {
@@ -493,7 +493,7 @@ static int D3D_UpdateTextureRep(IDirect3DDevice9 *device, D3D_TextureRep *textur
     dst = (Uint8 *)locked.pBits;
     length = w * SDL_BYTESPERPIXEL(texture->format);
     if (length == pitch && length == locked.Pitch) {
-        SDL_memcpy(dst, src, length * h);
+        SDL_memcpy(dst, src, (size_t)length * h);
     } else {
         if (length > pitch) {
             length = pitch;
@@ -676,7 +676,7 @@ static int D3D_LockTexture(SDL_Renderer *renderer, SDL_Texture *texture,
             }
         }
         *pixels =
-            (void *)((Uint8 *)texturedata->pixels + rect->y * texturedata->pitch +
+            (void *)(texturedata->pixels + rect->y * texturedata->pitch +
                      rect->x * SDL_BYTESPERPIXEL(texture->format));
         *pitch = texturedata->pitch;
     } else
@@ -691,9 +691,9 @@ static int D3D_LockTexture(SDL_Renderer *renderer, SDL_Texture *texture,
         }
 
         d3drect.left = rect->x;
-        d3drect.right = rect->x + rect->w;
+        d3drect.right = (LONG)rect->x + rect->w;
         d3drect.top = rect->y;
-        d3drect.bottom = rect->y + rect->h;
+        d3drect.bottom = (LONG)rect->y + rect->h;
 
         result = IDirect3DTexture9_LockRect(texturedata->texture.staging, 0, &locked, &d3drect, 0);
         if (FAILED(result)) {
@@ -717,7 +717,7 @@ static void D3D_UnlockTexture(SDL_Renderer *renderer, SDL_Texture *texture)
     if (texturedata->yuv) {
         const SDL_Rect *rect = &texturedata->locked_rect;
         void *pixels =
-            (void *)((Uint8 *)texturedata->pixels + rect->y * texturedata->pitch +
+            (void *)(texturedata->pixels + rect->y * texturedata->pitch +
                      rect->x * SDL_BYTESPERPIXEL(texture->format));
         D3D_UpdateTexture(renderer, texture, rect, pixels, texturedata->pitch);
     } else
@@ -1086,10 +1086,10 @@ static int SetDrawState(D3D_RenderData *data, const SDL_RenderCommand *cmd)
         const SDL_Rect *viewport = &data->drawstate.viewport;
         const SDL_Rect *rect = &data->drawstate.cliprect;
         RECT d3drect;
-        d3drect.left = viewport->x + rect->x;
-        d3drect.top = viewport->y + rect->y;
-        d3drect.right = viewport->x + rect->x + rect->w;
-        d3drect.bottom = viewport->y + rect->y + rect->h;
+        d3drect.left = (LONG)viewport->x + rect->x;
+        d3drect.top = (LONG)viewport->y + rect->y;
+        d3drect.right = (LONG)viewport->x + rect->x + rect->w;
+        d3drect.bottom = (LONG)viewport->y + rect->y + rect->h;
         IDirect3DDevice9_SetScissorRect(data->device, &d3drect);
         data->drawstate.cliprect_dirty = SDL_FALSE;
     }
@@ -1239,7 +1239,8 @@ static int D3D_RunCommandQueue(SDL_Renderer *renderer, SDL_RenderCommand *cmd, v
             const Vertex *verts = (Vertex *)(((Uint8 *)vertices) + first);
 
             /* DirectX 9 has the same line rasterization semantics as GDI,
-               so we need to close the endpoint of the line with a second draw call. */
+               so we need to close the endpoint of the line with a second draw call.
+               NOLINTNEXTLINE(clang-analyzer-core.NullDereference): FIXME: Can verts truly not be NULL ? */
             const SDL_bool close_endpoint = ((count == 2) || (verts[0].x != verts[count - 1].x) || (verts[0].y != verts[count - 1].y));
 
             SetDrawState(data, cmd);
@@ -1326,9 +1327,9 @@ static int D3D_RenderReadPixels(SDL_Renderer *renderer, const SDL_Rect *rect,
     }
 
     d3drect.left = rect->x;
-    d3drect.right = rect->x + rect->w;
+    d3drect.right = (LONG)rect->x + rect->w;
     d3drect.top = rect->y;
-    d3drect.bottom = rect->y + rect->h;
+    d3drect.bottom = (LONG)rect->y + rect->h;
 
     result = IDirect3DSurface9_LockRect(surface, &locked, &d3drect, D3DLOCK_READONLY);
     if (FAILED(result)) {
diff --git a/src/render/direct3d11/SDL_render_d3d11.c b/src/render/direct3d11/SDL_render_d3d11.c
index a37c1df38..4211e3050 100644
--- a/src/render/direct3d11/SDL_render_d3d11.c
+++ b/src/render/direct3d11/SDL_render_d3d11.c
@@ -702,9 +702,9 @@ static int D3D11_GetViewportAlignedD3DRect(SDL_Renderer *renderer, const SDL_Rec
     switch (rotation) {
     case DXGI_MODE_ROTATION_IDENTITY:
         outRect->left = sdlRect->x;
-        outRect->right = sdlRect->x + sdlRect->w;
+        outRect->right = (LONG)sdlRect->x + sdlRect->w;
         outRect->top = sdlRect->y;
-        outRect->bottom = sdlRect->y + sdlRect->h;
+        outRect->bottom = (LONG)sdlRect->y + sdlRect->h;
         if (includeViewportOffset) {
             outRect->left += viewport->x;
             outRect->right += viewport->x;
@@ -714,7 +714,7 @@ static int D3D11_GetViewportAlignedD3DRect(SDL_Renderer *renderer, const SDL_Rec
         break;
     case DXGI_MODE_ROTATION_ROTATE270:
         outRect->left = sdlRect->y;
-        outRect->right = sdlRect->y + sdlRect->h;
+        outRect->right = (LONG)sdlRect->y + sdlRect->h;
         outRect->top = viewport->w - sdlRect->x - sdlRect->w;
         outRect->bottom = viewport->w - sdlRect->x;
         break;
@@ -728,7 +728,7 @@ static int D3D11_GetViewportAlignedD3DRect(SDL_Renderer *renderer, const SDL_Rec
         outRect->left = viewport->h - sdlRect->y - sdlRect->h;
         outRect->right = viewport->h - sdlRect->y;
         outRect->top = sdlRect->x;
-        outRect->bottom = sdlRect->x + sdlRect->h;
+        outRect->bottom = (LONG)sdlRect->x + sdlRect->h;
         break;
     default:
         return SDL_SetError("The physical display is in an unknown or unsupported rotation");
@@ -930,7 +930,7 @@ static HRESULT D3D11_CreateWindowSizeDependentResources(SDL_Renderer *renderer)
 #endif
     } else {
         result = D3D11_CreateSwapChain(renderer, w, h);
-        if (FAILED(result)) {
+        if (FAILED(result) || data->swapChain == NULL) {
             goto done;
         }
     }
@@ -1297,7 +1297,7 @@ static int D3D11_UpdateTextureInternal(D3D11_RenderData *rendererData, ID3D11Tex
     dst = textureMemory.pData;
     length = w * bpp;
     if (length == pitch && length == textureMemory.RowPitch) {
-        SDL_memcpy(dst, src, length * h);
+        SDL_memcpy(dst, src, (size_t)length * h);
     } else {
         if (length > (UINT)pitch) {
             length = pitch;
@@ -1448,7 +1448,7 @@ static int D3D11_LockTexture(SDL_Renderer *renderer, SDL_Texture *texture,
         }
         textureData->locked_rect = *rect;
         *pixels =
-            (void *)((Uint8 *)textureData->pixels + rect->y * textureData->pitch +
+            (void *)(textureData->pixels + rect->y * textureData->pitch +
                      rect->x * SDL_BYTESPERPIXEL(texture->format));
         *pitch = textureData->pitch;
         return 0;
@@ -1519,7 +1519,7 @@ static void D3D11_UnlockTexture(SDL_Renderer *renderer, SDL_Texture *texture)
     if (textureData->yuv || textureData->nv12) {
         const SDL_Rect *rect = &textureData->locked_rect;
         void *pixels =
-            (void *)((Uint8 *)textureData->pixels + rect->y * textureData->pitch +
+            (void *)(textureData->pixels + rect->y * textureData->pitch +
                      rect->x * SDL_BYTESPERPIXEL(texture->format));
         D3D11_UpdateTexture(renderer, texture, rect, pixels, textureData->pitch);
         return;
diff --git a/src/render/direct3d12/SDL_render_d3d12.c b/src/render/direct3d12/SDL_render_d3d12.c
index 75c003034..3d41f50a4 100644
--- a/src/render/direct3d12/SDL_render_d3d12.c
+++ b/src/render/direct3d12/SDL_render_d3d12.c
@@ -1104,9 +1104,9 @@ static int D3D12_GetViewportAlignedD3DRect(SDL_Renderer *renderer, const SDL_Rec
     switch (rotation) {
     case DXGI_MODE_ROTATION_IDENTITY:
         outRect->left = sdlRect->x;
-        outRect->right = sdlRect->x + sdlRect->w;
+        outRect->right = (LONG)sdlRect->x + sdlRect->w;
         outRect->top = sdlRect->y;
-        outRect->bottom = sdlRect->y + sdlRect->h;
+        outRect->bottom = (LONG)sdlRect->y + sdlRect->h;
         if (includeViewportOffset) {
             outRect->left += viewport->x;
             outRect->right += viewport->x;
@@ -1116,7 +1116,7 @@ static int D3D12_GetViewportAlignedD3DRect(SDL_Renderer *renderer, const SDL_Rec
         break;
     case DXGI_MODE_ROTATION_ROTATE270:
         outRect->left = sdlRect->y;
-        outRect->right = sdlRect->y + sdlRect->h;
+        outRect->right = (LONG)sdlRect->y + sdlRect->h;
         outRect->top = viewport->w - sdlRect->x - sdlRect->w;
         outRect->bottom = viewport->w - sdlRect->x;
         break;
@@ -1130,7 +1130,7 @@ static int D3D12_GetViewportAlignedD3DRect(SDL_Renderer *renderer, const SDL_Rec
         outRect->left = viewport->h - sdlRect->y - sdlRect->h;
         outRect->right = viewport->h - sdlRect->y;
         outRect->top = sdlRect->x;
-        outRect->bottom = sdlRect->x + sdlRect->h;
+        outRect->bottom = (LONG)sdlRect->x + sdlRect->h;
         break;
     default:
         return SDL_SetError("The physical display is in an unknown or unsupported rotation");
@@ -1298,7 +1298,7 @@ static HRESULT D3D12_CreateWindowSizeDependentResources(SDL_Renderer *renderer)
     /* Set the proper rotation for the swap chain. */
     if (WIN_IsWindows8OrGreater()) {
         if (data->swapEffect == DXGI_SWAP_EFFECT_FLIP_SEQUENTIAL) {
-            result = D3D_CALL(data->swapChain, SetRotation, data->rotation);
+            result = D3D_CALL(data->swapChain, SetRotation, data->rotation); /* NOLINT(clang-analyzer-core.NullDereference) */
             if (FAILED(result)) {
                 WIN_SetErrorFromHRESULT(SDL_COMPOSE_ERROR("IDXGISwapChain4::SetRotation"), result);
                 goto done;
@@ -1316,7 +1316,7 @@ static HRESULT D3D12_CreateWindowSizeDependentResources(SDL_Renderer *renderer)
             goto done;
         }
 #else
-        result = D3D_CALL(data->swapChain, GetBuffer,
+        result = D3D_CALL(data->swapChain, GetBuffer, /* NOLINT(clang-analyzer-core.NullDereference) */
                           i,
                           D3D_GUID(SDL_IID_ID3D12Resource),
                           (void **)&data->renderTargets[i]);
@@ -1729,7 +1729,7 @@ static int D3D12_UpdateTextureInternal(D3D12_RenderData *rendererData, ID3D12Res
     dst = textureMemory;
     length = w * bpp;
     if (length == pitch && length == pitchedDesc.RowPitch) {
-        SDL_memcpy(dst, src, length * h);
+        SDL_memcpy(dst, src, (size_t)length * h);
     } else {
         if (length > (UINT)pitch) {
             length = pitch;
@@ -1902,7 +1902,7 @@ static int D3D12_LockTexture(SDL_Renderer *renderer, SDL_Texture *texture,
         }
         textureData->lockedRect = *rect;
         *pixels =
-            (void *)((Uint8 *)textureData->pixels + rect->y * textureData->pitch +
+            (void *)(textureData->pixels + rect->y * textureData->pitch +
                      rect->x * SDL_BYTESPERPIXEL(texture->format));
         *pitch = textureData->pitch;
         return 0;
@@ -2013,7 +2013,7 @@ static void D3D12_UnlockTexture(SDL_Renderer *renderer, SDL_Texture *texture)
     if (textureData->yuv || textureData->nv12) {
         const SDL_Rect *rect = &textureData->lockedRect;
         void *pixels =
-            (void *)((Uint8 *)textureData->pixels + rect->y * textureData->pitch +
+            (void *)(textureData->pixels + rect->y * textureData->pitch +
                      rect->x * SDL_BYTESPERPIXEL(texture->format));
         D3D12_UpdateTexture(renderer, texture, rect, pixels, textureData->pitch);
         return;
diff --git a/src/render/metal/SDL_render_metal.m b/src/render/metal/SDL_render_metal.m
index 80fd96f07..7e6b4b00a 100644
--- a/src/render/metal/SDL_render_metal.m
+++ b/src/render/metal/SDL_render_metal.m
@@ -1286,7 +1286,7 @@ SetCopyState(SDL_Renderer *renderer, const SDL_RenderCommand *cmd, const size_t
         [data.mtlcmdencoder setFragmentTexture:texturedata.mtltexture atIndex:0];
 #if SDL_HAVE_YUV
         if (texturedata.yuv || texturedata.nv12) {
-            [data.mtlcmdencoder setFragmentTexture:texturedata.mtltexture_uv atIndex:1];
+            [data.mtlcmdencoder setFragmentTexture:texturedata.mtltextureUv atIndex:1];
             [data.mtlcmdencoder setFragmentBuffer:data.mtlbufconstants offset:texturedata.conversionBufferOffset atIndex:1];
         }
 #endif
diff --git a/src/render/opengl/SDL_render_gl.c b/src/render/opengl/SDL_render_gl.c
index ef8532533..71f24a7a9 100644
--- a/src/render/opengl/SDL_render_gl.c
+++ b/src/render/opengl/SDL_render_gl.c
@@ -50,9 +50,6 @@
    http://developer.apple.com/library/mac/#documentation/GraphicsImaging/Conceptual/OpenGL-MacProgGuide/opengl_texturedata/opengl_texturedata.html
 */
 
-/* Used to re-create the window with OpenGL capability */
-extern int SDL_RecreateWindow(SDL_Window *window, Uint32 flags);
-
 static const float inv255f = 1.0f / 255.0f;
 
 typedef struct GL_FBOList GL_FBOList;
@@ -477,7 +474,7 @@ static int GL_CreateTexture(SDL_Renderer *renderer, SDL_Texture *texture)
     if (texture->access == SDL_TEXTUREACCESS_STREAMING) {
         size_t size;
         data->pitch = texture->w * SDL_BYTESPERPIXEL(texture->format);
-        size = texture->h * data->pitch;
+        size = (size_t)texture->h * data->pitch;
         if (texture->format == SDL_PIXELFORMAT_YV12 ||
             texture->format == SDL_PIXELFORMAT_IYUV) {
             /* Need to add size for the U and V planes */
@@ -695,7 +692,7 @@ static int GL_UpdateTexture(SDL_Renderer *renderer, SDL_Texture *texture,
     GL_TextureData *data = (GL_TextureData *)texture->driverdata;
     const int texturebpp = SDL_BYTESPERPIXEL(texture->format);
 
-    SDL_assert(texturebpp != 0); /* otherwise, division by zero later. */
+    SDL_assert_release(texturebpp != 0); /* otherwise, division by zero later. */
 
     GL_ActivateRenderer(renderer);
 
@@ -1430,12 +1427,12 @@ static int GL_RenderReadPixels(SDL_Renderer *renderer, const SDL_Rect *rect,
                             SDL_GetPixelFormatName(temp_format));
     }
 
-    if (!rect->w || !rect->h) {
+    if (rect->w == 0 || rect->h == 0) {
         return 0; /* nothing to do. */
     }
 
     temp_pitch = rect->w * SDL_BYTESPERPIXEL(temp_format);
-    temp_pixels = SDL_malloc(rect->h * temp_pitch);
+    temp_pixels = SDL_malloc((size_t)rect->h * temp_pitch);
     if (temp_pixels == NULL) {
         return SDL_OutOfMemory();
     }
diff --git a/src/render/opengl/SDL_shaders_gl.c b/src/render/opengl/SDL_shaders_gl.c
index 14bfeb4ae..440dd27dc 100644
--- a/src/render/opengl/SDL_shaders_gl.c
+++ b/src/render/opengl/SDL_shaders_gl.c
@@ -472,7 +472,7 @@ static SDL_bool CompileShaderProgram(GL_ShaderContext *ctx, int index, GL_Shader
     ctx->glUseProgramObjectARB(data->program);
     for (i = 0; i < num_tmus_bound; ++i) {
         char tex_name[10];
-        SDL_snprintf(tex_name, SDL_arraysize(tex_name), "tex%d", i);
+        (void)SDL_snprintf(tex_name, SDL_arraysize(tex_name), "tex%d", i);
         location = ctx->glGetUniformLocationARB(data->program, tex_name);
         if (location >= 0) {
             ctx->glUniform1iARB(location, i);
diff --git a/src/render/opengles2/SDL_render_gles2.c b/src/render/opengles2/SDL_render_gles2.c
index eebb985f8..e7212eee9 100644
--- a/src/render/opengles2/SDL_render_gles2.c
+++ b/src/render/opengles2/SDL_render_gles2.c
@@ -46,9 +46,6 @@
 #define RENDERER_CONTEXT_MAJOR 2
 #define RENDERER_CONTEXT_MINOR 0
 
-/* Used to re-create the window with OpenGL ES capability */
-extern int SDL_RecreateWindow(SDL_Window *window, Uint32 flags);
-
 /*************************************************************************************************
  * Context structures                                                                            *
  *************************************************************************************************/
@@ -1465,7 +1462,7 @@ static int GLES2_CreateTexture(SDL_Renderer *renderer, SDL_Texture *texture)
     if (texture->access == SDL_TEXTUREACCESS_STREAMING) {
         size_t size;
         data->pitch = texture->w * SDL_BYTESPERPIXEL(texture->format);
-        size = texture->h * data->pitch;
+        size = (size_t)texture->h * data->pitch;
 #if SDL_HAVE_YUV
         if (data->yuv) {
             /* Need to add size for the U and V planes */
@@ -1565,7 +1562,7 @@ static int GLES2_TexSubImage2D(GLES2_RenderData *data, GLenum target, GLint xoff
     Uint32 *blob2 = NULL;
 #endif
     Uint8 *src;
-    int src_pitch;
+    size_t src_pitch;
     int y;
 
     if ((width == 0) || (height == 0) || (bpp == 0)) {
@@ -1573,7 +1570,7 @@ static int GLES2_TexSubImage2D(GLES2_RenderData *data, GLenum target, GLint xoff
     }
 
     /* Reformat the texture data into a tightly packed array */
-    src_pitch = width * bpp;
+    src_pitch = (size_t)width * bpp;
     src = (Uint8 *)pixels;
     if (pitch != src_pitch) {
         blob = (Uint8 *)SDL_malloc(src_pitch * height);
@@ -1915,7 +1912,7 @@ static int GLES2_RenderReadPixels(SDL_Renderer *renderer, const SDL_Rect *rect,
     int status;
 
     temp_pitch = rect->w * SDL_BYTESPERPIXEL(temp_format);
-    buflen = rect->h * temp_pitch;
+    buflen = (size_t)rect->h * temp_pitch;
     if (buflen == 0) {
         return 0; /* nothing to do. */
     }
diff --git a/src/render/software/SDL_render_sw.c b/src/render/software/SDL_render_sw.c
index 8332d7dc9..f91f7d66c 100644
--- a/src/render/software/SDL_render_sw.c
+++ b/src/render/software/SDL_render_sw.c
@@ -142,7 +142,7 @@ static int SW_UpdateTexture(SDL_Renderer *renderer, SDL_Texture *texture,
     dst = (Uint8 *)surface->pixels +
           rect->y * surface->pitch +
           rect->x * surface->format->BytesPerPixel;
-    length = rect->w * surface->format->BytesPerPixel;
+    length = (size_t)rect->w * surface->format->BytesPerPixel;
     for (row = 0; row < rect->h; ++row) {
         SDL_memcpy(dst, src, length);
         src += pitch;
@@ -538,9 +538,9 @@ static int SW_QueueGeometry(SDL_Renderer *renderer, SDL_RenderCommand *cmd, SDL_
     int i;
     int count = indices ? num_indices : num_vertices;
     void *verts;
-    int sz = texture ? sizeof(GeometryCopyData) : sizeof(GeometryFillData);
+    size_t sz = texture != NULL ? sizeof(GeometryCopyData) : sizeof(GeometryFillData);
 
-    verts = (void *)SDL_AllocateRenderVertices(renderer, count * sz, 0, &cmd->data.draw.first);
+    verts = SDL_AllocateRenderVertices(renderer, count * sz, 0, &cmd->data.draw.first);
     if (verts == NULL) {
         return -1;
     }
@@ -641,7 +641,7 @@ static void SetDrawState(SDL_Surface *surface, SW_DrawStateCache *drawstate)
     if (drawstate->surface_cliprect_dirty) {
         const SDL_Rect *viewport = drawstate->viewport;
         const SDL_Rect *cliprect = drawstate->cliprect;
-        SDL_assert(viewport != NULL); /* the higher level should have forced a SDL_RENDERCMD_SETVIEWPORT */
+        SDL_assert_release(viewport != NULL); /* the higher level should have forced a SDL_RENDERCMD_SETVIEWPORT */
 
         if (cliprect != NULL) {
             SDL_Rect clip_rect;
diff --git a/src/render/software/SDL_rotate.c b/src/render/software/SDL_rotate.c
index 1b918ce08..6ebc5e137 100644
--- a/src/render/software/SDL_rotate.c
+++ b/src/render/software/SDL_rotate.c
@@ -432,7 +432,7 @@ static void transformSurfaceY(SDL_Surface *src, SDL_Surface *dst, int isin, int
     /*
      * Clear surface to colorkey
      */
-    SDL_memset(pc, (int)(get_colorkey(src) & 0xff), dst->pitch * dst->h);
+    SDL_memset(pc, (int)(get_colorkey(src) & 0xff), (size_t)dst->pitch * dst->h);
     /*
      * Iterate through destination surface
      */
diff --git a/src/render/software/SDL_triangle.c b/src/render/software/SDL_triangle.c
index f924427c9..b15ae9b07 100644
--- a/src/render/software/SDL_triangle.c
+++ b/src/render/software/SDL_triangle.c
@@ -659,7 +659,7 @@ int SDL_SW_BlitTriangle(
         tmp_info.src_pitch = src_pitch;
 
         /* dst */
-        tmp_info.dst = (Uint8 *)dst_ptr;
+        tmp_info.dst = dst_ptr;
         tmp_info.dst_pitch = dst_pitch;
 
         SDL_BlitTriangle_Slow(&tmp_info, s2_x_area, dstrect, area, bias_w0, bias_w1, bias_w2,
@@ -682,7 +682,7 @@ int SDL_SW_BlitTriangle(
         TRIANGLE_BEGIN_LOOP
         {
             TRIANGLE_GET_TEXTCOORD
-            Uint8 *sptr = (Uint8 *)((Uint8 *)src_ptr + srcy * src_pitch);
+            Uint8 *sptr = (Uint8 *)src_ptr + srcy * src_pitch;
             dptr[0] = sptr[3 * srcx];
             dptr[1] = sptr[3 * srcx + 1];
             dptr[2] = sptr[3 * srcx + 2];
@@ -700,7 +700,7 @@ int SDL_SW_BlitTriangle(
         TRIANGLE_BEGIN_LOOP
         {
             TRIANGLE_GET_TEXTCOORD
-            Uint8 *sptr = (Uint8 *)((Uint8 *)src_ptr + srcy * src_pitch);
+            Uint8 *sptr = (Uint8 *)src_ptr + srcy * src_pitch;
             *dptr = sptr[srcx];
         }
         TRIANGLE_END_LOOP
@@ -839,14 +839,17 @@ static void SDL_BlitTriangle_Slow(SDL_BlitInfo *info,
             break;
         case SDL_COPY_ADD:
             dstR = srcR + dstR;
-            if (dstR > 255)
+            if (dstR > 255) {
                 dstR = 255;
+            }
             dstG = srcG + dstG;
-            if (dstG > 255)
+            if (dstG > 255) {
                 dstG = 255;
+            }
             dstB = srcB + dstB;
-            if (dstB > 255)
+            if (dstB > 255) {
                 dstB = 255;
+            }
             break;
         case SDL_COPY_MOD:
             dstR = (srcR * dstR) / 255;
@@ -855,17 +858,21 @@ static void SDL_BlitTriangle_Slow(SDL_BlitInfo *info,
             break;
         case SDL_COPY_MUL:
             dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255;
-            if (dstR > 255)
+            if (dstR > 255) {
                 dstR = 255;
+            }
             dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255;
-            if (dstG > 255)
+            if (dstG > 255) {
                 dstG = 255;
+            }
             dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255;
-            if (dstB > 255)
+            if (dstB > 255) {
                 dstB = 255;
+            }
             dstA = ((srcA * dstA) + (dstA * (255 - srcA))) / 255;
-            if (dstA > 255)
+            if (dstA > 255) {
                 dstA = 255;
+            }
             break;
         }
         if (FORMAT_HAS_ALPHA(dstfmt_val)) {
diff --git a/src/stdlib/SDL_mslibc.c b/src/stdlib/SDL_mslibc.c
index 84f8169ae..75edb6454 100644
--- a/src/stdlib/SDL_mslibc.c
+++ b/src/stdlib/SDL_mslibc.c
@@ -41,23 +41,27 @@ __declspec(selectany) int _fltused = 1;
 /* The optimizer on Visual Studio 2005 and later generates memcpy() and memset() calls.
    Always provide it for the SDL2 DLL, but skip it when building static lib w/ static runtime. */
 #if (_MSC_VER >= 1400) && (!defined(_MT) || defined(DLL_EXPORT))
+/* NOLINTNEXTLINE(readability-redundant-declaration) */
 extern void *memcpy(void *dst, const void *src, size_t len);
 #pragma intrinsic(memcpy)
 
 #if !defined(__clang__)
 #pragma function(memcpy)
 #endif
+/* NOLINTNEXTLINE(readability-inconsistent-declaration-parameter-name) */
 void *memcpy(void *dst, const void *src, size_t len)
 {
     return SDL_memcpy(dst, src, len);
 }
 
+/* NOLINTNEXTLINE(readability-redundant-declaration) */
 extern void *memset(void *dst, int c, size_t len);
 #pragma intrinsic(memset)
 
 #if !defined(__clang__)
 #pragma function(memset)
 #endif
+/* NOLINTNEXTLINE(readability-inconsistent-declaration-parameter-name) */
 void *memset(void *dst, int c, size_t len)
 {
     return SDL_memset(dst, c, len);
diff --git a/src/stdlib/SDL_string.c b/src/stdlib/SDL_string.c
index 97971a97a..598ada799 100644
--- a/src/stdlib/SDL_string.c
+++ b/src/stdlib/SDL_string.c
@@ -43,14 +43,15 @@
 
 static unsigned UTF8_TrailingBytes(unsigned char c)
 {
-    if (c >= 0xC0 && c <= 0xDF)
+    if (c >= 0xC0 && c <= 0xDF) {
         return 1;
-    else if (c >= 0xE0 && c <= 0xEF)
+    } else if (c >= 0xE0 && c <= 0xEF) {
         return 2;
-    else if (c >= 0xF0 && c <= 0xF4)
+    } else if (c >= 0xF0 && c <= 0xF4) {
         return 3;
-    else
-        return 0;
+    }
+
+    return 0;
 }
 
 #if !defined(HAVE_VSSCANF) || !defined(HAVE_STRTOL) || !defined(HAVE_STRTOUL) || !defined(HAVE_STRTOD)
@@ -443,7 +444,7 @@ int SDL_wcscmp(const wchar_t *str1, const wchar_t *str2)
         ++str1;
         ++str2;
     }
-    return (int)(*str1 - *str2);
+    return *str1 - *str2;
 #endif /* HAVE_WCSCMP */
 }
 
@@ -463,7 +464,7 @@ int SDL_wcsncmp(const wchar_t *str1, const wchar_t *str2, size_t maxlen)
     if (!maxlen) {
         return 0;
     }
-    return (int)(*str1 - *str2);
+    return *str1 - *str2;
 
 #endif /* HAVE_WCSNCMP */
 }
@@ -666,7 +667,7 @@ SDL_strrev(char *string)
     char *b = &string[len - 1];
     len /= 2;
     while (len--) {
-        char c = *a;
+        char c = *a; /* NOLINT(clang-analyzer-core.uninitialized.Assign) */
         *a++ = *b;
         *b-- = c;
     }
@@ -1038,7 +1039,7 @@ int SDL_strcmp(const char *str1, const char *str2)
     int result;
 
     while (1) {
-        result = (int)((unsigned char)*str1 - (unsigned char)*str2);
+        result = ((unsigned char)*str1 - (unsigned char)*str2);
         if (result != 0 || (*str1 == '\0' /* && *str2 == '\0'*/)) {
             break;
         }
@@ -1138,6 +1139,7 @@ int SDL_vsscanf(const char *text, const char *fmt, va_list ap)
     return vsscanf(text, fmt, ap);
 }
 #else
+/* NOLINTNEXTLINE(readability-non-const-parameter) */
 int SDL_vsscanf(const char *text, const char *fmt, va_list ap)
 {
     int retval = 0;
@@ -1678,6 +1680,7 @@ SDL_PrintFloat(char *text, size_t maxlen, SDL_FormatInfo *info, double arg)
     return length;
 }
 
+/* NOLINTNEXTLINE(readability-non-const-parameter) */
 int SDL_vsnprintf(SDL_OUT_Z_CAP(maxlen) char *text, size_t maxlen, const char *fmt, va_list ap)
 {
     size_t length = 0;
diff --git a/src/test/SDL_test_assert.c b/src/test/SDL_test_assert.c
index 95d8911b6..1d2d6c7af 100644
--- a/src/test/SDL_test_assert.c
+++ b/src/test/SDL_test_assert.c
@@ -52,7 +52,7 @@ void SDLTest_Assert(int assertCondition, SDL_PRINTF_FORMAT_STRING const char *as
     /* Print assert description into a buffer */
     SDL_memset(logMessage, 0, SDLTEST_MAX_LOGMESSAGE_LENGTH);
     va_start(list, assertDescription);
-    SDL_vsnprintf(logMessage, SDLTEST_MAX_LOGMESSAGE_LENGTH - 1, assertDescription, list);
+    (void)SDL_vsnprintf(logMessage, SDLTEST_MAX_LOGMESSAGE_LENGTH - 1, assertDescription, list);
     va_end(list);
 
     /* Log, then assert and break on failure */
@@ -70,7 +70,7 @@ int SDLTest_AssertCheck(int assertCondition, SDL_PRINTF_FORMAT_STRING const char
     /* Print assert description into a buffer */
     SDL_memset(logMessage, 0, SDLTEST_MAX_LOGMESSAGE_LENGTH);
     va_start(list, assertDescription);
-    SDL_vsnprintf(logMessage, SDLTEST_MAX_LOGMESSAGE_LENGTH - 1, assertDescription, list);
+    (void)SDL_vsnprintf(logMessage, SDLTEST_MAX_LOGMESSAGE_LENGTH - 1, assertDescription, list);
     va_end(list);
 
     /* Log pass or fail message */
@@ -96,7 +96,7 @@ void SDLTest_AssertPass(SDL_PRINTF_FORMAT_STRING const char *assertDescription,
     /* Print assert description into a buffer */
     SDL_memset(logMessage, 0, SDLTEST_MAX_LOGMESSAGE_LENGTH);
     va_start(list, assertDescription);
-    SDL_vsnprintf(logMessage, SDLTEST_MAX_LOGMESSAGE_LENGTH - 1, assertDescription, list);
+    (void)SDL_vsnprintf(logMessage, SDLTEST_MAX_LOGMESSAGE_LENGTH - 1, assertDescription, list);
     va_end(list);
 
     /* Log pass message */
diff --git a/src/test/SDL_test_common.c b/src/test/SDL_test_common.c
index 6b1687504..75afd5b26 100644
--- a/src/test/SDL_test_common.c
+++ b/src/test/SDL_test_common.c
@@ -54,7 +54,7 @@ static void SDL_snprintfcat(SDL_OUT_Z_CAP(maxlen) char *text, size_t maxlen, SDL
     va_start(ap, fmt);
     text += length;
     maxlen -= length;
-    SDL_vsnprintf(text, maxlen, fmt, ap);
+    (void)SDL_vsnprintf(text, maxlen, fmt, ap);
     va_end(ap);
 }
 
@@ -957,28 +957,28 @@ static void SDLTest_PrintRenderer(SDL_RendererInfo *info)
 
     SDL_Log("  Renderer %s:\n", info->name);
 
-    SDL_snprintf(text, sizeof(text), "    Flags: 0x%8.8" SDL_PRIX32, info->flags);
-    SDL_snprintfcat(text, sizeof(text), " (");
+    (void)SDL_snprintf(text, sizeof text, "    Flags: 0x%8.8" SDL_PRIX32, info->flags);
+    SDL_snprintfcat(text, sizeof text, " (");
     count = 0;
-    for (i = 0; i < sizeof(info->flags) * 8; ++i) {
+    for (i = 0; i < 8 * sizeof info->flags; ++i) {
         Uint32 flag = (1 << i);
         if (info->flags & flag) {
             if (count > 0) {
-                SDL_snprintfcat(text, sizeof(text), " | ");
+                SDL_snprintfcat(text, sizeof text, " | ");
             }
-            SDLTest_PrintRendererFlag(text, sizeof(text), flag);
+            SDLTest_PrintRendererFlag(text, sizeof text, flag);
             ++count;
         }
     }
-    SDL_snprintfcat(text, sizeof(text), ")");
+    SDL_snprintfcat(text, sizeof text, ")");
     SDL_Log("%s\n", text);
 
-    SDL_snprintf(text, sizeof(text), "    Texture formats (%" SDL_PRIu32 "): ", info->num_texture_formats);
+    (void)SDL_snprintf(text, sizeof text, "    Texture formats (%" SDL_PRIu32 "): ", info->num_texture_formats);
     for (i = 0; i < (int)info->num_texture_formats; ++i) {
         if (i > 0) {
-            SDL_snprintfcat(text, sizeof(text), ", ");
+            SDL_snprintfcat(text, sizeof text, ", ");
         }
-        SDLTest_PrintPixelFormat(text, sizeof(text), info->texture_formats[i]);
+        SDLTest_PrintPixelFormat(text, sizeof text, info->texture_formats[i]);
     }
     SDL_Log("%s\n", text);
 
@@ -1065,12 +1065,12 @@ SDLTest_CommonInit(SDLTest_CommonState *state)
             if (n == 0) {
                 SDL_Log("No built-in video drivers\n");
             } else {
-                SDL_snprintf(text, sizeof(text), "Built-in video drivers:");
+                (void)SDL_snprintf(text, sizeof text, "Built-in video drivers:");
                 for (i = 0; i < n; ++i) {
                     if (i > 0) {
-                        SDL_snprintfcat(text, sizeof(text), ",");
+                        SDL_snprintfcat(text, sizeof text, ",");
                     }
-                    SDL_snprintfcat(text, sizeof(text), " %s", SDL_GetVideoDriver(i));
+                    SDL_snprintfcat(text, sizeof text, " %s", SDL_GetVideoDriver(i));
                 }
                 SDL_Log("%s\n", text);
             }
@@ -1262,8 +1262,8 @@ SDLTest_CommonInit(SDLTest_CommonState *state)
             }
 
             if (state->num_windows > 1) {
-                SDL_snprintf(title, SDL_arraysize(title), "%s %d",
-                             state->window_title, i + 1);
+                (void)SDL_snprintf(title, SDL_arraysize(title), "%s %d",
+                                   state->window_title, i + 1);
             } else {
                 SDL_strlcpy(title, state->window_title, SDL_arraysize(title));
             }
@@ -1360,12 +1360,12 @@ SDLTest_CommonInit(SDLTest_CommonState *state)
             if (n == 0) {
                 SDL_Log("No built-in audio drivers\n");
             } else {
-                SDL_snprintf(text, sizeof(text), "Built-in audio drivers:");
+                (void)SDL_snprintf(text, sizeof text, "Built-in audio drivers:");
                 for (i = 0; i < n; ++i) {
                     if (i > 0) {
-                        SDL_snprintfcat(text, sizeof(text), ",");
+                        SDL_snprintfcat(text, sizeof text, ",");
                     }
-                    SDL_snprintfcat(text, sizeof(text), " %s", SDL_GetAudioDriver(i));
+                    SDL_snprintfcat(text, sizeof text, " %s", SDL_GetAudioDriver(i));
                 }
                 SDL_Log("%s\n", text);
             }
@@ -2161,8 +2161,8 @@ void SDLTest_CommonEvent(SDLTest_CommonState *state, SDL_Event *event, int *done
             char message[256];
             SDL_Window *window = SDL_GetWindowFromID(event->key.windowID);
 
-            SDL_snprintf(message, sizeof(message), "(%" SDL_PRIs32 ", %" SDL_PRIs32 "), rel (%" SDL_PRIs32 ", %" SDL_PRIs32 ")\n",
-                         lastEvent.x, lastEvent.y, lastEvent.xrel, lastEvent.yrel);
+            (void)SDL_snprintf(message, sizeof message, "(%" SDL_PRIs32 ", %" SDL_PRIs32 "), rel (%" SDL_PRIs32 ", %" SDL_PRIs32 ")\n",
+                               lastEvent.x, lastEvent.y, lastEvent.xrel, lastEvent.yrel);
             SDL_ShowSimpleMessageBox(SDL_MESSAGEBOX_INFORMATION, "Last mouse position", message, window);
             break;
         }
@@ -2246,7 +2246,7 @@ void SDLTest_CommonDrawWindowInfo(SDL_Renderer *renderer, SDL_Window *window, in
 
     SDL_SetRenderDrawColor(renderer, 170, 170, 170, 255);
 
-    SDL_snprintf(text, sizeof(text), "SDL_GetCurrentVideoDriver: %s", SDL_GetCurrentVideoDriver());
+    (void)SDL_snprintf(text, sizeof text, "SDL_GetCurrentVideoDriver: %s", SDL_GetCurrentVideoDriver());
     SDLTest_DrawString(renderer, 0, textY, text);
     textY += lineHeight;
 
@@ -2259,31 +2259,31 @@ void SDLTest_CommonDrawWindowInfo(SDL_Renderer *renderer, SDL_Window *window, in
     SDL_SetRenderDrawColor(renderer, 170, 170, 170, 255);
 
     if (0 == SDL_GetRendererInfo(renderer, &info)) {
-        SDL_snprintf(text, sizeof(text), "SDL_GetRendererInfo: name: %s", info.name);
+        (void)SDL_snprintf(text, sizeof text, "SDL_GetRendererInfo: name: %s", info.name);
         SDLTest_DrawString(renderer, 0, textY, text);
         textY += lineHeight;
     }
 
     if (0 == SDL_GetRendererOutputSize(renderer, &w, &h)) {
-        SDL_snprintf(text, sizeof(text), "SDL_GetRendererOutputSize: %dx%d", w, h);
+        (void)SDL_snprintf(text, sizeof text, "SDL_GetRendererOutputSize: %dx%d", w, h);
         SDLTest_DrawString(renderer, 0, textY, text);
         textY += lineHeight;
     }
 
     SDL_RenderGetViewport(renderer, &rect);
-    SDL_snprintf(text, sizeof(text), "SDL_RenderGetViewport: %d,%d, %dx%d",
-                 rect.x, rect.y, rect.w, rect.h);
+    (void)SDL_snprintf(text, sizeof text, "SDL_RenderGetViewport: %d,%d, %dx%d",
+                       rect.x, rect.y, rect.w, rect.h);
     SDLTest_DrawString(renderer, 0, textY, text);
     textY += lineHeight;
 
     SDL_RenderGetScale(renderer, &scaleX, &scaleY);
-    SDL_snprintf(text, sizeof(text), "SDL_RenderGetScale: %f,%f",
-                 scaleX, scaleY);
+    (void)SDL_snprintf(text, sizeof text, "SDL_RenderGetScale: %f,%f",
+                       scaleX, scaleY);
     SDLTest_DrawString(renderer, 0, textY, text);
     textY += lineHeight;
 
     SDL_RenderGetLogicalSize(renderer, &w, &h);
-    SDL_snprintf(text, sizeof(text), "SDL_RenderGetLogicalSize: %dx%d", w, h);
+    (void)SDL_snprintf(text, sizeof text, "SDL_RenderGetLogicalSize: %dx%d", w, h);
     SDLTest_DrawString(renderer, 0, textY, text);
     textY += lineHeight;
 
@@ -2296,23 +2296,23 @@ void SDLTest_CommonDrawWindowInfo(SDL_Renderer *renderer, SDL_Window *window, in
     SDL_SetRenderDrawColor(renderer, 170, 170, 170, 255);
 
     SDL_GetWindowPosition(window, &x, &y);
-    SDL_snprintf(text, sizeof(text), "SDL_GetWindowPosition: %d,%d", x, y);
+    (void)SDL_snprintf(text, sizeof text, "SDL_GetWindowPosition: %d,%d", x, y);
     SDLTest_DrawString(renderer, 0, textY, text);
     textY += lineHeight;
 
     SDL_GetWindowSize(window, &w, &h);
-    SDL_snprintf(text, sizeof(text), "SDL_GetWindowSize: %dx%d", w, h);
+    (void)SDL_snprintf(text, sizeof text, "SDL_GetWindowSize: %dx%d", w, h);
     SDLTest_DrawString(renderer, 0, textY, text);
     textY += lineHeight;
 
-    SDL_snprintf(text, sizeof(text), "SDL_GetWindowFlags: ");
-    SDLTest_PrintWindowFlags(text, sizeof(text), SDL_GetWindowFlags(window));
+    (void)SDL_snprintf(text, sizeof text, "SDL_GetWindowFlags: ");
+    SDLTest_PrintWindowFlags(text, sizeof text, SDL_GetWindowFlags(window));
     SDLTest_DrawString(renderer, 0, textY, text);
     textY += lineHeight;
 
     if (0 == SDL_GetWindowDisplayMode(window, &mode)) {
-        SDL_snprintf(text, sizeof(text), "SDL_GetWindowDisplayMode: %dx%d@%dHz (%s)",
-                     mode.w, mode.h, mode.refresh_rate, SDL_GetPixelFormatName(mode.format));
+        (void)SDL_snprintf(text, sizeof text, "SDL_GetWindowDisplayMode: %dx%d@%dHz (%s)",
+                           mode.w, mode.h, mode.refresh_rate, SDL_GetPixelFormatName(mode.format));
         SDLTest_DrawString(renderer, 0, textY, text);
         textY += lineHeight;
     }
@@ -2325,44 +2325,44 @@ void SDLTest_CommonDrawWindowInfo(SDL_Renderer *renderer, SDL_Window *window, in
 
     SDL_SetRenderDrawColor(renderer, 170, 170, 170, 255);
 
-    SDL_snprintf(text, sizeof(text), "SDL_GetWindowDisplayIndex: %d", windowDisplayIndex);
+    (void)SDL_snprintf(text, sizeof text, "SDL_GetWindowDisplayIndex: %d", windowDisplayIndex);
     SDLTest_DrawString(renderer, 0, textY, text);
     textY += lineHeight;
 
-    SDL_snprintf(text, sizeof(text), "SDL_GetDisplayName: %s", SDL_GetDisplayName(windowDisplayIndex));
+    (void)SDL_snprintf(text, sizeof text, "SDL_GetDisplayName: %s", SDL_GetDisplayName(windowDisplayIndex));
     SDLTest_DrawString(renderer, 0, textY, text);
     textY += lineHeight;
 
     if (0 == SDL_GetDisplayBounds(windowDisplayIndex, &rect)) {
-        SDL_snprintf(text, sizeof(text), "SDL_GetDisplayBounds: %d,%d, %dx%d",
-                     rect.x, rect.y, rect.w, rect.h);
+        (void)SDL_snprintf(text, sizeof text, "SDL_GetDisplayBounds: %d,%d, %dx%d",
+                           rect.x, rect.y, rect.w, rect.h);
         SDLTest_DrawString(renderer, 0, textY, text);
         textY += lineHeight;
     }
 
     if (0 == SDL_GetCurrentDisplayMode(windowDisplayIndex, &mode)) {
-        SDL_snprintf(text, sizeof(text), "SDL_GetCurrentDisplayMode: %dx%d@%d",
-                     mode.w, mode.h, mode.refresh_rate);
+        (void)SDL_snprintf(text, sizeof text, "SDL_GetCurrentDisplayMode: %dx%d@%d",
+                           mode.w, mode.h, mode.refresh_rate);
         SDLTest_DrawString(renderer, 0, textY, text);
         textY += lineHeight;
     }
 
     if (0 == SDL_GetDesktopDisplayMode(windowDisplayIndex, &mode)) {
-        SDL_snprintf(text, sizeof(text), "SDL_GetDesktopDisplayMode: %dx%d@%d",
-                     mode.w, mode.h, mode.refresh_rate);
+        (void)SDL_snprintf(text, sizeof text, "SDL_GetDesktopDisplayMode: %dx%d@%d",
+                           mode.w, mode.h, mode.refresh_rate);
         SDLTest_DrawString(renderer, 0, textY, text);
         textY += lineHeight;
     }
 
     if (0 == SDL_GetDisplayDPI(windowDisplayIndex, &ddpi, &hdpi, &vdpi)) {
-        SDL_snprintf(text, sizeof(text), "SDL_GetDisplayDPI: ddpi: %f, hdpi: %f, vdpi: %f",
-                     ddpi, hdpi, vdpi);
+        (void)SDL_snprintf(text, sizeof text, "SDL_GetDisplayDPI: ddpi: %f, hdpi: %f, vdpi: %f",
+                           ddpi, hdpi, vdpi);
         SDLTest_DrawString(renderer, 0, textY, text);
         textY += lineHeight;
     }
 
-    SDL_snprintf(text, sizeof(text), "SDL_GetDisplayOrientation: ");
-    SDLTest_PrintDisplayOrientation(text, sizeof(text), SDL_GetDisplayOrientation(windowDisplayIndex));
+    (void)SDL_snprintf(text, sizeof text, "SDL_GetDisplayOrientation: ");
+    SDLTest_PrintDisplayOrientation(text, sizeof text, SDL_GetDisplayOrientation(windowDisplayIndex));
     SDLTest_DrawString(renderer, 0, textY, text);
     textY += lineHeight;
 
@@ -2375,14 +2375,14 @@ void SDLTest_CommonDrawWindowInfo(SDL_Renderer *renderer, SDL_Window *window, in
     SDL_SetRenderDrawColor(renderer, 170, 170, 170, 255);
 
     flags = SDL_GetMouseState(&x, &y);
-    SDL_snprintf(text, sizeof(text), "SDL_GetMouseState: %d,%d ", x, y);
-    SDLTest_PrintButtonMask(text, sizeof(text), flags);
+    (void)SDL_snprintf(text, sizeof text, "SDL_GetMouseState: %d,%d ", x, y);
+    SDLTest_PrintButtonMask(text, sizeof text, flags);
     SDLTest_DrawString(renderer, 0, textY, text);
     textY += lineHeight;
 
     flags = SDL_GetGlobalMouseState(&x, &y);
-    SDL_snprintf(text, sizeof(text), "SDL_GetGlobalMouseState: %d,%d ", x, y);
-    SDLTest_PrintButtonMask(text, sizeof(text), flags);
+    (void)SDL_snprintf(text, sizeof text, "SDL_GetGlobalMouseState: %d,%d ", x, y);
+    SDLTest_PrintButtonMask(text, sizeof text, flags);
     SDLTest_DrawString(renderer, 0, textY, text);
     textY += lineHeight;
 
diff --git a/src/test/SDL_test_compare.c b/src/test/SDL_test_compare.c
index 78f7406f3..14d3ce5ba 100644
--- a/src/test/SDL_test_compare.c
+++ b/src/test/SDL_test_compare.c
@@ -31,6 +31,8 @@
 
 #include "SDL_test.h"
 
+#define FILENAME_SIZE 128
+
 /* Counter for _CompareSurface calls; used for filename creation when comparisons fail */
 static int _CompareSurfaceCount = 0;
 
@@ -45,8 +47,8 @@ int SDLTest_CompareSurfaces(SDL_Surface *surface, SDL_Surface *referenceSurface,
     int sampleErrorX = 0, sampleErrorY = 0, sampleDist = 0;
     Uint8 R, G, B, A;
     Uint8 Rd, Gd, Bd, Ad;
-    char imageFilename[128];
-    char referenceFilename[128];
+    char imageFilename[FILENAME_SIZE];
+    char referenceFilename[FILENAME_SIZE];
 
     /* Validate input surfaces */
     if (surface == NULL || referenceSurface == NULL) {
@@ -103,9 +105,9 @@ int SDLTest_CompareSurfaces(SDL_Surface *surface, SDL_Surface *referenceSurface,
     if (ret != 0) {
         SDLTest_LogError("Comparison of pixels with allowable error of %i failed %i times.", allowable_error, ret);
         SDLTest_LogError("First detected occurrence at position %i,%i with a squared RGB-difference of %i.", sampleErrorX, sampleErrorY, sampleDist);
-        SDL_snprintf(imageFilename, 127, "CompareSurfaces%04d_TestOutput.bmp", _CompareSurfaceCount);
+        (void)SDL_snprintf(imageFilename, FILENAME_SIZE - 1, "CompareSurfaces%04d_TestOutput.bmp", _CompareSurfaceCount);
         SDL_SaveBMP(surface, imageFilename);
-        SDL_snprintf(referenceFilename, 127, "CompareSurfaces%04d_Reference.bmp", _CompareSurfaceCount);
+        (void)SDL_snprintf(referenceFilename, FILENAME_SIZE - 1, "CompareSurfaces%04d_Reference.bmp", _CompareSurfaceCount);
         SDL_SaveBMP(referenceSurface, referenceFilename);
         SDLTest_LogError("Surfaces from failed comparison saved as '%s' and '%s'", imageFilename, referenceFilename);
     }
diff --git a/src/test/SDL_test_font.c b/src/test/SDL_test_font.c
index 1355d559e..4148e09c5 100644
--- a/src/test/SDL_test_font.c
+++ b/src/test/SDL_test_font.c
@@ -3393,7 +3393,7 @@ void SDLTest_TextWindowAddText(SDLTest_TextWindow *textwin, const char *fmt, ...
     va_list ap;
 
     va_start(ap, fmt);
-    SDL_vsnprintf(text, sizeof(text), fmt, ap);
+    (void)SDL_vsnprintf(text, sizeof text, fmt, ap);
     va_end(ap);
 
     SDLTest_TextWindowAddTextWithLength(textwin, text, SDL_strlen(text));
diff --git a/src/test/SDL_test_harness.c b/src/test/SDL_test_harness.c
index ecb75ee93..baf5eddb1 100644
--- a/src/test/SDL_test_harness.c
+++ b/src/test/SDL_test_harness.c
@@ -130,8 +130,8 @@ static Uint64 SDLTest_GenerateExecKey(const char *runSeed, const char *suiteName
     }
 
     /* Convert iteration number into a string */
-    SDL_memset(iterationString, 0, sizeof(iterationString));
-    SDL_snprintf(iterationString, sizeof(iterationString) - 1, "%d", iteration);
+    SDL_memset(iterationString, 0, sizeof iterationString);
+    (void)SDL_snprintf(iterationString, sizeof iterationString - 1, "%d", iteration);
 
     /* Combine the parameters into single string */
     runSeedLength = SDL_strlen(runSeed);
@@ -145,7 +145,7 @@ static Uint64 SDLTest_GenerateExecKey(const char *runSeed, const char *suiteName
         SDL_Error(SDL_ENOMEM);
         return 0;
     }
-    SDL_snprintf(buffer, entireStringLength, "%s%s%s%d", runSeed, suiteName, testName, iteration);
+    (void)SDL_snprintf(buffer, entireStringLength, "%s%s%s%d", runSeed, suiteName, testName, iteration);
 
     /* Hash string and use half of the digest as 64bit exec key */
     SDLTest_Md5Init(&md5Context);
diff --git a/src/test/SDL_test_log.c b/src/test/SDL_test_log.c
index 6784a4868..e0b8b58e9 100644
--- a/src/test/SDL_test_log.c
+++ b/src/test/SDL_test_log.c
@@ -65,16 +65,21 @@ strftime_gcc2_workaround(char *s, size_t max, const char *fmt, const struct tm *
  *
  * \return Ascii representation of the timestamp in localtime in the format '08/23/01 14:55:02'
  */
-static char *SDLTest_TimestampToString(const time_t timestamp)
+static const char *
+SDLTest_TimestampToString(const time_t timestamp)
 {
     time_t copy;
     static char buffer[64];
     struct tm *local;
+    size_t result = 0;
 
     SDL_memset(buffer, 0, sizeof(buffer));
     copy = timestamp;
     local = localtime(&copy);
-    strftime(buffer, sizeof(buffer), "%x %X", local);
+    result = strftime(buffer, sizeof buffer, "%x %X", local);
+    if (result == 0) {
+        return "";
+    }
 
     return buffer;
 }
@@ -90,7 +95,7 @@ void SDLTest_Log(SDL_PRINTF_FORMAT_STRING const char *fmt, ...)
     /* Print log message into a buffer */
     SDL_memset(logMessage, 0, SDLTEST_MAX_LOGMESSAGE_LENGTH);
     va_start(list, fmt);
-    SDL_vsnprintf(logMessage, SDLTEST_MAX_LOGMESSAGE_LENGTH - 1, fmt, list);
+    (void)SDL_vsnprintf(logMessage, SDLTEST_MAX_LOGMESSAGE_LENGTH - 1, fmt, list);
     va_end(list);
 
     /* Log with timestamp and newline */
@@ -108,7 +113,7 @@ void SDLTest_LogError(SDL_PRINTF_FORMAT_STRING const char *fmt, ...)
     /* Print log message into a buffer */
     SDL_memset(logMessage, 0, SDLTEST_MAX_LOGMESSAGE_LENGTH);
     va_start(list, fmt);
-    SDL_vsnprintf(logMessage, SDLTEST_MAX_LOGMESSAGE_LENGTH - 1, fmt, list);
+    (void)SDL_vsnprintf(logMessage, SDLTEST_MAX_LOGMESSAGE_LENGTH - 1, fmt, list);
     va_end(list);
 
     /* Log with timestamp and newline */
diff --git a/src/test/SDL_test_memory.c b/src/test/SDL_test_memory.c
index d5dd5da91..7cf707d92 100644
--- a/src/test/SDL_test_memory.c
+++ b/src/test/SDL_test_memory.c
@@ -242,30 +242,30 @@ void SDLTest_LogAllocations()
     message = tmp;                                         \
     SDL_strlcat(message, line, message_size)
 
-    SDL_strlcpy(line, "Memory allocations:\n", sizeof(line));
+    SDL_strlcpy(line, "Memory allocations:\n", sizeof line);
     ADD_LINE();
-    SDL_strlcpy(line, "Expect 2 allocations from within SDL_GetErrBuf()\n", sizeof(line));
+    SDL_strlcpy(line, "Expect 2 allocations from within SDL_GetErrBuf()\n", sizeof line);
     ADD_LINE();
 
     count = 0;
     total_allocated = 0;
     for (index = 0; index < SDL_arraysize(s_tracked_allocations); ++index) {
         for (entry = s_tracked_allocations[index]; entry; entry = entry->next) {
-            SDL_snprintf(line, sizeof(line), "Allocation %d: %d bytes\n", count, (int)entry->size);
+            (void)SDL_snprintf(line, sizeof line, "Allocation %d: %d bytes\n", count, (int)entry->size);
             ADD_LINE();
             /* Start at stack index 1 to skip our tracking functions */
             for (stack_index = 1; stack_index < SDL_arraysize(entry->stack); ++stack_index) {
                 if (!entry->stack[stack_index]) {
                     break;
                 }
-                SDL_snprintf(line, sizeof(line), "\t0x%" SDL_PRIx64 ": %s\n", entry->stack[stack_index], entry->stack_names[stack_index]);
+                (void)SDL_snprintf(line, sizeof line, "\t0x%" SDL_PRIx64 ": %s\n", entry->stack[stack_index], entry->stack_names[stack_index]);
                 ADD_LINE();
             }
             total_allocated += entry->size;
             ++count;
         }
     }
-    SDL_snprintf(line, sizeof(line), "Total: %.2f Kb in %d allocations\n", (float)total_allocated / 1024, count);
+    (void)SDL_snprintf(line, sizeof line, "Total: %.2f Kb in %d allocations\n", total_allocated / 1024.0, count);
     ADD_LINE();
 #undef ADD_LINE
 
diff --git a/src/thread/SDL_thread.c b/src/thread/SDL_thread.c
index 408699063..926cf0cfa 100644
--- a/src/thread/SDL_thread.c
+++ b/src/thread/SDL_thread.c
@@ -154,7 +154,7 @@ SDL_Generic_GetTLSData(void)
     return storage;
 }
 
-int SDL_Generic_SetTLSData(SDL_TLSData *storage)
+int SDL_Generic_SetTLSData(SDL_TLSData *data)
 {
     SDL_threadID thread = SDL_ThreadID();
     SDL_TLSEntry *prev, *entry;
@@ -164,10 +164,10 @@ int SDL_Generic_SetTLSData(SDL_TLSData *storage)
     prev = NULL;
     for (entry = SDL_generic_TLS; entry; entry = entry->next) {
         if (entry->thread == thread) {
-            if (storage) {
-                entry->storage = storage;
+            if (data != NULL) {
+                entry->storage = data;
             } else {
-                if (prev) {
+                if (prev != NULL) {
                     prev->next = entry->next;
                 } else {
                     SDL_generic_TLS = entry->next;
@@ -182,7 +182,7 @@ int SDL_Generic_SetTLSData(SDL_TLSData *storage)
         entry = (SDL_TLSEntry *)SDL_malloc(sizeof(*entry));
         if (entry) {
             entry->thread = thread;
-            entry->storage = storage;
+            entry->storage = data;
             entry->next = SDL_generic_TLS;
             SDL_generic_TLS = entry;
         }
diff --git a/src/thread/pthread/SDL_syscond.c b/src/thread/pthread/SDL_syscond.c
index bb614bef4..d47c1c2d6 100644
--- a/src/thread/pthread/SDL_syscond.c
+++ b/src/thread/pthread/SDL_syscond.c
@@ -113,7 +113,7 @@ int SDL_CondWaitTimeout(SDL_cond *cond, SDL_mutex *mutex, Uint32 ms)
     gettimeofday(&delta, NULL);
 
     abstime.tv_sec = delta.tv_sec + (ms / 1000);
-    abstime.tv_nsec = (delta.tv_usec + (ms % 1000) * 1000) * 1000;
+    abstime.tv_nsec = (long)(delta.tv_usec + (ms % 1000) * 1000) * 1000;
 #endif
     if (abstime.tv_nsec > 1000000000) {
         abstime.tv_sec += 1;
diff --git a/src/video/SDL_RLEaccel.c b/src/video/SDL_RLEaccel.c
index a20e2b606..eb2af189f 100644
--- a/src/video/SDL_RLEaccel.c
+++ b/src/video/SDL_RLEaccel.c
@@ -705,10 +705,11 @@ static void RLEAlphaClipBlit(int w, Uint8 *srcbuf, SDL_Surface *surf_dst,
 
     switch (df->BytesPerPixel) {
     case 2:
-        if (df->Gmask == 0x07e0 || df->Rmask == 0x07e0 || df->Bmask == 0x07e0)
+        if (df->Gmask == 0x07e0 || df->Rmask == 0x07e0 || df->Bmask == 0x07e0) {
             RLEALPHACLIPBLIT(Uint16, Uint8, BLIT_TRANSL_565);
-        else
+        } else {
             RLEALPHACLIPBLIT(Uint16, Uint8, BLIT_TRANSL_555);
+        }
         break;
     case 4:
         RLEALPHACLIPBLIT(Uint32, Uint16, BLIT_TRANSL_888);
@@ -755,8 +756,9 @@ static int SDLCALL SDL_RLEAlphaBlit(SDL_Surface *surf_src, SDL_Rect *srcrect,
                         if (run) {
                             srcbuf += 2 * run;
                             ofs += run;
-                        } else if (!ofs)
+                        } else if (ofs == 0) {
                             goto done;
+                        }
                     } while (ofs < w);
 
                     /* skip padding */
@@ -785,8 +787,9 @@ static int SDLCALL SDL_RLEAlphaBlit(SDL_Surface *surf_src, SDL_Rect *srcrect,
                         if (run) {
                             srcbuf += 4 * run;
                             ofs += run;
-                        } else if (!ofs)
+                        } else if (ofs == 0) {
                             goto done;
+                        }
                     } while (ofs < w);
                 } while (--vskip);
             }
@@ -850,10 +853,11 @@ static int SDLCALL SDL_RLEAlphaBlit(SDL_Surface *surf_src, SDL_Rect *srcrect,
 
         switch (df->BytesPerPixel) {
         case 2:
-            if (df->Gmask == 0x07e0 || df->Rmask == 0x07e0 || df->Bmask == 0x07e0)
+            if (df->Gmask == 0x07e0 || df->Rmask == 0x07e0 || df->Bmask == 0x07e0) {
                 RLEALPHABLIT(Uint16, Uint8, BLIT_TRANSL_565);
-            else
+            } else {
                 RLEALPHABLIT(Uint16, Uint8, BLIT_TRANSL_555);
+            }
             break;
         case 4:
             RLEALPHABLIT(Uint32, Uint16, BLIT_TRANSL_888);
@@ -1039,15 +1043,17 @@ static int RLEAlphaSurface(SDL_Surface *surface)
             if (df->Gmask == 0x07e0 || df->Rmask == 0x07e0 || df->Bmask == 0x07e0) {
                 copy_opaque = copy_opaque_16;
                 copy_transl = copy_transl_565;
-            } else
+            } else {
                 return -1;
+            }
             break;
         case 0x7fff:
             if (df->Gmask == 0x03e0 || df->Rmask == 0x03e0 || df->Bmask == 0x03e0) {
                 copy_opaque = copy_opaque_16;
                 copy_transl = copy_transl_555;
-            } else
+            } else {
                 return -1;
+            }
             break;
         default:
             return -1;
@@ -1059,8 +1065,9 @@ static int RLEAlphaSurface(SDL_Surface *surface)
         maxsize = surface->h * (2 + (4 + 2) * (surface->w + 1)) + 2;
         break;
     case 4:
-        if (masksum != 0x00ffffff)
+        if (masksum != 0x00ffffff) {
             return -1; /* requires unused high byte */
+        }
         copy_opaque = copy_32;
         copy_transl = copy_32;
         max_opaque_run = 255; /* runs stored as short ints */
@@ -1128,11 +1135,13 @@ static int RLEAlphaSurface(SDL_Surface *surface)
             do {
                 int run, skip, len;
                 skipstart = x;
-                while (x < w && !ISOPAQUE(src[x], sf))
+                while (x < w && !ISOPAQUE(src[x], sf)) {
                     x++;
+                }
                 runstart = x;
-                while (x < w && ISOPAQUE(src[x], sf))
+                while (x < w && ISOPAQUE(src[x], sf)) {
                     x++;
+                }
                 skip = runstart - skipstart;
                 if (skip == w) {
                     blankline = 1;
@@ -1164,11 +1173,13 @@ static int RLEAlphaSurface(SDL_Surface *surface)
             do {
                 int run, skip, len;
                 skipstart = x;
-                while (x < w && !ISTRANSL(src[x], sf))
+                while (x < w && !ISTRANSL(src[x], sf)) {
                     x++;
+                }
                 runstart = x;
-                while (x < w && ISTRANSL(src[x], sf))
+                while (x < w && ISTRANSL(src[x], sf)) {
                     x++;
+                }
                 skip = runstart - skipstart;
                 blankline &= (skip == w);
                 run = x - runstart;
@@ -1319,16 +1330,19 @@ static int RLEColorkeySurface(SDL_Surface *surface)
         int x = 0;
         int blankline = 0;
         do {
-            int run, skip, len;
+            int run, skip;
+            int len;
             int runstart;
             int skipstart = x;
 
             /* find run of transparent, then opaque pixels */
-            while (x < w && (getpix(srcbuf + x * bpp) & rgbmask) == ckey)
+            while (x < w && (getpix(srcbuf + x * bpp) & rgbmask) == ckey) {
                 x++;
+            }
             runstart = x;
-            while (x < w && (getpix(srcbuf + x * bpp) & rgbmask) != ckey)
+            while (x < w && (getpix(srcbuf + x * bpp) & rgbmask) != ckey) {
                 x++;
+            }
             skip = runstart - skipstart;
             if (skip == w) {
                 blankline = 1;
@@ -1342,14 +1356,14 @@ static int RLEColorkeySurface(SDL_Surface *surface)
             }
             len = SDL_min(run, maxn);
             ADD_COUNTS(skip, len);
-            SDL_memcpy(dst, srcbuf + runstart * bpp, len * bpp);
+            SDL_memcpy(dst, srcbuf + runstart * bpp, (size_t)len * bpp);
             dst += len * bpp;
             run -= len;
             runstart += len;
             while (run) {
                 len = SDL_min(run, maxn);
                 ADD_COUNTS(0, len);
-                SDL_memcpy(dst, srcbuf + runstart * bpp, len * bpp);
+                SDL_memcpy(dst, srcbuf + runstart * bpp, (size_t)len * bpp);
                 dst += len * bpp;
                 runstart += len;
                 run -= len;
@@ -1477,13 +1491,13 @@ static SDL_bool UnRLEAlpha(SDL_Surface *surface)
         uncopy_opaque = uncopy_transl = uncopy_32;
     }
 
-    surface->pixels = SDL_SIMDAlloc(surface->h * surface->pitch);
-    if (!surface->pixels) {
+    surface->pixels = SDL_SIMDAlloc((size_t)surface->h * surface->pitch);
+    if (surface->pixels == NULL) {
         return SDL_FALSE;
     }
     surface->flags |= SDL_SIMD_ALIGNED;
     /* fill background with transparent pixels */
-    SDL_memset(surface->pixels, 0, surface->h * surface->pitch);
+    SDL_memset(surface->pixels, 0, (size_t)surface->h * surface->pitch);
 
     dst = surface->pixels;
     srcbuf = (Uint8 *)(df + 1);
@@ -1543,8 +1557,8 @@ void SDL_UnRLESurface(SDL_Surface *surface, int recode)
                 SDL_Rect full;
 
                 /* re-create the original surface */
-                surface->pixels = SDL_SIMDAlloc(surface->h * surface->pitch);
-                if (!surface->pixels) {
+                surface->pixels = SDL_SIMDAlloc((size_t)surface->h * surface->pitch);
+                if (surface->pixels == NULL) {
                     /* Oh crap... */
                     surface->flags |= SDL_RLEACCEL;
                     return;
diff --git a/src/video/SDL_blit.c b/src/video/SDL_blit.c
index fe0bd5ac2..c4cc8104c 100644
--- a/src/video/SDL_blit.c
+++ b/src/video/SDL_blit.c
@@ -137,7 +137,7 @@ static SDL_BlitFunc SDL_ChooseBlitFunc(Uint32 src_format, Uint32 dst_format, int
 
         /* Allow an override for testing .. */
         if (override) {
-            SDL_sscanf(override, "%u", &features);
+            (void)SDL_sscanf(override, "%u", &features);
         } else {
             if (SDL_HasMMX()) {
                 features |= SDL_CPU_MMX;
diff --git a/src/video/SDL_blit_A.c b/src/video/SDL_blit_A.c
index 87d3ec7ce..acfc1a478 100644
--- a/src/video/SDL_blit_A.c
+++ b/src/video/SDL_blit_A.c
@@ -1457,18 +1457,22 @@ SDL_CalculateBlitA(SDL_Surface *surface)
                 if (surface->map->identity) {
                     if (df->Gmask == 0x7e0) {
 #ifdef __MMX__
-                        if (SDL_HasMMX())
+                        if (SDL_HasMMX()) {
                             return Blit565to565SurfaceAlphaMMX;
-                        else
+                        } else
 #endif
+                        {
                             return Blit565to565SurfaceAlpha;
+                        }
                     } else if (df->Gmask == 0x3e0) {
 #ifdef __MMX__
-                        if (SDL_HasMMX())
+                        if (SDL_HasMMX()) {
                             return Blit555to555SurfaceAlphaMMX;
-                        else
+                        } else
 #endif
+                        {
                             return Blit555to555SurfaceAlpha;
+                        }
                     }
                 }
                 return BlitNtoNSurfaceAlpha;
diff --git a/src/video/SDL_blit_N.c b/src/video/SDL_blit_N.c
index 4b7033471..20f5b27ac 100644
--- a/src/video/SDL_blit_N.c
+++ b/src/video/SDL_blit_N.c
@@ -3418,11 +3418,11 @@ SDL_CalculateBlitN(SDL_Surface *surface)
            because RLE is the preferred fast way to deal with this.
            If a particular case turns out to be useful we'll add it. */
 
-        if (srcfmt->BytesPerPixel == 2 && surface->map->identity)
+        if (srcfmt->BytesPerPixel == 2 && surface->map->identity != 0) {
             return Blit2to2Key;
-        else if (dstfmt->BytesPerPixel == 1)
+        } else if (dstfmt->BytesPerPixel == 1) {
             return BlitNto1Key;
-        else {
+        } else {
 #if SDL_ALTIVEC_BLITTERS
             if ((srcfmt->BytesPerPixel == 4) && (dstfmt->BytesPerPixel == 4) && SDL_HasAltiVec()) {
                 return Blit32to32KeyAltivec;
diff --git a/src/video/SDL_bmp.c b/src/video/SDL_bmp.c
index bfd87cbfb..be1043245 100644
--- a/src/video/SDL_bmp.c
+++ b/src/video/SDL_bmp.c
@@ -616,11 +616,11 @@ done:
     return surface;
 }
 
-int SDL_SaveBMP_RW(SDL_Surface *saveme, SDL_RWops *dst, int freedst)
+int SDL_SaveBMP_RW(SDL_Surface *surface, SDL_RWops *dst, int freedst)
 {
     Sint64 fp_offset;
     int i, pad;
-    SDL_Surface *surface;
+    SDL_Surface *intermediate_surface;
     Uint8 *bits;
     SDL_bool save32bit = SDL_FALSE;
     SDL_bool saveLegacyBMP = SDL_FALSE;
@@ -657,35 +657,36 @@ int SDL_SaveBMP_RW(SDL_Surface *saveme, SDL_RWops *dst, int freedst)
     Uint32 bV4GammaBlue = 0;
 
     /* Make sure we have somewhere to save */
-    surface = NULL;
+    intermediate_surface = NULL;
     if (dst) {
 #ifdef SAVE_32BIT_BMP
         /* We can save alpha information in a 32-bit BMP */
-        if (saveme->format->BitsPerPixel >= 8 && (saveme->format->Amask ||
-                                                  saveme->map->info.flags & SDL_COPY_COLORKEY)) {
+        if (surface->format->BitsPerPixel >= 8 &&
+            (surface->format->Amask != 0 ||
+             surface->map->info.flags & SDL_COPY_COLORKEY)) {
             save32bit = SDL_TRUE;
         }
 #endif /* SAVE_32BIT_BMP */
 
-        if (saveme->format->palette && !save32bit) {
-            if (saveme->format->BitsPerPixel == 8) {
-                surface = saveme;
+        if (surface->format->palette != NULL && !save32bit) {
+            if (surface->format->BitsPerPixel == 8) {
+                intermediate_surface = surface;
             } else {
                 SDL_SetError("%d bpp BMP files not supported",
-                             saveme->format->BitsPerPixel);
+                             surface->format->BitsPerPixel);
             }
-        } else if ((saveme->format->BitsPerPixel == 24) && !save32bit &&
+        } else if ((surface->format->BitsPerPixel == 24) && !save32bit &&
 #if SDL_BYTEORDER == SDL_LIL_ENDIAN
-                   (saveme->format->Rmask == 0x00FF0000) &&
-                   (saveme->format->Gmask == 0x0000FF00) &&
-                   (saveme->format->Bmask == 0x000000FF)
+                   (surface->format->Rmask == 0x00FF0000) &&
+                   (surface->format->Gmask == 0x0000FF00) &&
+                   (surface->format->Bmask == 0x000000FF)
 #else
-                   (saveme->format->Rmask == 0x000000FF) &&
-                   (saveme->format->Gmask == 0x0000FF00) &&
-                   (saveme->format->Bmask == 0x00FF0000)
+                   (surface->format->Rmask == 0x000000FF) &&
+                   (surface->format->Gmask == 0x0000FF00) &&
+                   (surface->format->Bmask == 0x00FF0000)
 #endif
         ) {
-            surface = saveme;
+            intermediate_surface = surface;
         } else {
             SDL_PixelFormat format;
 
@@ -712,8 +713,8 @@ int SDL_SaveBMP_RW(SDL_Surface *saveme, SDL_RWops *dst, int freedst)
         saveLegacyBMP = SDL_GetHintBoolean(SDL_HINT_BMP_SAVE_LEGACY_FORMAT, SDL_FALSE);
     }
 
-    if (surface && (SDL_LockSurface(surface) == 0)) {
-        const int bw = surface->w * surface->format->BytesPerPixel;
+    if (intermediate_surface && (SDL_LockSurface(intermediate_surface) == 0)) {
+        const int bw = intermediate_surface->w * intermediate_surface->format->BytesPerPixel;
 
         /* Set the BMP file header values */
         bfSize = 0; /* We'll write this when we're done */
@@ -732,16 +733,16 @@ int SDL_SaveBMP_RW(SDL_Surface *saveme, SDL_RWops *dst, int freedst)
 
         /* Set the BMP info values */
         biSize = 40;
-        biWidth = surface->w;
-        biHeight = surface->h;
+        biWidth = intermediate_surface->w;
+        biHeight = intermediate_surface->h;
         biPlanes = 1;
-        biBitCount = surface->format->BitsPerPixel;
+        biBitCount = intermediate_surface->format->BitsPerPixel;
         biCompression = BI_RGB;
-        biSizeImage = surface->h * surface->pitch;
+        biSizeImage = intermediate_surface->h * intermediate_surface->pitch;
         biXPelsPerMeter = 0;
         biYPelsPerMeter = 0;
-        if (surface->format->palette) {
-            biClrUsed = surface->format->palette->ncolors;
+        if (intermediate_surface->format->palette) {
+            biClrUsed = intermediate_surface->format->palette->ncolors;
         } else {
             biClrUsed = 0;
         }
@@ -791,12 +792,12 @@ int SDL_SaveBMP_RW(SDL_Surface *saveme, SDL_RWops *dst, int freedst)
         }
 
         /* Write the palette (in BGR color order) */
-        if (surface->format->palette) {
+        if (intermediate_surface->format->palette) {
             SDL_Color *colors;
             int ncolors;
 
-            colors = surface->format->palette->colors;
-            ncolors = surface->format->palette->ncolors;
+            colors = intermediate_surface->format->palette->colors;
+            ncolors = intermediate_surface->format->palette->ncolors;
             for (i = 0; i < ncolors; ++i) {
                 SDL_RWwrite(dst, &colors[i].b, 1, 1);
                 SDL_RWwrite(dst, &colors[i].g, 1, 1);
@@ -816,10 +817,10 @@ int SDL_SaveBMP_RW(SDL_Surface *saveme, SDL_RWops *dst, int freedst)
         }
 
         /* Write the bitmap image upside down */
-        bits = (Uint8 *)surface->pixels + (surface->h * surface->pitch);
+        bits = (Uint8 *)intermediate_surface->pixels + (intermediate_surface->h * intermediate_surface->pitch);
         pad = ((bw % 4) ? (4 - (bw % 4)) : 0);
-        while (bits > (Uint8 *)surface->pixels) {
-            bits -= surface->pitch;
+        while (bits > (Uint8 *)intermediate_surface->pixels) {
+            bits -= intermediate_surface->pitch;
             if (SDL_RWwrite(dst, bits, 1, bw) != bw) {
                 SDL_Error(SDL_EFWRITE);
                 break;
@@ -843,9 +844,9 @@ int SDL_SaveBMP_RW(SDL_Surface *saveme, SDL_RWops *dst, int freedst)
         }
 
         /* Close it up.. */
-        SDL_UnlockSurface(surface);
-        if (surface != saveme) {
-            SDL_FreeSurface(surface);
+        SDL_UnlockSurface(intermediate_surface);
+        if (intermediate_surface != surface) {
+            SDL_FreeSurface(intermediate_surface);
         }
     }
 
diff --git a/src/video/SDL_egl.c b/src/video/SDL_egl.c
index 034e0c453..f7fcd3445 100644
--- a/src/video/SDL_egl.c
+++ b/src/video/SDL_egl.c
@@ -162,7 +162,7 @@ int SDL_EGL_SetErrorEx(const char *message, const char *eglFunctionName, EGLint
     char altErrorText[32];
     if (errorText[0] == '\0') {
         /* An unknown-to-SDL error code was reported.  Report its hexadecimal value, instead of its name. */
-        SDL_snprintf(altErrorText, SDL_arraysize(altErrorText), "0x%x", (unsigned int)eglErrorCode);
+        (void)SDL_snprintf(altErrorText, SDL_arraysize(altErrorText), "0x%x", (unsigned int)eglErrorCode);
         errorText = altErrorText;
     }
     return SDL_SetError("%s (call to %s failed, reporting an error of %s)", message, eglFunctionName, errorText);
diff --git a/src/video/SDL_fillrect.c b/src/video/SDL_fillrect.c
index 9a6620192..e3d2be526 100644
--- a/src/video/SDL_fillrect.c
+++ b/src/video/SDL_fillrect.c
@@ -333,7 +333,7 @@ int SDL_FillRects(SDL_Surface *dst, const SDL_Rect *rects, int count,
             if (r->x == 0 && r->y == 0 && r->w == dst->w && r->h == dst->h) {
                 if (dst->format->BitsPerPixel == 4) {
                     Uint8 b = (((Uint8)color << 4) | (Uint8)color);
-                    SDL_memset(dst->pixels, b, dst->h * dst->pitch);
+                    SDL_memset(dst->pixels, b, (size_t)dst->h * dst->pitch);
                     return 1;
                 }
             }
diff --git a/src/video/SDL_pixels.c b/src/video/SDL_pixels.c
index 7cffbc140..d325c0b50 100644
--- a/src/video/SDL_pixels.c
+++ b/src/video/SDL_pixels.c
@@ -569,8 +569,9 @@ int SDL_InitFormat(SDL_PixelFormat *format, Uint32 pixel_format)
         for (mask = Rmask; !(mask & 0x01); mask >>= 1) {
             ++format->Rshift;
         }
-        for (; (mask & 0x01); mask >>= 1)
+        for (; (mask & 0x01); mask >>= 1) {
             --format->Rloss;
+        }
     }
 
     format->Gmask = Gmask;
@@ -580,8 +581,9 @@ int SDL_InitFormat(SDL_PixelFormat *format, Uint32 pixel_format)
         for (mask = Gmask; !(mask & 0x01); mask >>= 1) {
             ++format->Gshift;
         }
-        for (; (mask & 0x01); mask >>= 1)
+        for (; (mask & 0x01); mask >>= 1) {
             --format->Gloss;
+        }
     }
 
     format->Bmask = Bmask;
@@ -591,8 +593,9 @@ int SDL_InitFormat(SDL_PixelFormat *format, Uint32 pixel_format)
         for (mask = Bmask; !(mask & 0x01); mask >>= 1) {
             ++format->Bshift;
         }
-        for (; (mask & 0x01); mask >>= 1)
+        for (; (mask & 0x01); mask >>= 1) {
             --format->Bloss;
+        }
     }
 
     format->Amask = Amask;
@@ -602,8 +605,9 @@ int SDL_InitFormat(SDL_PixelFormat *format, Uint32 pixel_format)
         for (mask = Amask; !(mask & 0x01); mask >>= 1) {
             ++format->Ashift;
         }
-        for (; (mask & 0x01); mask >>= 1)
+        for (; (mask & 0x01); mask >>= 1) {
             --format->Aloss;
+        }
     }
 
     format->palette = NULL;
diff --git a/src/video/SDL_shape.c b/src/video/SDL_shape.c
index 2cba72df2..a495ade93 100644
--- a/src/video/SDL_shape.c
+++ b/src/video/SDL_shape.c
@@ -50,17 +50,17 @@ SDL_CreateShapedWindow(const char *title, unsigned int x, unsigned int y, unsign
             SDL_DestroyWindow(result);
             return NULL;
         }
-    } else
-        return NULL;
+    }
+    return NULL;
 }
 
 SDL_bool
 SDL_IsShapedWindow(const SDL_Window *window)
 {
-    if (window == NULL)
+    if (window == NULL) {
         return SDL_FALSE;
-    else
-        return (SDL_bool)(window->shaper != NULL);
+    }
+    return (SDL_bool)(window->shaper != NULL);
 }
 
 /* REQUIRES that bitmap point to a w-by-h bitmap with ppb pixels-per-byte. */
@@ -71,7 +71,7 @@ void SDL_CalculateShapeBitmap(SDL_WindowShapeMode mode, SDL_Surface *shape, Uint
     Uint8 r = 0, g = 0, b = 0, alpha = 0;
     Uint8 *pixel = NULL;
     Uint32 pixel_value = 0, mask_value = 0;
-    int bytes_per_scanline = (shape->w + (ppb - 1)) / ppb;
+    size_t bytes_per_scanline = (size_t)(shape->w + (ppb - 1)) / ppb;
     Uint8 *bitmap_scanline;
     SDL_Color key;
 
@@ -241,8 +241,9 @@ void SDL_TraverseShapeTree(SDL_ShapeTree *tree, SDL_TraversalFunction function,
         SDL_TraverseShapeTree((SDL_ShapeTree *)tree->data.children.upright, function, closure);
         SDL_TraverseShapeTree((SDL_ShapeTree *)tree->data.children.downleft, function, closure);
         SDL_TraverseShapeTree((SDL_ShapeTree *)tree->data.children.downright, function, closure);
-    } else
+    } else {
         function(tree, closure);
+    }
 }
 
 void SDL_FreeShapeTree(SDL_ShapeTree **shape_tree)
@@ -324,17 +325,15 @@ int SDL_GetShapedWindowMode(SDL_Window *window, SDL_WindowShapeMode *shape_mode)
 {
     if (window != NULL && SDL_IsShapedWindow(window)) {
         if (shape_mode == NULL) {
-            if (SDL_WindowHasAShape(window))
-                /* The window given has a shape. */
-                return 0;
-            else
-                /* The window given is shapeable but lacks a shape. */
-                return SDL_WINDOW_LACKS_SHAPE;
+            if (SDL_WindowHasAShape(window)) {
+                return 0; /* The window given has a shape. */
+            } else {
+                return SDL_WINDOW_LACKS_SHAPE; /* The window given is shapeable but lacks a shape. */
+            }
         } else {
             *shape_mode = window->shaper->mode;
             return 0;
         }
-    } else
-        /* The window given is not a valid shapeable window. */
-        return SDL_NONSHAPEABLE_WINDOW;
+    }
+    return SDL_NONSHAPEABLE_WINDOW; /* The window given is not a valid shapeable window. */
 }
diff --git a/src/video/SDL_video.c b/src/video/SDL_video.c
index 089b3e6a8..6590ddbfa 100644
--- a/src/video/SDL_video.c
+++ b/src/video/SDL_video.c
@@ -304,7 +304,7 @@ static int SDL_CreateWindowTexture(SDL_VideoDevice *_this, SDL_Window *window, U
                                       window->w, window->h);
     if (!data->texture) {
         /* codechecker_false_positive [Malloc] Static analyzer doesn't realize allocated `data` is saved to SDL_WINDOWTEXTUREDATA and not leaked here. */
-        return -1;
+        return -1; /* NOLINT(clang-analyzer-unix.Malloc) */
     }
 
     /* Create framebuffer data */
@@ -313,7 +313,7 @@ static int SDL_CreateWindowTexture(SDL_VideoDevice *_this, SDL_Window *window, U
 
     {
         /* Make static analysis happy about potential SDL_malloc(0) calls. */
-        const size_t allocsize = window->h * data->pitch;
+        const size_t allocsize = (size_t)window->h * data->pitch;
         data->pixels = SDL_malloc((allocsize > 0) ? allocsize : 1);
         if (!data->pixels) {
             return SDL_OutOfMemory();
@@ -1576,6 +1576,11 @@ SDL_CreateWindow(const char *title, int x, int y, int w, int h, Uint32 flags)
         if (SDL_Init(SDL_INIT_VIDEO) < 0) {
             return NULL;
         }
+
+        /* Make clang-tidy happy */
+        if (_this == NULL) {
+            return NULL;
+        }
     }
 
     /* ensure no more than one of these flags is set */
@@ -3997,7 +4002,7 @@ SDL_GL_CreateContext(SDL_Window *window)
     return ctx;
 }
 
-int SDL_GL_MakeCurrent(SDL_Window *window, SDL_GLContext ctx)
+int SDL_GL_MakeCurrent(SDL_Window *window, SDL_GLContext context)
 {
     int retval;
 
@@ -4006,12 +4011,12 @@ int SDL_GL_MakeCurrent(SDL_Window *window, SDL_GLContext ctx)
     }
 
     if (window == SDL_GL_GetCurrentWindow() &&
-        ctx == SDL_GL_GetCurrentContext()) {
+        context == SDL_GL_GetCurrentContext()) {
         /* We're already current. */
         return 0;
     }
 
-    if (!ctx) {
+    if (!context) {
         window = NULL;
     } else if (window) {
         CHECK_WINDOW_MAGIC(window, -1);
@@ -4023,12 +4028,12 @@ int SDL_GL_MakeCurrent(SDL_Window *window, SDL_GLContext ctx)
         return SDL_SetError("Use of OpenGL without a window is not supported on this platform");
     }
 
-    retval = _this->GL_MakeCurrent(_this, window, ctx);
+    retval = _this->GL_MakeCurrent(_this, window, context);
     if (retval == 0) {
         _this->current_glwin = window;
-        _this->current_glctx = ctx;
+        _this->current_glctx = context;
         SDL_TLSSet(_this->current_glwin_tls, window, NULL);
-        SDL_TLSSet(_this->current_glctx_tls, ctx, NULL);
+        SDL_TLSSet(_this->current_glctx_tls, context, NULL);
     }
     return retval;
 }
@@ -4570,7 +4575,7 @@ SDL_ShouldAllowTopmost(void)
     return SDL_GetHintBoolean(SDL_HINT_ALLOW_TOPMOST, SDL_TRUE);
 }
 
-int SDL_SetWindowHitTest(SDL_Window *window, SDL_HitTest callback, void *userdata)
+int SDL_SetWindowHitTest(SDL_Window *window, SDL_HitTest callback, void *callback_data)
 {
     CHECK_WINDOW_MAGIC(window, -1);
 
@@ -4581,7 +4586,7 @@ int SDL_SetWindowHitTest(SDL_Window *window, SDL_HitTest callback, void *userdat
     }
 
     window->hit_test = callback;
-    window->hit_test_data = userdata;
+    window->hit_test_data = callback_data;
 
     return 0;
 }
diff --git a/src/video/SDL_vulkan_utils.c b/src/video/SDL_vulkan_utils.c
index 257a3ca37..b07b248db 100644
--- a/src/video/SDL_vulkan_utils.c
+++ b/src/video/SDL_vulkan_utils.c
@@ -231,8 +231,8 @@ SDL_bool SDL_Vulkan_Display_CreateSurface(void *vkGetInstanceProcAddr_,
         SDL_SetError(VK_KHR_DISPLAY_EXTENSION_NAME " extension is not enabled in the Vulkan instance.");
         goto error;
     }
-
-    if ((chosenDisplayId = SDL_getenv("SDL_VULKAN_DISPLAY")) != NULL) {
+    chosenDisplayId = SDL_getenv("SDL_VULKAN_DISPLAY");
+    if (chosenDisplayId != NULL) {
         displayId = SDL_atoi(chosenDisplayId);
     }
 
diff --git a/src/video/SDL_yuv.c b/src/video/SDL_yuv.c
index 275674282..897d56642 100644
--- a/src/video/SDL_yuv.c
+++ b/src/video/SDL_yuv.c
@@ -465,7 +465,7 @@ int SDL_ConvertPixels_YUV_to_RGB(int width, int height,
         void *tmp;
         int tmp_pitch = (width * sizeof(Uint32));
 
-        tmp = SDL_malloc(tmp_pitch * height);
+        tmp = SDL_malloc((size_t)tmp_pitch * height);
         if (tmp == NULL) {
             return SDL_OutOfMemory();
         }
@@ -846,7 +846,7 @@ int SDL_ConvertPixels_RGB_to_YUV(int width, int height,
         void *tmp;
         int tmp_pitch = (width * sizeof(Uint32));
 
-        tmp = SDL_malloc(tmp_pitch * height);
+        tmp = SDL_malloc((size_t)tmp_pitch * height);
         if (tmp == NULL) {
             return SDL_OutOfMemory();
         }
@@ -995,11 +995,11 @@ static int SDL_ConvertPixels_PackUVPlanes_to_NV(int width, int height, const voi
 
     if (src == dst) {
         /* Need to make a copy of the buffer so we don't clobber it while converting */
-        tmp = (Uint8 *)SDL_malloc(2 * UVheight * srcUVPitch);
+        tmp = (Uint8 *)SDL_malloc((size_t)2 * UVheight * srcUVPitch);
         if (tmp == NULL) {
             return SDL_OutOfMemory();
         }
-        SDL_memcpy(tmp, src, 2 * UVheight * srcUVPitch);
+        SDL_memcpy(tmp, src, (size_t)2 * UVheight * srcUVPitch);
         src = tmp;
     }
 
@@ -1068,11 +1068,11 @@ static int SDL_ConvertPixels_SplitNV_to_UVPlanes(int width, int height, const vo
 
     if (src == dst) {
         /* Need to make a copy of the buffer so we don't clobber it while converting */
-        tmp = (Uint8 *)SDL_malloc(UVheight * srcUVPitch);
+        tmp = (Uint8 *)SDL_malloc((size_t)UVheight * srcUVPitch);
         if (tmp == NULL) {
             return SDL_OutOfMemory();
         }
-        SDL_memcpy(tmp, src, UVheight * srcUVPitch);
+        SDL_memcpy(tmp, src, (size_t)UVheight * srcUVPitch);
         src = tmp;
     }
 
diff --git a/src/video/android/SDL_androidmouse.c b/src/video/android/SDL_androidmouse.c
index fa80daa4a..61cd0db01 100644
--- a/src/video/android/SDL_androidmouse.c
+++ b/src/video/android/SDL_androidmouse.c
@@ -121,7 +121,7 @@ static SDL_Cursor *Android_CreateEmptyCursor()
     if (empty_cursor == NULL) {
         SDL_Surface *empty_surface = SDL_CreateRGBSurfaceWithFormat(0, 1, 1, 32, SDL_PIXELFORMAT_ARGB8888);
         if (empty_surface) {
-            SDL_memset(empty_surface->pixels, 0, empty_surface->h * empty_surface->pitch);
+            SDL_memset(empty_surface->pixels, 0, (size_t)empty_surface->h * empty_surface->pitch);
             empty_cursor = Android_CreateCursor(empty_surface, 0, 0);
             SDL_FreeSurface(empty_surface);
         }
diff --git a/src/video/cocoa/SDL_cocoaevents.m b/src/video/cocoa/SDL_cocoaevents.m
index ed2aaa6c6..9cdd01d76 100644
--- a/src/video/cocoa/SDL_cocoaevents.m
+++ b/src/video/cocoa/SDL_cocoaevents.m
@@ -48,6 +48,7 @@ static SDL_Window *FindSDLWindowForNSWindow(NSWindow *win)
             NSWindow *nswindow = ((__bridge SDL_WindowData *) sdlwindow->driverdata).nswindow;
             if (win == nswindow)
                 return sdlwindow;
+            }
         }
     }
 
@@ -192,8 +193,9 @@ static void Cocoa_DispatchEvent(NSEvent *theEvent)
     }
 
     /* Don't do anything if this was not an SDL window that was closed */
-    if (FindSDLWindowForNSWindow(win) == NULL)
+    if (FindSDLWindowForNSWindow(win) == NULL) {
         return;
+    }
 
     /* HACK: Make the next window in the z-order key when the key window is
      * closed. The custom event loop and/or windowing code we have seems to
@@ -391,7 +393,7 @@ CreateApplicationMenus(void)
     [appleMenu addItem:[NSMenuItem separatorItem]];
 
     serviceMenu = [[NSMenu alloc] initWithTitle:@""];
-    menuItem = (NSMenuItem *)[appleMenu addItemWithTitle:@"Services" action:nil keyEquivalent:@""];
+    menuItem = [appleMenu addItemWithTitle:@"Services" action:nil keyEquivalent:@""];
     [menuItem setSubmenu:serviceMenu];
 
     [NSApp setServicesMenu:serviceMenu];
diff --git a/src/video/cocoa/SDL_cocoakeyboard.m b/src/video/cocoa/SDL_cocoakeyboard.m
index 096b71a4c..34add44b5 100644
--- a/src/video/cocoa/SDL_cocoakeyboard.m
+++ b/src/video/cocoa/SDL_cocoakeyboard.m
@@ -221,8 +221,9 @@ HandleModifiers(_THIS, unsigned short scancode, unsigned int modifierFlags)
         {
             if (modifierFlags & modifiers[i])
                 SDL_SendKeyboardKey(SDL_PRESSED, code);
-            else
+            } else {
                 SDL_SendKeyboardKey(SDL_RELEASED, code);
+            }
         }
     }
 }
diff --git a/src/video/cocoa/SDL_cocoametalview.m b/src/video/cocoa/SDL_cocoametalview.m
index 7c424ba19..8fe008fe6 100644
--- a/src/video/cocoa/SDL_cocoametalview.m
+++ b/src/video/cocoa/SDL_cocoametalview.m
@@ -81,7 +81,8 @@ SDL_MetalViewEventWatch(void *userdata, SDL_Event *event)
                       highDPI:(BOOL)highDPI
                      windowID:(Uint32)windowID;
 {
-    if ((self = [super initWithFrame:frame])) {
+    self = [super initWithFrame:frame];
+    if (self != nil) {
         self.highDPI = highDPI;
         self.sdlWindowID = windowID;
         self.wantsLayer = YES;
diff --git a/src/video/dummy/SDL_nullframebuffer.c b/src/video/dummy/SDL_nullframebuffer.c
index d85924987..353a5921d 100644
--- a/src/video/dummy/SDL_nullframebuffer.c
+++ b/src/video/dummy/SDL_nullframebuffer.c
@@ -64,8 +64,8 @@ int SDL_DUMMY_UpdateWindowFramebuffer(_THIS, SDL_Window *window, const SDL_Rect
     /* Send the data to the display */
     if (SDL_getenv("SDL_VIDEO_DUMMY_SAVE_FRAMES")) {
         char file[128];
-        SDL_snprintf(file, sizeof(file), "SDL_window%" SDL_PRIu32 "-%8.8d.bmp",
-                     SDL_GetWindowID(window), ++frame_number);
+        (void)SDL_snprintf(file, sizeof file, "SDL_window%" SDL_PRIu32 "-%8.8d.bmp",
+                           SDL_GetWindowID(window), ++frame_number);
         SDL_SaveBMP(surface, file);
     }
     return 0;
diff --git a/src/video/kmsdrm/SDL_kmsdrmdyn.c b/src/video/kmsdrm/SDL_kmsdrmdyn.c
index 39fa2683d..1f03f65dd 100644
--- a/src/video/kmsdrm/SDL_kmsdrmdyn.c
+++ b/src/video/kmsdrm/SDL_kmsdrmdyn.c
@@ -38,9 +38,6 @@ typedef struct
     const char *libname;
 } kmsdrmdynlib;
 
-#ifndef SDL_VIDEO_DRIVER_KMSDRM_DYNAMIC
-#define SDL_VIDEO_DRIVER_KMSDRM_DYNAMIC NULL
-#endif
 #ifndef SDL_VIDEO_DRIVER_KMSDRM_DYNAMIC_GBM
 #define SDL_VIDEO_DRIVER_KMSDRM_DYNAMIC_GBM NULL
 #endif
diff --git a/src/video/kmsdrm/SDL_kmsdrmmouse.c b/src/video/kmsdrm/SDL_kmsdrmmouse.c
index d3f983ae3..2b5c54489 100644
--- a/src/video/kmsdrm/SDL_kmsdrmmouse.c
+++ b/src/video/kmsdrm/SDL_kmsdrmmouse.c
@@ -171,7 +171,7 @@ static int KMSDRM_DumpCursorToBO(SDL_VideoDisplay *display, SDL_Cursor *cursor)
     /* Copy from the cursor buffer to a buffer that we can dump to the GBM BO. */
     for (i = 0; i < curdata->h; i++) {
         src_row = &((uint8_t *)curdata->buffer)[i * curdata->w * 4];
-        SDL_memcpy(ready_buffer + (i * bo_stride), src_row, 4 * curdata->w);
+        SDL_memcpy(ready_buffer + (i * bo_stride), src_row, (size_t)4 * curdata->w);
     }
 
     /* Dump the cursor buffer to our GBM BO. */
@@ -261,7 +261,7 @@ static SDL_Cursor *KMSDRM_CreateCursor(SDL_Surface *surface, int hot_x, int hot_
     /* Configure the cursor buffer info.
        This buffer has the original size of the cursor surface we are given. */
     curdata->buffer_pitch = surface->w;
-    curdata->buffer_size = surface->w * surface->h * 4;
+    curdata->buffer_size = (size_t)surface->w * surface->h * 4;
     curdata->buffer = (uint32_t *)SDL_malloc(curdata->buffer_size);
 
     if (!curdata->buffer) {
diff --git a/src/video/kmsdrm/SDL_kmsdrmvideo.c b/src/video/kmsdrm/SDL_kmsdrmvideo.c
index da825315a..d98252f04 100644
--- a/src/video/kmsdrm/SDL_kmsdrmvideo.c
+++ b/src/video/kmsdrm/SDL_kmsdrmvideo.c
@@ -197,8 +197,8 @@ static int KMSDRM_Available(void)
 
     kmsdrm_dri_pathsize = SDL_strlen(kmsdrm_dri_path);
     kmsdrm_dri_devnamesize = SDL_strlen(kmsdrm_dri_devname);
-    SDL_snprintf(kmsdrm_dri_cardpath, sizeof(kmsdrm_dri_cardpath), "%s%s",
-                 kmsdrm_dri_path, kmsdrm_dri_devname);
+    (void)SDL_snprintf(kmsdrm_dri_cardpath, sizeof kmsdrm_dri_cardpath, "%s%s",
+                       kmsdrm_dri_path, kmsdrm_dri_devname);
 
     ret = get_driindex();
     if (ret >= 0) {
@@ -878,7 +878,7 @@ cleanup:
             SDL_free(dispdata);
         }
     }
-}
+} /* NOLINT(clang-analyzer-unix.Malloc): If no error `dispdata` is saved in the display */
 
 /* Initializes the list of SDL displays: we build a new display for each
    connecter connector we find.
@@ -897,8 +897,8 @@ static int KMSDRM_InitDisplays(_THIS)
     int i;
 
     /* Open /dev/dri/cardNN (/dev/drmN if on OpenBSD version less than 6.9) */
-    SDL_snprintf(viddata->devpath, sizeof(viddata->devpath), "%s%d",
-                 kmsdrm_dri_cardpath, viddata->devindex);
+    (void)SDL_snprintf(viddata->devpath, sizeof viddata->devpath, "%s%d",
+                       kmsdrm_dri_cardpath, viddata->devindex);
 
     SDL_LogDebug(SDL_LOG_CATEGORY_VIDEO, "Opening device %s", viddata->devpath);
     viddata->drm_fd = open(viddata->devpath, O_RDWR | O_CLOEXEC);
@@ -1441,7 +1441,8 @@ int KMSDRM_CreateWindow(_THIS, SDL_Window *window)
             /* Reopen FD, create gbm dev, setup display plane, etc,.
                but only when we come here for the first time,
                and only if it's not a VK window. */
-            if ((ret = KMSDRM_GBMInit(_this, dispdata))) {
+            ret = KMSDRM_GBMInit(_this, dispdata);
+            if (ret != 0) {
                 return SDL_SetError("Can't init GBM on window creation.");
             }
         }
@@ -1490,7 +1491,8 @@ int KMSDRM_CreateWindow(_THIS, SDL_Window *window)
 
         /* Create the window surfaces with the size we have just chosen.
            Needs the window diverdata in place. */
-        if ((ret = KMSDRM_CreateSurfaces(_this, window))) {
+        ret = KMSDRM_CreateSurfaces(_this, window);
+        if (ret == 0) {
             return SDL_SetError("Can't window GBM/EGL surfaces on window creation.");
         }
     } /* NON-Vulkan block ends. */
diff --git a/src/video/offscreen/SDL_offscreenframebuffer.c b/src/video/offscreen/SDL_offscreenframebuffer.c
index b6dc22452..4b62a50d6 100644
--- a/src/video/offscreen/SDL_offscreenframebuffer.c
+++ b/src/video/offscreen/SDL_offscreenframebuffer.c
@@ -64,8 +64,8 @@ int SDL_OFFSCREEN_UpdateWindowFramebuffer(_THIS, SDL_Window *window, const SDL_R
     /* Send the data to the display */
     if (SDL_getenv("SDL_VIDEO_OFFSCREEN_SAVE_FRAMES")) {
         char file[128];
-        SDL_snprintf(file, sizeof(file), "SDL_window%d-%8.8d.bmp",
-                     (int)SDL_GetWindowID(window), ++frame_number);
+        (void)SDL_snprintf(file, sizeof file, "SDL_window%" SDL_PRIu32 "-%8.8d.bmp",
+                           SDL_GetWindowID(window), ++frame_number);
         SDL_SaveBMP(surface, file);
     }
     return 0;
diff --git a/src/video/wayland/SDL_waylanddatamanager.c b/src/video/wayland/SDL_waylanddatamanager.c
index 9353caa53..bbcec9ac4 100644
--- a/src/video/wayland/SDL_waylanddatamanager.c
+++ b/src/video/wayland/SDL_waylanddatamanager.c
@@ -256,9 +256,11 @@ Wayland_source_send(SDL_MimeDataList *mime_data, const char *mime_type, int fd)
         status = SDL_SetError("Invalid mime type");
         close(fd);
     } else {
-        while (write_pipe(fd, mime_data->data, mime_data->length,
-                          &written_bytes) > 0)
-            ;
+        while (write_pipe(fd,
+                          mime_data->data,
+                          mime_data->length,
+                          &written_bytes) > 0) {
+        }
         close(fd);
         status = written_bytes;
     }
@@ -422,10 +424,9 @@ void Wayland_primary_selection_source_destroy(SDL_WaylandPrimarySelectionSource
     }
 }
 
-void *
-Wayland_data_offer_receive(SDL_WaylandDataOffer *offer,
-                           size_t *length, const char *mime_type,
-                           SDL_bool null_terminate)
+void *Wayland_data_offer_receive(SDL_WaylandDataOffer *offer,
+                                 size_t *length, const char *mime_type,
+                                 SDL_bool null_terminate)
 {
     SDL_WaylandDataDevice *data_device = NULL;
 
@@ -435,7 +436,10 @@ Wayland_data_offer_receive(SDL_WaylandDataOffer *offer,
 
     if (offer == NULL) {
         SDL_SetError("Invalid data offer");
-    } else if ((data_device = offer->data_device) == NULL) {
+        return NULL;
+    }
+    data_device = offer->data_device;
+    if (data_device == NULL) {
         SDL_SetError("Data device not initialized");
     } else if (pipe2(pipefd, O_CLOEXEC | O_NONBLOCK) == -1) {
         SDL_SetError("Could not read pipe");
@@ -447,8 +451,8 @@ Wayland_data_offer_receive(SDL_WaylandDataOffer *offer,
 
         close(pipefd[1]);
 
-        while (read_pipe(pipefd[0], &buffer, length, null_terminate) > 0)
-            ;
+        while (read_pipe(pipefd[0], &buffer, length, null_terminate) > 0) {
+        }
         close(pipefd[0]);
     }
     return buffer;
@@ -467,7 +471,10 @@ Wayland_primary_selection_offer_receive(SDL_WaylandPrimarySelectionOffer *offer,
 
     if (offer == NULL) {
         SDL_SetError("Invalid data offer");
-    } else if ((primary_selection_device = offer->primary_selection_device) == NULL) {
+        return NULL;
+    }
+    primary_selection_device = offer->primary_selection_device;
+    if (primary_selection_device == NULL) {
         SDL_SetError("Primary selection device not initialized");
     } else if (pipe2(pipefd, O_CLOEXEC | O_NONBLOCK) == -1) {
         SDL_SetError("Could not read pipe");
@@ -479,8 +486,8 @@ Wayland_primary_selection_offer_receive(SDL_WaylandPrimarySelectionOffer *offer,
 
         close(pipefd[1]);
 
-        while (read_pipe(pipefd[0], &buffer, length, null_terminate) > 0)
-            ;
+        while (read_pipe(pipefd[0], &buffer, length, null_terminate) > 0) {
+        }
         close(pipefd[0]);
     }
     return buffer;
diff --git a/src/video/wayland/SDL_waylandevents.c b/src/video/wayland/SDL_waylandevents.c
index da5116de9..827d8681a 100644
--- a/src/video/wayland/SDL_waylandevents.c
+++ b/src/video/wayland/SDL_waylandevents.c
@@ -723,10 +723,11 @@ static void pointer_handle_axis(void *data, struct wl_pointer *pointer,
 {
     struct SDL_WaylandInput *input = data;
 
-    if (wl_seat_get_version(input->seat) >= 5)
+    if (wl_seat_get_version(input->seat) >= 5) {
         pointer_handle_axis_common(input, AXIS_EVENT_CONTINUOUS, axis, value);
-    else
+    } else {
         pointer_handle_axis_common_v1(input, time, axis, value);
+    }
 }
 
 static void pointer_handle_frame(void *data, struct wl_pointer *pointer)
@@ -1007,9 +1008,12 @@ static void keyboard_handle_keymap(void *data, struct wl_keyboard *keyboard,
      */
 
     /* Look up the preferred locale, falling back to "C" as default */
-    if (!(locale = SDL_getenv("LC_ALL"))) {
-        if (!(locale = SDL_getenv("LC_CTYPE"))) {
-            if (!(locale = SDL_getenv("LANG"))) {
+    locale = SDL_getenv("LC_ALL");
+    if (locale == NULL) {
+        locale = SDL_getenv("LC_CTYPE");
+        if (locale == NULL) {
+            locale = SDL_getenv("LANG");
+            if (locale == NULL) {
                 locale = "C";
             }
         }
diff --git a/src/video/wayland/SDL_waylandmessagebox.c b/src/video/wayland/SDL_waylandmessagebox.c
index b4a15473e..477d3e696 100644
--- a/src/video/wayland/SDL_waylandmessagebox.c
+++ b/src/video/wayland/SDL_waylandmessagebox.c
@@ -152,7 +152,7 @@ int Wayland_ShowMessageBox(const SDL_MessageBoxData *messageboxdata, int *button
                         return SDL_SetError("Couldn't open pipe for reading: %s", strerror(errno));
                     }
                     tmp = fgets(output, output_len + 1, outputfp);
-                    fclose(outputfp);
+                    (void)fclose(outputfp);
 
                     if ((tmp == NULL) || (*tmp == '\0') || (*tmp == '\n')) {
                         SDL_free(output);
diff --git a/src/video/wayland/SDL_waylandvideo.c b/src/video/wayland/SDL_waylandvideo.c
index 76c3e4d4a..75ee711fb 100644
--- a/src/video/wayland/SDL_waylandvideo.c
+++ b/src/video/wayland/SDL_waylandvideo.c
@@ -107,10 +107,9 @@ static char *get_classname()
     /* Next look at the application's executable name */
 #if defined(__LINUX__) || defined(__FREEBSD__)
 #if defined(__LINUX__)
-    SDL_snprintf(procfile, SDL_arraysize(procfile), "/proc/%d/exe", getpid());
+    (void)SDL_snprintf(procfile, SDL_arraysize(procfile), "/proc/%d/exe", getpid());
 #elif defined(__FREEBSD__)
-    SDL_snprintf(procfile, SDL_arraysize(procfile), "/proc/%d/file",
-                 getpid());
+    (void)SDL_snprintf(procfile, SDL_arraysize(procfile), "/proc/%d/file", getpid());
 #else
 #error Where can we find the executable name?
 #endif
@@ -695,10 +694,10 @@ static void Wayland_add_display(SDL_VideoData *d, uint32_t id)
 
     /* Keep a list of outputs for deferred xdg-output initialization. */
     if (d->output_list != NULL) {
-        SDL_WaylandOutputData *node = (SDL_WaylandOutputData *)d->output_list;
+        SDL_WaylandOutputData *node = d->output_list;
 
         while (node->next != NULL) {
-            node = (SDL_WaylandOutputData *)node->next;
+            node = node->next;
         }
 
         node->next = (struct SDL_WaylandOutputData *)data;
diff --git a/src/video/windows/SDL_windowsevents.c b/src/video/windows/SDL_windowsevents.c
index 2cb3d4b90..269046e26 100644
--- a/src/video/windows/SDL_windowsevents.c
+++ b/src/video/windows/SDL_windowsevents.c
@@ -882,8 +882,8 @@ WIN_WindowProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
                     data->last_raw_mouse_position.x = x;
                     data->last_raw_mouse_position.y = y;
                 }
-                relX = (int)(x - data->last_raw_mouse_position.x);
-                relY = (int)(y - data->last_raw_mouse_position.y);
+                relX = x - data->last_raw_mouse_position.x;
+                relY = y - data->last_raw_mouse_position.y;
 
                 if (remote_desktop) {
                     if (!data->in_title_click && !data->focus_click_pending) {
@@ -938,10 +938,11 @@ WIN_WindowProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
     {
         short amount = GET_WHEEL_DELTA_WPARAM(wParam);
         float fAmount = (float)amount / WHEEL_DELTA;
-        if (msg == WM_MOUSEWHEEL)
+        if (msg == WM_MOUSEWHEEL) {
             SDL_SendMouseWheel(data->window, 0, 0.0f, fAmount, SDL_MOUSEWHEEL_NORMAL);
-        else
+        } else {
             SDL_SendMouseWheel(data->window, 0, fAmount, 0.0f, SDL_MOUSEWHEEL_NORMAL);
+        }
     } break;
 
     case WM_MOUSELEAVE:
@@ -1172,11 +1173,11 @@ WIN_WindowProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
                 info->ptMaxPosition.x = SDL_min(0, ((screenW - w) / 2));
                 info->ptMaxPosition.y = SDL_min(0, ((screenH - h) / 2));
             }
-            info->ptMinTrackSize.x = w + min_w;
-            info->ptMinTrackSize.y = h + min_h;
+            info->ptMinTrackSize.x = (LONG)w + min_w;
+            info->ptMinTrackSize.y = (LONG)h + min_h;
             if (constrain_max_size) {
-                info->ptMaxTrackSize.x = w + max_w;
-                info->ptMaxTrackSize.y = h + max_h;
+                info->ptMaxTrackSize.x = (LONG)w + max_w;
+                info->ptMaxTrackSize.y = (LONG)h + max_h;
             }
         } else {
             info->ptMaxSize.x = w;
diff --git a/src/video/windows/SDL_windowsframebuffer.c b/src/video/windows/SDL_windowsframebuffer.c
index 5b792ecac..d401b9db4 100644
--- a/src/video/windows/SDL_windowsframebuffer.c
+++ b/src/video/windows/SDL_windowsframebuffer.c
@@ -81,7 +81,7 @@ int WIN_CreateWindowFramebuffer(_THIS, SDL_Window *window, Uint32 *format, void
     *pitch = (((window->w * SDL_BYTESPERPIXEL(*format)) + 3) & ~3);
     info->bmiHeader.biWidth = window->w;
     info->bmiHeader.biHeight = -window->h; /* negative for topdown bitmap */
-    info->bmiHeader.biSizeImage = window->h * (*pitch);
+    info->bmiHeader.biSizeImage = (DWORD)window->h * (*pitch);
 
     data->mdc = CreateCompatibleDC(data->hdc);
     data->hbm = CreateDIBSection(data->hdc, info, DIB_RGB_COLORS, pixels, NULL, 0);
diff --git a/src/video/windows/SDL_windowskeyboard.c b/src/video/windows/SDL_windowskeyboard.c
index 425d6c546..6253ef44d 100644
--- a/src/video/windows/SDL_windowskeyboard.c
+++ b/src/video/windows/SDL_windowskeyboard.c
@@ -36,7 +36,6 @@ static void IME_Init(SDL_VideoData *videodata, HWND hwnd);
 static void IME_Enable(SDL_VideoData *videodata, HWND hwnd);
 static void IME_Disable(SDL_VideoData *videodata, HWND hwnd);
 static void IME_Quit(SDL_VideoData *videodata);
-static void IME_ClearComposition(SDL_VideoData *videodata);
 static SDL_bool IME_IsTextInputShown(SDL_VideoData *videodata);
 #endif /* !SDL_DISABLE_WINDOWS_IME */
 
@@ -259,9 +258,9 @@ void WIN_SetTextInputRect(_THIS, const SDL_Rect *rect)
         cof.ptCurrentPos.x = videodata->ime_rect.x;
         cof.ptCurrentPos.y = videodata->ime_rect.y;
         cof.rcArea.left = videodata->ime_rect.x;
-        cof.rcArea.right = videodata->ime_rect.x + videodata->ime_rect.w;
+        cof.rcArea.right = (LONG)videodata->ime_rect.x + videodata->ime_rect.w;
         cof.rcArea.top = videodata->ime_rect.y;
-        cof.rcArea.bottom = videodata->ime_rect.y + videodata->ime_rect.h;
+        cof.rcArea.bottom = (LONG)videodata->ime_rect.y + videodata->ime_rect.h;
         ImmSetCompositionWindow(himc, &cof);
 
         caf.dwIndex = 0;
@@ -269,9 +268,9 @@ void WIN_SetTextInputRect(_THIS, const SDL_Rect *rect)
         caf.ptCurrentPos.x = videodata->ime_rect.x;
         caf.ptCurrentPos.y = videodata->ime_rect.y;
         caf.rcArea.left = videodata->ime_rect.x;
-        caf.rcArea.right = videodata->ime_rect.x + videodata->ime_rect.w;
+        caf.rcArea.right = (LONG)videodata->ime_rect.x + videodata->ime_rect.w;
         caf.rcArea.top = videodata->ime_rect.y;
-        caf.rcArea.bottom = videodata->ime_rect.y + videodata->ime_rect.h;
+        caf.rcArea.bottom = (LONG)videodata->ime_rect.y + videodata->ime_rect.h;
         ImmSetCandidateWindow(himc, &caf);
 
         ImmReleaseContext(videodata->ime_hwnd_current, himc);
@@ -380,8 +379,9 @@ static void IME_Init(SDL_VideoData *videodata, HWND hwnd)
 {
     HRESULT hResult = S_OK;
 
-    if (videodata->ime_initialized)
+    if (videodata->ime_initialized) {
         return;
+    }
 
     videodata->ime_hwnd_main = hwnd;
     if (SUCCEEDED(WIN_CoInitialize())) {
@@ -418,10 +418,11 @@ static void IME_Init(SDL_VideoData *videodata, HWND hwnd)
     videodata->ime_available = SDL_TRUE;
     IME_UpdateInputLocale(videodata);
     IME_SetupAPI(videodata);
-    if (WIN_ShouldShowNativeUI())
+    if (WIN_ShouldShowNativeUI()) {
         videodata->ime_uiless = SDL_FALSE;
-    else
+    } else {
         videodata->ime_uiless = UILess_SetupSinks(videodata);
+    }
     IME_UpdateInputLocale(videodata);
     IME_Disable(videodata, hwnd);
 }
@@ -550,7 +551,7 @@ static void IME_GetReadingString(SDL_VideoData *videodata, HWND hwnd)
                 break;
             }
 
-            p = *(LPBYTE *)((LPBYTE)p + 1 * 4 + 5 * 4);
+            p = *(LPBYTE *)(p + 1 * 4 + 5 * 4);
             if (!p) {
                 break;
             }
@@ -1014,8 +1015,9 @@ IME_HandleMessage(HWND hwnd, UINT msg, WPARAM wParam, LPARAM *lParam, SDL_VideoD
         if (wParam == VK_PROCESSKEY) {
             videodata->ime_uicontext = 1;
             trap = SDL_TRUE;
-        } else
+        } else {
             videodata->ime_uicontext = 0;
+        }
         break;
     case WM_INPUTLANGCHANGE:
         IME_InputLangChanged(videodata);
@@ -1149,10 +1151,11 @@ static void UILess_GetCandidateList(SDL_VideoData *videodata, ITfCandidateListUI
         if (idxlist) {
             pcandlist->lpVtbl->GetPageIndex(pcandlist, idxlist, pgcount, &pgcount);
             pgstart = idxlist[page];
-            if (page < pgcount - 1)
+            if (page < pgcount - 1) {
                 pgsize = SDL_min(count, idxlist[page + 1]) - pgstart;
-            else
+            } else {
                 pgsize = count - pgstart;
+            }
 
             SDL_free(idxlist);
         }
@@ -1444,7 +1447,7 @@ static void *StartDrawToBitmap(HDC hdc, HBITMAP *hhbm, int width, int height)
         SDL_zero(info);
         infoHeader->biSize = sizeof(BITMAPINFOHEADER);
         infoHeader->biWidth = width;
-        infoHeader->biHeight = -1 * SDL_abs(height);
+        infoHeader->biHeight = (LONG)-1 * SDL_abs(height);
         infoHeader->biPlanes = 1;
         infoHeader->biBitCount = 32;
         infoHeader->biCompression = BI_RGB;
@@ -1623,7 +1626,7 @@ static void IME_RenderCandidateList(SDL_VideoData *videodata, HDC hdc)
             (candcount * maxcandsize.cy);
     } else {
         size.cx =
-            (listborder * 2) +
+            (LONG)(listborder * 2) +
             (listpadding * 2) +
             ((candcount + 1) * candmargin) +
             (candcount * candborder * 2) +
diff --git a/src/video/windows/SDL_windowsmessagebox.c b/src/video/windows/SDL_windowsmessagebox.c
index 7c7679161..8e91c51f9 100644
--- a/src/video/windows/SDL_windowsmessagebox.c
+++ b/src/video/windows/SDL_windowsmessagebox.c
@@ -804,13 +804,13 @@ static int WIN_ShowOldMessageBox(const SDL_MessageBoxData *messageboxdata, int *
     }
 
     /* Ensure the size is wide enough for all of the buttons. */
-    if (Size.cx < messageboxdata->numbuttons * (ButtonWidth + ButtonMargin) + ButtonMargin) {
-        Size.cx = messageboxdata->numbuttons * (ButtonWidth + ButtonMargin) + ButtonMargin;
+    if (Size.cx < (LONG)messageboxdata->numbuttons * (ButtonWidth + ButtonMargin) + ButtonMargin) {
+        Size.cx = (LONG)messageboxdata->numbuttons * (ButtonWidth + ButtonMargin) + ButtonMargin;
     }
 
     /* Reset the height to the icon size if it is actually bigger than the text. */
-    if (icon && Size.cy < IconMargin * 2 + IconHeight) {
-        Size.cy = IconMargin * 2 + IconHeight;
+    if (icon && Size.cy < (LONG)IconMargin * 2 + IconHeight) {
+        Size.cy = (LONG)IconMargin * 2 + IconHeight;
     }
 
     /* Add vertical space for the buttons and border. */
diff --git a/src/video/windows/SDL_windowsmodes.c b/src/video/windows/SDL_windowsmodes.c
index 0e087fa7d..825023281 100644
--- a/src/video/windows/SDL_windowsmodes.c
+++ b/src/video/windows/SDL_windowsmodes.c
@@ -42,6 +42,7 @@ static void WIN_UpdateDisplayMode(_THIS, LPCWSTR deviceName, DWORD index, SDL_Di
         (DM_BITSPERPEL | DM_PELSWIDTH | DM_PELSHEIGHT | DM_DISPLAYFREQUENCY |
          DM_DISPLAYFLAGS);
 
+    /* NOLINTNEXTLINE(bugprone-assignment-in-if-condition): No simple way to extract the assignment */
     if (index == ENUM_CURRENT_SETTINGS && (hdc = CreateDC(deviceName, NULL, NULL, NULL)) != NULL) {
         char bmi_data[sizeof(BITMAPINFOHEADER) + 256 * sizeof(RGBQUAD)];
         LPBITMAPINFO bmi;
diff --git a/src/video/windows/SDL_windowsmouse.c b/src/video/windows/SDL_windowsmouse.c
index 45997148b..4c6f75197 100644
--- a/src/video/windows/SDL_windowsmouse.c
+++ b/src/video/windows/SDL_windowsmouse.c
@@ -134,7 +134,7 @@ static SDL_Cursor *WIN_CreateCursor(SDL_Surface *surface, int hot_x, int hot_y)
 
     SDL_assert(surface->format->format == SDL_PIXELFORMAT_ARGB8888);
     SDL_assert(surface->pitch == surface->w * 4);
-    SDL_memcpy(pixels, surface->pixels, surface->h * surface->pitch);
+    SDL_memcpy(pixels, surface->pixels, (size_t)surface->h * surface->pitch);
 
     hicon = CreateIconIndirect(&ii);
 
@@ -391,7 +391,7 @@ void WIN_QuitMouse(_THIS)
  * https://superuser.com/questions/278362/windows-mouse-acceleration-curve-smoothmousexcurve-and-smoothmouseycurve
  * http://www.esreality.com/?a=post&id=1846538/
  */
-static SDL_bool LoadFiveFixedPointFloats(BYTE *bytes, float *values)
+static SDL_bool LoadFiveFixedPointFloats(const BYTE *bytes, float *values)
 {
     int i;
 
diff --git a/src/video/windows/SDL_windowsshape.c b/src/video/windows/SDL_windowsshape.c
index 5a51664a0..da47970cf 100644
--- a/src/video/windows/SDL_windowsshape.c
+++ b/src/video/windows/SDL_windowsshape.c
@@ -67,8 +67,9 @@ static void CombineRectRegions(SDL_ShapeTree *node, void *closure)
         if (mask_region != NULL) {
             CombineRgn(mask_region, mask_region, temp_region, RGN_OR);
             DeleteObject(temp_region);
-        } else
+        } else {
             *((HRGN *)closure) = temp_region;
+        }
     }
 }
 
diff --git a/src/video/windows/SDL_windowsvulkan.c b/src/video/windows/SDL_windowsvulkan.c
index bc013835a..b536abee2 100644
--- a/src/video/windows/SDL_windowsvulkan.c
+++ b/src/video/windows/SDL_windowsvulkan.c
@@ -137,7 +137,7 @@ SDL_bool WIN_Vulkan_CreateSurface(_THIS,
         (PFN_vkGetInstanceProcAddr)_this->vulkan_config.vkGetInstanceProcAddr;
     PFN_vkCreateWin32SurfaceKHR vkCreateWin32SurfaceKHR =
         (PFN_vkCreateWin32SurfaceKHR)vkGetInstanceProcAddr(
-            (VkInstance)instance,
+            instance,
             "vkCreateWin32SurfaceKHR");
     VkWin32SurfaceCreateInfoKHR createInfo;
     VkResult result;
diff --git a/src/video/windows/SDL_windowswindow.c b/src/video/windows/SDL_windowswindow.c
index d574040e2..ab30713fa 100644
--- a/src/video/windows/SDL_windowswindow.c
+++ b/src/video/windows/SDL_windowswindow.c
@@ -174,17 +174,19 @@ static void WIN_AdjustWindowRectWithStyle(SDL_Window *window, DWORD style, BOOL
 
             screen_rect.left = *x;
             screen_rect.top = *y;
-            screen_rect.right = *x + *width;
-            screen_rect.bottom = *y + *height;
+            screen_rect.right = (LONG)*x + *width;
+            screen_rect.bottom = (LONG)*y + *height;
 
             mon = MonitorFromRect(&screen_rect, MONITOR_DEFAULTTONEAREST);
 
-            /* GetDpiForMonitor docs promise to return the same hdpi / vdpi */
-            if (videodata->GetDpiForMonitor(mon, MDT_EFFECTIVE_DPI, &frame_dpi, &unused) != S_OK) {
-                frame_dpi = 96;
-            }
+            if (videodata != NULL) {
+                /* GetDpiForMonitor docs promise to return the same hdpi / vdpi */
+                if (videodata->GetDpiForMonitor(mon, MDT_EFFECTIVE_DPI, &frame_dpi, &unused) != S_OK) {
+                    frame_dpi = 96;
+                }
 
-            videodata->AdjustWindowRectExForDpi(&rect, style, menu, 0, frame_dpi);
+                videodata->AdjustWindowRectExForDpi(&rect, style, menu, 0, frame_dpi);
+            }
         } else {
             AdjustWindowRectEx(&rect, style, menu, 0);
         }
@@ -600,7 +602,7 @@ int WIN_CreateWindowFrom(_THIS, SDL_Window *window, const void *data)
                the window to share a pixel format with
             */
             SDL_Window *otherWindow = NULL;
-            SDL_sscanf(hint, "%p", (void **)&otherWindow);
+            (void)SDL_sscanf(hint, "%p", (void **)&otherWindow);
 
             /* Do some error checking on the pointer */
             if (otherWindow != NULL && otherWindow->magic == &_this->window_magic) {
@@ -1373,7 +1375,7 @@ int WIN_SetWindowOpacity(_THIS, SDL_Window *window, float opacity)
     return -1;
 #else
     const SDL_WindowData *data = (SDL_WindowData *)window->driverdata;
-    const HWND hwnd = data->hwnd;
+    HWND hwnd = data->hwnd;
     const LONG style = GetWindowLong(hwnd, GWL_EXSTYLE);
 
     SDL_assert(style != 0);
diff --git a/src/video/windows/SDL_windowswindow.h b/src/video/windows/SDL_windowswindow.h
index d4488c627..972d19d5b 100644
--- a/src/video/windows/SDL_windowswindow.h
+++ b/src/video/windows/SDL_windowswindow.h
@@ -106,8 +106,8 @@ extern SDL_bool WIN_GetWindowWMInfo(_THIS, SDL_Window * window,
 extern void WIN_OnWindowEnter(_THIS, SDL_Window * window);
 extern void WIN_UpdateClipCursor(SDL_Window *window);
 extern int WIN_SetWindowHitTest(SDL_Window *window, SDL_bool enabled);
-extern void WIN_ClientPointToSDL(const SDL_Window *window, int *w, int *h);
-extern void WIN_ClientPointFromSDL(const SDL_Window *window, int *w, int *h);
+extern void WIN_ClientPointToSDL(const SDL_Window *window, int *x, int *y);
+extern void WIN_ClientPointFromSDL(const SDL_Window *window, int *x, int *y);
 extern void WIN_AcceptDragAndDrop(SDL_Window *window, SDL_bool accept);
 extern int WIN_FlashWindow(_THIS, SDL_Window *window, SDL_FlashOperation operation);
 
diff --git a/src/video/x11/SDL_x11events.c b/src/video/x11/SDL_x11events.c
index 99650e06e..939d6fa54 100644
--- a/src/video/x11/SDL_x11events.c
+++ b/src/video/x11/SDL_x11events.c
@@ -521,8 +521,8 @@ static void InitiateWindowMove(_THIS, const SDL_WindowData *data, const SDL_Poin
     evt.xclient.window = data->xwindow;
     evt.xclient.message_type = X11_XInternAtom(display, "_NET_WM_MOVERESIZE", True);
     evt.xclient.format = 32;
-    evt.xclient.data.l[0] = window->x + point->x;
-    evt.xclient.data.l[1] = window->y + point->y;
+    evt.xclient.data.l[0] = (size_t)window->x + point->x;
+    evt.xclient.data.l[1] = (size_t)window->y + point->y;
     evt.xclient.data.l[2] = _NET_WM_MOVERESIZE_MOVE;
     evt.xclient.data.l[3] = Button1;
     evt.xclient.data.l[4] = 0;
@@ -550,8 +550,8 @@ static void InitiateWindowResize(_THIS, const SDL_WindowData *data, const SDL_Po
     evt.xclient.window = data->xwindow;
     evt.xclient.message_type = X11_XInternAtom(display, "_NET_WM_MOVERESIZE", True);
     evt.xclient.format = 32;
-    evt.xclient.data.l[0] = window->x + point->x;
-    evt.xclient.data.l[1] = window->y + point->y;
+    evt.xclient.data.l[0] = (size_t)window->x + point->x;
+    evt.xclient.data.l[1] = (size_t)window->y + point->y;
     evt.xclient.data.l[2] = direction;
     evt.xclient.data.l[3] = Button1;
     evt.xclient.data.l[4] = 0;
diff --git a/src/video/x11/SDL_x11framebuffer.c b/src/video/x11/SDL_x11framebuffer.c
index e6e05f644..56611a960 100644
--- a/src/video/x11/SDL_x11framebuffer.c
+++ b/src/video/x11/SDL_x11framebuffer.c
@@ -30,13 +30,14 @@
 /* Shared memory error handler routine */
 static int shm_error;
 static int (*X_handler)(Display *, XErrorEvent *) = NULL;
-static int shm_errhandler(Display *d, XErrorEvent *e)
+static int
+shm_errhandler(Display *d, XErrorEvent *e)
 {
     if (e->error_code == BadAccess) {
         shm_error = True;
         return 0;
-    } else
-        return X_handler(d, e);
+    }
+    return X_handler(d, e);
 }
 
 static SDL_bool have_mitshm(Display *dpy)
@@ -83,7 +84,7 @@ int X11_CreateWindowFramebuffer(_THIS, SDL_Window *window, Uint32 *format,
     if (have_mitshm(display)) {
         XShmSegmentInfo *shminfo = &data->shminfo;
 
-        shminfo->shmid = shmget(IPC_PRIVATE, window->h * (*pitch), IPC_CREAT | 0777);
+        shminfo->shmid = shmget(IPC_PRIVATE, (size_t)window->h * (*pitch), IPC_CREAT | 0777);
         if (shminfo->shmid >= 0) {
             shminfo->shmaddr = (char *)shmat(shminfo->shmid, 0, 0);
             shminfo->readOnly = False;
@@ -123,7 +124,7 @@ int X11_CreateWindowFramebuffer(_THIS, SDL_Window *window, Uint32 *format,
     }
 #endif /* not NO_SHARED_MEMORY */
 
-    *pixels = SDL_malloc(window->h * (*pitch));
+    *pixels = SDL_malloc((size_t)window->h * (*pitch));
     if (*pixels == NULL) {
         return SDL_OutOfMemory();
     }
diff --git a/src/video/x11/SDL_x11keyboard.c b/src/video/x11/SDL_x11keyboard.c
index 25dadff12..a98ae46f1 100644
--- a/src/video/x11/SDL_x11keyboard.c
+++ b/src/video/x11/SDL_x11keyboard.c
@@ -85,7 +85,8 @@ X11_KeyCodeToSym(_THIS, KeyCode keycode, unsigned char group)
             int action = XkbOutOfRangeGroupAction(info);
 
             if (action == XkbRedirectIntoRange) {
-                if ((group = XkbOutOfRangeGroupNumber(info)) >= num_groups) {
+                group = XkbOutOfRangeGroupNumber(info);
+                if (group >= num_groups) {
                     group = 0;
                 }
             } else if (action == XkbClampIntoRange) {
@@ -176,14 +177,14 @@ int X11_InitKeyboard(_THIS)
             new_xmods = "@im=none";
         }
 
-        setlocale(LC_ALL, "");
+        (void)setlocale(LC_ALL, "");
         X11_XSetLocaleModifiers(new_xmods);
 
         data->im = X11_XOpenIM(data->display, NULL, data->classname, data->classname);
 
         /* Reset the locale + X locale modifiers back to how they were,
            locale first because the X locale modifiers depend on it. */
-        setlocale(LC_ALL, prev_locale);
+        (void)setlocale(LC_ALL, prev_locale);
         X11_XSetLocaleModifiers(prev_xmods);
 
         if (prev_locale) {
@@ -451,9 +452,9 @@ void X11_ShowScreenKeyboard(_THIS, SDL_Window *window)
          * https://partner.steamgames.com/doc/api/ISteamUtils#ShowFloatingGamepadTextInput
          */
         char deeplink[128];
-        SDL_snprintf(deeplink, sizeof(deeplink),
-                     "steam://open/keyboard?XPosition=0&YPosition=0&Width=0&Height=0&Mode=%d",
-                     SDL_GetHintBoolean(SDL_HINT_RETURN_KEY_HIDES_IME, SDL_FALSE) ? 0 : 1);
+        (void)SDL_snprintf(deeplink, sizeof deeplink,
+                           "steam://open/keyboard?XPosition=0&YPosition=0&Width=0&Height=0&Mode=%d",
+                           SDL_GetHintBoolean(SDL_HINT_RETURN_KEY_HIDES_IME, SDL_FALSE) ? 0 : 1);
         SDL_OpenURL(deeplink);
         videodata->steam_keyboard_open = SDL_TRUE;
     }
diff --git a/src/video/x11/SDL_x11messagebox.c b/src/video/x11/SDL_x11messagebox.c
index 649bb7cbe..fcc06b663 100644
--- a/src/video/x11/SDL_x11messagebox.c
+++ b/src/video/x11/SDL_x11messagebox.c
@@ -240,7 +240,7 @@ static int X11_MessageBoxInitPositions(SDL_MessageBoxDataX11 *data)
     const SDL_MessageBoxData *messageboxdata = data->messageboxdata;
 
     /* Go over text and break linefeeds into separate lines. */
-    if (messageboxdata->message[0]) {
+    if (messageboxdata != NULL && messageboxdata->message[0]) {
         const char *text = messageboxdata->message;
         const int linecount = CountLinesOfText(text);
         TextLineData *plinedata = (TextLineData *)SDL_malloc(sizeof(TextLineData) * linecount);
@@ -588,6 +588,7 @@ static void X11_MessageBoxDraw(SDL_MessageBoxDataX11 *data, GC ctx)
 #endif
 }
 
+/* NOLINTNEXTLINE(readability-non-const-parameter): cannot make XPointer a const pointer due to typedef */
 static Bool X11_MessageBoxEventTest(Display *display, XEvent *event, XPointer arg)
 {
     const SDL_MessageBoxDataX11 *data = (const SDL_MessageBoxDataX11 *)arg;
@@ -766,7 +767,7 @@ static int X11_ShowMessageBoxImpl(const SDL_MessageBoxData *messageboxdata, int
         if (origlocale == NULL) {
             return SDL_OutOfMemory();
         }
-        setlocale(LC_ALL, "");
+        (void)setlocale(LC_ALL, "");
     }
 #endif
 
@@ -792,7 +793,7 @@ static int X11_ShowMessageBoxImpl(const SDL_MessageBoxData *messageboxdata, int
 
 #if SDL_SET_LOCALE
     if (origlocale) {
-        setlocale(LC_ALL, origlocale);
+        (void)setlocale(LC_ALL, origlocale);
         SDL_free(origlocale);
     }
 #endif
diff --git a/src/video/x11/SDL_x11modes.c b/src/video/x11/SDL_x11modes.c
index 36fa07ff9..8fd80e422 100644
--- a/src/video/x11/SDL_x11modes.c
+++ b/src/video/x11/SDL_x11modes.c
@@ -274,7 +274,7 @@ static void SetXRandRDisplayName(Display *dpy, Atom EDID, char *name, const size
     inches = (int)((SDL_sqrtf(widthmm * widthmm + heightmm * heightmm) / 25.4f) + 0.5f);
     if (*name && inches) {
         const size_t len = SDL_strlen(name);
-        SDL_snprintf(&name[len], namelen - len, " %d\"", inches);
+        (void)SDL_snprintf(&name[len], namelen - len, " %d\"", inches);
     }
 
 #ifdef X11MODES_DEBUG
diff --git a/src/video/x11/SDL_x11mouse.c b/src/video/x11/SDL_x11mouse.c
index c383e13b5..f13b9fd81 100644
--- a/src/video/x11/SDL_x11mouse.c
+++ b/src/video/x11/SDL_x11mouse.c
@@ -98,7 +98,7 @@ static Cursor X11_CreateXCursorCursor(SDL_Surface *surface, int hot_x, int hot_y
 
     SDL_assert(surface->format->format == SDL_PIXELFORMAT_ARGB8888);
     SDL_assert(surface->pitch == surface->w * 4);
-    SDL_memcpy(image->pixels, surface->pixels, surface->h * surface->pitch);
+    SDL_memcpy(image->pixels, surface->pixels, (size_t)surface->h * surface->pitch);
 
     cursor = X11_XcursorImageLoadCursor(display, image);
 
@@ -118,7 +118,7 @@ static Cursor X11_CreatePixmapCursor(SDL_Surface *surface, int hot_x, int hot_y)
     Pixmap data_pixmap, mask_pixmap;
     int x, y;
     unsigned int rfg, gfg, bfg, rbg, gbg, bbg, fgBits, bgBits;
-    unsigned int width_bytes = ((surface->w + 7) & ~7) / 8;
+    size_t width_bytes = ((surface->w + 7) & ~((size_t)7)) / 8;
 
     data_bits = SDL_calloc(1, surface->h * width_bytes);
     if (data_bits == NULL) {
@@ -168,15 +168,17 @@ static Cursor X11_CreatePixmapCursor(SDL_Surface *surface, int hot_x, int hot_y)
         fg.red = rfg * 257 / fgBits;
         fg.green = gfg * 257 / fgBits;
         fg.blue = bfg * 257 / fgBits;
-    } else
+    } else {
         fg.red = fg.green = fg.blue = 0;
+    }
 
     if (bgBits) {
         bg.red = rbg * 257 / bgBits;
         bg.green = gbg * 257 / bgBits;
         bg.blue = bbg * 257 / bgBits;
-    } else
+    } else {
         bg.red = bg.green = bg.blue = 0;
+    }
 
     data_pixmap = X11_XCreateBitmapFromData(display, DefaultRootWindow(display),
                                             (char *)data_bits,
diff --git a/src/video/x11/SDL_x11shape.h b/src/video/x11/SDL_x11shape.h
index d24d25a9b..e006292d0 100644
--- a/src/video/x11/SDL_x11shape.h
+++ b/src/video/x11/SDL_x11shape.h
@@ -35,6 +35,6 @@ typedef struct
 
 extern SDL_WindowShaper *X11_CreateShaper(SDL_Window *window);
 extern int X11_ResizeWindowShape(SDL_Window *window);
-extern int X11_SetWindowShape(SDL_WindowShaper *shaper, SDL_Surface *shape, SDL_WindowShapeMode *shapeMode);
+extern int X11_SetWindowShape(SDL_WindowShaper *shaper, SDL_Surface *shape, SDL_WindowShapeMode *shape_mode);
 
 #endif /* SDL_x11shape_h_ */
diff --git a/src/video/x11/SDL_x11video.c b/src/video/x11/SDL_x11video.c
index e3f2e24bb..53f19fd24 100644
--- a/src/video/x11/SDL_x11video.c
+++ b/src/video/x11/SDL_x11video.c
@@ -67,10 +67,9 @@ static char *get_classname()
     /* Next look at the application's executable name */
 #if defined(__LINUX__) || defined(__FREEBSD__)
 #if defined(__LINUX__)
-    SDL_snprintf(procfile, SDL_arraysize(procfile), "/proc/%d/exe", getpid());
+    (void)SDL_snprintf(procfile, SDL_arraysize(procfile), "/proc/%d/exe", getpid());
 #elif defined(__FREEBSD__)
-    SDL_snprintf(procfile, SDL_arraysize(procfile), "/proc/%d/file",
-                 getpid());
+    (void)SDL_snprintf(procfile, SDL_arraysize(procfile), "/proc/%d/file", getpid());
 #else
 #error Where can we find the executable name?
 #endif
diff --git a/src/video/x11/SDL_x11window.c b/src/video/x11/SDL_x11window.c
index 682604bb7..1b30e1d29 100644
--- a/src/video/x11/SDL_x11window.c
+++ b/src/video/x11/SDL_x11window.c
@@ -45,11 +45,13 @@
 #define _NET_WM_STATE_REMOVE 0l
 #define _NET_WM_STATE_ADD    1l
 
-static Bool isMapNotify(Display *dpy, XEvent *ev, XPointer win)
+static Bool
+isMapNotify(Display *dpy, XEvent *ev, XPointer win) /* NOLINT(readability-non-const-parameter): cannot make XPointer a const pointer due to typedef */
 {
     return ev->type == MapNotify && ev->xmap.window == *((Window *)win);
 }
-static Bool isUnmapNotify(Display *dpy, XEvent *ev, XPointer win)
+static Bool
+isUnmapNotify(Display *dpy, XEvent *ev, XPointer win) /* NOLINT(readability-non-const-parameter): cannot make XPointer a const pointer due to typedef */
 {
     return ev->type == UnmapNotify && ev->xunmap.window == *((Window *)win);
 }
@@ -586,14 +588,14 @@ int X11_CreateWindow(_THIS, SDL_Window *window)
     X11_SetNetWMState(_this, w, window->flags);
 
     compositor = 2; /* don't disable compositing except for "normal" windows */
-
+    hint = SDL_GetHint(SDL_HINT_X11_WINDOW_TYPE);
     if (window->flags & SDL_WINDOW_UTILITY) {
         wintype_name = "_NET_WM_WINDOW_TYPE_UTILITY";
     } else if (window->flags & SDL_WINDOW_TOOLTIP) {
         wintype_name = "_NET_WM_WINDOW_TYPE_TOOLTIP";
     } else if (window->flags & SDL_WINDOW_POPUP_MENU) {
         wintype_name = "_NET_WM_WINDOW_TYPE_POPUP_MENU";
-    } else if (((hint = SDL_GetHint(SDL_HINT_X11_WINDOW_TYPE)) != NULL) && *hint) {
+    } else if (hint != NULL && *hint) {
         wintype_name = hint;
     } else {
         wintype_name = "_NET_WM_WINDOW_TYPE_NORMAL";
@@ -1555,7 +1557,7 @@ X11_GetWindowICCProfile(_THIS, SDL_Window *window, size_t *size)
 
     X11_XGetWindowAttributes(display, data->xwindow, &attributes);
     if (X11_XScreenNumberOfScreen(attributes.screen) > 0) {
-        SDL_snprintf(icc_atom_string, sizeof("_ICC_PROFILE_") + 12, "%s%d", "_ICC_PROFILE_", X11_XScreenNumberOfScreen(attributes.screen));
+        (void)SDL_snprintf(icc_atom_string, sizeof("_ICC_PROFILE_") + 12, "%s%d", "_ICC_PROFILE_", X11_XScreenNumberOfScreen(attributes.screen));
     } else {
         SDL_strlcpy(icc_atom_string, "_ICC_PROFILE", sizeof("_ICC_PROFILE"));
     }
@@ -1818,7 +1820,7 @@ int SDL_X11_SetWindowTitle(Display *display, Window xwindow, char *title)
 {
     Atom _NET_WM_NAME = X11_XInternAtom(display, "_NET_WM_NAME", False);
     XTextProperty titleprop;
-    int conv = X11_XmbTextListToTextProperty(display, (char **)&title, 1, XTextStyle, &titleprop);
+    int conv = X11_XmbTextListToTextProperty(display, &title, 1, XTextStyle, &titleprop);
     Status status;
 
     if (X11_XSupportsLocale() != True) {
@@ -1837,7 +1839,7 @@ int SDL_X11_SetWindowTitle(Display *display, Window xwindow, char *title)
     }
 
 #ifdef X_HAVE_UTF8_STRING
-    status = X11_Xutf8TextListToTextProperty(display, (char **)&title, 1, XUTF8StringStyle, &titleprop);
+    status = X11_Xutf8TextListToTextProperty(display, &title, 1, XUTF8StringStyle, &titleprop);
     if (status == Success) {
         X11_XSetTextProperty(display, xwindow, &titleprop, _NET_WM_NAME);
         X11_XFree(titleprop.value);
diff --git a/src/video/x11/SDL_x11window.h b/src/video/x11/SDL_x11window.h
index 25a459a86..515ae384f 100644
--- a/src/video/x11/SDL_x11window.h
+++ b/src/video/x11/SDL_x11window.h
@@ -117,7 +117,7 @@ extern int X11_SetWindowHitTest(SDL_Window *window, SDL_bool enabled);
 extern void X11_AcceptDragAndDrop(SDL_Window *window, SDL_bool accept);
 extern int X11_FlashWindow(_THIS, SDL_Window *window, SDL_FlashOperation operation);
 
-int SDL_X11_SetWindowTitle(Display *display, Window xwindow, char *string);
+int SDL_X11_SetWindowTitle(Display *display, Window xwindow, char *title);
 
 #endif /* SDL_x11window_h_ */
 
diff --git a/test/checkkeys.c b/test/checkkeys.c
index 91b219f1e..528b82747 100644
--- a/test/checkkeys.c
+++ b/test/checkkeys.c
@@ -161,7 +161,7 @@ PrintText(const char *eventtype, const char *text)
     expanded[0] = '\0';
     for (spot = text; *spot; ++spot) {
         size_t length = SDL_strlen(expanded);
-        SDL_snprintf(expanded + length, sizeof(expanded) - length, "\\x%.2x", (unsigned char)*spot);
+        (void)SDL_snprintf(expanded + length, sizeof expanded - length, "\\x%.2x", (unsigned char)*spot);
     }
     SDL_Log("%s Text (%s): \"%s%s\"\n", eventtype, expanded, *text == '"' ? "\\" : "", text);
 }
diff --git a/test/checkkeysthreads.c b/test/checkkeysthreads.c
index c14cb29e9..9c93337fe 100644
--- a/test/checkkeysthreads.c
+++ b/test/checkkeysthreads.c
@@ -146,7 +146,6 @@ PrintKey(SDL_Keysym *sym, SDL_bool pressed, SDL_bool repeat)
         print_string(&spot, &left, " (repeat)");
     }
     SDL_Log("%s\n", message);
-    fflush(stderr);
 }
 
 static void
@@ -158,7 +157,7 @@ PrintText(const char *eventtype, const char *text)
     expanded[0] = '\0';
     for (spot = text; *spot; ++spot) {
         size_t length = SDL_strlen(expanded);
-        SDL_snprintf(expanded + length, sizeof(expanded) - length, "\\x%.2x", (unsigned char)*spot);
+        (void)SDL_snprintf(expanded + length, sizeof expanded - length, "\\x%.2x", (unsigned char)*spot);
     }
     SDL_Log("%s Text (%s): \"%s%s\"\n", eventtype, expanded, *text == '"' ? "\\" : "", text);
 }
@@ -169,12 +168,11 @@ void loop()
     /* Check for events */
     /*SDL_WaitEvent(&event); emscripten does not like waiting*/
 
-    fprintf(stderr, "starting loop\n");
-    fflush(stderr);
+    (void)fprintf(stderr, "starting loop\n");
+    (void)fflush(stderr);
     // while (SDL_PollEvent(&event)) {
     while (!done && SDL_WaitEvent(&event)) {
-        fprintf(stderr, "got event type: %" SDL_PRIu32 "\n", event.type);
-        fflush(stderr);
+        SDL_Log("Got event type: %" SDL_PRIu32 "\n", event.type);
         switch (event.type) {
         case SDL_KEYDOWN:
         case SDL_KEYUP:
@@ -188,8 +186,8 @@ void loop()
             break;
         case SDL_MOUSEBUTTONDOWN:
             /* Left button quits the app, other buttons toggles text input */
-            fprintf(stderr, "mouse button down button: %d (LEFT=%d)\n", event.button.button, SDL_BUTTON_LEFT);
-            fflush(stderr);
+            (void)fprintf(stderr, "mouse button down button: %d (LEFT=%d)\n", event.button.button, SDL_BUTTON_LEFT);
+            (void)fflush(stderr);
             if (event.button.button == SDL_BUTTON_LEFT) {
                 done = 1;
             } else {
@@ -208,11 +206,11 @@ void loop()
         default:
             break;
         }
-        fprintf(stderr, "waiting new event\n");
-        fflush(stderr);
+        (void)fprintf(stderr, "waiting new event\n");
+        (void)fflush(stderr);
     }
-    fprintf(stderr, "exiting event loop\n");
-    fflush(stderr);
+    (void)fprintf(stderr, "exiting event loop\n");
+    (void)fflush(stderr);
 #ifdef __EMSCRIPTEN__
     if (done) {
         emscripten_cancel_main_loop();
@@ -227,8 +225,8 @@ static int SDLCALL ping_thread(void *ptr)
     SDL_Event sdlevent;
     SDL_memset(&sdlevent, 0, sizeof(SDL_Event));
     for (cnt = 0; cnt < 10; ++cnt) {
-        fprintf(stderr, "sending event (%d/%d) from thread.\n", cnt + 1, 10);
-        fflush(stderr);
+        (void)fprintf(stderr, "sending event (%d/%d) from thread.\n", cnt + 1, 10);
+        (void)fflush(stderr);
         sdlevent.type = SDL_KEYDOWN;
         sdlevent.key.keysym.sym = SDLK_1;
         SDL_PushEvent(&sdlevent);
@@ -282,7 +280,7 @@ int main(int argc, char *argv[])
     /* Watch keystrokes */
     done = 0;
 
-    thread = SDL_CreateThread(ping_thread, "PingThread", (void *)NULL);
+    thread = SDL_CreateThread(ping_thread, "PingThread", NULL);
 
 #ifdef __EMSCRIPTEN__
     emscripten_set_main_loop(loop, 0, 1);
diff --git a/test/controllermap.c b/test/controllermap.c
index d172c776d..2f3c5bd47 100644
--- a/test/controllermap.c
+++ b/test/controllermap.c
@@ -393,7 +393,6 @@ WatchJoystick(SDL_Joystick *joystick)
 
     /* Skip any spurious events at start */
     while (SDL_PollEvent(&event) > 0) {
-        continue;
     }
 
     /* Loop, getting joystick events! */
@@ -594,7 +593,7 @@ WatchJoystick(SDL_Joystick *joystick)
             char crc_string[5];
 
             SDL_strlcat(mapping, "crc:", SDL_arraysize(mapping));
-            SDL_snprintf(crc_string, sizeof(crc_string), "%.4x", crc);
+            (void)SDL_snprintf(crc_string, sizeof crc_string, "%.4x", crc);
             SDL_strlcat(mapping, crc_string, SDL_arraysize(mapping));
             SDL_strlcat(mapping, ",", SDL_arraysize(mapping));
         }
@@ -667,17 +666,17 @@ WatchJoystick(SDL_Joystick *joystick)
             pszElement[0] = '\0';
             switch (pBinding->bindType) {
             case SDL_CONTROLLER_BINDTYPE_BUTTON:
-                SDL_snprintf(pszElement, sizeof(pszElement), "b%d", pBinding->value.button);
+                (void)SDL_snprintf(pszElement, sizeof pszElement, "b%d", pBinding->value.button);
                 break;
             case SDL_CONTROLLER_BINDTYPE_AXIS:
                 if (pBinding->value.axis.axis_min == 0 && pBinding->value.axis.axis_max == SDL_JOYSTICK_AXIS_MIN) {
                     /* The negative half axis */
-                    SDL_snprintf(pszElement, sizeof(pszElement), "-a%d", pBinding->value.axis.axis);
+                    (void)SDL_snprintf(pszElement, sizeof pszElement, "-a%d", pBinding->value.axis.axis);
                 } else if (pBinding->value.axis.axis_min == 0 && pBinding->value.axis.axis_max == SDL_JOYSTICK_AXIS_MAX) {
                     /* The positive half axis */
-                    SDL_snprintf(pszElement, sizeof(pszElement), "+a%d", pBinding->value.axis.axis);
+                    (void)SDL_snprintf(pszElement, sizeof pszElement, "+a%d", pBinding->value.axis.axis);
                 } else {
-                    SDL_snprintf(pszElement, sizeof(pszElement), "a%d", pBinding->value.axis.axis);
+                    (void)SDL_snprintf(pszElement, sizeof pszElement, "a%d", pBinding->value.axis.axis);
                     if (pBinding->value.axis.axis_min > pBinding->value.axis.axis_max) {
                         /* Invert the axis */
                         SDL_strlcat(pszElement, "~", SDL_arraysize(pszElement));
@@ -685,7 +684,7 @@ WatchJoystick(SDL_Joystick *joystick)
                 }
                 break;
             case SDL_CONTROLLER_BINDTYPE_HAT:
-                SDL_snprintf(pszElement, sizeof(pszElement), "h%d.%d", pBinding->value.hat.hat, pBinding->value.hat.hat_mask);
+                (void)SDL_snprintf(pszElement, sizeof pszElement, "h%d.%d", pBinding->value.hat.hat, pBinding->value.hat.hat_mask);
                 break;
             default:
                 SDL_assert(!"Unknown bind type");
diff --git a/test/loopwavequeue.c b/test/loopwavequeue.c
index 23157a381..2a75f10e5 100644
--- a/test/loopwavequeue.c
+++ b/test/loopwavequeue.c
@@ -100,13 +100,13 @@ int main(int argc, char *argv[])
 #if HAVE_SIGNAL_H
     /* Set the signals */
 #ifdef SIGHUP
-    signal(SIGHUP, poked);
+    (void)signal(SIGHUP, poked);
 #endif
-    signal(SIGINT, poked);
+    (void)signal(SIGINT, poked);
 #ifdef SIGQUIT
-    signal(SIGQUIT, poked);
+    (void)signal(SIGQUIT, poked);
 #endif
-    signal(SIGTERM, poked);
+    (void)signal(SIGTERM, poked);
 #endif /* HAVE_SIGNAL_H */
 
     /* Initialize fillerup() variables */
diff --git a/test/testatomic.c b/test/testatomic.c
index 1bb0f2d8c..c412afd52 100644
--- a/test/testatomic.c
+++ b/test/testatomic.c
@@ -617,7 +617,7 @@ static void RunFIFOTest(SDL_bool lock_free)
     SDL_zeroa(readerData);
     for (i = 0; i < NUM_READERS; ++i) {
         char name[64];
-        SDL_snprintf(name, sizeof(name), "FIFOReader%d", i);
+        (void)SDL_snprintf(name, sizeof name, "FIFOReader%d", i);
         readerData[i].queue = &queue;
         readerData[i].lock_free = lock_free;
         readerData[i].thread = SDL_CreateThread(FIFO_Reader, name, &readerData[i]);
@@ -628,7 +628,7 @@ static void RunFIFOTest(SDL_bool lock_free)
     SDL_zeroa(writerData);
     for (i = 0; i < NUM_WRITERS; ++i) {
         char name[64];
-        SDL_snprintf(name, sizeof(name), "FIFOWriter%d", i);
+        (void)SDL_snprintf(name, sizeof name, "FIFOWriter%d", i);
         writerData[i].queue = &queue;
         writerData[i].index = i;
         writerData[i].lock_free = lock_free;
@@ -677,17 +677,17 @@ static void RunFIFOTest(SDL_bool lock_free)
         }
         grand_total += total;
         SDL_Log("Reader %d read %d events, had %d waits\n", i, total, readerData[i].waits);
-        SDL_snprintf(textBuffer, sizeof(textBuffer), "  { ");
+        (void)SDL_snprintf(textBuffer, sizeof textBuffer, "  { ");
         for (j = 0; j < NUM_WRITERS; ++j) {
             if (j > 0) {
                 len = SDL_strlen(textBuffer);
-                SDL_snprintf(textBuffer + len, sizeof(textBuffer) - len, ", ");
+                (void)SDL_snprintf(textBuffer + len, sizeof textBuffer - len, ", ");
             }
             len = SDL_strlen(textBuffer);
-            SDL_snprintf(textBuffer + len, sizeof(textBuffer) - len, "%d", readerData[i].counters[j]);
+            (void)SDL_snprintf(textBuffer + len, sizeof textBuffer - len, "%d", readerData[i].counters[j]);
         }
         len = SDL_strlen(textBuffer);
-        SDL_snprintf(textBuffer + len, sizeof(textBuffer) - len, " }\n");
+        (void)SDL_snprintf(textBuffer + len, sizeof textBuffer - len, " }\n");
         SDL_Log("%s", textBuffer);
     }
     SDL_Log("Readers read %d total events\n", grand_total);
diff --git a/test/testaudiohotplug.c b/test/testaudiohotplug.c
index 2feca5a36..2ce22884c 100644
--- a/test/testaudiohotplug.c
+++ b/test/testaudiohotplug.c
@@ -96,9 +96,9 @@ iteration()
             int index = e.adevice.which;
             int iscapture = e.adevice.iscapture;
             const char *name = SDL_GetAudioDeviceName(index, iscapture);
-            if (name != NULL)
+            if (name != NULL) {
                 SDL_Log("New %s audio device at index %u: %s\n", devtypestr(iscapture), (unsigned int)index, name);
-            else {
+            } else {
                 SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Got new %s device at index %u, but failed to get the name: %s\n",
                              devtypestr(iscapture), (unsigned int)index, SDL_GetError());
                 continue;
@@ -166,13 +166,13 @@ int main(int argc, char *argv[])
 #if HAVE_SIGNAL_H
     /* Set the signals */
 #ifdef SIGHUP
-    signal(SIGHUP, poked);
+    (void)signal(SIGHUP, poked);
 #endif
-    signal(SIGINT, poked);
+    (void)signal(SIGINT, poked);
 #ifdef SIGQUIT
-    signal(SIGQUIT, poked);
+    (void)signal(SIGQUIT, poked);
 #endif
-    signal(SIGTERM, poked);
+    (void)signal(SIGTERM, poked);
 #endif /* HAVE_SIGNAL_H */
 
     /* Show the list of available drivers */
diff --git a/test/testaudioinfo.c b/test/testaudioinfo.c
index ecb26dc30..bf0ee42d3 100644
--- a/test/testaudioinfo.c
+++ b/test/testaudioinfo.c
@@ -21,18 +21,19 @@ print_devices(int iscapture)
 
     SDL_Log("Found %d %s device%s:\n", n, typestr, n != 1 ? "s" : "");
 
-    if (n == -1)
+    if (n == -1) {
         SDL_Log("  Driver can't detect specific %s devices.\n\n", typestr);
-    else if (n == 0)
+    } else if (n == 0) {
         SDL_Log("  No %s devices found.\n\n", typestr);
-    else {
+    } else {
         int i;
         for (i = 0; i < n; i++) {
             const char *name = SDL_GetAudioDeviceName(i, iscapture);
-            if (name != NULL)
+            if (name != NULL) {
                 SDL_Log("  %d: %s\n", i, name);
-            else
+            } else {
                 SDL_Log("  %d Error: %s\n", i, SDL_GetError());
+            }
 
             if (SDL_GetAudioDeviceSpec(i, iscapture, &spec) == 0) {
                 SDL_Log("     Sample Rate: %d\n", spec.freq);
diff --git a/test/testautomation.c b/test/testautomation.c
index 42a4ee39f..c9f67e78e 100644
--- a/test/testautomation.c
+++ b/test/testautomation.c
@@ -62,7 +62,7 @@ int main(int argc, char *argv[])
                 }
             } else if (SDL_strcasecmp(argv[i], "--execKey") == 0) {
                 if (argv[i + 1]) {
-                    SDL_sscanf(argv[i + 1], "%" SDL_PRIu64, &userExecKey);
+                    (void)SDL_sscanf(argv[i + 1], "%" SDL_PRIu64, &userExecKey);
                     consumed = 2;
                 }
             } else if (SDL_strcasecmp(argv[i], "--seed") == 0) {
diff --git a/test/testautomation_audio.c b/test/testautomation_audio.c
index fafbca37e..92b7feb34 100644
--- a/test/testautomation_audio.c
+++ b/test/testautomation_audio.c
@@ -32,7 +32,7 @@ void _audioSetUp(void *arg)
 void _audioTearDown(void *arg)
 {
     /* Remove a possibly created file from SDL disk writer audio driver; ignore errors */
-    remove("sdlaudio.raw");
+    (void)remove("sdlaudio.raw");
 
     SDLTest_AssertPass("Cleanup of test files completed");
 }
@@ -94,8 +94,8 @@ int audio_initQuitAudio()
     for (i = 0; i < iMax; i++) {
         audioDriver = SDL_GetAudioDriver(i);
         SDLTest_AssertPass("Call to SDL_GetAudioDriver(%d)", i);
-        SDLTest_AssertCheck(audioDriver != NULL, "Audio driver name is not NULL");
-        SDLTest_AssertCheck(audioDriver[0] != '\0', "Audio driver name is not empty; got: %s", audioDriver);
+        SDLTest_Assert(audioDriver != NULL, "Audio driver name is not NULL");
+        SDLTest_AssertCheck(audioDriver[0] != '\0', "Audio driver name is not empty; got: %s", audioDriver); /* NOLINT(clang-analyzer-core.NullDereference): Checked for NULL above */
 
         /* Call Init */
         result = SDL_AudioInit(audioDriver);
@@ -151,8 +151,8 @@ int audio_initOpenCloseQuitAudio()
     for (i = 0; i < iMax; i++) {
         audioDriver = SDL_GetAudioDriver(i);
         SDLTest_AssertPass("Call to SDL_GetAudioDriver(%d)", i);
-        SDLTest_AssertCheck(audioDriver != NULL, "Audio driver name is not NULL");
-        SDLTest_AssertCheck(audioDriver[0] != '\0', "Audio driver name is not empty; got: %s", audioDriver);
+        SDLTest_Assert(audioDriver != NULL, "Audio driver name is not NULL");
+        SDLTest_AssertCheck(audioDriver[0] != '\0', "Audio driver name is not empty; got: %s", audioDriver); /* NOLINT(clang-analyzer-core.NullDereference): Checked for NULL above */
 
         /* Change specs */
         for (j = 0; j < 2; j++) {
@@ -240,8 +240,8 @@ int audio_pauseUnpauseAudio()
     for (i = 0; i < iMax; i++) {
         audioDriver = SDL_GetAudioDriver(i);
         SDLTest_AssertPass("Call to SDL_GetAudioDriver(%d)", i);
-        SDLTest_AssertCheck(audioDriver != NULL, "Audio driver name is not NULL");
-        SDLTest_AssertCheck(audioDriver[0] != '\0', "Audio driver name is not empty; got: %s", audioDriver);
+        SDLTest_Assert(audioDriver != NULL, "Audio driver name is not NULL");
+        SDLTest_AssertCheck(audioDriver[0] != '\0', "Audio driver name is not empty; got: %s", audioDriver); /* NOLINT(clang-analyzer-core.NullDereference): Checked for NULL above */
 
         /* Change specs */
         for (j = 0; j < 2; j++) {
diff --git a/test/testautomation_clipboard.c b/test/testautomation_clipboard.c
index b7bab5ada..dbe1ef8e4 100644
--- a/test/testautomation_clipboard.c
+++ b/test/testautomation_clipboard.c
@@ -169,11 +169,11 @@ int clipboard_testClipboardTextFunctions(void *arg)
     /* Empty clipboard  */
     charResult = SDL_GetClipboardText();
     SDLTest_AssertPass("Call to SDL_GetClipboardText succeeded");
-    SDLTest_AssertCheck(
+    SDLTest_Assert(
         charResult != NULL,
         "Verify SDL_GetClipboardText did not return NULL");
     SDLTest_AssertCheck(
-        charResult[0] == '\0',
+        charResult[0] == '\0', /* NOLINT(clang-analyzer-core.NullDereference): Checked for NULL above */
         "Verify SDL_GetClipboardText returned string with length 0, got length %i",
         (int)SDL_strlen(charResult));
     intResult = SDL_SetClipboardText((const char *)text);
@@ -247,11 +247,11 @@ int clipboard_testPrimarySelectionTextFunctions(void *arg)
     /* Empty primary selection  */
     charResult = SDL_GetPrimarySelectionText();
     SDLTest_AssertPass("Call to SDL_GetPrimarySelectionText succeeded");
-    SDLTest_AssertCheck(
+    SDLTest_Assert(
         charResult != NULL,
         "Verify SDL_GetPrimarySelectionText did not return NULL");
     SDLTest_AssertCheck(
-        charResult[0] == '\0',
+        charResult[0] == '\0', /* NOLINT(clang-analyzer-core.NullDereference): Checked for NULL above */
         "Verify SDL_GetPrimarySelectionText returned string with length 0, got length %i",
         (int)SDL_strlen(charResult));
     intResult = SDL_SetPrimarySelectionText((const char *)text);
diff --git a/test/testautomation_keyboard.c b/test/testautomation_keyboard.c
index a8bf40bdf..0d459d0b2 100644
--- a/test/testautomation_keyboard.c
+++ b/test/testautomation_keyboard.c
@@ -616,14 +616,14 @@ int keyboard_getScancodeFromNameNegative(void *arg)
 
     /* Zero length string input */
     name = "";
-    scancode = SDL_GetScancodeFromName((const char *)name);
+    scancode = SDL_GetScancodeFromName(name);
     SDLTest_AssertPass("Call to SDL_GetScancodeFromName(NULL)");
     SDLTest_AssertCheck(scancode == SDL_SCANCODE_UNKNOWN, "Validate return value from SDL_GetScancodeFromName, expected: %i, got: %i", SDL_SCANCODE_UNKNOWN, scancode);
     _checkInvalidNameError();
 
     /* NULL input */
     name = NULL;
-    scancode = SDL_GetScancodeFromName((const char *)name);
+    scancode = SDL_GetScancodeFromName(name);
     SDLTest_AssertPass("Call to SDL_GetScancodeFromName(NULL)");
     SDLTest_AssertCheck(scancode == SDL_SCANCODE_UNKNOWN, "Validate return value from SDL_GetScancodeFromName, expected: %i, got: %i", SDL_SCANCODE_UNKNOWN, scancode);
     _checkInvalidNameError();
diff --git a/test/testautomation_math.c b/test/testautomation_math.c
index f3b34a262..8b8dad4af 100644
--- a/test/testautomation_math.c
+++ b/test/testautomation_math.c
@@ -12,7 +12,7 @@
 
 /* Range tests parameters */
 #define RANGE_TEST_ITERATIONS 10000000
-#define RANGE_TEST_STEP       SDL_MAX_UINT32 / RANGE_TEST_ITERATIONS
+#define RANGE_TEST_STEP       ((Uint32)(SDL_MAX_UINT32 / RANGE_TEST_ITERATIONS))
 
 /* Margin of error for imprecise tests */
 #define EPSILON 1.0E-10
diff --git a/test/testautomation_platform.c b/test/testautomation_platform.c
index 3ffc6cdbb..ac85eef23 100644
--- a/test/testautomation_platform.c
+++ b/test/testautomation_platform.c
@@ -34,16 +34,16 @@ int platform_testTypes(void *arg)
     int ret;
 
     ret = _compareSizeOfType(sizeof(Uint8), 1);
-    SDLTest_AssertCheck(ret == 0, "sizeof(Uint8) = %lu, expected  1", (unsigned long)sizeof(Uint8));
+    SDLTest_AssertCheck(ret == 0, "sizeof(Uint8) = %u, expected  1", (unsigned int)sizeof(Uint8));
 
     ret = _compareSizeOfType(sizeof(Uint16), 2);
-    SDLTest_AssertCheck(ret == 0, "sizeof(Uint16) = %lu, expected 2", (unsigned long)sizeof(Uint16));
+    SDLTest_AssertCheck(ret == 0, "sizeof(Uint16) = %u, expected 2", (unsigned int)sizeof(Uint16));
 
     ret = _compareSizeOfType(sizeof(Uint32), 4);
-    SDLTest_AssertCheck(ret == 0, "sizeof(Uint32) = %lu, expected 4", (unsigned long)sizeof(Uint32));
+    SDLTest_AssertCheck(ret == 0, "sizeof(Uint32) = %u, expected 4", (unsigned int)sizeof(Uint32));
 
     ret = _compareSizeOfType(sizeof(Uint64), 8);
-    SDLTest_AssertCheck(ret == 0, "sizeof(Uint64) = %lu, expected 8", (unsigned long)sizeof(Uint64));
+    SDLTest_AssertCheck(ret == 0, "sizeof(Uint64) = %u, expected 8", (unsigned int)sizeof(Uint64));
 
     return TEST_COMPLETED;
 }
diff --git a/test/testautomation_rect.c b/test/testautomation_rect.c
index f259cb960..d1d7e1d4a 100644
--- a/test/testautomation_rect.c
+++ b/test/testautomation_rect.c
@@ -651,7 +651,7 @@ int rect_testIntersectRectEmpty(void *arg)
     rectB = refRectB;
     intersection = SDL_IntersectRect(&rectA, &rectB, &result);
     _validateIntersectRectResults(intersection, SDL_FALSE, &rectA, &rectB, &refRectA, &refRectB, (SDL_Rect *)NULL, (SDL_Rect *)NULL);
-    empty = (SDL_bool)SDL_RectEmpty(&result);
+    empty = SDL_RectEmpty(&result);
     SDLTest_AssertCheck(empty == SDL_TRUE, "Validate result is empty Rect; got: %s", (empty == SDL_TRUE) ? "SDL_TRUE" : "SDL_FALSE");
 
     /* Rect B empty */
@@ -668,7 +668,7 @@ int rect_testIntersectRectEmpty(void *arg)
     rectB = refRectB;
     intersection = SDL_IntersectRect(&rectA, &rectB, &result);
     _validateIntersectRectResults(intersection, SDL_FALSE, &rectA, &rectB, &refRectA, &refRectB, (SDL_Rect *)NULL, (SDL_Rect *)NULL);
-    empty = (SDL_bool)SDL_RectEmpty(&result);
+    empty = SDL_RectEmpty(&result);
     SDLTest_AssertCheck(empty == SDL_TRUE, "Validate result is empty Rect; got: %s", (empty == SDL_TRUE) ? "SDL_TRUE" : "SDL_FALSE");
 
     /* Rect A and B empty */
@@ -687,7 +687,7 @@ int rect_testIntersectRectEmpty(void *arg)
     rectB = refRectB;
     intersection = SDL_IntersectRect(&rectA, &rectB, &result);
     _validateIntersectRectResults(intersection, SDL_FALSE, &rectA, &rectB, &refRectA, &refRectB, (SDL_Rect *)NULL, (SDL_Rect *)NULL);
-    empty = (SDL_bool)SDL_RectEmpty(&result);
+    empty = SDL_RectEmpty(&result);
     SDLTest_AssertCheck(empty == SDL_TRUE, "Validate result is empty Rect; got: %s", (empty == SDL_TRUE) ? "SDL_TRUE" : "SDL_FALSE");
 
     return TEST_COMPLETED;
@@ -1533,7 +1533,7 @@ int rect_testRectEmpty(void *arg)
     refRect.h = SDLTest_RandomIntegerInRange(256, 1024);
     expectedResult = SDL_FALSE;
     rect = refRect;
-    result = (SDL_bool)SDL_RectEmpty((const SDL_Rect *)&rect);
+    result = SDL_RectEmpty(&rect);
     _validateRectEmptyResults(result, expectedResult, &rect, &refRect);
 
     /* Empty case */
@@ -1546,7 +1546,7 @@ int rect_testRectEmpty(void *arg)
                 refRect.h = h;
                 expectedResult = SDL_TRUE;
                 rect = refRect;
-                result = (SDL_bool)SDL_RectEmpty((const SDL_Rect *)&rect);
+                result = SDL_RectEmpty(&rect);
                 _validateRectEmptyResults(result, expectedResult, &rect, &refRect);
             }
         }
@@ -1566,7 +1566,7 @@ int rect_testRectEmptyParam(void *arg)
     SDL_bool result;
 
     /* invalid parameter combinations */
-    result = (SDL_bool)SDL_RectEmpty((const SDL_Rect *)NULL);
+    result = SDL_RectEmpty(NULL);
     SDLTest_AssertCheck(result == SDL_TRUE, "Check that function returns TRUE when 1st parameter is NULL");
 
     return TEST_COMPLETED;
@@ -1596,7 +1596,7 @@ int rect_testRectEquals(void *arg)
     expectedResult = SDL_TRUE;
     rectA = refRectA;
     rectB = refRectB;
-    result = (SDL_bool)SDL_RectEquals((const SDL_Rect *)&rectA, (const SDL_Rect *)&rectB);
+    result = SDL_RectEquals(&rectA, &rectB);
     _validateRectEqualsResults(result, expectedResult, &rectA, &rectB, &refRectA, &refRectB);
 
     return TEST_COMPLETED;
@@ -1625,11 +1625,11 @@ int rect_testRectEqualsParam(void *arg)
     rectB.h = SDLTest_RandomIntegerInRange(1, 1024);
 
     /* invalid parameter combinations */
-    result = (SDL_bool)SDL_RectEquals((const SDL_Rect *)NULL, (const SDL_Rect *)&rectB);
+    result = SDL_RectEquals(NULL, &rectB);
     SDLTest_AssertCheck(result == SDL_FALSE, "Check that function returns SDL_FALSE when 1st parameter is NULL");
-    result = (SDL_bool)SDL_RectEquals((const SDL_Rect *)&rectA, (const SDL_Rect *)NULL);
+    result = SDL_RectEquals(&rectA, NULL);
     SDLTest_AssertCheck(result == SDL_FALSE, "Check that function returns SDL_FALSE when 2nd parameter is NULL");
-    result = (SDL_bool)SDL_RectEquals((const SDL_Rect *)NULL, (const SDL_Rect *)NULL);
+    result = SDL_RectEquals(NULL, NULL);
     SDLTest_AssertCheck(result == SDL_FALSE, "Check that function returns SDL_FALSE when 1st and 2nd parameter are NULL");
 
     return TEST_COMPLETED;
@@ -1659,7 +1659,7 @@ int rect_testFRectEquals(void *arg)
     expectedResult = SDL_TRUE;
     rectA = refRectA;
     rectB = refRectB;
-    result = (SDL_bool)SDL_FRectEquals((const SDL_FRect *)&rectA, (const SDL_FRect *)&rectB);
+    result = SDL_FRectEquals(&rectA, &rectB);
     _validateFRectEqualsResults(result, expectedResult, &rectA, &rectB, &refRectA, &refRectB);
 
     return TEST_COMPLETED;
@@ -1688,11 +1688,11 @@ int rect_testFRectEqualsParam(void *arg)
     rectB.h = SDLTest_RandomFloat();
 
     /* invalid parameter combinations */
-    result = (SDL_bool)SDL_FRectEquals((const SDL_FRect *)NULL, (const SDL_FRect *)&rectB);
+    result = SDL_FRectEquals(NULL, &rectB);
     SDLTest_AssertCheck(result == SDL_FALSE, "Check that function returns SDL_FALSE when 1st parameter is NULL");
-    result = (SDL_bool)SDL_FRectEquals((const SDL_FRect *)&rectA, (const SDL_FRect *)NULL);
+    result = SDL_FRectEquals(&rectA, NULL);
     SDLTest_AssertCheck(result == SDL_FALSE, "Check that function returns SDL_FALSE when 2nd parameter is NULL");
-    result = (SDL_bool)SDL_FRectEquals((const SDL_FRect *)NULL, (const SDL_FRect *)NULL);
+    result = SDL_FRectEquals(NULL, NULL);
     SDLTest_AssertCheck(result == SDL_FALSE, "Check that function returns SDL_FALSE when 1st and 2nd parameter are NULL");
 
     return TEST_COMPLETED;
diff --git a/test/testautomation_rwops.c b/test/testautomation_rwops.c
index b4b12a654..441ba73b3 100644
--- a/test/testautomation_rwops.c
+++ b/test/testautomation_rwops.c
@@ -39,9 +39,9 @@ void RWopsSetUp(void *arg)
     int result;
 
     /* Clean up from previous runs (if any); ignore errors */
-    remove(RWopsReadTestFilename);
-    remove(RWopsWriteTestFilename);
-    remove(RWopsAlphabetFilename);
+    (void)remove(RWopsReadTestFilename);
+    (void)remove(RWopsWriteTestFilename);
+    (void)remove(RWopsAlphabetFilename);
 
     /* Create a test file */
     handle = fopen(RWopsReadTestFilename, "w");
@@ -81,7 +81,7 @@ void RWopsTearDown(void *arg)
     /* Remove the created files to clean up; ignore errors for write filename */
     result = remove(RWopsReadTestFilename);
     SDLTest_AssertCheck(result == 0, "Verify result from remove(%s), expected 0, got %i", RWopsReadTestFilename, result);
-    remove(RWopsWriteTestFilename);
+    (void)remove(RWopsWriteTestFilename);
     result = remove(RWopsAlphabetFilename);
     SDLTest_AssertCheck(result == 0, "Verify result from remove(%s), expected 0, got %i", RWopsAlphabetFilename, result);
 
@@ -198,7 +198,7 @@ int rwops_testParamNegative(void)
     SDLTest_AssertPass("Call to SDL_RWFromFile(\"something\", NULL) succeeded");
     SDLTest_AssertCheck(rwops == NULL, "Verify SDL_RWFromFile(\"something\", NULL) returns NULL");
 
-    rwops = SDL_RWFromMem((void *)NULL, 10);
+    rwops = SDL_RWFromMem(NULL, 10);
     SDLTest_AssertPass("Call to SDL_RWFromMem(NULL, 10) succeeded");
     SDLTest_AssertCheck(rwops == NULL, "Verify SDL_RWFromMem(NULL, 10) returns NULL");
 
diff --git a/test/testautomation_sdltest.c b/test/testautomation_sdltest.c
index 53e357154..194a69d0f 100644
--- a/test/testautomation_sdltest.c
+++ b/test/testautomation_sdltest.c
@@ -24,9 +24,6 @@
 
 /* Test case functions */
 
-/* Forward declarations for internal harness functions */
-extern char *SDLTest_GenerateRunSeed(const int length);
-
 /**
  * @brief Calls to SDLTest_GenerateRunSeed()
  */
@@ -37,7 +34,7 @@ int sdltest_generateRunSeed(void *arg)
     int j;
 
     for (i = 1; i <= 10; i += 3) {
-        result = SDLTest_GenerateRunSeed((const int)i);
+        result = SDLTest_GenerateRunSeed((int)i);
         SDLTest_AssertPass("Call to SDLTest_GenerateRunSeed()");
         SDLTest_AssertCheck(result != NULL, "Verify returned value is not NULL");
         if (result != NULL) {
@@ -49,7 +46,7 @@ int sdltest_generateRunSeed(void *arg)
 
     /* Negative cases */
     for (j = -2; j <= 0; j++) {
-        result = SDLTest_GenerateRunSeed((const int)j);
+        result = SDLTest_GenerateRunSeed(j);
         SDLTest_AssertPass("Call to SDLTest_GenerateRunSeed()");
         SDLTest_AssertCheck(result == NULL, "Verify returned value is not NULL");
     }
@@ -136,7 +133,7 @@ int sdltest_randomNumber(void *arg)
     SDLTest_AssertPass("Call to SDLTest_RandomFloat");
     SDLTest_AssertCheck(dresult >= (double)(-FLT_MAX) && dresult <= (double)FLT_MAX, "Verify result value, expected: [%e,%e], got: %e", (double)(-FLT_MAX), (double)FLT_MAX, dresult);
 
-    dresult = (double)SDLTest_RandomUnitDouble();
+    dresult = SDLTest_RandomUnitDouble();
     SDLTest_AssertPass("Call to SDLTest_RandomUnitDouble");
     SDLTest_AssertCheck(dresult >= 0.0 && dresult < 1.0, "Verify result value, expected: [0.0,1.0[, got: %e", dresult);
 
@@ -487,63 +484,63 @@ int sdltest_randomBoundaryNumberUint64(void *arg)
     SDLTest_AssertPass("SDL_ClearError()");
 
     /* RandomUintXBoundaryValue(10, 10, SDL_TRUE) returns 10 */
-    uresult = (Uint64)SDLTest_RandomUint64BoundaryValue(10, 10, SDL_TRUE);
+    uresult = SDLTest_RandomUint64BoundaryValue(10, 10, SDL_TRUE);
     SDLTest_AssertPass("Call to SDLTest_RandomUint64BoundaryValue");
     SDLTest_AssertCheck(
         uresult == 10,
         "Validate result value for parameters (10,10,SDL_TRUE); expected: 10, got: %" SDL_PRIs64, uresult);
 
     /* RandomUintXBoundaryValue(10, 11, SDL_TRUE) returns 10, 11 */
-    uresult = (Uint64)SDLTest_RandomUint64BoundaryValue(10, 11, SDL_TRUE);
+    uresult = SDLTest_RandomUint64BoundaryValue(10, 11, SDL_TRUE);
     SDLTest_AssertPass("Call to SDLTest_RandomUint64BoundaryValue");
     SDLTest_AssertCheck(
         uresult == 10 || uresult == 11,
         "Validate result value for parameters (10,11,SDL_TRUE); expected: 10|11, got: %" SDL_PRIs64, uresult);
 
     /* RandomUintXBoundaryValue(10, 12, SDL_TRUE) returns 10, 11, 12 */
-    uresult = (Uint64)SDLTest_RandomUint64BoundaryValue(10, 12, SDL_TRUE);
+    uresult = SDLTest_RandomUint64BoundaryValue(10, 12, SDL_TRUE);
     SDLTest_AssertPass("Call to SDLTest_RandomUint64BoundaryValue");
     SDLTest_AssertCheck(
         uresult == 10 || uresult == 11 || uresult == 12,
         "Validate result value for parameters (10,12,SDL_TRUE); expected: 10|11|12, got: %" SDL_PRIs64, uresult);
 
     /* RandomUintXBoundaryValue(10, 13, SDL_TRUE) returns 10, 11, 12, 13 */
-    uresult = (Uint64)SDLTest_RandomUint64BoundaryValue(10, 13, SDL_TRUE);
+    uresult = SDLTest_RandomUint64BoundaryValue(10, 13, SDL_TRUE);
     SDLTest_AssertPass("Call to SDLTest_RandomUint64BoundaryValue");
     SDLTest_AssertCheck(
         uresult == 10 || uresult == 11 || uresult == 12 || uresult == 13,
         "Validate result value for parameters (10,13,SDL_TRUE); expected: 10|11|12|13, got: %" SDL_PRIs64, uresult);
 
     /* RandomUintXBoundaryValue(10, 20, SDL_TRUE) returns 10, 11, 19 or 20 */
-    uresult = (Uint64)SDLTest_RandomUint64BoundaryValue(10, 20, SDL_TRUE);
+    uresult = SDLTest_RandomUint64BoundaryValue(10, 20, SDL_TRUE);
     SDLTest_AssertPass("Call to SDLTest_RandomUint64BoundaryValue");
     SDLTest_AssertCheck(
         uresult == 10 || uresult == 11 || uresult == 19 || uresult == 20,
         "Validate result value for parameters (10,20,SDL_TRUE); expected: 10|11|19|20, got: %" SDL_PRIs64, uresult);
 
     /* RandomUintXBoundaryValue(20, 10, SDL_TRUE) returns 10, 11, 19 or 20 */
-    uresult = (Uint64)SDLTest_RandomUint64BoundaryValue(20, 10, SDL_TRUE);
+    uresult = SDLTest_RandomUint64BoundaryValue(20, 10, SDL_TRUE);
     SDLTest_AssertPass("Call to SDLTest_RandomUint64BoundaryValue");
     SDLTest_AssertCheck(
         uresult == 10 || uresult == 11 || uresult == 19 || uresult == 20,
         "Validate result value for parameters (20,10,SDL_TRUE); expected: 10|11|19|20, got: %" SDL_PRIs64, uresult);
 
     /* RandomUintXBoundaryValue(1, 20, SDL_FALSE) returns 0, 21 */
-    uresult = (Uint64)SDLTest_RandomUint64BoundaryValue(1, 20, SDL_FALSE);
+    uresult = SDLTest_RandomUint64BoundaryValue(1, 20, SDL_FALSE);
     SDLTest_AssertPass("Call to SDLTest_RandomUint64BoundaryValue");
     SDLTest_AssertCheck(
         uresult == 0 || uresult == 21,
         "Validate result value for parameters (1,20,SDL_FALSE); expected: 0|21, got: %" SDL_PRIs64, uresult);
 
     /* RandomUintXBoundaryValue(0, 99, SDL_FALSE) returns 100 */
-    uresult = (Uint64)SDLTest_RandomUint64BoundaryValue(0, 99, SDL_FALSE);
+    uresult = SDLTest_RandomUint64BoundaryValue(0, 99, SDL_FALSE);
     SDLTest_AssertPass("Call to SDLTest_RandomUint64BoundaryValue");
     SDLTest_AssertCheck(
         uresult == 100,
         "Validate result value for parameters (0,99,SDL_FALSE); expected: 100, got: %" SDL_PRIs64, uresult);
 
     /* RandomUintXBoundaryValue(1, 0xffffffffffffffff, SDL_FALSE) returns 0 (no error) */
-    uresult = (Uint64)SDLTest_RandomUint64BoundaryValue(1, (Uint64)0xffffffffffffffffULL, SDL_FALSE);
+    uresult = SDLTest_RandomUint64BoundaryValue(1, 0xffffffffffffffffULL, SDL_FALSE);
     SDLTest_AssertPass("Call to SDLTest_RandomUint64BoundaryValue");
     SDLTest_AssertCheck(
         uresult == 0,
@@ -553,17 +550,17 @@ int sdltest_randomBoundaryNumberUint64(void *arg)
     SDLTest_AssertCheck(lastError == NULL || lastError[0] == '\0', "Validate no error message was set");
 
     /* RandomUintXBoundaryValue(0, 0xfffffffffffffffe, SDL_FALSE) returns 0xffffffffffffffff (no error) */
-    uresult = (Uint64)SDLTest_RandomUint64BoundaryValue(0, (Uint64)0xfffffffffffffffeULL, SDL_FALSE);
+    uresult = SDLTest_RandomUint64BoundaryValue(0, 0xfffffffffffffffeULL, SDL_FALSE);
     SDLTest_AssertPass("Call to SDLTest_RandomUint64BoundaryValue");
     SDLTest_AssertCheck(
-        uresult == (Uint64)0xffffffffffffffffULL,
+        uresult == 0xffffffffffffffffULL,
         "Validate result value for parameters (0,0xfffffffffffffffe,SDL_FALSE); expected: 0xffffffffffffffff, got: %" SDL_PRIs64, uresult);
     lastError = (char *)SDL_GetError();
     SDLTest_AssertPass("SDL_GetError()");
     SDLTest_AssertCheck(lastError == NULL || lastError[0] == '\0', "Validate no error message was set");
 
     /* RandomUintXBoundaryValue(0, 0xffffffffffffffff, SDL_FALSE) returns 0 (sets error) */
-    uresult = (Uint64)SDLTest_RandomUint64BoundaryValue(0, (Uint64)0xffffffffffffffffULL, SDL_FALSE);
+    uresult = SDLTest_RandomUint64BoundaryValue(0, 0xffffffffffffffffULL, SDL_FALSE);
     SDLTest_AssertPass("Call to SDLTest_RandomUint64BoundaryValue");
     SDLTest_AssertCheck(
         uresult == 0,
@@ -930,63 +927,63 @@ int sdltest_randomBoundaryNumberSint64(void *arg)
     SDLTest_AssertPass("SDL_ClearError()");
 
     /* RandomSintXBoundaryValue(10, 10, SDL_TRUE) returns 10 */
-    sresult = (Sint64)SDLTest_RandomSint64BoundaryValue(10, 10, SDL_TRUE);
+    sresult = SDLTest_RandomSint64BoundaryValue(10, 10, SDL_TRUE);
     SDLTest_AssertPass("Call to SDLTest_RandomSint64BoundaryValue");
     SDLTest_AssertCheck(
         sresult == 10,
         "Validate result value for parameters (10,10,SDL_TRUE); expected: 10, got: %" SDL_PRIs64, sresult);
 
     /* RandomSintXBoundaryValue(10, 11, SDL_TRUE) returns 10, 11 */
-    sresult = (Sint64)SDLTest_RandomSint64BoundaryValue(10, 11, SDL_TRUE);
+    sresult = SDLTest_RandomSint64BoundaryValue(10, 11, SDL_TRUE);
     SDLTest_AssertPass("Call to SDLTest_RandomSint64BoundaryValue");
     SDLTest_AssertCheck(
         sresult == 10 || sresult == 11,
         "Validate result value for parameters (10,11,SDL_TRUE); expected: 10|11, got: %" SDL_PRIs64, sresult);
 
     /* RandomSintXBoundaryValue(10, 12, SDL_TRUE) returns 10, 11, 12 */
-    sresult = (Sint64)SDLTest_RandomSint64BoundaryValue(10, 12, SDL_TRUE);
+    sresult = SDLTest_RandomSint64BoundaryValue(10, 12, SDL_TRUE);
     SDLTest_AssertPass("Call to SDLTest_RandomSint64BoundaryValue");
     SDLTest_AssertCheck(
         sresult == 10 || sresult == 11 || sresult == 12,
         "Validate result value for parameters (10,12,SDL_TRUE); expected: 10|11|12, got: %" SDL_PRIs64, sresult);
 
     /* RandomSintXBoundaryValue(10, 13, SDL_TRUE) returns 10, 11, 12, 13 */
-    sresult = (Sint64)SDLTest_RandomSint64BoundaryValue(10, 13, SDL_TRUE);
+    sresult = SDLTest_RandomSint64BoundaryValue(10, 13, SDL_TRUE);
     SDLTest_AssertPass("Call to SDLTest_RandomSint64BoundaryValue");
     SDLTest_AssertCheck(
         sresult == 10 || sresult == 11 || sresult == 12 || sresult == 13,
         "Validate result value for parameters (10,13,SDL_TRUE); expected: 10|11|12|13, got: %" SDL_PRIs64, sresult);
 
     /* RandomSintXBoundaryValue(10, 20, SDL_TRUE) returns 10, 11, 19 or 20 */
-    sresult = (Sint64)SDLTest_RandomSint64BoundaryValue(10, 20, SDL_TRUE);
+    sresult = SDLTest_RandomSint64BoundaryValue(10, 20, SDL_TRUE);
     SDLTest_AssertPass("Call to SDLTest_RandomSint64BoundaryValue");
     SDLTest_AssertCheck(
         sresult == 10 || sresult == 11 || sresult == 19 || sresult == 20,
         "Validate result value for parameters (10,20,SDL_TRUE); expected: 10|11|19|20, got: %" SDL_PRIs64, sresult);
 
     /* RandomSintXBoundaryValue(20, 10, SDL_TRUE) returns 10, 11, 19 or 20 */
-    sresult = (Sint64)SDLTest_RandomSint64BoundaryValue(20, 10, SDL_TRUE);
+    sresult = SDLTest_RandomSint64BoundaryValue(20, 10, SDL_TRUE);
     SDLTest_AssertPass("Call to SDLTest_RandomSint64BoundaryValue");
     SDLTest_AssertCheck(
         sresult == 10 || sresult == 11 || sresult == 19 || sresult == 20,
         "Validate result value for parameters (20,10,SDL_TRUE); expected: 10|11|19|20, got: %" SDL_PRIs64, sresult);
 
     /* RandomSintXBoundaryValue(1, 20, SDL_FALSE) returns 0, 21 */
-    sresult = (Sint64)SDLTest_RandomSint64BoundaryValue(1, 20, SDL_FALSE);
+    sresult = SDLTest_RandomSint64BoundaryValue(1, 20, SDL_FALSE);
     SDLTest_AssertPass("Call to SDLTest_RandomSint64BoundaryValue");
     SDLTest_AssertCheck(
         sresult == 0 || sresult == 21,
         "Validate result value for parameters (1,20,SDL_FALSE); expected: 0|21, got: %" SDL_PRIs64, sresult);
 
     /* RandomSintXBoundaryValue(LLONG_MIN, 99, SDL_FALSE) returns 100 */
-    sresult = (Sint64)SDLTest_RandomSint64BoundaryValue(INT64_MIN, 99, SDL_FALSE);
+    sresult = SDLTest_RandomSint64BoundaryValue(INT64_MIN, 99, SDL_FALSE);
     SDLTest_AssertPass("Call to SDLTest_RandomSint64BoundaryValue");
     SDLTest_AssertCheck(
         sresult == 100,
         "Validate result value for parameters (LLONG_MIN,99,SDL_FALSE); expected: 100, got: %" SDL_PRIs64, sresult);
 
     /* RandomSintXBoundaryValue(LLONG_MIN + 1, LLONG_MAX, SDL_FALSE) returns LLONG_MIN (no error) */
-    sresult = (Sint64)SDLTest_RandomSint64BoundaryValue(INT64_MIN + 1, INT64_MAX, SDL_FALSE);
+    sresult = SDLTest_RandomSint64BoundaryValue(INT64_MIN + 1, INT64_MAX, SDL_FALSE);
     SDLTest_AssertPass("Call to SDLTest_RandomSint64BoundaryValue");
     SDLTest_AssertCheck(
         sresult == INT64_MIN,
@@ -996,7 +993,7 @@ int sdltest_randomBoundaryNumberSint64(void *arg)
     SDLTest_AssertCheck(lastError == NULL || lastError[0] == '\0', "Validate no error message was set");
 
     /* RandomSintXBoundaryValue(LLONG_MIN, LLONG_MAX - 1, SDL_FALSE) returns LLONG_MAX (no error) */
-    sresult = (Sint64)SDLTest_RandomSint64BoundaryValue(INT64_MIN, INT64_MAX - 1, SDL_FALSE);
+    sresult = SDLTest_RandomSint64BoundaryValue(INT64_MIN, INT64_MAX - 1, SDL_FALSE);
     SDLTest_AssertPass("Call to SDLTest_RandomSint64BoundaryValue");
     SDLTest_AssertCheck(
         sresult == INT64_MAX,
@@ -1006,7 +1003,7 @@ int sdltest_randomBoundaryNumberSint64(void *arg)
     SDLTest_AssertCheck(lastError == NULL || lastError[0] == '\0', "Validate no error message was set");
 
     /* RandomSintXBoundaryValue(LLONG_MIN, LLONG_MAX, SDL_FALSE) returns 0 (sets error) */
-    sresult = (Sint64)SDLTest_RandomSint64BoundaryValue(INT64_MIN, INT64_MAX, SDL_FALSE);
+    sresult = SDLTest_RandomSint64BoundaryValue(INT64_MIN, INT64_MAX, SDL_FALSE);
     SDLTest_AssertPass("Call to SDLTest_RandomSint64BoundaryValue");
     SDLTest_AssertCheck(
         sresult == INT64_MIN,
diff --git a/test/testautomation_stdlib.c b/test/testautomation_stdlib.c
index 1f26a6509..3f45cbf9e 100644
--- a/test/testautomation_stdlib.c
+++ b/test/testautomation_stdlib.c
@@ -383,7 +383,7 @@ int stdlib_sscanf(void *arg)
     SIZED_TEST_CASE(long long, long_long, "%lld")
 
     size_output = 123;
-    expected_size_output = (size_t)~0;
+    expected_size_output = ~((size_t)0);
     expected_result = 1;
     result = SDL_snprintf(text, sizeof(text), "%zu", expected_size_output);
     result = SDL_sscanf(text, "%zu", &size_output);
diff --git a/test/testautomation_video.c b/test/testautomation_video.c
index 2e4a6920e..3f01c634e 100644
--- a/test/testautomation_video.c
+++ b/test/testautomation_video.c
@@ -450,13 +450,15 @@ int video_getClosestDisplayModeCurrentResolution(void *arg)
             /* Make call */
             dResult = SDL_GetClosestDisplayMode(i, &target, &closest);
             SDLTest_AssertPass("Call to SDL_GetClosestDisplayMode(target=current/variation%d)", variation);
-            SDLTest_AssertCheck(dResult != NULL, "Verify returned value is not NULL");
+            SDLTest_Assert(dResult != NULL, "Verify returned value is not NULL");
 
             /* Check that one gets the current resolution back again */
             SDLTest_AssertCheck(closest.w == current.w, "Verify returned width matches current width; expected: %d, got: %d", current.w, closest.w);
             SDLTest_AssertCheck(closest.h == current.h, "Verify returned height matches current height; expected: %d, got: %d", current.h, closest.h);
+            /* NOLINTBEGIN(clang-analyzer-core.NullDereference): Checked earlier for NULL */
             SDLTest_AssertCheck(closest.w == dResult->w, "Verify return value matches assigned value; expected: %d, got: %d", closest.w, dResult->w);
             SDLTest_AssertCheck(closest.h == dResult->h, "Verify return value matches assigned value; expected: %d, got: %d", closest.h, dResult->h);
+            /* NOLINTEND(clang-analyzer-core.NullDereference) */
         }
     }
 
@@ -1685,7 +1687,7 @@ int video_getSetWindowData(void *arg)
         returnValue = TEST_ABORTED;
         goto cleanup;
     }
-    userdata2 = (char *)SDL_strdup(referenceUserdata2);
+    userdata2 = SDL_strdup(referenceUserdata2);
     if (userdata2 == NULL) {
         returnValue = TEST_ABORTED;
         goto cleanup;
diff --git a/test/testcustomcursor.c b/test/testcustomcursor.c
index 81d72c9cb..8a4a48d8e 100644
--- a/test/testcustomcursor.c
+++ b/test/testcustomcursor.c
@@ -102,7 +102,8 @@ init_system_cursor(const char *image[])
     int i, row, col;
     Uint8 data[4 * 32];
     Uint8 mask[4 * 32];
-    int hot_x, hot_y;
+    int hot_x = 0;
+    int hot_y = 0;
 
     i = -1;
     for (row = 0; row < 32; ++row) {
@@ -127,7 +128,7 @@ init_system_cursor(const char *image[])
             }
         }
     }
-    SDL_sscanf(image[4 + row], "%d,%d", &hot_x, &hot_y);
+    (void)SDL_sscanf(image[4 + row], "%d,%d", &hot_x, &hot_y);
     return SDL_CreateCursor(data, mask, 32, 32, hot_x, hot_y);
 }
 
diff --git a/test/testdisplayinfo.c b/test/testdisplayinfo.c
index 9c1c1f520..136ed93c6 100644
--- a/test/testdisplayinfo.c
+++ b/test/testdisplayinfo.c
@@ -80,7 +80,7 @@ int main(int argc, char *argv[])
                 SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "    MODE %d: failed to query (%s)\n", m, SDL_GetError());
             } else {
                 char prefix[64];
-                SDL_snprintf(prefix, sizeof(prefix), "    MODE %d", m);
+                (void)SDL_snprintf(prefix, sizeof prefix, "    MODE %d", m);
                 print_mode(prefix, &mode);
             }
         }
diff --git a/test/testfile.c b/test/testfile.c
index 225ed7d5c..1a2f15af6 100644
--- a/test/testfile.c
+++ b/test/testfile.c
@@ -171,7 +171,7 @@ int main(int argc, char *argv[])
     if (7 != rwops->read(rwops, test_buf, 1, 7)) {
         RWOP_ERR_QUIT(rwops);
     }
-    if (SDL_memcmp(test_buf, "1234567", 7)) {
+    if (SDL_memcmp(test_buf, "1234567", 7) != 0) {
         RWOP_ERR_QUIT(rwops);
     }
     if (0 != rwops->read(rwops, test_buf, 1, 1)) {
@@ -186,7 +186,7 @@ int main(int argc, char *argv[])
     if (2 != rwops->read(rwops, test_buf, 10, 3)) {
         RWOP_ERR_QUIT(rwops);
     }
-    if (SDL_memcmp(test_buf, "12345678901234567890", 20)) {
+    if (SDL_memcmp(test_buf, "12345678901234567890", 20) != 0) {
         RWOP_ERR_QUIT(rwops);
     }
     if (0 != rwops->write(rwops, test_buf, 1, 1)) {
@@ -225,7 +225,7 @@ int main(int argc, char *argv[])
     if (7 != rwops->read(rwops, test_buf, 1, 7)) {
         RWOP_ERR_QUIT(rwops);
     }
-    if (SDL_memcmp(test_buf, "1234567", 7)) {
+    if (SDL_memcmp(test_buf, "1234567", 7) != 0) {
         RWOP_ERR_QUIT(rwops);
     }
     if (0 != rwops->read(rwops, test_buf, 1, 1)) {
@@ -240,7 +240,7 @@ int main(int argc, char *argv[])
     if (2 != rwops->read(rwops, test_buf, 10, 3)) {
         RWOP_ERR_QUIT(rwops);
     }
-    if (SDL_memcmp(test_buf, "12345678901234567890", 20)) {
+    if (SDL_memcmp(test_buf, "12345678901234567890", 20) != 0) {
         RWOP_ERR_QUIT(rwops);
     }
     rwops->close(rwops);
@@ -276,7 +276,7 @@ int main(int argc, char *argv[])
     if (7 != rwops->read(rwops, test_buf, 1, 7)) {
         RWOP_ERR_QUIT(rwops);
     }
-    if (SDL_memcmp(test_buf, "1234567", 7)) {
+    if (SDL_memcmp(test_buf, "1234567", 7) != 0) {
         RWOP_ERR_QUIT(rwops);
     }
     if (0 != rwops->read(rwops, test_buf, 1, 1)) {
@@ -291,7 +291,7 @@ int main(int argc, char *argv[])
     if (2 != rwops->read(rwops, test_buf, 10, 3)) {
         RWOP_ERR_QUIT(rwops);
     }
-    if (SDL_memcmp(test_buf, "12345678901234567890", 20)) {
+    if (SDL_memcmp(test_buf, "12345678901234567890", 20) != 0) {
         RWOP_ERR_QUIT(rwops);
     }
     rwops->close(rwops);
@@ -328,7 +328,7 @@ int main(int argc, char *argv[])
     if (7 != rwops->read(rwops, test_buf, 1, 7)) {
         RWOP_ERR_QUIT(rwops);
     }
-    if (SDL_memcmp(test_buf, "1234567", 7)) {
+    if (SDL_memcmp(test_buf, "1234567", 7) != 0) {
         RWOP_ERR_QUIT(rwops);
     }
     if (0 != rwops->read(rwops, test_buf, 1, 1)) {
@@ -348,7 +348,7 @@ int main(int argc, char *argv[])
     if (3 != rwops->read(rwops, test_buf, 10, 3)) {
         RWOP_ERR_QUIT(rwops);
     }
-    if (SDL_memcmp(test_buf, "123456789012345678901234567123", 30)) {
+    if (SDL_memcmp(test_buf, "123456789012345678901234567123", 30) != 0) {
         RWOP_ERR_QUIT(rwops);
     }
     rwops->close(rwops);
diff --git a/test/testgamecontroller.c b/test/testgamecontroller.c
index a2f0d0e5a..4cbfcd811 100644
--- a/test/testgamecontroller.c
+++ b/test/testgamecontroller.c
@@ -744,7 +744,7 @@ void loop(void *arg)
                 Uint8 r, g, b;
 
                 if (x < 0) {
-                    r = (Uint8)(((int)(~x) * 255) / 32767);
+                    r = (Uint8)(((~x) * 255) / 32767);
                     b = 0;
                 } else {
                     r = 0;
diff --git a/test/testgles2.c b/test/testgles2.c
index e67746bc5..885fd624d 100644
--- a/test/testgles2.c
+++ b/test/testgles2.c
@@ -189,7 +189,7 @@ perspective_matrix(float fovy, float aspect, float znear, float zfar, float *r)
  * major. In-place multiplication is supported.
  */
 static void
-multiply_matrix(float *lhs, float *rhs, float *r)
+multiply_matrix(const float *lhs, const float *rhs, float *r)
 {
     int i, j, k;
     float tmp[16];
diff --git a/test/testiconv.c b/test/testiconv.c
index 084821a37..6da9c0171 100644
--- a/test/testiconv.c
+++ b/test/testiconv.c
@@ -86,10 +86,10 @@ int main(int argc, char *argv[])
         }
         test[0] = SDL_iconv_string("UTF-8", "UCS-4", ucs4, len);
         SDL_free(ucs4);
-        fputs(test[0], stdout);
+        (void)fputs(test[0], stdout);
         SDL_free(test[0]);
     }
-    fclose(file);
+    (void)fclose(file);
 
     SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "Total errors: %d\n", errors);
     return errors ? errors + 1 : 0;
diff --git a/test/testime.c b/test/testime.c
index c0e580c16..3e8cd97a5 100644
--- a/test/testime.c
+++ b/test/testime.c
@@ -159,15 +159,15 @@ static int unifont_init(const char *fontname)
         }
 
         /* Looking for the colon that separates the codepoint and glyph data at position 2, 4, 6 and 8. */
-        if (hexBuffer[2] == ':')
+        if (hexBuffer[2] == ':') {
             codepointHexSize = 2;
-        else if (hexBuffer[4] == ':')
+        } else if (hexBuffer[4] == ':') {
             codepointHexSize = 4;
-        else if (hexBuffer[6] == ':')
+        } else if (hexBuffer[6] == ':') {
             codepointHexSize = 6;
-        else if (hexBuffer[8] == ':')
+        } else if (hexBuffer[8] == ':') {
             codepointHexSize = 8;
-        else {
+        } else {
             SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "unifont: Could not find codepoint and glyph data separator symbol in hex file on line %d.\n", lineNumber);
             return -1;
         }
@@ -190,9 +190,9 @@ static int unifont_init(const char *fontname)
             SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "unifont: Unexpected end of hex file.\n");
             return -1;
         }
-        if (hexBuffer[32] == '\n')
+        if (hexBuffer[32] == '\n') {
             glyphWidth = 8;
-        else {
+        } else {
             glyphWidth = 16;
             bytesRead = SDL_RWread(hexFile, hexBuffer + 33, 1, 32);
             if (bytesRead < 32) {
@@ -207,9 +207,9 @@ static int unifont_init(const char *fontname)
         }
 
         if (codepoint <= UNIFONT_MAX_CODEPOINT) {
-            if (unifontGlyph[codepoint].width > 0)
+            if (unifontGlyph[codepoint].width > 0) {
                 SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "unifont: Ignoring duplicate codepoint 0x%08" SDL_PRIx32 " in hex file on line %d.\n", codepoint, lineNumber);
-            else {
+            } else {
                 unifontGlyph[codepoint].width = glyphWidth;
                 /* Pack the hex data into a more compact form. */
                 for (i = 0; i < glyphWidth * 2; i++) {
@@ -227,7 +227,8 @@ static int unifont_init(const char *fontname)
     return 0;
 }
 
-static void unifont_make_rgba(Uint8 *src, Uint8 *dst, Uint8 width)
+static void
+unifont_make_rgba(const Uint8 *src, Uint8 *dst, Uint8 width)
 {
     int i, j;
     Uint8 *row = dst;
@@ -279,7 +280,7 @@ static int unifont_load_texture(Uint32 textureID)
         Uint32 codepoint = UNIFONT_GLYPHS_IN_TEXTURE * textureID + i;
         if (unifontGlyph[codepoint].width > 0) {
             const Uint32 cInTex = codepoint % UNIFONT_GLYPHS_IN_TEXTURE;
-            const size_t offset = (cInTex / UNIFONT_GLYPHS_IN_ROW) * UNIFONT_TEXTURE_PITCH * 16 + (cInTex % UNIFONT_GLYPHS_IN_ROW) * 16 * 4;
+            const size_t offset = ((size_t)cInTex / UNIFONT_GLYPHS_IN_ROW) * UNIFONT_TEXTURE_PITCH * 16 + (cInTex % UNIFONT_GLYPHS_IN_ROW) * 16 * 4;
             unifont_make_rgba(unifontGlyph[codepoint].data, textureRGBA + offset, unifontGlyph[codepoint].width);
         }
     }
@@ -362,16 +363,16 @@ static void unifont_cleanup()
 size_t utf8_length(unsigned char c)
 {
     c = (unsigned char)(0xff & c);
-    if (c < 0x80)
+    if (c < 0x80) {
         return 1;
-    else if ((c >> 5) == 0x6)
+    } else if ((c >> 5) == 0x6) {
         return 2;
-    else if ((c >> 4) == 0xe)
+    } else if ((c >> 4) == 0xe) {
         return 3;
-    else if ((c >> 3) == 0x1e)
+    } else if ((c >> 3) == 0x1e) {
         return 4;
-    else
-        return 0;
+    }
+    return 0;
 }
 
 char *utf8_next(char *p)
@@ -409,9 +410,9 @@ Uint32 utf8_decode(char *p, size_t len)
     }
 
     for (; i < len; ++i) {
-        if (i == 0)
+        if (i == 0) {
             codepoint = (0xff >> len) & *p;
-        else {
+        } else {
             codepoint <<= 6;
             codepoint |= 0x3f & *p;
         }
@@ -641,9 +642,9 @@ int main(int argc, char *argv[])
             argc--;
             argv++;
 
-            if (argc > 0)
+            if (argc > 0) {
                 fontname = argv[0];
-            else {
+            } else {
                 usage();
                 return 0;
             }
diff --git a/test/testintersections.c b/test/testintersections.c
index ac21da074..d6b47e565 100644
--- a/test/testintersections.c
+++ b/test/testintersections.c
@@ -173,7 +173,7 @@ DrawRectLineIntersections(SDL_Renderer *renderer)
 
     SDL_SetRenderDrawColor(renderer, 0, 255, 55, 255);
 
-    for (i = 0; i < num_rects; i++)
+    for (i = 0; i < num_rects; i++) {
         for (j = 0; j < num_lines; j++) {
             int x1, y1, x2, y2;
             SDL_Rect r;
@@ -188,6 +188,7 @@ DrawRectLineIntersections(SDL_Renderer *renderer)
                 SDL_RenderDrawLine(renderer, x1, y1, x2, y2);
             }
         }
+    }
 }
 
 static void
@@ -197,13 +198,14 @@ DrawRectRectIntersections(SDL_Renderer *renderer)
 
     SDL_SetRenderDrawColor(renderer, 255, 200, 0, 255);
 
-    for (i = 0; i < num_rects; i++)
+    for (i = 0; i < num_rects; i++) {
         for (j = i + 1; j < num_rects; j++) {
             SDL_Rect r;
             if (SDL_IntersectRect(&rects[i], &rects[j], &r)) {
                 SDL_RenderFillRect(renderer, &r);
             }
         }
+    }
 }
 
 void loop()
@@ -230,18 +232,20 @@ void loop()
         case SDL_KEYDOWN:
             switch (event.key.keysym.sym) {
             case 'l':
-                if (event.key.keysym.mod & KMOD_SHIFT)
+                if (event.key.keysym.mod & KMOD_SHIFT) {
                     num_lines = 0;
-                else
+                } else {
                     add_line(rand() % 640, rand() % 480, rand() % 640,
                              rand() % 480);
+                }
                 break;
             case 'r':
-                if (event.key.keysym.mod & KMOD_SHIFT)
+                if (event.key.keysym.mod & KMOD_SHIFT) {
                     num_rects = 0;
-                else
+                } else {
                     add_rect(rand() % 640, rand() % 480, rand() % 640,
                              rand() % 480);
+                }
                 break;
             }
             break;
diff --git a/test/testloadso.c b/test/testloadso.c
index 1665814fa..7c8de1756 100644
--- a/test/testloadso.c
+++ b/test/testloadso.c
@@ -67,11 +67,9 @@ int main(int argc, char *argv[])
             SDL_Log("Found %s in %s at %p\n", symname, libname, fn);
             if (hello) {
                 SDL_Log("Calling function...\n");
-                fflush(stdout);
                 fn("     HELLO, WORLD!\n");
                 SDL_Log("...apparently, we survived.  :)\n");
                 SDL_Log("Unloading library...\n");
-                fflush(stdout);
             }
         }
         SDL_UnloadObject(lib);
diff --git a/test/testlock.c b/test/testlock.c
index 3b48d3468..dfecd9663 100644
--- a/test/testlock.c
+++ b/test/testlock.c
@@ -42,7 +42,7 @@ void printid(void)
 
 void terminate(int sig)
 {
-    signal(SIGINT, terminate);
+    (void)signal(SIGINT, terminate);
     SDL_AtomicSet(&doterminate, 1);
 }
 
@@ -63,7 +63,7 @@ int SDLCALL
 Run(void *data)
 {
     if (SDL_ThreadID() == mainthread) {
-        signal(SIGTERM, closemutex);
+        (void)signal(SIGTERM, closemutex);
     }
     while (!SDL_AtomicGet(&doterminate)) {
         SDL_Log("Process %lu ready to work\n", SDL_ThreadID());
@@ -83,7 +83,7 @@ Run(void *data)
     }
     if (SDL_ThreadID() == mainthread && SDL_AtomicGet(&doterminate)) {
         SDL_Log("Process %lu:  raising SIGTERM\n", SDL_ThreadID());
-        raise(SIGTERM);
+        (void)raise(SIGTERM);
     }
     return 0;
 }
@@ -101,26 +101,28 @@ int main(int argc, char *argv[])
         SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s\n", SDL_GetError());
         exit(1);
     }
-    atexit(SDL_Quit_Wrapper);
+    (void)atexit(SDL_Quit_Wrapper);
 
     SDL_AtomicSet(&doterminate, 0);
 
-    if ((mutex = SDL_CreateMutex()) == NULL) {
+    mutex = SDL_CreateMutex();
+    if (mutex == NULL) {
         SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Couldn't create mutex: %s\n", SDL_GetError());
         exit(1);
     }
 
     mainthread = SDL_ThreadID();
     SDL_Log("Main thread: %lu\n", mainthread);
-    atexit(printid);
+    (void)atexit(printid);
     for (i = 0; i < maxproc; ++i) {
         char name[64];
-        SDL_snprintf(name, sizeof(name), "Worker%d", i);
-        if ((threads[i] = SDL_CreateThread(Run, name, NULL)) == NULL) {
+        (void)SDL_snprintf(name, sizeof name, "Worker%d", i);
+        threads[i] = SDL_CreateThread(Run, name, NULL);
+        if (threads[i] == NULL) {
             SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Couldn't create thread!\n");
         }
     }
-    signal(SIGINT, terminate);
+    (void)signal(SIGINT, terminate);
     Run(NULL);
 
     return 0; /* Never reached */
diff --git a/test/testmultiaudio.c b/test/testmultiaudio.c
index 48171ff24..ef4c20ec8 100644
--- a/test/testmultiaudio.c
+++ b/test/testmultiaudio.c
@@ -90,7 +90,6 @@ test_multi_audio(int devcount)
     for (i = 0; i < devcount; i++) {
         const char *devname = SDL_GetAudioDeviceName(i, 0);
         SDL_Log("playing on device #%d: ('%s')...", i, devname);
-        fflush(stdout);
 
         SDL_memset(&cbd[0], '\0', sizeof(callback_data));
         spec.userdata = &cbd[0];
diff --git a/test/testnative.c b/test/testnative.c
index ff0973338..d73758701 100644
--- a/test/testnative.c
+++ b/test/testnative.c
@@ -47,7 +47,7 @@ static void
 quit(int rc)
 {
     SDL_VideoQuit();
-    if (native_window) {
+    if (native_window != NULL && factory != NULL) {
         factory->DestroyNativeWindow(native_window);
     }
     exit(rc);
diff --git a/test/testoverlay2.c b/test/testoverlay2.c
index f388fabff..9d96f7fea 100644
--- a/test/testoverlay2.c
+++ b/test/testoverlay2.c
@@ -319,6 +319,7 @@ int main(int argc, char **argv)
     filename = GetResourceFilename(NULL, "moose.dat");
     if (filename == NULL) {
         SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Out of memory\n");
+        SDL_free(RawMooseData);
         return -1;
     }
     handle = SDL_RWFromFile(filename, "rb");
diff --git a/test/testpower.c b/test/testpower.c
index 96a89334c..1c4596ff2 100644
--- a/test/testpower.c
+++ b/test/testpower.c
@@ -54,8 +54,7 @@ report_power(void)
     if (seconds == -1) {
         SDL_Log("Time left: unknown\n");
     } else {
-        SDL_Log("Time left: %d minutes, %d seconds\n", (int)(seconds / 60),
-                (int)(seconds % 60));
+        SDL_Log("Time left: %d minutes, %d seconds\n", seconds / 60, seconds % 60);
     }
 }
 
diff --git a/test/testqsort.c b/test/testqsort.c
index 0f89829e2..adc041ae3 100644
--- a/test/testqsort.c
+++ b/test/testqsort.c
@@ -51,10 +51,11 @@ int main(int argc, char *argv[])
     if (argc > 1) {
         int success;
         Uint64 seed = 0;
-        if (argv[1][0] == '0' && argv[1][1] == 'x')
+        if (argv[1][0] == '0' && argv[1][1] == 'x') {
             success = SDL_sscanf(argv[1] + 2, "%" SDL_PRIx64, &seed);
-        else
+        } else {
             success = SDL_sscanf(argv[1], "%" SDL_PRIu64, &seed);
+        }
         if (!success) {
             SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Invalid seed. Use a decimal or hexadecimal number.\n");
             return 1;
diff --git a/test/testresample.c b/test/testresample.c
index 1bcbebac6..3a3ee8130 100644
--- a/test/testresample.c
+++ b/test/testresample.c
@@ -56,7 +56,7 @@ int main(int argc, char **argv)
     }
 
     cvt.len = len;
-    cvt.buf = (Uint8 *)SDL_malloc(len * cvt.len_mult);
+    cvt.buf = (Uint8 *)SDL_malloc((size_t)len * cvt.len_mult);
     if (cvt.buf == NULL) {
         SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Out of memory.\n");
         SDL_FreeWAV(data);
diff --git a/test/testsem.c b/test/testsem.c
index efbe78f76..2b36a3a82 100644
--- a/test/testsem.c
+++ b/test/testsem.c
@@ -76,7 +76,7 @@ TestRealWorld(int init_sem)
     /* Create all the threads */
     for (i = 0; i < NUM_THREADS; ++i) {
         char name[64];
-        SDL_snprintf(name, sizeof(name), "Thread%u", (unsigned int)i);
+        (void)SDL_snprintf(name, sizeof name, "Thread%u", (unsigned int)i);
         thread_states[i].number = i;
         thread_states[i].thread = SDL_CreateThread(ThreadFuncRealWorld, name, (void *)&thread_states[i]);
     }
@@ -198,7 +198,7 @@ TestOverheadContended(SDL_bool try_wait)
     /* Create multiple threads to starve the semaphore and cause contention */
     for (i = 0; i < NUM_THREADS; ++i) {
         char name[64];
-        SDL_snprintf(name, sizeof(name), "Thread%u", (unsigned int)i);
+        (void)SDL_snprintf(name, sizeof name, "Thread%u", (unsigned int)i);
         thread_states[i].flag = try_wait;
         thread_states[i].thread = SDL_CreateThread(ThreadFuncOverheadContended, name, (void *)&thread_states[i]);
     }
@@ -229,17 +229,17 @@ TestOverheadContended(SDL_bool try_wait)
             duration, try_wait ? "where contended" : "timed out", content_count,
             loop_count, ((float)content_count * 100) / loop_count);
     /* Print how many semaphores where consumed per thread */
-    SDL_snprintf(textBuffer, sizeof(textBuffer), "{ ");
+    (void)SDL_snprintf(textBuffer, sizeof textBuffer, "{ ");
     for (i = 0; i < NUM_THREADS; ++i) {
         if (i > 0) {
             len = SDL_strlen(textBuffer);
-            SDL_snprintf(textBuffer + len, sizeof(textBuffer) - len, ", ");
+            (void)SDL_snprintf(textBuffer + len, sizeof textBuffer - len, ", ");
         }
         len = SDL_strlen(textBuffer);
-        SDL_snprintf(textBuffer + len, sizeof(textBuffer) - len, "%d", thread_states[i].loop_count - thread_states[i].content_count);
+        (void)SDL_snprintf(textBuffer + len, sizeof textBuffer - len, "%d", thread_states[i].loop_count - thread_states[i].content_count);
     }
     len = SDL_strlen(textBuffer);
-    SDL_snprintf(textBuffer + len, sizeof(textBuffer) - len, " }\n");
+    (void)SDL_snprintf(textBuffer + len, sizeof textBuffer - len, " }\n");
     SDL_Log("%s\n", textBuffer);
 
     SDL_DestroySemaphore(sem);
@@ -262,8 +262,8 @@ int main(int argc, char **argv)
         SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Couldn't initialize SDL: %s\n", SDL_GetError());
         return 1;
     }
-    signal(SIGTERM, killed);
-    signal(SIGINT, killed);
+    (void)signal(SIGTERM, killed);
+    (void)signal(SIGINT, killed);
 
     init_sem = SDL_atoi(argv[1]);
     if (init_sem > 0) {
diff --git a/test/testsensor.c b/test/testsensor.c
index 1e207e13f..9eb1a091d 100644
--- a/test/testsensor.c
+++ b/test/testsensor.c
@@ -28,7 +28,7 @@ static const char *GetSensorTypeString(SDL_SensorType type)
     case SDL_SENSOR_GYRO:
         return "SDL_SENSOR_GYRO";
     default:
-        SDL_snprintf(unknown_type, sizeof(unknown_type), "UNKNOWN (%d)", type);
+        (void)SDL_snprintf(unknown_type, sizeof unknown_type, "UNKNOWN (%d)", type);
         return unknown_type;
     }
 }
diff --git a/test/testshader.c b/test/testshader.c
index 7a1a4e0a6..366b91ac4 100644
--- a/test/testshader.c
+++ b/test/testshader.c
@@ -134,7 +134,7 @@ static SDL_bool CompileShader(GLhandleARB shader, const char *source)
         char *info;
 
         glGetObjectParameterivARB(shader, GL_OBJECT_INFO_LOG_LENGTH_ARB, &length);
-        info = (char *)SDL_malloc(length + 1);
+        info = (char *)SDL_malloc((size_t)length + 1);
         if (info == NULL) {
             SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Out of memory!");
         } else {
@@ -162,7 +162,7 @@ static SDL_bool LinkProgram(ShaderData *data)
         char *info;
 
         glGetObjectParameterivARB(data->program, GL_OBJECT_INFO_LOG_LENGTH_ARB, &length);
-        info = (char *)SDL_malloc(length + 1);
+        info = (char *)SDL_malloc((size_t)length + 1);
         if (info == NULL) {
             SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Out of memory!");
         } else {
@@ -208,7 +208,7 @@ static SDL_bool CompileShaderProgram(ShaderData *data)
     glUseProgramObjectARB(data->program);
     for (i = 0; i < num_tmus_bound; ++i) {
         char tex_name[5];
-        SDL_snprintf(tex_name, SDL_arraysize(tex_name), "tex%d", i);
+        (void)SDL_snprintf(tex_name, SDL_arraysize(tex_name), "tex%d", i);
         location = glGetUniformLocationARB(data->program, tex_name);
         if (location >= 0) {
             glUniform1iARB(location, i);
diff --git a/test/testshape.c b/test/testshape.c
index fa8de5e0a..4676de855 100644
--- a/test/testshape.c
+++ b/test/testshape.c
@@ -158,7 +158,7 @@ int main(int argc, char **argv)
     texture_dimensions.x = 0;
     texture_dimensions.y = 0;
     SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "Changing to shaped bmp: %s", pictures[current_picture].name);
-    SDL_QueryTexture(pictures[current_picture].texture, (Uint32 *)&pixelFormat, (int *)&access, &texture_dimensions.w, &texture_dimensions.h);
+    SDL_QueryTexture(pictures[current_picture].texture, &pixelFormat, &access, &texture_dimensions.w, &texture_dimensions.h);
     SDL_SetWindowSize(window, texture_dimensions.w, texture_dimensions.h);
     SDL_SetWindowShape(window, pictures[current_picture].surface, &pictures[current_picture].mode);
     while (should_exit == 0) {
@@ -177,7 +177,7 @@ int main(int argc, char **argv)
                     current_picture = 0;
                 }
                 SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "Changing to shaped bmp: %s", pictures[current_picture].name);
-                SDL_QueryTexture(pictures[current_picture].texture, (Uint32 *)&pixelFormat, (int *)&access, &texture_dimensions.w, &texture_dimensions.h);
+                SDL_QueryTexture(pictures[current_picture].texture, &pixelFormat, &access, &texture_dimensions.w, &texture_dimensions.h);
                 SDL_SetWindowSize(window, texture_dimensions.w, texture_dimensions.h);
                 SDL_SetWindowShape(window, pictures[current_picture].surface, &pictures[current_picture].mode);
             }
diff --git a/test/testthread.c b/test/testthread.c
index faa022e8c..6bf6c2a57 100644
--- a/test/testthread.c
+++ b/test/testthread.c
@@ -126,13 +126,13 @@ int main(int argc, char *argv[])
     SDL_Log("Main thread data finally: %s\n", (const char *)SDL_TLSGet(tls));
 
     alive = 1;
-    signal(SIGTERM, killed);
+    (void)signal(SIGTERM, killed);
     thread = SDL_CreateThread(ThreadFunc, "Two", "#2");
     if (thread == NULL) {
         SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Couldn't create thread: %s\n", SDL_GetError());
         quit(1);
     }
-    raise(SIGTERM);
+    (void)raise(SIGTERM);
 
     SDL_Quit(); /* Never reached */
     return 0;   /* Never reached */
diff --git a/test/testutils.c b/test/testutils.c
index 024003052..a28e2b6ba 100644
--- a/test/testutils.c
+++ b/test/testutils.c
@@ -33,7 +33,7 @@ GetNearbyFilename(const char *file)
             return NULL;
         }
 
-        SDL_snprintf(path, len, "%s%s", base, file);
+        (void)SDL_snprintf(path, len, "%s%s", base, file);
         SDL_free(base);
 
         rw = SDL_RWFromFile(path, "rb");
diff --git a/test/testvulkan.c b/test/testvulkan.c
index 64319a408..93ef598d9 100644
--- a/test/testvulkan.c
+++ b/test/testvulkan.c
@@ -897,7 +897,9 @@ static void rerecordCommandBuffer(uint32_t frameIndex, const VkClearColorValue *
 
 static void destroySwapchainAndSwapchainSpecificStuff(SDL_bool doDestroySwapchain)
 {
-    vkDeviceWaitIdle(vulkanContext->device);
+    if (vkDeviceWaitIdle != NULL) {
+        vkDeviceWaitIdle(vulkanContext->device);
+    }
     destroyFences();
     destroyCommandBuffers();
     destroyCommandPool();
diff --git a/test/testwm2.c b/test/testwm2.c
index 01c3642a5..522ccacbd 100644
--- a/test/testwm2.c
+++ b/test/testwm2.c
@@ -83,12 +83,12 @@ draw_modes_menu(SDL_Window *window, SDL_Renderer *renderer, SDL_Rect viewport)
 
     y += lineHeight;
 
-    SDL_snprintf(text, sizeof(text), "Click on a mode to set it with SDL_SetWindowDisplayMode");
+    SDL_strlcpy(text, "Click on a mode to set it with SDL_SetWindowDisplayMode", sizeof text);
     SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);
     SDLTest_DrawString(renderer, x, y, text);
     y += lineHeight;
 
-    SDL_snprintf(text, sizeof(text), "Press Ctrl+Enter to toggle SDL_WINDOW_FULLSCREEN");
+    SDL_strlcpy(text, "Press Ctrl+Enter to toggle SDL_WINDOW_FULLSCREEN", sizeof text);
     SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);
     SDLTest_DrawString(renderer, x, y, text);
     y += lineHeight;
@@ -107,8 +107,8 @@ draw_modes_menu(SDL_Window *window, SDL_Renderer *renderer, SDL_Rect viewport)
             return;
         }
 
-        SDL_snprintf(text, sizeof(text), "%d: %dx%d@%dHz",
-                     i, mode.w, mode.h, mode.refresh_rate);
+        (void)SDL_snprintf(text, sizeof text, "%d: %dx%d@%dHz",
+                           i, mode.w, mode.h, mode.refresh_rate);
 
         /* Update column width */
         text_length = (int)SDL_strlen(text);
diff --git a/test/testyuv.c b/test/testyuv.c
index 788a65acb..ab4547268 100644
--- a/test/testyuv.c
+++ b/test/testyuv.c
@@ -436,7 +436,7 @@ int main(int argc, char **argv)
             if (current == 0) {
                 SDLTest_DrawString(renderer, 4, 4, titles[current]);
             } else {
-                SDL_snprintf(title, sizeof(title), "%s %s %s", titles[current], yuv_name, yuv_mode);
+                (void)SDL_snprintf(title, sizeof title, "%s %s %s", titles[current], yuv_name, yuv_mode);
                 SDLTest_DrawString(renderer, 4, 4, title);
             }
             SDL_RenderPresent(renderer);
diff --git a/test/testyuv_cvt.c b/test/testyuv_cvt.c
index 4c9ebdbe3..0d27e3939 100644
--- a/test/testyuv_cvt.c
+++ b/test/testyuv_cvt.c
@@ -19,7 +19,7 @@ static float clip3(float x, float y, float z)
     return (z < x) ? x : ((z > y) ? y : z);
 }
 
-static void RGBtoYUV(Uint8 *rgb, int *yuv, SDL_YUV_CONVERSION_MODE mode, int monochrome, int luminance)
+static void RGBtoYUV(const Uint8 *rgb, int *yuv, SDL_YUV_CONVERSION_MODE mode, int monochrome, int luminance)
 {
     if (mode == SDL_YUV_CONVERSION_JPEG) {
         /* Full range YUV */
diff --git a/test/torturethread.c b/test/torturethread.c
index 6835e020b..fd323ef90 100644
--- a/test/torturethread.c
+++ b/test/torturethread.c
@@ -52,7 +52,7 @@ ThreadFunc(void *data)
 
     for (i = 0; i < NUMTHREADS; i++) {
         char name[64];
-        SDL_snprintf(name, sizeof(name), "Child%d_%d", tid, i);
+        (void)SDL_snprintf(name, sizeof name, "Child%d_%d", tid, i);
         flags[i] = 0;
         sub_threads[i] = SDL_CreateThread(SubThreadFunc, name, &flags[i]);
     }
@@ -87,10 +87,10 @@ int main(int argc, char *argv[])
         return 1;
     }
 
-    signal(SIGSEGV, SIG_DFL);
+    (void)signal(SIGSEGV, SIG_DFL);
     for (i = 0; i < NUMTHREADS; i++) {
         char name[64];
-        SDL_snprintf(name, sizeof(name), "Parent%d", i);
+        (void)SDL_snprintf(name, sizeof name, "Parent%d", i);
         SDL_AtomicSet(&time_for_threads_to_die[i], 0);
         threads[i] = SDL_CreateThread(ThreadFunc, name, (void *)(uintptr_t)i);
 
-- 
2.17.1

