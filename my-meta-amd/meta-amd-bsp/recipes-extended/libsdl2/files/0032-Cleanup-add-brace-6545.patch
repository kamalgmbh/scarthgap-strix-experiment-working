From fb0ce375f0474501764a4bce7b609a1eab143526 Mon Sep 17 00:00:00 2001
From: Sylvain Becker <sylvain.becker@gmail.com>
Date: Sun, 27 Nov 2022 17:38:43 +0100
Subject: [PATCH 032/458] Cleanup add brace (#6545)

* Add braces after if conditions

* More add braces after if conditions

* Add braces after while() conditions

* Fix compilation because of macro being modified

* Add braces to for loop

* Add braces after if/goto

* Move comments up

* Remove extra () in the 'return ...;' statements

* More remove extra () in the 'return ...;' statements

* More remove extra () in the 'return ...;' statements after merge

* Fix inconsistent patterns are xxx == NULL vs !xxx

* More "{}" for "if() break;"  and "if() continue;"

* More "{}" after if() short statement

* More "{}" after "if () return;" statement

* More fix inconsistent patterns are xxx == NULL vs !xxx

* Revert some modificaion on SDL_RLEaccel.c

* SDL_RLEaccel: no short statement

* Cleanup 'if' where the bracket is in a new line

* Cleanup 'while' where the bracket is in a new line

* Cleanup 'for' where the bracket is in a new line

* Cleanup 'else' where the bracket is in a new line

(cherry picked from commit 6a2200823c66e53bd3cda4a25f0206b834392652 to reduce conflicts merging between SDL2 and SDL3)
---
 VisualC-GDK/tests/testgdk/src/testgdk.cpp     |   13 +-
 Xcode-iOS/Demos/src/accelerometer.c           |    4 +-
 Xcode-iOS/Demos/src/fireworks.c               |   25 +-
 Xcode-iOS/Demos/src/happy.c                   |    2 +-
 Xcode-iOS/Demos/src/keyboard.c                |    4 +-
 Xcode-iOS/Demos/src/mixer.c                   |    4 +-
 Xcode-iOS/Demos/src/rectangles.c              |    4 +-
 Xcode-iOS/Demos/src/touch.c                   |    2 +-
 src/SDL.c                                     |   21 +-
 src/SDL_assert.c                              |    5 +-
 src/SDL_dataqueue.c                           |   22 +-
 src/SDL_guid.c                                |    6 +-
 src/SDL_hints.c                               |   18 +-
 src/SDL_log.c                                 |   10 +-
 src/atomic/SDL_atomic.c                       |   20 +-
 src/atomic/SDL_spinlock.c                     |   22 +-
 src/audio/SDL_audio.c                         |    8 +-
 src/audio/SDL_audiocvt.c                      |   42 +-
 src/audio/SDL_audiodev.c                      |    3 +-
 src/audio/SDL_wave.c                          |   14 +-
 src/audio/aaudio/SDL_aaudio.c                 |    2 +-
 src/audio/alsa/SDL_alsa_audio.c               |   69 +-
 src/audio/android/SDL_androidaudio.c          |   14 +-
 src/audio/directsound/SDL_directsound.c       |    6 +-
 src/audio/disk/SDL_diskaudio.c                |    2 +-
 src/audio/dsp/SDL_dspaudio.c                  |   11 +-
 src/audio/jack/SDL_jackaudio.c                |    2 +-
 src/audio/netbsd/SDL_netbsdaudio.c            |    2 +-
 src/audio/openslES/SDL_openslES.c             |    4 +-
 src/audio/pipewire/SDL_pipewire.c             |   10 +-
 src/audio/ps2/SDL_ps2audio.c                  |    3 +-
 src/audio/psp/SDL_pspaudio.c                  |    4 +-
 src/audio/pulseaudio/SDL_pulseaudio.c         |   14 +-
 src/audio/vita/SDL_vitaaudio.c                |    4 +-
 src/audio/wasapi/SDL_wasapi_winrt.cpp         |    5 +-
 src/core/android/SDL_android.c                |   27 +-
 src/core/freebsd/SDL_evdev_kbd_freebsd.c      |  111 +-
 src/core/gdk/SDL_gdk.cpp                      |    4 +-
 src/core/linux/SDL_dbus.c                     |   25 +-
 src/core/linux/SDL_evdev.c                    |   84 +-
 src/core/linux/SDL_evdev_capabilities.c       |    3 +-
 src/core/linux/SDL_evdev_kbd.c                |   64 +-
 src/core/linux/SDL_fcitx.c                    |   34 +-
 src/core/linux/SDL_ibus.c                     |   73 +-
 src/core/linux/SDL_ime.c                      |   27 +-
 src/core/linux/SDL_threadprio.c               |   46 +-
 src/core/linux/SDL_udev.c                     |   11 +-
 src/core/openbsd/SDL_wscons_kbd.c             |  155 +-
 src/core/openbsd/SDL_wscons_mouse.c           |   14 +-
 src/core/windows/SDL_hid.c                    |    6 +-
 src/core/windows/SDL_immdevice.c              |    4 +-
 src/core/windows/SDL_windows.c                |    6 +-
 src/core/windows/SDL_xinput.c                 |    4 +-
 src/core/winrt/SDL_winrtapp_common.cpp        |   11 +-
 src/core/winrt/SDL_winrtapp_direct3d.cpp      |    8 +-
 src/cpuinfo/SDL_cpuinfo.c                     |   39 +-
 src/events/SDL_clipboardevents.c              |    2 +-
 src/events/SDL_displayevents.c                |    4 +-
 src/events/SDL_events.c                       |   32 +-
 src/events/SDL_gesture.c                      |   90 +-
 src/events/SDL_keyboard.c                     |   17 +-
 src/events/SDL_mouse.c                        |   28 +-
 src/events/SDL_touch.c                        |   50 +-
 src/events/SDL_windowevents.c                 |    2 +-
 src/file/SDL_rwops.c                          |   59 +-
 src/filesystem/android/SDL_sysfilesystem.c    |    2 +-
 src/filesystem/emscripten/SDL_sysfilesystem.c |    9 +-
 src/filesystem/haiku/SDL_sysfilesystem.cc     |    8 +-
 src/filesystem/ps2/SDL_sysfilesystem.c        |   13 +-
 src/filesystem/psp/SDL_sysfilesystem.c        |    4 +-
 src/filesystem/riscos/SDL_sysfilesystem.c     |   25 +-
 src/filesystem/unix/SDL_sysfilesystem.c       |   38 +-
 src/filesystem/vita/SDL_sysfilesystem.c       |    6 +-
 src/filesystem/windows/SDL_sysfilesystem.c    |    6 +-
 src/filesystem/winrt/SDL_sysfilesystem.cpp    |   12 +-
 src/haptic/SDL_haptic.c                       |   44 +-
 src/haptic/android/SDL_syshaptic.c            |   14 +-
 src/haptic/darwin/SDL_syshaptic.c             |    3 +-
 src/haptic/linux/SDL_syshaptic.c              |   34 +-
 src/haptic/windows/SDL_dinputhaptic.c         |   15 +-
 src/haptic/windows/SDL_xinputhaptic.c         |    2 +-
 src/hidapi/SDL_hidapi.c                       |   34 +-
 src/joystick/SDL_gamecontroller.c             |  154 +-
 src/joystick/SDL_joystick.c                   |   41 +-
 src/joystick/android/SDL_sysjoystick.c        |    2 +-
 src/joystick/bsd/SDL_bsdjoystick.c            |   27 +-
 src/joystick/darwin/SDL_iokitjoystick.c       |   26 +-
 src/joystick/emscripten/SDL_sysjoystick.c     |   24 +-
 src/joystick/haiku/SDL_haikujoystick.cc       |    3 +-
 src/joystick/hidapi/SDL_hidapi_gamecube.c     |    4 +-
 src/joystick/hidapi/SDL_hidapi_luna.c         |   19 +-
 src/joystick/hidapi/SDL_hidapi_ps3.c          |   14 +-
 src/joystick/hidapi/SDL_hidapi_ps4.c          |   12 +-
 src/joystick/hidapi/SDL_hidapi_ps5.c          |   10 +-
 src/joystick/hidapi/SDL_hidapi_rumble.c       |    2 +-
 src/joystick/hidapi/SDL_hidapi_shield.c       |   12 +-
 src/joystick/hidapi/SDL_hidapi_stadia.c       |   10 +-
 src/joystick/hidapi/SDL_hidapi_steam.c        |  231 +--
 src/joystick/hidapi/SDL_hidapi_switch.c       |   41 +-
 src/joystick/hidapi/SDL_hidapi_wii.c          |   10 +-
 src/joystick/hidapi/SDL_hidapi_xbox360.c      |   10 +-
 src/joystick/hidapi/SDL_hidapi_xbox360w.c     |   11 +-
 src/joystick/hidapi/SDL_hidapi_xboxone.c      |   24 +-
 src/joystick/hidapi/SDL_hidapijoystick.c      |   20 +-
 src/joystick/linux/SDL_sysjoystick.c          |   56 +-
 src/joystick/n3ds/SDL_sysjoystick.c           |    2 +-
 src/joystick/ps2/SDL_sysjoystick.c            |   20 +-
 src/joystick/psp/SDL_sysjoystick.c            |   14 +-
 src/joystick/virtual/SDL_virtualjoystick.c    |   27 +-
 src/joystick/vita/SDL_sysjoystick.c           |   21 +-
 src/joystick/windows/SDL_dinputjoystick.c     |   36 +-
 src/joystick/windows/SDL_rawinputjoystick.c   |   43 +-
 .../windows/SDL_windows_gaming_input.c        |    6 +-
 src/joystick/windows/SDL_windowsjoystick.c    |   32 +-
 src/joystick/windows/SDL_xinputjoystick.c     |   15 +-
 src/loadso/dlopen/SDL_sysloadso.c             |    4 +-
 src/loadso/dummy/SDL_sysloadso.c              |    4 +-
 src/loadso/windows/SDL_sysloadso.c            |    2 +-
 src/locale/SDL_locale.c                       |    9 +-
 src/locale/unix/SDL_syslocale.c               |    2 +-
 src/locale/vita/SDL_syslocale.c               |    3 +-
 src/locale/windows/SDL_syslocale.c            |    2 +-
 src/locale/winrt/SDL_syslocale.c              |    3 +-
 src/main/dummy/SDL_dummy_main.c               |    2 +-
 src/main/haiku/SDL_BeApp.cc                   |    9 +-
 src/main/ngage/SDL_ngage_main.cpp             |    7 +-
 src/main/ps2/SDL_ps2_main.c                   |    6 +-
 src/main/psp/SDL_psp_main.c                   |    3 +-
 src/main/windows/SDL_windows_main.c           |    4 +-
 src/misc/SDL_url.c                            |    2 +-
 src/power/emscripten/SDL_syspower.c           |    3 +-
 src/power/linux/SDL_syspower.c                |   16 +-
 src/power/windows/SDL_syspower.c              |    3 +-
 src/render/SDL_render.c                       |   94 +-
 src/render/SDL_yuv_sw.c                       |   11 +-
 src/render/direct3d/SDL_render_d3d.c          |   37 +-
 src/render/direct3d11/SDL_render_d3d11.c      |   35 +-
 src/render/direct3d11/SDL_render_winrt.cpp    |    2 +-
 src/render/direct3d12/SDL_render_d3d12.c      |   58 +-
 src/render/opengl/SDL_render_gl.c             |   29 +-
 src/render/opengl/SDL_shaders_gl.c            |    4 +-
 src/render/opengles/SDL_render_gles.c         |   18 +-
 src/render/opengles2/SDL_render_gles2.c       |   29 +-
 src/render/opengles2/SDL_shaders_gles2.c      |    9 +-
 src/render/ps2/SDL_render_ps2.c               |   47 +-
 src/render/psp/SDL_render_psp.c               |  150 +-
 src/render/software/SDL_blendfillrect.c       |    6 +-
 src/render/software/SDL_blendline.c           |    8 +-
 src/render/software/SDL_blendpoint.c          |    6 +-
 src/render/software/SDL_drawline.c            |    8 +-
 src/render/software/SDL_drawpoint.c           |    4 +-
 src/render/software/SDL_render_sw.c           |   34 +-
 src/render/software/SDL_rotate.c              |   49 +-
 src/render/software/SDL_triangle.c            |   24 +-
 src/render/vitagxm/SDL_render_vita_gxm.c      |   36 +-
 .../vitagxm/SDL_render_vita_gxm_memory.c      |   45 +-
 .../vitagxm/SDL_render_vita_gxm_tools.c       |   21 +-
 src/sensor/SDL_sensor.c                       |    2 +-
 src/sensor/android/SDL_androidsensor.c        |    8 +-
 src/sensor/vita/SDL_vitasensor.c              |   11 +-
 src/sensor/windows/SDL_windowssensor.c        |    6 +-
 src/stdlib/SDL_crc16.c                        |    2 +-
 src/stdlib/SDL_crc32.c                        |    2 +-
 src/stdlib/SDL_getenv.c                       |   36 +-
 src/stdlib/SDL_iconv.c                        |   24 +-
 src/stdlib/SDL_string.c                       |  105 +-
 src/test/SDL_test_assert.c                    |   14 +-
 src/test/SDL_test_common.c                    |   60 +-
 src/test/SDL_test_font.c                      |   13 +-
 src/test/SDL_test_fuzzer.c                    |   10 +-
 src/test/SDL_test_harness.c                   |   48 +-
 src/test/SDL_test_md5.c                       |   35 +-
 src/test/SDL_test_memory.c                    |    6 +-
 src/test/SDL_test_random.c                    |   17 +-
 src/thread/SDL_thread.c                       |   22 +-
 src/thread/generic/SDL_syscond.c              |    6 +-
 src/thread/generic/SDL_syssem.c               |    8 +-
 src/thread/generic/SDL_systhread.c            |    4 +-
 src/thread/n3ds/SDL_syscond.c                 |   16 +-
 src/thread/n3ds/SDL_syssem.c                  |   18 +-
 src/thread/ngage/SDL_sysmutex.cpp             |   24 +-
 src/thread/ngage/SDL_syssem.cpp               |   51 +-
 src/thread/ngage/SDL_systhread.cpp            |   21 +-
 src/thread/ps2/SDL_syssem.c                   |    3 +-
 src/thread/psp/SDL_syscond.c                  |    8 +-
 src/thread/pthread/SDL_syscond.c              |   10 +-
 src/thread/pthread/SDL_sysmutex.c             |    2 +-
 src/thread/pthread/SDL_syssem.c               |    8 +-
 src/thread/pthread/SDL_systhread.c            |    2 +-
 src/thread/stdcpp/SDL_syscond.cpp             |    6 +-
 src/thread/stdcpp/SDL_systhread.cpp           |    9 +-
 src/thread/vita/SDL_syscond.c                 |    8 +-
 src/thread/windows/SDL_syscond_cv.c           |   12 +-
 src/thread/windows/SDL_sysmutex.c             |    2 +-
 src/thread/windows/SDL_syssem.c               |   18 +-
 src/thread/windows/SDL_systhread.c            |    4 +-
 src/timer/SDL_timer.c                         |    8 +-
 src/timer/ngage/SDL_systimer.cpp              |    6 +-
 src/timer/psp/SDL_systimer.c                  |    3 +-
 src/timer/unix/SDL_systimer.c                 |    4 +-
 src/timer/vita/SDL_systimer.c                 |    3 +-
 src/video/SDL_RLEaccel.c                      |  179 +-
 src/video/SDL_blit.c                          |    2 +-
 src/video/SDL_blit_A.c                        |   40 +-
 src/video/SDL_blit_N.c                        |   37 +-
 src/video/SDL_blit_auto.c                     | 1664 ++++++++++++-----
 src/video/SDL_blit_copy.c                     |    8 +-
 src/video/SDL_blit_slow.c                     |   21 +-
 src/video/SDL_bmp.c                           |   66 +-
 src/video/SDL_clipboard.c                     |   20 +-
 src/video/SDL_egl.c                           |   12 +-
 src/video/SDL_fillrect.c                      |    8 +-
 src/video/SDL_pixels.c                        |   73 +-
 src/video/SDL_rect.c                          |    4 +-
 src/video/SDL_rect_impl.h                     |   28 +-
 src/video/SDL_shape.c                         |   59 +-
 src/video/SDL_surface.c                       |   91 +-
 src/video/SDL_video.c                         |  176 +-
 src/video/SDL_vulkan_utils.c                  |   18 +-
 src/video/SDL_yuv.c                           |   46 +-
 src/video/android/SDL_androidkeyboard.c       |    2 +-
 src/video/android/SDL_androidmouse.c          |    8 +-
 src/video/android/SDL_androidtouch.c          |    2 +-
 src/video/android/SDL_androidvideo.c          |    7 +-
 src/video/android/SDL_androidvulkan.c         |   50 +-
 src/video/android/SDL_androidwindow.c         |    4 +-
 src/video/dummy/SDL_nullframebuffer.c         |    4 +-
 src/video/dummy/SDL_nullvideo.c               |    6 +-
 src/video/emscripten/SDL_emscriptenevents.c   |   27 +-
 .../emscripten/SDL_emscriptenframebuffer.c    |    4 +-
 src/video/emscripten/SDL_emscriptenmouse.c    |   20 +-
 src/video/emscripten/SDL_emscriptenvideo.c    |   19 +-
 src/video/haiku/SDL_bclipboard.cc             |   12 +-
 src/video/haiku/SDL_bframebuffer.cc           |   13 +-
 src/video/haiku/SDL_bkeyboard.cc              |   10 +-
 src/video/haiku/SDL_bmessagebox.cc            |   68 +-
 src/video/haiku/SDL_bmodes.cc                 |   46 +-
 src/video/haiku/SDL_bopengl.cc                |   10 +-
 src/video/haiku/SDL_bvideo.cc                 |   16 +-
 src/video/haiku/SDL_bwindow.cc                |   22 +-
 src/video/kmsdrm/SDL_kmsdrmdyn.c              |    8 +-
 src/video/kmsdrm/SDL_kmsdrmmouse.c            |   12 +-
 src/video/kmsdrm/SDL_kmsdrmopengles.c         |    2 +-
 src/video/kmsdrm/SDL_kmsdrmvideo.c            |  100 +-
 src/video/kmsdrm/SDL_kmsdrmvulkan.c           |   79 +-
 src/video/n3ds/SDL_n3dsframebuffer.c          |    8 +-
 src/video/n3ds/SDL_n3dsvideo.c                |    4 +-
 src/video/ngage/SDL_ngageevents.cpp           |    3 +-
 src/video/ngage/SDL_ngageframebuffer.cpp      |   70 +-
 src/video/ngage/SDL_ngagevideo.cpp            |   30 +-
 src/video/ngage/SDL_ngagewindow.cpp           |    2 +-
 .../offscreen/SDL_offscreenframebuffer.c      |    4 +-
 src/video/offscreen/SDL_offscreenvideo.c      |    4 +-
 src/video/offscreen/SDL_offscreenwindow.c     |    2 +-
 src/video/ps2/SDL_ps2video.c                  |    4 +-
 src/video/psp/SDL_pspevents.c                 |   19 +-
 src/video/psp/SDL_pspgl.c                     |    9 +-
 src/video/raspberry/SDL_rpivideo.c            |    2 +-
 src/video/riscos/SDL_riscosevents.c           |    3 +-
 src/video/riscos/SDL_riscosmessagebox.c       |    9 +-
 src/video/riscos/SDL_riscosmodes.c            |    9 +-
 src/video/riscos/SDL_riscosvideo.c            |    4 +-
 src/video/riscos/SDL_riscoswindow.c           |    5 +-
 src/video/vita/SDL_vitaframebuffer.c          |   11 +-
 src/video/vita/SDL_vitagl_pvr.c               |    9 +-
 src/video/vita/SDL_vitagles.c                 |    3 +-
 src/video/vita/SDL_vitagles_pvr.c             |    6 +-
 src/video/vita/SDL_vitakeyboard.c             |   42 +-
 src/video/vita/SDL_vitamessagebox.c           |   53 +-
 src/video/vita/SDL_vitamouse.c                |   15 +-
 src/video/vita/SDL_vitatouch.c                |   14 +-
 src/video/vita/SDL_vitavideo.c                |   24 +-
 src/video/vivante/SDL_vivantevulkan.c         |   47 +-
 src/video/wayland/SDL_waylanddyn.c            |    8 +-
 src/video/wayland/SDL_waylandevents.c         |  106 +-
 src/video/wayland/SDL_waylandkeyboard.c       |   10 +-
 src/video/wayland/SDL_waylandmessagebox.c     |    4 +-
 src/video/wayland/SDL_waylandmouse.c          |   31 +-
 src/video/wayland/SDL_waylandopengles.c       |    3 +-
 src/video/wayland/SDL_waylandtouch.h          |    2 +-
 src/video/wayland/SDL_waylandvideo.c          |    6 +-
 src/video/wayland/SDL_waylandvulkan.c         |   50 +-
 src/video/wayland/SDL_waylandwindow.c         |    3 +-
 src/video/windows/SDL_windowsclipboard.c      |    2 +-
 src/video/windows/SDL_windowsevents.c         |   76 +-
 src/video/windows/SDL_windowsframebuffer.c    |    5 +-
 src/video/windows/SDL_windowskeyboard.c       |  246 ++-
 src/video/windows/SDL_windowsmessagebox.c     |   22 +-
 src/video/windows/SDL_windowsmodes.c          |   14 +-
 src/video/windows/SDL_windowsmouse.c          |    2 +-
 src/video/windows/SDL_windowsopengl.c         |   31 +-
 src/video/windows/SDL_windowsshape.c          |   25 +-
 src/video/windows/SDL_windowsvideo.c          |   16 +-
 src/video/windows/SDL_windowsvulkan.c         |   50 +-
 src/video/windows/SDL_windowswindow.c         |   18 +-
 src/video/winrt/SDL_winrtgamebar.cpp          |    6 +-
 src/video/winrt/SDL_winrtvideo.cpp            |   12 +-
 src/video/x11/SDL_x11clipboard.c              |    2 +-
 src/video/x11/SDL_x11dyn.c                    |    8 +-
 src/video/x11/SDL_x11events.c                 |  116 +-
 src/video/x11/SDL_x11framebuffer.c            |   36 +-
 src/video/x11/SDL_x11keyboard.c               |    2 +-
 src/video/x11/SDL_x11messagebox.c             |   21 +-
 src/video/x11/SDL_x11modes.c                  |   30 +-
 src/video/x11/SDL_x11mouse.c                  |   15 +-
 src/video/x11/SDL_x11opengl.c                 |   41 +-
 src/video/x11/SDL_x11shape.c                  |   20 +-
 src/video/x11/SDL_x11video.c                  |   10 +-
 src/video/x11/SDL_x11vulkan.c                 |   94 +-
 src/video/x11/SDL_x11window.c                 |   45 +-
 src/video/x11/SDL_x11xfixes.c                 |    4 +-
 src/video/x11/SDL_x11xinput2.c                |   16 +-
 test/checkkeys.c                              |   47 +-
 test/checkkeysthreads.c                       |   45 +-
 test/controllermap.c                          |    8 +-
 test/loopwave.c                               |    7 +-
 test/loopwavequeue.c                          |    8 +-
 test/testatomic.c                             |    9 +-
 test/testaudiocapture.c                       |    2 +-
 test/testaudiohotplug.c                       |    9 +-
 test/testaudioinfo.c                          |    2 +-
 test/testautomation.c                         |   19 +-
 test/testautomation_audio.c                   |   23 +-
 test/testautomation_mouse.c                   |   12 +-
 test/testautomation_pixels.c                  |    2 +-
 test/testautomation_platform.c                |   21 +-
 test/testautomation_rect.c                    |   80 +-
 test/testautomation_render.c                  |  191 +-
 test/testautomation_rwops.c                   |   38 +-
 test/testautomation_stdlib.c                  |    2 +-
 test/testautomation_surface.c                 |   43 +-
 test/testautomation_video.c                   |   50 +-
 test/testcustomcursor.c                       |    4 +-
 test/testdisplayinfo.c                        |    3 +-
 test/testdraw2.c                              |    5 +-
 test/testdrawchessboard.c                     |   13 +-
 test/testdropfile.c                           |    4 +-
 test/testerror.c                              |    6 +-
 test/testevdev.c                              |    3 +-
 test/testfile.c                               |  234 ++-
 test/testfilesystem.c                         |    6 +-
 test/testgamecontroller.c                     |   10 +-
 test/testgeometry.c                           |   13 +-
 test/testgesture.c                            |    6 +-
 test/testgl2.c                                |    5 +-
 test/testgles.c                               |    5 +-
 test/testgles2.c                              |   32 +-
 test/testgles2_sdf.c                          |   30 +-
 test/testhaptic.c                             |   51 +-
 test/testhittesting.c                         |    5 +-
 test/testhotplug.c                            |   46 +-
 test/testiconv.c                              |    6 +-
 test/testime.c                                |  220 +--
 test/testintersections.c                      |   37 +-
 test/testjoystick.c                           |   17 +-
 test/testkeys.c                               |    2 +-
 test/testlock.c                               |   13 +-
 test/testmessage.c                            |   10 +-
 test/testmouse.c                              |   11 +-
 test/testmultiaudio.c                         |    9 +-
 test/testnative.c                             |   12 +-
 test/testoffscreen.c                          |    4 +-
 test/testoverlay2.c                           |    6 +-
 test/testplatform.c                           |   47 +-
 test/testqsort.c                              |    7 +-
 test/testrelative.c                           |   25 +-
 test/testrendercopyex.c                       |    5 +-
 test/testrendertarget.c                       |   15 +-
 test/testrumble.c                             |    6 +-
 test/testscale.c                              |    5 +-
 test/testsem.c                                |   15 +-
 test/testsensor.c                             |    6 +-
 test/testshader.c                             |    8 +-
 test/testshape.c                              |   64 +-
 test/testsprite2.c                            |   19 +-
 test/teststreaming.c                          |    6 +-
 test/testthread.c                             |    9 +-
 test/testtimer.c                              |   21 +-
 test/testutils.c                              |    2 +-
 test/testver.c                                |    2 +-
 test/testviewport.c                           |    8 +-
 test/testvulkan.c                             |   40 +-
 test/testwm2.c                                |    4 +-
 test/testyuv.c                                |   19 +-
 test/testyuv_cvt.c                            |    7 +-
 test/torturethread.c                          |    4 +-
 386 files changed, 6102 insertions(+), 4636 deletions(-)

diff --git a/VisualC-GDK/tests/testgdk/src/testgdk.cpp b/VisualC-GDK/tests/testgdk/src/testgdk.cpp
index ed69ecbea..8395c8bb1 100644
--- a/VisualC-GDK/tests/testgdk/src/testgdk.cpp
+++ b/VisualC-GDK/tests/testgdk/src/testgdk.cpp
@@ -239,17 +239,17 @@ LoadSprite(const char *file)
         /* This does the SDL_LoadBMP step repeatedly, but that's OK for test code. */
         sprites[i] = LoadTexture(state->renderers[i], file, SDL_TRUE, &sprite_w, &sprite_h);
         if (!sprites[i]) {
-            return (-1);
+            return -1;
         }
         if (SDL_SetTextureBlendMode(sprites[i], blendMode) < 0) {
             SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Couldn't set blend mode: %s\n", SDL_GetError());
             SDL_DestroyTexture(sprites[i]);
-            return (-1);
+            return -1;
         }
     }
 
     /* We're ready to roll. :) */
-    return (0);
+    return 0;
 }
 
 void
@@ -364,8 +364,9 @@ loop()
 #endif
     }
     for (i = 0; i < state->num_windows; ++i) {
-        if (state->windows[i] == NULL)
+        if (state->windows[i] == NULL) {
             continue;
+        }
         DrawSprites(state->renderers[i], sprites[i]);
     }
 }
@@ -382,7 +383,7 @@ main(int argc, char *argv[])
 
     /* Initialize test framework */
     state = SDLTest_CommonCreateState(argv, SDL_INIT_VIDEO | SDL_INIT_AUDIO);
-    if (!state) {
+    if (state == NULL) {
         return 1;
     }
 
@@ -445,7 +446,7 @@ main(int argc, char *argv[])
     /* Create the windows, initialize the renderers, and load the textures */
     sprites =
         (SDL_Texture **) SDL_malloc(state->num_windows * sizeof(*sprites));
-    if (!sprites) {
+    if (sprites == NULL) {
         SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Out of memory!\n");
         quit(2);
     }
diff --git a/Xcode-iOS/Demos/src/accelerometer.c b/Xcode-iOS/Demos/src/accelerometer.c
index 0af153676..3ce812513 100644
--- a/Xcode-iOS/Demos/src/accelerometer.c
+++ b/Xcode-iOS/Demos/src/accelerometer.c
@@ -127,7 +127,7 @@ initializeTextures(SDL_Renderer *renderer)
 
     /* create ship texture from surface */
     ship = SDL_CreateTextureFromSurface(renderer, bmp_surface);
-    if (!ship) {
+    if (ship == NULL) {
         fatalError("could not create ship texture");
     }
     SDL_SetTextureBlendMode(ship, SDL_BLENDMODE_BLEND);
@@ -145,7 +145,7 @@ initializeTextures(SDL_Renderer *renderer)
     }
     /* create space texture from surface */
     space = SDL_CreateTextureFromSurface(renderer, bmp_surface);
-    if (!space) {
+    if (space == NULL) {
         fatalError("could not create space texture");
     }
     SDL_FreeSurface(bmp_surface);
diff --git a/Xcode-iOS/Demos/src/fireworks.c b/Xcode-iOS/Demos/src/fireworks.c
index 600d20bbb..eb3bb4cde 100644
--- a/Xcode-iOS/Demos/src/fireworks.c
+++ b/Xcode-iOS/Demos/src/fireworks.c
@@ -84,14 +84,16 @@ stepParticles(double deltaTime)
         /* is the particle actually active, or is it marked for deletion? */
         if (curr->isActive) {
             /* is the particle off the screen? */
-            if (curr->y > screen_h)
+            if (curr->y > screen_h) {
                 curr->isActive = 0;
-            else if (curr->y < 0)
+            } else if (curr->y < 0) {
                 curr->isActive = 0;
-            if (curr->x > screen_w)
+            }
+            if (curr->x > screen_w) {
                 curr->isActive = 0;
-            else if (curr->x < 0)
+            } else if (curr->x < 0) {
                 curr->isActive = 0;
+            }
 
             /* step velocity, then step position */
             curr->yvel += ACCEL * deltaMilliseconds;
@@ -133,15 +135,17 @@ stepParticles(double deltaTime)
                 }
 
                 /* if we're a dust particle, shrink our size */
-                if (curr->type == dust)
+                if (curr->type == dust) {
                     curr->size -= deltaMilliseconds * 0.010f;
+                }
 
             }
 
             /* if we're still active, pack ourselves in the array next
                to the last active guy (pack the array tightly) */
-            if (curr->isActive)
+            if (curr->isActive) {
                 *(slot++) = *curr;
+            }
         }                       /* endif (curr->isActive) */
         curr++;
     }
@@ -188,8 +192,9 @@ explodeEmitter(struct particle *emitter)
     int i;
     for (i = 0; i < 200; i++) {
 
-        if (num_active_particles >= MAX_PARTICLES)
+        if (num_active_particles >= MAX_PARTICLES) {
             return;
+        }
 
         /* come up with a random angle and speed for new particle */
         float theta = randomFloat(0, 2.0f * 3.141592);
@@ -226,8 +231,9 @@ void
 spawnTrailFromEmitter(struct particle *emitter)
 {
 
-    if (num_active_particles >= MAX_PARTICLES)
+    if (num_active_particles >= MAX_PARTICLES) {
         return;
+    }
 
     /* select the particle at the slot at the end of our array */
     struct particle *p = &particles[num_active_particles];
@@ -262,8 +268,9 @@ void
 spawnEmitterParticle(GLfloat x, GLfloat y)
 {
 
-    if (num_active_particles >= MAX_PARTICLES)
+    if (num_active_particles >= MAX_PARTICLES) {
         return;
+    }
 
     /* find particle at endpoint of array */
     struct particle *p = &particles[num_active_particles];
diff --git a/Xcode-iOS/Demos/src/happy.c b/Xcode-iOS/Demos/src/happy.c
index 73d4d4feb..42562007e 100644
--- a/Xcode-iOS/Demos/src/happy.c
+++ b/Xcode-iOS/Demos/src/happy.c
@@ -117,7 +117,7 @@ initializeTexture(SDL_Renderer *renderer)
 
     /* convert RGBA surface to texture */
     texture = SDL_CreateTextureFromSurface(renderer, bmp_surface);
-    if (!texture) {
+    if (texture == NULL) {
         fatalError("could not create texture");
     }
     SDL_SetTextureBlendMode(texture, SDL_BLENDMODE_BLEND);
diff --git a/Xcode-iOS/Demos/src/keyboard.c b/Xcode-iOS/Demos/src/keyboard.c
index 4d630bae5..6ab1db213 100644
--- a/Xcode-iOS/Demos/src/keyboard.c
+++ b/Xcode-iOS/Demos/src/keyboard.c
@@ -165,7 +165,7 @@ loadFont(void)
 {
     SDL_Surface *surface = SDL_LoadBMP("kromasky_16x16.bmp");
 
-    if (!surface) {
+    if (surface == NULL) {
         printf("Error loading bitmap: %s\n", SDL_GetError());
         return 0;
     } else {
@@ -183,7 +183,7 @@ loadFont(void)
         SDL_BlitSurface(surface, NULL, converted, NULL);
         /* create our texture */
         texture = SDL_CreateTextureFromSurface(renderer, converted);
-        if (!texture) {
+        if (texture == NULL) {
             printf("texture creation failed: %s\n", SDL_GetError());
         } else {
             /* set blend mode for our texture */
diff --git a/Xcode-iOS/Demos/src/mixer.c b/Xcode-iOS/Demos/src/mixer.c
index 18e33f134..4c4ffbad0 100644
--- a/Xcode-iOS/Demos/src/mixer.c
+++ b/Xcode-iOS/Demos/src/mixer.c
@@ -207,9 +207,9 @@ playSound(struct sound *s)
             break;
         }
         /* if this channel's sound is older than the oldest so far, set it to oldest */
-        if (mixer.channels[i].timestamp <
-            mixer.channels[oldest_channel].timestamp)
+        if (mixer.channels[i].timestamp < mixer.channels[oldest_channel].timestamp) {
             oldest_channel = i;
+        }
     }
 
     /* no empty channels, take the oldest one */
diff --git a/Xcode-iOS/Demos/src/rectangles.c b/Xcode-iOS/Demos/src/rectangles.c
index a08f99790..9102cf279 100644
--- a/Xcode-iOS/Demos/src/rectangles.c
+++ b/Xcode-iOS/Demos/src/rectangles.c
@@ -58,11 +58,11 @@ main(int argc, char *argv[])
 
     /* create window and renderer */
     window = SDL_CreateWindow(NULL, 0, 0, 320, 480, SDL_WINDOW_ALLOW_HIGHDPI);
-    if (!window) {
+    if (window == NULL) {
         fatalError("Could not initialize Window");
     }
     renderer = SDL_CreateRenderer(window, -1, 0);
-    if (!renderer) {
+    if (renderer == NULL) {
         fatalError("Could not create renderer");
     }
 
diff --git a/Xcode-iOS/Demos/src/touch.c b/Xcode-iOS/Demos/src/touch.c
index 6c184630d..22a251be1 100644
--- a/Xcode-iOS/Demos/src/touch.c
+++ b/Xcode-iOS/Demos/src/touch.c
@@ -63,7 +63,7 @@ initializeTexture(SDL_Renderer *renderer)
     brush =
         SDL_CreateTextureFromSurface(renderer, bmp_surface);
     SDL_FreeSurface(bmp_surface);
-    if (!brush) {
+    if (brush == NULL) {
         fatalError("could not create brush texture");
     }
     /* additive blending -- laying strokes on top of eachother makes them brighter */
diff --git a/src/SDL.c b/src/SDL.c
index cde3434a9..463cb2b9e 100644
--- a/src/SDL.c
+++ b/src/SDL.c
@@ -231,7 +231,7 @@ SDL_InitSubSystem(Uint32 flags)
     }
 
     /* Initialize the timer subsystem */
-    if ((flags & SDL_INIT_TIMER)){
+    if ((flags & SDL_INIT_TIMER)) {
 #if !SDL_TIMERS_DISABLED && !SDL_TIMER_DUMMY
         if (SDL_PrivateShouldInitSubsystem(SDL_INIT_TIMER)) {
             if (SDL_TimerInit() < 0) {
@@ -247,7 +247,7 @@ SDL_InitSubSystem(Uint32 flags)
     }
 
     /* Initialize the video subsystem */
-    if ((flags & SDL_INIT_VIDEO)){
+    if ((flags & SDL_INIT_VIDEO)) {
 #if !SDL_VIDEO_DISABLED
         if (SDL_PrivateShouldInitSubsystem(SDL_INIT_VIDEO)) {
             if (SDL_VideoInit(NULL) < 0) {
@@ -263,7 +263,7 @@ SDL_InitSubSystem(Uint32 flags)
     }
 
     /* Initialize the audio subsystem */
-    if ((flags & SDL_INIT_AUDIO)){
+    if ((flags & SDL_INIT_AUDIO)) {
 #if !SDL_AUDIO_DISABLED
         if (SDL_PrivateShouldInitSubsystem(SDL_INIT_AUDIO)) {
             if (SDL_AudioInit(NULL) < 0) {
@@ -279,7 +279,7 @@ SDL_InitSubSystem(Uint32 flags)
     }
 
     /* Initialize the joystick subsystem */
-    if ((flags & SDL_INIT_JOYSTICK)){
+    if ((flags & SDL_INIT_JOYSTICK)) {
 #if !SDL_JOYSTICK_DISABLED
         if (SDL_PrivateShouldInitSubsystem(SDL_INIT_JOYSTICK)) {
            if (SDL_JoystickInit() < 0) {
@@ -294,7 +294,7 @@ SDL_InitSubSystem(Uint32 flags)
 #endif
     }
 
-    if ((flags & SDL_INIT_GAMECONTROLLER)){
+    if ((flags & SDL_INIT_GAMECONTROLLER)) {
 #if !SDL_JOYSTICK_DISABLED
         if (SDL_PrivateShouldInitSubsystem(SDL_INIT_GAMECONTROLLER)) {
             if (SDL_GameControllerInit() < 0) {
@@ -310,7 +310,7 @@ SDL_InitSubSystem(Uint32 flags)
     }
 
     /* Initialize the haptic subsystem */
-    if ((flags & SDL_INIT_HAPTIC)){
+    if ((flags & SDL_INIT_HAPTIC)) {
 #if !SDL_HAPTIC_DISABLED
         if (SDL_PrivateShouldInitSubsystem(SDL_INIT_HAPTIC)) {
             if (SDL_HapticInit() < 0) {
@@ -326,7 +326,7 @@ SDL_InitSubSystem(Uint32 flags)
     }
 
     /* Initialize the sensor subsystem */
-    if ((flags & SDL_INIT_SENSOR)){
+    if ((flags & SDL_INIT_SENSOR)) {
 #if !SDL_SENSOR_DISABLED
         if (SDL_PrivateShouldInitSubsystem(SDL_INIT_SENSOR)) {
             if (SDL_SensorInit() < 0) {
@@ -343,11 +343,11 @@ SDL_InitSubSystem(Uint32 flags)
 
     (void) flags_initialized;  /* make static analysis happy, since this only gets used in error cases. */
 
-    return (0);
+    return 0;
 
 quit_and_error:
     SDL_QuitSubSystem(flags_initialized);
-    return (-1);
+    return -1;
 }
 
 int
@@ -522,8 +522,7 @@ SDL_GetVersion(SDL_version * ver)
     static SDL_bool check_hint = SDL_TRUE;
     static SDL_bool legacy_version = SDL_FALSE;
 
-    if (!ver) {
-        return;
+    if (ver == NULL) {        return;
     }
 
     SDL_VERSION(ver);
diff --git a/src/SDL_assert.c b/src/SDL_assert.c
index aa8d23511..e60f7a9b3 100644
--- a/src/SDL_assert.c
+++ b/src/SDL_assert.c
@@ -252,10 +252,7 @@ SDL_PromptAssertion(const SDL_assert_data *data, void *userdata)
         } else {
             state = (SDL_assert_state)selected;
         }
-    }
-
-    else
-    {
+    } else {
 #if defined(__EMSCRIPTEN__)
         /* This is nasty, but we can't block on a custom UI. */
         for ( ; ; ) {
diff --git a/src/SDL_dataqueue.c b/src/SDL_dataqueue.c
index e63fc6dfd..6a44621eb 100644
--- a/src/SDL_dataqueue.c
+++ b/src/SDL_dataqueue.c
@@ -58,7 +58,7 @@ SDL_NewDataQueue(const size_t _packetlen, const size_t initialslack)
 {
     SDL_DataQueue *queue = (SDL_DataQueue *) SDL_malloc(sizeof (SDL_DataQueue));
 
-    if (!queue) {
+    if (queue == NULL) {
         SDL_OutOfMemory();
         return NULL;
     } else {
@@ -102,7 +102,7 @@ SDL_ClearDataQueue(SDL_DataQueue *queue, const size_t slack)
     SDL_DataQueuePacket *prev = NULL;
     size_t i;
 
-    if (!queue) {
+    if (queue == NULL) {
         return;
     }
 
@@ -181,7 +181,7 @@ SDL_WriteToDataQueue(SDL_DataQueue *queue, const void *_data, const size_t _len)
     size_t origlen;
     size_t datalen;
 
-    if (!queue) {
+    if (queue == NULL) {
         return SDL_InvalidParamError("queue");
     }
 
@@ -191,13 +191,13 @@ SDL_WriteToDataQueue(SDL_DataQueue *queue, const void *_data, const size_t _len)
 
     while (len > 0) {
         SDL_DataQueuePacket *packet = queue->tail;
-        SDL_assert(!packet || (packet->datalen <= packet_size));
-        if (!packet || (packet->datalen >= packet_size)) {
+        SDL_assert(packet == NULL || (packet->datalen <= packet_size));
+        if (packet == NULL || (packet->datalen >= packet_size)) {
             /* tail packet missing or completely full; we need a new packet. */
             packet = AllocateDataQueuePacket(queue);
-            if (!packet) {
+            if (packet == NULL) {
                 /* uhoh, reset so we've queued nothing new, free what we can. */
-                if (!origtail) {
+                if (origtail == NULL) {
                     packet = queue->head;  /* whole queue. */
                 } else {
                     packet = origtail->next;  /* what we added to existing queue. */
@@ -232,7 +232,7 @@ SDL_PeekIntoDataQueue(SDL_DataQueue *queue, void *_buf, const size_t _len)
     Uint8 *ptr = buf;
     SDL_DataQueuePacket *packet;
 
-    if (!queue) {
+    if (queue == NULL) {
         return 0;
     }
 
@@ -257,7 +257,7 @@ SDL_ReadFromDataQueue(SDL_DataQueue *queue, void *_buf, const size_t _len)
     Uint8 *ptr = buf;
     SDL_DataQueuePacket *packet;
 
-    if (!queue) {
+    if (queue == NULL) {
         return 0;
     }
 
@@ -300,7 +300,7 @@ SDL_ReserveSpaceInDataQueue(SDL_DataQueue *queue, const size_t len)
 {
     SDL_DataQueuePacket *packet;
 
-    if (!queue) {
+    if (queue == NULL) {
         SDL_InvalidParamError("queue");
         return NULL;
     } else if (len == 0) {
@@ -324,7 +324,7 @@ SDL_ReserveSpaceInDataQueue(SDL_DataQueue *queue, const size_t len)
 
     /* Need a fresh packet. */
     packet = AllocateDataQueuePacket(queue);
-    if (!packet) {
+    if (packet == NULL) {
         SDL_OutOfMemory();
         return NULL;
     }
diff --git a/src/SDL_guid.c b/src/SDL_guid.c
index d3529b728..f75ab0a89 100644
--- a/src/SDL_guid.c
+++ b/src/SDL_guid.c
@@ -52,15 +52,15 @@ void SDL_GUIDToString(SDL_GUID guid, char *pszGUID, int cbGUID)
 static unsigned char nibble(unsigned char c)
 {
     if ((c >= '0') && (c <= '9')) {
-        return (c - '0');
+        return c - '0';
     }
 
     if ((c >= 'A') && (c <= 'F')) {
-        return (c - 'A' + 0x0a);
+        return c - 'A' + 0x0a;
     }
 
     if ((c >= 'a') && (c <= 'f')) {
-        return (c - 'a' + 0x0a);
+        return c - 'a' + 0x0a;
     }
 
     /* received an invalid character, and no real way to return an error */
diff --git a/src/SDL_hints.c b/src/SDL_hints.c
index 4341f8d20..5e310ca01 100644
--- a/src/SDL_hints.c
+++ b/src/SDL_hints.c
@@ -52,7 +52,7 @@ SDL_SetHintWithPriority(const char *name, const char *value,
     SDL_Hint *hint;
     SDL_HintWatch *entry;
 
-    if (!name) {
+    if (name == NULL) {
         return SDL_FALSE;
     }
 
@@ -67,7 +67,7 @@ SDL_SetHintWithPriority(const char *name, const char *value,
                 return SDL_FALSE;
             }
             if (hint->value != value &&
-                (!value || !hint->value || SDL_strcmp(hint->value, value) != 0)) {
+                (value == NULL || !hint->value || SDL_strcmp(hint->value, value) != 0)) {
                 for (entry = hint->callbacks; entry; ) {
                     /* Save the next entry in case this one is deleted */
                     SDL_HintWatch *next = entry->next;
@@ -84,7 +84,7 @@ SDL_SetHintWithPriority(const char *name, const char *value,
 
     /* Couldn't find the hint, add a new one */
     hint = (SDL_Hint *)SDL_malloc(sizeof(*hint));
-    if (!hint) {
+    if (hint == NULL) {
         return SDL_FALSE;
     }
     hint->name = SDL_strdup(name);
@@ -103,7 +103,7 @@ SDL_ResetHint(const char *name)
     SDL_Hint *hint;
     SDL_HintWatch *entry;
 
-    if (!name) {
+    if (name == NULL) {
         return SDL_FALSE;
     }
 
@@ -181,7 +181,7 @@ SDL_GetHint(const char *name)
 SDL_bool
 SDL_GetStringBoolean(const char *value, SDL_bool default_value)
 {
-    if (!value || !*value) {
+    if (value == NULL || !*value) {
         return default_value;
     }
     if (*value == '0' || SDL_strcasecmp(value, "false") == 0) {
@@ -204,7 +204,7 @@ SDL_AddHintCallback(const char *name, SDL_HintCallback callback, void *userdata)
     SDL_HintWatch *entry;
     const char *value;
 
-    if (!name || !*name) {
+    if (name == NULL || !*name) {
         SDL_InvalidParamError("name");
         return;
     }
@@ -216,7 +216,7 @@ SDL_AddHintCallback(const char *name, SDL_HintCallback callback, void *userdata)
     SDL_DelHintCallback(name, callback, userdata);
 
     entry = (SDL_HintWatch *)SDL_malloc(sizeof(*entry));
-    if (!entry) {
+    if (entry == NULL) {
         SDL_OutOfMemory();
         return;
     }
@@ -228,10 +228,10 @@ SDL_AddHintCallback(const char *name, SDL_HintCallback callback, void *userdata)
             break;
         }
     }
-    if (!hint) {
+    if (hint == NULL) {
         /* Need to add a hint entry for this watcher */
         hint = (SDL_Hint *)SDL_malloc(sizeof(*hint));
-        if (!hint) {
+        if (hint == NULL) {
             SDL_OutOfMemory();
             SDL_free(entry);
             return;
diff --git a/src/SDL_log.c b/src/SDL_log.c
index c01e31d8a..63743da7f 100644
--- a/src/SDL_log.c
+++ b/src/SDL_log.c
@@ -108,7 +108,7 @@ static int SDL_android_priority[SDL_NUM_LOG_PRIORITIES] = {
 void
 SDL_LogInit(void)
 {
-    if (!log_function_mutex) {
+    if (log_function_mutex == NULL) {
         /* if this fails we'll try to continue without it. */
         log_function_mutex = SDL_CreateMutex();
     }
@@ -316,7 +316,7 @@ SDL_LogMessageV(int category, SDL_LogPriority priority, const char *fmt, va_list
         return;
     }
 
-    if (!log_function_mutex) {
+    if (log_function_mutex == NULL) {
         /* this mutex creation can race if you log from two threads at startup. You should have called SDL_Init first! */
         log_function_mutex = SDL_CreateMutex();
     }
@@ -326,15 +326,17 @@ SDL_LogMessageV(int category, SDL_LogPriority priority, const char *fmt, va_list
     len = SDL_vsnprintf(stack_buf, sizeof(stack_buf), fmt, aq);
     va_end(aq);
 
-    if (len < 0)
+    if (len < 0) {
         return;
+    }
 
     /* If message truncated, allocate and re-render */
     if (len >= sizeof(stack_buf) && SDL_size_add_overflow(len, 1, &len_plus_term) == 0) {
         /* Allocate exactly what we need, including the zero-terminator */
         message = (char *)SDL_malloc(len_plus_term);
-        if (!message)
+        if (message == NULL) {
             return;
+        }
         va_copy(aq, ap);
         len = SDL_vsnprintf(message, len_plus_term, fmt, aq);
         va_end(aq);
diff --git a/src/atomic/SDL_atomic.c b/src/atomic/SDL_atomic.c
index a89134e1a..deea13d95 100644
--- a/src/atomic/SDL_atomic.c
+++ b/src/atomic/SDL_atomic.c
@@ -129,15 +129,15 @@ SDL_AtomicCAS(SDL_atomic_t *a, int oldval, int newval)
 {
 #ifdef HAVE_MSC_ATOMICS
     SDL_COMPILE_TIME_ASSERT(atomic_cas, sizeof(long) == sizeof(a->value));
-    return (_InterlockedCompareExchange((long*)&a->value, (long)newval, (long)oldval) == (long)oldval);
+    return _InterlockedCompareExchange((long *)&a->value, (long)newval, (long)oldval) == (long)oldval;
 #elif defined(HAVE_WATCOM_ATOMICS)
-    return (SDL_bool) _SDL_cmpxchg_watcom(&a->value, newval, oldval);
+    return (SDL_bool)_SDL_cmpxchg_watcom(&a->value, newval, oldval);
 #elif defined(HAVE_GCC_ATOMICS)
     return (SDL_bool) __sync_bool_compare_and_swap(&a->value, oldval, newval);
 #elif defined(__MACOSX__)  /* this is deprecated in 10.12 sdk; favor gcc atomics. */
     return (SDL_bool) OSAtomicCompareAndSwap32Barrier(oldval, newval, &a->value);
 #elif defined(__SOLARIS__)
-    return (SDL_bool) ((int) atomic_cas_uint((volatile uint_t*)&a->value, (uint_t)oldval, (uint_t)newval) == oldval);
+    return (SDL_bool)((int)atomic_cas_uint((volatile uint_t *)&a->value, (uint_t)oldval, (uint_t)newval) == oldval);
 #elif EMULATE_CAS
     SDL_bool retval = SDL_FALSE;
 
@@ -158,9 +158,9 @@ SDL_bool
 SDL_AtomicCASPtr(void **a, void *oldval, void *newval)
 {
 #if defined(HAVE_MSC_ATOMICS)
-    return (_InterlockedCompareExchangePointer(a, newval, oldval) == oldval);
+    return _InterlockedCompareExchangePointer(a, newval, oldval) == oldval;
 #elif defined(HAVE_WATCOM_ATOMICS)
-    return (SDL_bool) _SDL_cmpxchg_watcom((int *)a, (long)newval, (long)oldval);
+    return (SDL_bool)_SDL_cmpxchg_watcom((int *)a, (long)newval, (long)oldval);
 #elif defined(HAVE_GCC_ATOMICS)
     return __sync_bool_compare_and_swap(a, oldval, newval);
 #elif defined(__MACOSX__) && defined(__LP64__)  /* this is deprecated in 10.12 sdk; favor gcc atomics. */
@@ -168,7 +168,7 @@ SDL_AtomicCASPtr(void **a, void *oldval, void *newval)
 #elif defined(__MACOSX__) && !defined(__LP64__)  /* this is deprecated in 10.12 sdk; favor gcc atomics. */
     return (SDL_bool) OSAtomicCompareAndSwap32Barrier((int32_t)oldval, (int32_t)newval, (int32_t*) a);
 #elif defined(__SOLARIS__)
-    return (SDL_bool) (atomic_cas_ptr(a, oldval, newval) == oldval);
+    return (SDL_bool)(atomic_cas_ptr(a, oldval, newval) == oldval);
 #elif EMULATE_CAS
     SDL_bool retval = SDL_FALSE;
 
@@ -190,13 +190,13 @@ SDL_AtomicSet(SDL_atomic_t *a, int v)
 {
 #ifdef HAVE_MSC_ATOMICS
     SDL_COMPILE_TIME_ASSERT(atomic_set, sizeof(long) == sizeof(a->value));
-    return _InterlockedExchange((long*)&a->value, v);
+    return _InterlockedExchange((long *)&a->value, v);
 #elif defined(HAVE_WATCOM_ATOMICS)
     return _SDL_xchg_watcom(&a->value, v);
 #elif defined(HAVE_GCC_ATOMICS)
     return __sync_lock_test_and_set(&a->value, v);
 #elif defined(__SOLARIS__)
-    return (int) atomic_swap_uint((volatile uint_t*)&a->value, v);
+    return (int)atomic_swap_uint((volatile uint_t *)&a->value, v);
 #else
     int value;
     do {
@@ -212,7 +212,7 @@ SDL_AtomicSetPtr(void **a, void *v)
 #if defined(HAVE_MSC_ATOMICS)
     return _InterlockedExchangePointer(a, v);
 #elif defined(HAVE_WATCOM_ATOMICS)
-    return (void *) _SDL_xchg_watcom((int *)a, (long)v);
+    return (void *)_SDL_xchg_watcom((int *)a, (long)v);
 #elif defined(HAVE_GCC_ATOMICS)
     return __sync_lock_test_and_set(a, v);
 #elif defined(__SOLARIS__)
@@ -231,7 +231,7 @@ SDL_AtomicAdd(SDL_atomic_t *a, int v)
 {
 #ifdef HAVE_MSC_ATOMICS
     SDL_COMPILE_TIME_ASSERT(atomic_add, sizeof(long) == sizeof(a->value));
-    return _InterlockedExchangeAdd((long*)&a->value, v);
+    return _InterlockedExchangeAdd((long *)&a->value, v);
 #elif defined(HAVE_WATCOM_ATOMICS)
     return _SDL_xadd_watcom(&a->value, v);
 #elif defined(HAVE_GCC_ATOMICS)
diff --git a/src/atomic/SDL_spinlock.c b/src/atomic/SDL_spinlock.c
index 965c021e1..58f5cf6c5 100644
--- a/src/atomic/SDL_spinlock.c
+++ b/src/atomic/SDL_spinlock.c
@@ -66,7 +66,7 @@ SDL_AtomicTryLock(SDL_SpinLock *lock)
     /* Terrible terrible damage */
     static SDL_mutex *_spinlock_mutex;
 
-    if (!_spinlock_mutex) {
+    if (_spinlock_mutex == NULL) {
         /* Race condition on first lock... */
         _spinlock_mutex = SDL_CreateMutex();
     }
@@ -81,14 +81,14 @@ SDL_AtomicTryLock(SDL_SpinLock *lock)
     }
 
 #elif HAVE_GCC_ATOMICS || HAVE_GCC_SYNC_LOCK_TEST_AND_SET
-    return (__sync_lock_test_and_set(lock, 1) == 0);
+    return __sync_lock_test_and_set(lock, 1) == 0;
 
 #elif defined(_MSC_VER) && (defined(_M_ARM) || defined(_M_ARM64))
-    return (_InterlockedExchange_acq(lock, 1) == 0);
+    return _InterlockedExchange_acq(lock, 1) == 0;
 
 #elif defined(_MSC_VER)
     SDL_COMPILE_TIME_ASSERT(locksize, sizeof(*lock) == sizeof(long));
-    return (InterlockedExchange((long*)lock, 1) == 0);
+    return InterlockedExchange((long *)lock, 1) == 0;
 
 #elif defined(__WATCOMC__) && defined(__386__)
     return _SDL_xchg_watcom(lock, 1) == 0;
@@ -105,28 +105,28 @@ SDL_AtomicTryLock(SDL_SpinLock *lock)
         __asm__ __volatile__ (
             "ldrex %0, [%2]\nteq   %0, #0\nstrexeq %0, %1, [%2]"
             : "=&r" (result) : "r" (1), "r" (lock) : "cc", "memory");
-        return (result == 0);
+        return result == 0;
     }
 #endif
 
     __asm__ __volatile__ (
         "swp %0, %1, [%2]\n"
         : "=&r,&r" (result) : "r,0" (1), "r,r" (lock) : "memory");
-    return (result == 0);
+    return result == 0;
 
 #elif defined(__GNUC__) && defined(__arm__)
     int result;
     __asm__ __volatile__ (
         "ldrex %0, [%2]\nteq   %0, #0\nstrexeq %0, %1, [%2]"
         : "=&r" (result) : "r" (1), "r" (lock) : "cc", "memory");
-    return (result == 0);
+    return result == 0;
 
 #elif defined(__GNUC__) && (defined(__i386__) || defined(__x86_64__))
     int result;
     __asm__ __volatile__(
         "lock ; xchgl %0, (%1)\n"
         : "=r" (result) : "r" (lock), "0" (1) : "cc", "memory");
-    return (result == 0);
+    return result == 0;
 
 #elif defined(__MACOSX__) || defined(__IPHONEOS__)
     /* Maybe used for PowerPC, but the Intel asm or gcc atomics are favored. */
@@ -134,11 +134,11 @@ SDL_AtomicTryLock(SDL_SpinLock *lock)
 
 #elif defined(__SOLARIS__) && defined(_LP64)
     /* Used for Solaris with non-gcc compilers. */
-    return (SDL_bool) ((int) atomic_cas_64((volatile uint64_t*)lock, 0, 1) == 0);
+    return (SDL_bool)((int)atomic_cas_64((volatile uint64_t *)lock, 0, 1) == 0);
 
 #elif defined(__SOLARIS__) && !defined(_LP64)
     /* Used for Solaris with non-gcc compilers. */
-    return (SDL_bool) ((int) atomic_cas_32((volatile uint32_t*)lock, 0, 1) == 0);
+    return (SDL_bool)((int)atomic_cas_32((volatile uint32_t *)lock, 0, 1) == 0);
 #elif defined(PS2)
     uint32_t oldintr;
     SDL_bool res = SDL_FALSE;
@@ -150,7 +150,7 @@ SDL_AtomicTryLock(SDL_SpinLock *lock)
         res = SDL_TRUE;
     }
     // enable interuption
-    if(oldintr) { EIntr(); }
+    if (oldintr) { EIntr(); }
     return res;
 #else
 #error Please implement for your platform.
diff --git a/src/audio/SDL_audio.c b/src/audio/SDL_audio.c
index 088887822..91d01339a 100644
--- a/src/audio/SDL_audio.c
+++ b/src/audio/SDL_audio.c
@@ -541,11 +541,9 @@ SDL_RemoveAudioDevice(const SDL_bool iscapture, void *handle)
     } else {
         mark_device_removed(handle, current_audio.outputDevices, &current_audio.outputDevicesRemoved);
     }
-    for (device_index = 0; device_index < SDL_arraysize(open_devices); device_index++)
-    {
+    for (device_index = 0; device_index < SDL_arraysize(open_devices); device_index++) {
         device = open_devices[device_index];
-        if (device != NULL && device->handle == handle)
-        {
+        if (device != NULL && device->handle == handle) {
             device_was_opened = SDL_TRUE;
             SDL_OpenedAudioDeviceDisconnected(device);
             break;
@@ -1009,7 +1007,7 @@ SDL_AudioInit(const char *driver_name)
         }
     } else {
         for (i = 0; (!initialized) && (bootstrap[i]); ++i) {
-            if(bootstrap[i]->demand_only) {
+            if (bootstrap[i]->demand_only) {
                 continue;
             }
 
diff --git a/src/audio/SDL_audiocvt.c b/src/audio/SDL_audiocvt.c
index 69427c5ef..398bdba1d 100644
--- a/src/audio/SDL_audiocvt.c
+++ b/src/audio/SDL_audiocvt.c
@@ -184,7 +184,7 @@ ResamplerPadding(const int inrate, const int outrate)
         return 0;
     }
     if (inrate > outrate) {
-        return (int) SDL_ceilf(((float) (RESAMPLER_SAMPLES_PER_ZERO_CROSSING * inrate) / ((float) outrate)));
+        return (int)SDL_ceilf(((float)(RESAMPLER_SAMPLES_PER_ZERO_CROSSING * inrate) / ((float)outrate)));
     }
     return RESAMPLER_SAMPLES_PER_ZERO_CROSSING;
 }
@@ -249,7 +249,7 @@ SDL_ResampleAudio(const int chans, const int inrate, const int outrate,
         outtime = ((ResampleFloatType) i) / ((ResampleFloatType) outrate);
     }
 
-    return outframes * chans * sizeof (float);
+    return outframes * chans * sizeof(float);
 }
 
 int
@@ -488,7 +488,7 @@ SDL_ResampleCVT(SDL_AudioCVT *cvt, const int chans, const SDL_AudioFormat format
 
     /* we keep no streaming state here, so pad with silence on both ends. */
     padding = (float *) SDL_calloc(paddingsamples ? paddingsamples : 1, sizeof (float));
-    if (!padding) {
+    if (padding == NULL) {
         SDL_OutOfMemory();
         return;
     }
@@ -586,7 +586,7 @@ SDL_BuildAudioResampleCVT(SDL_AudioCVT * cvt, const int dst_channels,
        !!! FIXME in 2.1:   We need to store data for this resampler, because the cvt structure doesn't store the original sample rates,
        !!! FIXME in 2.1:   so we steal the ninth and tenth slot.  :( */
     if (cvt->filter_index >= (SDL_AUDIOCVT_MAX_FILTERS-2)) {
-        return SDL_SetError("Too many filters needed for conversion, exceeded maximum of %d", SDL_AUDIOCVT_MAX_FILTERS-2);
+        return SDL_SetError("Too many filters needed for conversion, exceeded maximum of %d", SDL_AUDIOCVT_MAX_FILTERS - 2);
     }
     cvt->filters[SDL_AUDIOCVT_MAX_FILTERS-1] = (SDL_AudioFilter) (uintptr_t) src_rate;
     cvt->filters[SDL_AUDIOCVT_MAX_FILTERS] = (SDL_AudioFilter) (uintptr_t) dst_rate;
@@ -788,7 +788,7 @@ SDL_BuildAudioCVT(SDL_AudioCVT * cvt,
     }
 
     cvt->needed = (cvt->filter_index != 0);
-    return (cvt->needed);
+    return cvt->needed;
 }
 
 typedef int (*SDL_ResampleAudioStreamFunc)(SDL_AudioStream *stream, const void *inbuf, const int inbuflen, void *outbuf, const int outbuflen);
@@ -835,7 +835,7 @@ EnsureStreamBufferSize(SDL_AudioStream *stream, const int newlen)
         ptr = stream->work_buffer_base;
     } else {
         ptr = (Uint8 *) SDL_realloc(stream->work_buffer_base, newlen + 32);
-        if (!ptr) {
+        if (ptr == NULL) {
             SDL_OutOfMemory();
             return NULL;
         }
@@ -911,12 +911,12 @@ SetupLibSampleRateResampling(SDL_AudioStream *stream)
 
     if (SRC_available) {
         state = SRC_src_new(SRC_converter, stream->pre_resample_channels, &result);
-        if (!state) {
+        if (state == NULL) {
             SDL_SetError("src_new() failed: %s", SRC_src_strerror(result));
         }
     }
 
-    if (!state) {
+    if (state == NULL) {
         SDL_CleanupAudioStreamResampler_SRC(stream);
         return SDL_FALSE;
     }
@@ -983,7 +983,7 @@ SDL_NewAudioStream(const SDL_AudioFormat src_format,
     SDL_AudioStream *retval;
 
     retval = (SDL_AudioStream *) SDL_calloc(1, sizeof (SDL_AudioStream));
-    if (!retval) {
+    if (retval == NULL) {
         SDL_OutOfMemory();
         return NULL;
     }
@@ -1126,7 +1126,7 @@ SDL_AudioStreamPutInternal(SDL_AudioStream *stream, const void *buf, int len, in
     #endif
 
     workbuf = EnsureStreamBufferSize(stream, workbuflen);
-    if (!workbuf) {
+    if (workbuf == NULL) {
         return -1;  /* probably out of memory. */
     }
 
@@ -1193,8 +1193,9 @@ SDL_AudioStreamPutInternal(SDL_AudioStream *stream, const void *buf, int len, in
 
     if (maxputbytes) {
         const int maxbytes = *maxputbytes;
-        if (buflen > maxbytes)
+        if (buflen > maxbytes) {
             buflen = maxbytes;
+        }
         *maxputbytes -= buflen;
     }
 
@@ -1217,10 +1218,10 @@ SDL_AudioStreamPut(SDL_AudioStream *stream, const void *buf, int len)
     SDL_Log("AUDIOSTREAM: wants to put %d preconverted bytes\n", buflen);
     #endif
 
-    if (!stream) {
+    if (stream == NULL) {
         return SDL_InvalidParamError("stream");
     }
-    if (!buf) {
+    if (buf == NULL) {
         return SDL_InvalidParamError("buf");
     }
     if (len == 0) {
@@ -1272,7 +1273,7 @@ SDL_AudioStreamPut(SDL_AudioStream *stream, const void *buf, int len)
 
 int SDL_AudioStreamFlush(SDL_AudioStream *stream)
 {
-    if (!stream) {
+    if (stream == NULL) {
         return SDL_InvalidParamError("stream");
     }
 
@@ -1290,8 +1291,9 @@ int SDL_AudioStreamFlush(SDL_AudioStream *stream)
         const SDL_bool first_run = stream->first_run;
         const int filled = stream->staging_buffer_filled;
         int actual_input_frames = filled / stream->src_sample_frame_size;
-        if (!first_run)
+        if (!first_run) {
             actual_input_frames += stream->resampler_padding_samples / stream->pre_resample_channels;
+        }
 
         if (actual_input_frames > 0) {  /* don't bother if nothing to flush. */
             /* This is how many bytes we're expecting without silence appended. */
@@ -1330,10 +1332,10 @@ SDL_AudioStreamGet(SDL_AudioStream *stream, void *buf, int len)
     SDL_Log("AUDIOSTREAM: want to get %d converted bytes\n", len);
     #endif
 
-    if (!stream) {
+    if (stream == NULL) {
         return SDL_InvalidParamError("stream");
     }
-    if (!buf) {
+    if (buf == NULL) {
         return SDL_InvalidParamError("buf");
     }
     if (len <= 0) {
@@ -1343,20 +1345,20 @@ SDL_AudioStreamGet(SDL_AudioStream *stream, void *buf, int len)
         return SDL_SetError("Can't request partial sample frames");
     }
 
-    return (int) SDL_ReadFromDataQueue(stream->queue, buf, len);
+    return (int)SDL_ReadFromDataQueue(stream->queue, buf, len);
 }
 
 /* number of converted/resampled bytes available */
 int
 SDL_AudioStreamAvailable(SDL_AudioStream *stream)
 {
-    return stream ? (int) SDL_CountDataQueue(stream->queue) : 0;
+    return stream ? (int)SDL_CountDataQueue(stream->queue) : 0;
 }
 
 void
 SDL_AudioStreamClear(SDL_AudioStream *stream)
 {
-    if (!stream) {
+    if (stream == NULL) {
         SDL_InvalidParamError("stream");
     } else {
         SDL_ClearDataQueue(stream->queue, stream->packetlen * 2);
diff --git a/src/audio/SDL_audiodev.c b/src/audio/SDL_audiodev.c
index 0d06f65cd..ee674d7df 100644
--- a/src/audio/SDL_audiodev.c
+++ b/src/audio/SDL_audiodev.c
@@ -84,8 +84,9 @@ SDL_EnumUnixAudioDevices_Internal(const int iscapture, const int classic, int (*
     const char *audiodev;
     char audiopath[1024];
 
-    if (test == NULL)
+    if (test == NULL) {
         test = test_stub;
+    }
 
     /* Figure out what our audio device is */
     if (((audiodev = SDL_getenv("SDL_PATH_DSP")) == NULL) &&
diff --git a/src/audio/SDL_wave.c b/src/audio/SDL_wave.c
index e49b55068..9a0b9cc50 100644
--- a/src/audio/SDL_wave.c
+++ b/src/audio/SDL_wave.c
@@ -820,7 +820,7 @@ IMA_ADPCM_Init(WaveFile *file, size_t datalength)
         /* There's no specification for this, but it's basically the same
          * format because the extensible header has wSampePerBlocks too.
          */
-    } else  {
+    } else {
         /* The Standards Update says there 'should' be 2 bytes for wSamplesPerBlock. */
         if (chunk->size >= 20 && format->extsize >= 2) {
             format->samplesperblock = chunk->data[18] | ((Uint16)chunk->data[19] << 8);
@@ -901,14 +901,18 @@ IMA_ADPCM_ProcessNibble(Sint8 *cindex, Sint16 lastsample, Uint8 nybble)
      * (nybble & 0x8 ? -1 : 1) * ((nybble & 0x7) * step / 4 + step / 8)
      */
     delta = step >> 3;
-    if (nybble & 0x04)
+    if (nybble & 0x04) {
         delta += step;
-    if (nybble & 0x02)
+    }
+    if (nybble & 0x02) {
         delta += step >> 1;
-    if (nybble & 0x01)
+    }
+    if (nybble & 0x01) {
         delta += step >> 2;
-    if (nybble & 0x08)
+    }
+    if (nybble & 0x08) {
         delta = -delta;
+    }
 
     sample = lastsample + delta;
 
diff --git a/src/audio/aaudio/SDL_aaudio.c b/src/audio/aaudio/SDL_aaudio.c
index 5f318661d..2fac33614 100644
--- a/src/audio/aaudio/SDL_aaudio.c
+++ b/src/audio/aaudio/SDL_aaudio.c
@@ -441,7 +441,7 @@ SDL_bool aaudio_DetectBrokenPlayState( void )
     int64_t framePosition, timeNanoseconds;
     aaudio_result_t res;
 
-    if ( !audioDevice || !audioDevice->hidden ) {
+    if (audioDevice == NULL || !audioDevice->hidden ) {
         return SDL_FALSE;
     }
 
diff --git a/src/audio/alsa/SDL_alsa_audio.c b/src/audio/alsa/SDL_alsa_audio.c
index 59de607f8..7e35efd70 100644
--- a/src/audio/alsa/SDL_alsa_audio.c
+++ b/src/audio/alsa/SDL_alsa_audio.c
@@ -233,7 +233,7 @@ get_audio_device(void *handle, const int channels)
     const char *device;
 
     if (handle != NULL) {
-        return (const char *) handle;
+        return (const char *)handle;
     }
 
     /* !!! FIXME: we also check "SDL_AUDIO_DEVICE_NAME" at the higher level. */
@@ -401,8 +401,7 @@ ALSA_PlayDevice(_THIS)
                 return;
             }
             continue;
-        }
-        else if (status == 0) {
+        } else if (status == 0) {
             /* No frames were written (no available space in pcm device).
                Allow other threads to catch up. */
             Uint32 delay = (frames_left / 2 * 1000) / this->spec.freq;
@@ -417,7 +416,7 @@ ALSA_PlayDevice(_THIS)
 static Uint8 *
 ALSA_GetDeviceBuf(_THIS)
 {
-    return (this->hidden->mixbuf);
+    return this->hidden->mixbuf;
 }
 
 static int
@@ -441,8 +440,7 @@ ALSA_CaptureFromDevice(_THIS, void *buffer, int buflen)
         if (status == -EAGAIN) {
             ALSA_snd_pcm_wait(this->hidden->pcm_handle, wait_time);
             status = 0;
-        }
-        else if (status < 0) {
+        } else if (status < 0) {
             /*printf("ALSA: capture error %d\n", status);*/
             status = ALSA_snd_pcm_recover(this->hidden->pcm_handle, status, 0);
             if (status < 0) {
@@ -503,7 +501,7 @@ ALSA_set_buffer_size(_THIS, snd_pcm_hw_params_t *params)
     status = ALSA_snd_pcm_hw_params_set_period_size_near(
                 this->hidden->pcm_handle, hwparams, &persize, NULL);
     if ( status < 0 ) {
-        return(-1);
+        return -1;
     }
 
     /* Need to at least double buffer */
@@ -511,19 +509,19 @@ ALSA_set_buffer_size(_THIS, snd_pcm_hw_params_t *params)
     status = ALSA_snd_pcm_hw_params_set_periods_min(
                 this->hidden->pcm_handle, hwparams, &periods, NULL);
     if ( status < 0 ) {
-        return(-1);
+        return -1;
     }
 
     status = ALSA_snd_pcm_hw_params_set_periods_first(
                 this->hidden->pcm_handle, hwparams, &periods, NULL);
     if ( status < 0 ) {
-        return(-1);
+        return -1;
     }
 
     /* "set" the hardware with the desired parameters */
     status = ALSA_snd_pcm_hw_params(this->hidden->pcm_handle, hwparams);
     if ( status < 0 ) {
-        return(-1);
+        return -1;
     }
 
     this->spec.samples = persize;
@@ -539,7 +537,7 @@ ALSA_set_buffer_size(_THIS, snd_pcm_hw_params_t *params)
             persize, periods, bufsize);
     }
 
-    return(0);
+    return 0;
 }
 
 static int
@@ -575,8 +573,7 @@ ALSA_OpenDevice(_THIS, const char *devname)
                 SND_PCM_NONBLOCK);
 
     if (status < 0) {
-        return SDL_SetError("ALSA: Couldn't open audio device: %s",
-                            ALSA_snd_strerror(status));
+        return SDL_SetError("ALSA: Couldn't open audio device: %s", ALSA_snd_strerror(status));
     }
 
     this->hidden->pcm_handle = pcm_handle;
@@ -585,16 +582,14 @@ ALSA_OpenDevice(_THIS, const char *devname)
     snd_pcm_hw_params_alloca(&hwparams);
     status = ALSA_snd_pcm_hw_params_any(pcm_handle, hwparams);
     if (status < 0) {
-        return SDL_SetError("ALSA: Couldn't get hardware config: %s",
-                            ALSA_snd_strerror(status));
+        return SDL_SetError("ALSA: Couldn't get hardware config: %s", ALSA_snd_strerror(status));
     }
 
     /* SDL only uses interleaved sample output */
     status = ALSA_snd_pcm_hw_params_set_access(pcm_handle, hwparams,
                                                SND_PCM_ACCESS_RW_INTERLEAVED);
     if (status < 0) {
-        return SDL_SetError("ALSA: Couldn't set interleaved access: %s",
-                     ALSA_snd_strerror(status));
+        return SDL_SetError("ALSA: Couldn't set interleaved access: %s", ALSA_snd_strerror(status));
     }
 
     /* Try for a closest match on audio format */
@@ -676,8 +671,7 @@ ALSA_OpenDevice(_THIS, const char *devname)
     status = ALSA_snd_pcm_hw_params_set_rate_near(pcm_handle, hwparams,
                                                   &rate, NULL);
     if (status < 0) {
-        return SDL_SetError("ALSA: Couldn't set audio frequency: %s",
-                            ALSA_snd_strerror(status));
+        return SDL_SetError("ALSA: Couldn't set audio frequency: %s", ALSA_snd_strerror(status));
     }
     this->spec.freq = rate;
 
@@ -691,24 +685,20 @@ ALSA_OpenDevice(_THIS, const char *devname)
     snd_pcm_sw_params_alloca(&swparams);
     status = ALSA_snd_pcm_sw_params_current(pcm_handle, swparams);
     if (status < 0) {
-        return SDL_SetError("ALSA: Couldn't get software config: %s",
-                            ALSA_snd_strerror(status));
+        return SDL_SetError("ALSA: Couldn't get software config: %s", ALSA_snd_strerror(status));
     }
     status = ALSA_snd_pcm_sw_params_set_avail_min(pcm_handle, swparams, this->spec.samples);
     if (status < 0) {
-        return SDL_SetError("Couldn't set minimum available samples: %s",
-                            ALSA_snd_strerror(status));
+        return SDL_SetError("Couldn't set minimum available samples: %s", ALSA_snd_strerror(status));
     }
     status =
         ALSA_snd_pcm_sw_params_set_start_threshold(pcm_handle, swparams, 1);
     if (status < 0) {
-        return SDL_SetError("ALSA: Couldn't set start threshold: %s",
-                            ALSA_snd_strerror(status));
+        return SDL_SetError("ALSA: Couldn't set start threshold: %s", ALSA_snd_strerror(status));
     }
     status = ALSA_snd_pcm_sw_params(pcm_handle, swparams);
     if (status < 0) {
-        return SDL_SetError("Couldn't set software audio parameters: %s",
-                            ALSA_snd_strerror(status));
+        return SDL_SetError("Couldn't set software audio parameters: %s", ALSA_snd_strerror(status));
     }
 
     /* Calculate the final parameters for this audio specification */
@@ -749,7 +739,7 @@ add_device(const int iscapture, const char *name, void *hint, ALSA_Device **pSee
     char *handle = NULL;
     char *ptr;
 
-    if (!dev) {
+    if (dev == NULL) {
         return;
     }
 
@@ -759,7 +749,7 @@ add_device(const int iscapture, const char *name, void *hint, ALSA_Device **pSee
        Make sure not to free the storage associated with desc in this case */
     if (hint) {
         desc = ALSA_snd_device_name_get_hint(hint, "DESC");
-        if (!desc) {
+        if (desc == NULL) {
             SDL_free(dev);
             return;
         }
@@ -779,7 +769,7 @@ add_device(const int iscapture, const char *name, void *hint, ALSA_Device **pSee
     /*printf("ALSA: adding %s device '%s' (%s)\n", iscapture ? "capture" : "output", name, desc);*/
 
     handle = SDL_strdup(name);
-    if (!handle) {
+    if (handle == NULL) {
         if (hint) {
             free(desc);
         }
@@ -792,8 +782,9 @@ add_device(const int iscapture, const char *name, void *hint, ALSA_Device **pSee
      * enumeration time
      */
     SDL_AddAudioDevice(iscapture, desc, NULL, handle);
-    if (hint)
+    if (hint) {
         free(desc);
+    }
     dev->name = handle;
     dev->iscapture = iscapture;
     dev->next = *pSeen;
@@ -832,7 +823,7 @@ ALSA_HotplugIteration(void)
            if we can find a preferred prefix for the system. */
         for (i = 0; hints[i]; i++) {
             char *name = ALSA_snd_device_name_get_hint(hints[i], "NAME");
-            if (!name) {
+            if (name == NULL) {
                 continue;
             }
 
@@ -861,17 +852,17 @@ ALSA_HotplugIteration(void)
             char *name;
 
             /* if we didn't find a device name prefix we like at all... */
-            if ((!match) && (defaultdev != i)) {
+            if ((match == NULL) && (defaultdev != i)) {
                 continue;  /* ...skip anything that isn't the default device. */
             }
 
             name = ALSA_snd_device_name_get_hint(hints[i], "NAME");
-            if (!name) {
+            if (name == NULL) {
                 continue;
             }
 
             /* only want physical hardware interfaces */
-            if (!match || (SDL_strncmp(name, match, match_len) == 0)) {
+            if (match == NULL || (SDL_strncmp(name, match, match_len) == 0)) {
                 char *ioid = ALSA_snd_device_name_get_hint(hints[i], "IOID");
                 const SDL_bool isoutput = (ioid == NULL) || (SDL_strcmp(ioid, "Output") == 0);
                 const SDL_bool isinput = (ioid == NULL) || (SDL_strcmp(ioid, "Input") == 0);
@@ -896,8 +887,12 @@ ALSA_HotplugIteration(void)
                         }
                         dev->next = seen;
                         seen = dev;
-                        if (isinput) have_input = SDL_TRUE;
-                        if (isoutput) have_output = SDL_TRUE;
+                        if (isinput) {
+                            have_input = SDL_TRUE;
+                        }
+                        if (isoutput) {
+                            have_output = SDL_TRUE;
+                        }
                     } else {
                         prev = dev;
                     }
diff --git a/src/audio/android/SDL_androidaudio.c b/src/audio/android/SDL_androidaudio.c
index aa0d44242..7db3cbc30 100644
--- a/src/audio/android/SDL_androidaudio.c
+++ b/src/audio/android/SDL_androidaudio.c
@@ -147,26 +147,24 @@ void ANDROIDAUDIO_PauseDevices(void)
 {
     /* TODO: Handle multiple devices? */
     struct SDL_PrivateAudioData *private;
-    if(audioDevice != NULL && audioDevice->hidden != NULL) {
+    if (audioDevice != NULL && audioDevice->hidden != NULL) {
         private = (struct SDL_PrivateAudioData *) audioDevice->hidden;
         if (SDL_AtomicGet(&audioDevice->paused)) {
             /* The device is already paused, leave it alone */
             private->resume = SDL_FALSE;
-        }
-        else {
+        } else {
             SDL_LockMutex(audioDevice->mixer_lock);
             SDL_AtomicSet(&audioDevice->paused, 1);
             private->resume = SDL_TRUE;
         }
     }
 
-    if(captureDevice != NULL && captureDevice->hidden != NULL) {
+    if (captureDevice != NULL && captureDevice->hidden != NULL) {
         private = (struct SDL_PrivateAudioData *) captureDevice->hidden;
         if (SDL_AtomicGet(&captureDevice->paused)) {
             /* The device is already paused, leave it alone */
             private->resume = SDL_FALSE;
-        }
-        else {
+        } else {
             SDL_LockMutex(captureDevice->mixer_lock);
             SDL_AtomicSet(&captureDevice->paused, 1);
             private->resume = SDL_TRUE;
@@ -179,7 +177,7 @@ void ANDROIDAUDIO_ResumeDevices(void)
 {
     /* TODO: Handle multiple devices? */
     struct SDL_PrivateAudioData *private;
-    if(audioDevice != NULL && audioDevice->hidden != NULL) {
+    if (audioDevice != NULL && audioDevice->hidden != NULL) {
         private = (struct SDL_PrivateAudioData *) audioDevice->hidden;
         if (private->resume) {
             SDL_AtomicSet(&audioDevice->paused, 0);
@@ -188,7 +186,7 @@ void ANDROIDAUDIO_ResumeDevices(void)
         }
     }
 
-    if(captureDevice != NULL && captureDevice->hidden != NULL) {
+    if (captureDevice != NULL && captureDevice->hidden != NULL) {
         private = (struct SDL_PrivateAudioData *) captureDevice->hidden;
         if (private->resume) {
             SDL_AtomicSet(&captureDevice->paused, 0);
diff --git a/src/audio/directsound/SDL_directsound.c b/src/audio/directsound/SDL_directsound.c
index 885b5f0d5..e000cf71e 100644
--- a/src/audio/directsound/SDL_directsound.c
+++ b/src/audio/directsound/SDL_directsound.c
@@ -296,7 +296,7 @@ DSOUND_GetDeviceBuf(_THIS)
     }
     if (result != DS_OK) {
         SetDSerror("DirectSound GetCurrentPosition", result);
-        return (NULL);
+        return NULL;
     }
     cursor /= this->spec.size;
 #ifdef DEBUG_SOUND
@@ -331,9 +331,9 @@ DSOUND_GetDeviceBuf(_THIS)
     }
     if (result != DS_OK) {
         SetDSerror("DirectSound Lock", result);
-        return (NULL);
+        return NULL;
     }
-    return (this->hidden->locked_buf);
+    return this->hidden->locked_buf;
 }
 
 static int
diff --git a/src/audio/disk/SDL_diskaudio.c b/src/audio/disk/SDL_diskaudio.c
index 0a7a395e4..1a7f08b2e 100644
--- a/src/audio/disk/SDL_diskaudio.c
+++ b/src/audio/disk/SDL_diskaudio.c
@@ -68,7 +68,7 @@ DISKAUDIO_PlayDevice(_THIS)
 static Uint8 *
 DISKAUDIO_GetDeviceBuf(_THIS)
 {
-    return (_this->hidden->mixbuf);
+    return _this->hidden->mixbuf;
 }
 
 static int
diff --git a/src/audio/dsp/SDL_dspaudio.c b/src/audio/dsp/SDL_dspaudio.c
index 8734f7960..de67bf0eb 100644
--- a/src/audio/dsp/SDL_dspaudio.c
+++ b/src/audio/dsp/SDL_dspaudio.c
@@ -82,12 +82,13 @@ DSP_OpenDevice(_THIS, const char *devname)
 
     /* Make sure fragment size stays a power of 2, or OSS fails. */
     /* I don't know which of these are actually legal values, though... */
-    if (this->spec.channels > 8)
+    if (this->spec.channels > 8) {
         this->spec.channels = 8;
-    else if (this->spec.channels > 4)
+    } else if (this->spec.channels > 4) {
         this->spec.channels = 4;
-    else if (this->spec.channels > 2)
+    } else if (this->spec.channels > 2) {
         this->spec.channels = 2;
+    }
 
     /* Initialize all variables that we clean on shutdown */
     this->hidden = (struct SDL_PrivateAudioData *)
@@ -260,13 +261,13 @@ DSP_PlayDevice(_THIS)
 static Uint8 *
 DSP_GetDeviceBuf(_THIS)
 {
-    return (this->hidden->mixbuf);
+    return this->hidden->mixbuf;
 }
 
 static int
 DSP_CaptureFromDevice(_THIS, void *buffer, int buflen)
 {
-    return (int) read(this->hidden->audio_fd, buffer, buflen);
+    return (int)read(this->hidden->audio_fd, buffer, buflen);
 }
 
 static void
diff --git a/src/audio/jack/SDL_jackaudio.c b/src/audio/jack/SDL_jackaudio.c
index f6e7e0cd3..3302c3450 100644
--- a/src/audio/jack/SDL_jackaudio.c
+++ b/src/audio/jack/SDL_jackaudio.c
@@ -313,7 +313,7 @@ JACK_OpenDevice(_THIS, const char *devname)
     }
 
     devports = JACK_jack_get_ports(client, NULL, NULL, JackPortIsPhysical | sysportflags);
-    if (!devports || !devports[0]) {
+    if (devports == NULL || !devports[0]) {
         return SDL_SetError("No physical JACK ports available");
     }
 
diff --git a/src/audio/netbsd/SDL_netbsdaudio.c b/src/audio/netbsd/SDL_netbsdaudio.c
index 5f021ea37..9a223fb83 100644
--- a/src/audio/netbsd/SDL_netbsdaudio.c
+++ b/src/audio/netbsd/SDL_netbsdaudio.c
@@ -146,7 +146,7 @@ NETBSDAUDIO_PlayDevice(_THIS)
 static Uint8 *
 NETBSDAUDIO_GetDeviceBuf(_THIS)
 {
-    return (this->hidden->mixbuf);
+    return this->hidden->mixbuf;
 }
 
 
diff --git a/src/audio/openslES/SDL_openslES.c b/src/audio/openslES/SDL_openslES.c
index 474de3bfe..814a75aaa 100644
--- a/src/audio/openslES/SDL_openslES.c
+++ b/src/audio/openslES/SDL_openslES.c
@@ -424,7 +424,7 @@ openslES_CreatePCMPlayer(_THIS)
        it can be done as described here:
         https://developer.android.com/ndk/guides/audio/opensl/android-extensions.html#floating-point
     */
-    if(SDL_GetAndroidSDKVersion() >= 21) {
+    if (SDL_GetAndroidSDKVersion() >= 21) {
         SDL_AudioFormat test_format;
         for (test_format = SDL_FirstAudioFormat(this->spec.format); test_format; test_format = SDL_NextAudioFormat()) {
             if (SDL_AUDIO_ISSIGNED(test_format)) {
@@ -499,7 +499,7 @@ openslES_CreatePCMPlayer(_THIS)
         break;
     }
 
-    if(SDL_AUDIO_ISFLOAT(this->spec.format)) {
+    if (SDL_AUDIO_ISFLOAT(this->spec.format)) {
         /* Copy all setup into PCM EX structure */
         format_pcm_ex.formatType = SL_ANDROID_DATAFORMAT_PCM_EX;
         format_pcm_ex.endianness = format_pcm.endianness;
diff --git a/src/audio/pipewire/SDL_pipewire.c b/src/audio/pipewire/SDL_pipewire.c
index 2e173ef9a..f707a2df1 100644
--- a/src/audio/pipewire/SDL_pipewire.c
+++ b/src/audio/pipewire/SDL_pipewire.c
@@ -1065,7 +1065,7 @@ input_callback(void *data)
     }
 
     pw_buf = PIPEWIRE_pw_stream_dequeue_buffer(stream);
-    if (!pw_buf) {
+    if (pw_buf == NULL) {
         return;
     }
 
@@ -1189,15 +1189,15 @@ PIPEWIRE_OpenDevice(_THIS, const char *devname)
 
     /* Get the hints for the application name, stream name and role */
     app_name = SDL_GetHint(SDL_HINT_AUDIO_DEVICE_APP_NAME);
-    if (!app_name || *app_name == '\0') {
+    if (app_name == NULL || *app_name == '\0') {
         app_name = SDL_GetHint(SDL_HINT_APP_NAME);
-        if (!app_name || *app_name == '\0') {
+        if (app_name == NULL || *app_name == '\0') {
             app_name = "SDL Application";
         }
     }
 
     stream_name = SDL_GetHint(SDL_HINT_AUDIO_DEVICE_STREAM_NAME);
-    if (!stream_name || *stream_name == '\0') {
+    if (stream_name == NULL || *stream_name == '\0') {
         stream_name = "Audio Stream";
     }
 
@@ -1206,7 +1206,7 @@ PIPEWIRE_OpenDevice(_THIS, const char *devname)
      * but 'Game' seems more appropriate for the majority of SDL applications.
      */
     stream_role = SDL_GetHint(SDL_HINT_AUDIO_DEVICE_STREAM_ROLE);
-    if (!stream_role || *stream_role == '\0') {
+    if (stream_role == NULL || *stream_role == '\0') {
         stream_role = "Game";
     }
 
diff --git a/src/audio/ps2/SDL_ps2audio.c b/src/audio/ps2/SDL_ps2audio.c
index b050984de..fa85f0437 100644
--- a/src/audio/ps2/SDL_ps2audio.c
+++ b/src/audio/ps2/SDL_ps2audio.c
@@ -156,8 +156,9 @@ static void PS2AUDIO_Deinitialize(void)
 
 static SDL_bool PS2AUDIO_Init(SDL_AudioDriverImpl * impl)
 {
-    if(init_audio_driver() < 0)
+    if (init_audio_driver() < 0) {
         return SDL_FALSE;
+    }
 
     /* Set the function pointers */
     impl->OpenDevice = PS2AUDIO_OpenDevice;
diff --git a/src/audio/psp/SDL_pspaudio.c b/src/audio/psp/SDL_pspaudio.c
index d908170c6..077b001b6 100644
--- a/src/audio/psp/SDL_pspaudio.c
+++ b/src/audio/psp/SDL_pspaudio.c
@@ -105,7 +105,7 @@ PSPAUDIO_OpenDevice(_THIS, const char *devname)
 
 static void PSPAUDIO_PlayDevice(_THIS)
 {
-    if (this->spec.freq != 44100){
+    if (this->spec.freq != 44100) {
         Uint8 *mixbuf = this->hidden->mixbufs[this->hidden->next_buffer];
         SDL_assert(this->spec.channels == 2);
         sceAudioSRCOutputBlocking(PSP_AUDIO_VOLUME_MAX, mixbuf);
@@ -131,7 +131,7 @@ static Uint8 *PSPAUDIO_GetDeviceBuf(_THIS)
 static void PSPAUDIO_CloseDevice(_THIS)
 {
     if (this->hidden->channel >= 0) {
-        if (this->spec.freq != 44100){
+        if (this->spec.freq != 44100) {
             sceAudioSRCChRelease();
         } else {
             sceAudioChRelease(this->hidden->channel);
diff --git a/src/audio/pulseaudio/SDL_pulseaudio.c b/src/audio/pulseaudio/SDL_pulseaudio.c
index 288c3d98a..a6360dad9 100644
--- a/src/audio/pulseaudio/SDL_pulseaudio.c
+++ b/src/audio/pulseaudio/SDL_pulseaudio.c
@@ -53,17 +53,11 @@ static SDL_bool include_monitors = SDL_FALSE;
 #if (PA_API_VERSION < 12)
 /** Return non-zero if the passed state is one of the connected states */
 static SDL_INLINE int PA_CONTEXT_IS_GOOD(pa_context_state_t x) {
-    return
-        x == PA_CONTEXT_CONNECTING ||
-        x == PA_CONTEXT_AUTHORIZING ||
-        x == PA_CONTEXT_SETTING_NAME ||
-        x == PA_CONTEXT_READY;
+    return x == PA_CONTEXT_CONNECTING || x == PA_CONTEXT_AUTHORIZING || x == PA_CONTEXT_SETTING_NAME || x == PA_CONTEXT_READY;
 }
 /** Return non-zero if the passed state is one of the connected states */
 static SDL_INLINE int PA_STREAM_IS_GOOD(pa_stream_state_t x) {
-    return
-        x == PA_STREAM_CREATING ||
-        x == PA_STREAM_READY;
+    return x == PA_STREAM_CREATING || x == PA_STREAM_READY;
 }
 #endif /* pulseaudio <= 0.9.10 */
 
@@ -312,7 +306,7 @@ ConnectToPulseServer_Internal(pa_mainloop **_mainloop, pa_context **_context)
     SDL_assert(mainloop_api);  /* this never fails, right? */
 
     context = PULSEAUDIO_pa_context_new(mainloop_api, getAppName());
-    if (!context) {
+    if (context == NULL) {
         PULSEAUDIO_pa_mainloop_free(mainloop);
         return SDL_SetError("pa_context_new() failed");
     }
@@ -545,7 +539,7 @@ FindDeviceName(struct SDL_PrivateAudioData *h, const SDL_bool iscapture, void *h
                 SinkDeviceNameCallback, &h->device_name));
     }
 
-    return (h->device_name != NULL);
+    return h->device_name != NULL;
 }
 
 static int
diff --git a/src/audio/vita/SDL_vitaaudio.c b/src/audio/vita/SDL_vitaaudio.c
index 88f4a3285..41a785b60 100644
--- a/src/audio/vita/SDL_vitaaudio.c
+++ b/src/audio/vita/SDL_vitaaudio.c
@@ -81,7 +81,7 @@ VITAAUD_OpenDevice(_THIS, const char *devname)
         }
     }
 
-    if(!test_format) {
+    if (!test_format) {
         return SDL_SetError("Unsupported audio format");
     }
 
@@ -111,7 +111,7 @@ VITAAUD_OpenDevice(_THIS, const char *devname)
         format = SCE_AUDIO_OUT_MODE_STEREO;
     }
 
-    if(this->spec.freq < 48000) {
+    if (this->spec.freq < 48000) {
         port = SCE_AUDIO_OUT_PORT_TYPE_BGM;
     }
 
diff --git a/src/audio/wasapi/SDL_wasapi_winrt.cpp b/src/audio/wasapi/SDL_wasapi_winrt.cpp
index 235ae7d32..40dd00278 100644
--- a/src/audio/wasapi/SDL_wasapi_winrt.cpp
+++ b/src/audio/wasapi/SDL_wasapi_winrt.cpp
@@ -389,8 +389,7 @@ WASAPI_RemoveDevice(const SDL_bool iscapture, LPCWSTR devid)
         if (SDL_wcscmp(i->str, devid) == 0) {
             if (prev) {
                 prev->next = next;
-            }
-            else {
+            } else {
                 deviceid_list = next;
             }
             SDL_RemoveAudioDevice(iscapture, i->str);
@@ -421,7 +420,7 @@ WASAPI_AddDevice(const SDL_bool iscapture, const char *devname, WAVEFORMATEXTENS
     }
 
     devidlist = (DevIdList *)SDL_malloc(sizeof(*devidlist));
-    if (!devidlist) {
+    if (devidlist == NULL) {
         return;  /* oh well. */
     }
 
diff --git a/src/core/android/SDL_android.c b/src/core/android/SDL_android.c
index ebdd1041b..ea1eb51f4 100644
--- a/src/core/android/SDL_android.c
+++ b/src/core/android/SDL_android.c
@@ -734,7 +734,7 @@ JNIEXPORT int JNICALL SDL_JAVA_INTERFACE(nativeRunMain)(JNIEnv *env, jclass cls,
     library_file = (*env)->GetStringUTFChars(env, library, NULL);
     library_handle = dlopen(library_file, RTLD_GLOBAL);
 
-    if (!library_handle) {
+    if (library_handle == NULL) {
         /* When deploying android app bundle format uncompressed native libs may not extract from apk to filesystem.
            In this case we should use lib name without path. https://bugzilla.libsdl.org/show_bug.cgi?id=4739 */
         const char *library_name = SDL_strrchr(library_file, '/');
@@ -777,7 +777,7 @@ JNIEXPORT int JNICALL SDL_JAVA_INTERFACE(nativeRunMain)(JNIEnv *env, jclass cls,
                     }
                     (*env)->DeleteLocalRef(env, string);
                 }
-                if (!arg) {
+                if (arg == NULL) {
                     arg = SDL_strdup("");
                 }
                 argv[argc++] = arg;
@@ -874,8 +874,7 @@ JNIEXPORT void JNICALL SDL_JAVA_INTERFACE(onNativeResize)(
 {
     SDL_LockMutex(Android_ActivityMutex);
 
-    if (Android_Window)
-    {
+    if (Android_Window) {
         Android_SendResize(Android_Window);
     }
 
@@ -890,8 +889,7 @@ JNIEXPORT void JNICALL SDL_JAVA_INTERFACE(onNativeOrientationChanged)(
 
     displayOrientation = (SDL_DisplayOrientation)orientation;
 
-    if (Android_Window)
-    {
+    if (Android_Window) {
         SDL_VideoDisplay *display = SDL_GetDisplay(0);
         SDL_SendDisplayEvent(display, SDL_DISPLAYEVENT_ORIENTATION, orientation);
     }
@@ -1000,8 +998,7 @@ JNIEXPORT void JNICALL SDL_JAVA_INTERFACE(onNativeSurfaceCreated)(JNIEnv *env, j
 {
     SDL_LockMutex(Android_ActivityMutex);
 
-    if (Android_Window)
-    {
+    if (Android_Window) {
         SDL_WindowData *data = (SDL_WindowData *) Android_Window->driverdata;
 
         data->native_window = Android_JNI_GetNativeWindow();
@@ -1019,8 +1016,7 @@ JNIEXPORT void JNICALL SDL_JAVA_INTERFACE(onNativeSurfaceChanged)(JNIEnv *env, j
     SDL_LockMutex(Android_ActivityMutex);
 
 #if SDL_VIDEO_OPENGL_EGL
-    if (Android_Window)
-    {
+    if (Android_Window) {
         SDL_VideoDevice *_this = SDL_GetVideoDevice();
         SDL_WindowData  *data  = (SDL_WindowData *) Android_Window->driverdata;
 
@@ -1045,8 +1041,7 @@ retry:
 
     SDL_LockMutex(Android_ActivityMutex);
 
-    if (Android_Window)
-    {
+    if (Android_Window) {
         SDL_VideoDevice *_this = SDL_GetVideoDevice();
         SDL_WindowData  *data  = (SDL_WindowData *) Android_Window->driverdata;
 
@@ -1880,7 +1875,7 @@ size_t Android_JNI_FileRead(SDL_RWops* ctx, void* buffer,
 
     if (result > 0) {
         /* Number of chuncks */
-        return (result / size);
+        return result / size;
     } else {
         /* Error or EOF */
         return result;
@@ -2265,7 +2260,7 @@ void *SDL_AndroidGetActivity(void)
     /* See SDL_system.h for caveats on using this function. */
 
     JNIEnv *env = Android_JNI_GetEnv();
-    if (!env) {
+    if (env == NULL) {
         return NULL;
     }
 
@@ -2319,7 +2314,7 @@ const char * SDL_AndroidGetInternalStoragePath(void)
 {
     static char *s_AndroidInternalFilesPath = NULL;
 
-    if (!s_AndroidInternalFilesPath) {
+    if (s_AndroidInternalFilesPath == NULL) {
         struct LocalReferenceHolder refs = LocalReferenceHolder_Setup(__FUNCTION__);
         jmethodID mid;
         jobject context;
@@ -2412,7 +2407,7 @@ const char * SDL_AndroidGetExternalStoragePath(void)
 {
     static char *s_AndroidExternalFilesPath = NULL;
 
-    if (!s_AndroidExternalFilesPath) {
+    if (s_AndroidExternalFilesPath == NULL) {
         struct LocalReferenceHolder refs = LocalReferenceHolder_Setup(__FUNCTION__);
         jmethodID mid;
         jobject context;
diff --git a/src/core/freebsd/SDL_evdev_kbd_freebsd.c b/src/core/freebsd/SDL_evdev_kbd_freebsd.c
index c242053ac..b44656f2c 100644
--- a/src/core/freebsd/SDL_evdev_kbd_freebsd.c
+++ b/src/core/freebsd/SDL_evdev_kbd_freebsd.c
@@ -68,7 +68,7 @@ struct SDL_EVDEV_keyboard_state
 
 static int SDL_EVDEV_kbd_load_keymaps(SDL_EVDEV_keyboard_state *kbd)
 {
-    return (ioctl(kbd->keyboard_fd, GIO_KEYMAP, kbd->key_map) >= 0);
+    return ioctl(kbd->keyboard_fd, GIO_KEYMAP, kbd->key_map) >= 0;
 }
 
 static SDL_EVDEV_keyboard_state * kbd_cleanup_state = NULL;
@@ -96,7 +96,9 @@ static void kbd_cleanup(void)
     SDL_zero(mData);
     mData.operation = MOUSE_SHOW;
     ioctl(kbd->keyboard_fd, KDSKBMODE, kbd->old_kbd_mode);
-    if (kbd->keyboard_fd != kbd->console_fd) close(kbd->keyboard_fd);
+    if (kbd->keyboard_fd != kbd->console_fd) {
+        close(kbd->keyboard_fd);
+    }
     ioctl(kbd->console_fd, CONS_SETKBD, (unsigned long)(kbd->kbInfo->kb_index));
     ioctl(kbd->console_fd, CONS_MOUSECTL, &mData);
 }
@@ -152,13 +154,14 @@ static void kbd_unregister_emerg_cleanup()
         old_action_p = &(old_sigaction[signum]);
 
         /* Examine current signal action */
-        if (sigaction(signum, NULL, &cur_action))
+        if (sigaction(signum, NULL, &cur_action)) {
             continue;
+        }
 
         /* Check if action installed and not modifed */
-        if (!(cur_action.sa_flags & SA_SIGINFO)
-                || cur_action.sa_sigaction != &kbd_cleanup_signal_action)
+        if (!(cur_action.sa_flags & SA_SIGINFO) || cur_action.sa_sigaction != &kbd_cleanup_signal_action) {
             continue;
+        }
 
         /* Restore original action */
         sigaction(signum, old_action_p, NULL);
@@ -202,16 +205,16 @@ static void kbd_register_emerg_cleanup(SDL_EVDEV_keyboard_state * kbd)
         struct sigaction new_action;
         signum = fatal_signals[tabidx];   
         old_action_p = &(old_sigaction[signum]);
-        if (sigaction(signum, NULL, old_action_p))
+        if (sigaction(signum, NULL, old_action_p)) {
             continue;
+        }
 
         /* Skip SIGHUP and SIGPIPE if handler is already installed
          * - assume the handler will do the cleanup
          */
-        if ((signum == SIGHUP || signum == SIGPIPE)
-                && (old_action_p->sa_handler != SIG_DFL 
-                    || (void (*)(int))old_action_p->sa_sigaction != SIG_DFL))
+        if ((signum == SIGHUP || signum == SIGPIPE) && (old_action_p->sa_handler != SIG_DFL || (void(*)(int))old_action_p->sa_sigaction != SIG_DFL)) {
             continue;
+        }
 
         new_action = *old_action_p;
         new_action.sa_flags |= SA_SIGINFO;
@@ -231,7 +234,7 @@ SDL_EVDEV_kbd_init(void)
     SDL_zero(mData);
     mData.operation = MOUSE_HIDE;
     kbd = (SDL_EVDEV_keyboard_state *)SDL_calloc(1, sizeof(SDL_EVDEV_keyboard_state));
-    if (!kbd) {
+    if (kbd == NULL) {
         return NULL;
     }
 
@@ -253,8 +256,7 @@ SDL_EVDEV_kbd_init(void)
         kbd->ledflagstate = flag_state;
     }
     
-    if (ioctl(kbd->console_fd, GIO_DEADKEYMAP, kbd->accents) < 0)
-    {
+    if (ioctl(kbd->console_fd, GIO_DEADKEYMAP, kbd->accents) < 0) {
         SDL_free(kbd->accents);
         kbd->accents = &accentmap_default_us_acc;
     }
@@ -262,8 +264,7 @@ SDL_EVDEV_kbd_init(void)
     if (ioctl(kbd->console_fd, KDGKBMODE, &kbd->old_kbd_mode) == 0) {
         /* Set the keyboard in XLATE mode and load the keymaps */
         ioctl(kbd->console_fd, KDSKBMODE, (unsigned long)(K_XLATE));
-        if(!SDL_EVDEV_kbd_load_keymaps(kbd))
-        {
+        if (!SDL_EVDEV_kbd_load_keymaps(kbd)) {
             SDL_free(kbd->key_map);
             kbd->key_map = &keymap_default_us_acc;
         }
@@ -275,8 +276,7 @@ SDL_EVDEV_kbd_init(void)
             ioctl(kbd->console_fd, CONS_RELKBD, 1ul);
             SDL_asprintf(&devicePath, "/dev/kbd%d", kbd->kbInfo->kb_index);
             kbd->keyboard_fd = open(devicePath, O_WRONLY | O_CLOEXEC);
-            if (kbd->keyboard_fd == -1)
-            {
+            if (kbd->keyboard_fd == -1) {
                 // Give keyboard back.
                 ioctl(kbd->console_fd, CONS_SETKBD, (unsigned long)(kbd->kbInfo->kb_index));
                 kbd->keyboard_fd = kbd->console_fd;
@@ -289,8 +289,7 @@ SDL_EVDEV_kbd_init(void)
                 kbd_register_emerg_cleanup(kbd);
             }
             SDL_free(devicePath);
-        }
-        else kbd->keyboard_fd = kbd->console_fd;
+        } else kbd->keyboard_fd = kbd->console_fd;
     }
 
     return kbd;
@@ -301,7 +300,7 @@ SDL_EVDEV_kbd_quit(SDL_EVDEV_keyboard_state *kbd)
 {
     struct mouse_info mData;
 
-    if (!kbd) {
+    if (kbd == NULL) {
         return;
     }
     SDL_zero(mData);
@@ -315,8 +314,7 @@ SDL_EVDEV_kbd_quit(SDL_EVDEV_keyboard_state *kbd)
         ioctl(kbd->keyboard_fd, KDSKBMODE, kbd->old_kbd_mode);
 
         close(kbd->keyboard_fd);
-        if (kbd->console_fd != kbd->keyboard_fd && kbd->console_fd >= 0)
-        {
+        if (kbd->console_fd != kbd->keyboard_fd && kbd->console_fd >= 0) {
             // Give back keyboard.
             ioctl(kbd->console_fd, CONS_SETKBD, (unsigned long)(kbd->kbInfo->kb_index));
         }
@@ -347,10 +345,12 @@ static void put_utf8(SDL_EVDEV_keyboard_state *kbd, uint c)
         put_queue(kbd, 0xc0 | (c >> 6));
         put_queue(kbd, 0x80 | (c & 0x3f));
     } else if (c < 0x10000) {
-        if (c >= 0xD800 && c < 0xE000)
+        if (c >= 0xD800 && c < 0xE000) {
             return;
-        if (c == 0xFFFF)
+        }
+        if (c == 0xFFFF) {
             return;
+        }
         /* 1110**** 10****** 10****** */
         put_queue(kbd, 0xe0 | (c >> 12));
         put_queue(kbd, 0x80 | ((c >> 6) & 0x3f));
@@ -379,13 +379,14 @@ static unsigned int handle_diacr(SDL_EVDEV_keyboard_state *kbd, unsigned int ch)
     kbd->diacr = 0;
 
     for (i = 0; i < kbd->accents->n_accs; i++) {
-        if (kbd->accents->acc[i].accchar == d)
-        {
+        if (kbd->accents->acc[i].accchar == d) {
             for (j = 0; j < NUM_ACCENTCHARS; ++j) {
-                    if (kbd->accents->acc[i].map[j][0] == 0)        /* end of table */
+                    if (kbd->accents->acc[i].map[j][0] == 0) { /* end of table */
                             break;
-                    if (kbd->accents->acc[i].map[j][0] == ch)
+                    } 
+                    if (kbd->accents->acc[i].map[j][0] == ch) {
                             return kbd->accents->acc[i].map[j][1];
+                    }
             }
         }
     }
@@ -416,11 +417,13 @@ static void chg_vc_kbd_led(SDL_EVDEV_keyboard_state *kbd, int flag)
 
 static void k_self(SDL_EVDEV_keyboard_state *kbd, unsigned int value, char up_flag)
 {
-    if (up_flag)
-        return;        /* no action, if this is a key release */
+    if (up_flag) {
+        return; /* no action, if this is a key release */
+    }
 
-    if (kbd->diacr)
+    if (kbd->diacr) {
         value = handle_diacr(kbd, value);
+    }
 
     if (kbd->dead_key_next) {
         kbd->dead_key_next = SDL_FALSE;
@@ -450,8 +453,9 @@ static void k_shift(SDL_EVDEV_keyboard_state *kbd, unsigned char value, char up_
          * handle the case that two shift or control
          * keys are depressed simultaneously
          */
-        if (kbd->shift_down[value])
+        if (kbd->shift_down[value]) {
             kbd->shift_down[value]--;
+        }
     } else
         kbd->shift_down[value]++;
 
@@ -477,7 +481,7 @@ SDL_EVDEV_kbd_keycode(SDL_EVDEV_keyboard_state *kbd, unsigned int keycode, int d
 
     key_map = *kbd->key_map;
 
-    if (!kbd) {
+    if (kbd == NULL) {
         return;
     }
 
@@ -488,10 +492,10 @@ SDL_EVDEV_kbd_keycode(SDL_EVDEV_keyboard_state *kbd, unsigned int keycode, int d
             /* These constitute unprintable language-related keys, so ignore them. */
             return;
         }
-        if (keycode > 95)
+        if (keycode > 95) {
             keycode -= 7;
-        if (vc_kbd_led(kbd, ALKED) || (kbd->shift_state & 0x8))
-        {
+        }
+        if (vc_kbd_led(kbd, ALKED) || (kbd->shift_state & 0x8)) {
             keycode += ALTGR_OFFSET;
         }
         keysym = key_map.key[keycode];
@@ -500,18 +504,21 @@ SDL_EVDEV_kbd_keycode(SDL_EVDEV_keyboard_state *kbd, unsigned int keycode, int d
     }
 
     final_key_state = kbd->shift_state & 0x7;
-    if ((keysym.flgs & FLAG_LOCK_C) && vc_kbd_led(kbd, LED_CAP))
+    if ((keysym.flgs & FLAG_LOCK_C) && vc_kbd_led(kbd, LED_CAP)) {
         final_key_state ^= 0x1;
-    if ((keysym.flgs & FLAG_LOCK_N) && vc_kbd_led(kbd, LED_NUM))
+    }
+    if ((keysym.flgs & FLAG_LOCK_N) && vc_kbd_led(kbd, LED_NUM)) {
         final_key_state ^= 0x1;
+    }
 
     map_from_key_sym = keysym.map[final_key_state];
     if ((keysym.spcl & (0x80 >> final_key_state)) || (map_from_key_sym & SPCLKEY)) {
         /* Special function.*/
         if (map_from_key_sym == 0)
             return; /* Nothing to do. */
-        if (map_from_key_sym & SPCLKEY)
+        if (map_from_key_sym & SPCLKEY) {
             map_from_key_sym &= ~SPCLKEY;
+        }
         if (map_from_key_sym >= F_ACC && map_from_key_sym <= L_ACC) {
             /* Accent function.*/
             unsigned int accent_index = map_from_key_sym - F_ACC;
@@ -525,36 +532,50 @@ SDL_EVDEV_kbd_keycode(SDL_EVDEV_keyboard_state *kbd, unsigned int keycode, int d
                 break;
             case LSHA: /* left shift + alt lock */
             case RSHA: /* right shift + alt lock */
-                if (down == 0) chg_vc_kbd_led(kbd, ALKED);
+                if (down == 0) {
+                    chg_vc_kbd_led(kbd, ALKED);
+                }
             case LSH: /* left shift */
             case RSH: /* right shift */
                 k_shift(kbd, 0, down == 0);
                 break;
             case LCTRA: /* left ctrl + alt lock */
             case RCTRA: /* right ctrl + alt lock */
-                if (down == 0) chg_vc_kbd_led(kbd, ALKED);
+                if (down == 0) {
+                    chg_vc_kbd_led(kbd, ALKED);
+                }
             case LCTR: /* left ctrl */
             case RCTR: /* right ctrl */
                 k_shift(kbd, 1, down == 0);
                 break;
             case LALTA: /* left alt + alt lock */
             case RALTA: /* right alt + alt lock */
-                if (down == 0) chg_vc_kbd_led(kbd, ALKED);
+                if (down == 0) {
+                    chg_vc_kbd_led(kbd, ALKED);
+                }
             case LALT: /* left alt */
             case RALT: /* right alt */
                 k_shift(kbd, 2, down == 0);
                 break;
             case ALK: /* alt lock */
-                if (down == 1) chg_vc_kbd_led(kbd, ALKED);
+                if (down == 1) {
+                    chg_vc_kbd_led(kbd, ALKED);
+                }
                 break;
             case CLK: /* caps lock*/
-                if (down == 1) chg_vc_kbd_led(kbd, CLKED);
+                if (down == 1) {
+                    chg_vc_kbd_led(kbd, CLKED);
+                }
                 break;
             case NLK: /* num lock */
-                if (down == 1) chg_vc_kbd_led(kbd, NLKED);
+                if (down == 1) {
+                    chg_vc_kbd_led(kbd, NLKED);
+                }
                 break;
             case SLK: /* scroll lock */
-                if (down == 1) chg_vc_kbd_led(kbd, SLKED);
+                if (down == 1) {
+                    chg_vc_kbd_led(kbd, SLKED);
+                }
                 break;
             default:
                 return;
diff --git a/src/core/gdk/SDL_gdk.cpp b/src/core/gdk/SDL_gdk.cpp
index a9ccc1ca9..11033ff7c 100644
--- a/src/core/gdk/SDL_gdk.cpp
+++ b/src/core/gdk/SDL_gdk.cpp
@@ -109,13 +109,13 @@ SDL_GDKRunApp(SDL_main_func mainFunction, void *reserved)
 
     /* Parse it into argv and argc */
     argv = (char **) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, (argc + 1) * sizeof(*argv));
-    if (!argv) {
+    if (argv == NULL) {
         return OutOfMemory();
     }
     for (i = 0; i < argc; ++i) {
         DWORD len;
         char *arg = WIN_StringToUTF8W(argvw[i]);
-        if (!arg) {
+        if (arg == NULL) {
             return OutOfMemory();
         }
         len = (DWORD) SDL_strlen(arg);
diff --git a/src/core/linux/SDL_dbus.c b/src/core/linux/SDL_dbus.c
index 9153e5052..a35dc4aa1 100644
--- a/src/core/linux/SDL_dbus.c
+++ b/src/core/linux/SDL_dbus.c
@@ -201,7 +201,7 @@ SDL_DBus_Quit(void)
 SDL_DBusContext *
 SDL_DBus_GetContext(void)
 {
-    if (!dbus_handle || !dbus.session_conn) {
+    if (dbus_handle == NULL || !dbus.session_conn) {
         SDL_DBus_Init();
     }
     
@@ -379,20 +379,25 @@ SDL_DBus_AppendDictWithKeyValue(DBusMessageIter *iterInit, const char *key, cons
 {
     DBusMessageIter iterDict, iterEntry, iterValue;
 
-    if (!dbus.message_iter_open_container(iterInit, DBUS_TYPE_ARRAY, "{sv}", &iterDict))
+    if (!dbus.message_iter_open_container(iterInit, DBUS_TYPE_ARRAY, "{sv}", &iterDict)) {
         goto failed;
+    }
 
-    if (!dbus.message_iter_open_container(&iterDict, DBUS_TYPE_DICT_ENTRY, NULL, &iterEntry))
+    if (!dbus.message_iter_open_container(&iterDict, DBUS_TYPE_DICT_ENTRY, NULL, &iterEntry)) {
         goto failed;
+    }
 
-    if (!dbus.message_iter_append_basic(&iterEntry, DBUS_TYPE_STRING, &key))
+    if (!dbus.message_iter_append_basic(&iterEntry, DBUS_TYPE_STRING, &key)) {
         goto failed;
+    }
 
-    if (!dbus.message_iter_open_container(&iterEntry, DBUS_TYPE_VARIANT, DBUS_TYPE_STRING_AS_STRING, &iterValue))
+    if (!dbus.message_iter_open_container(&iterEntry, DBUS_TYPE_VARIANT, DBUS_TYPE_STRING_AS_STRING, &iterValue)) {
         goto failed;
+    }
 
-    if (!dbus.message_iter_append_basic(&iterValue, DBUS_TYPE_STRING, &value))
+    if (!dbus.message_iter_append_basic(&iterValue, DBUS_TYPE_STRING, &value)) {
         goto failed;
+    }
 
     if (!dbus.message_iter_close_container(&iterEntry, &iterValue)
         || !dbus.message_iter_close_container(&iterDict, &iterEntry)
@@ -439,12 +444,12 @@ SDL_DBus_ScreensaverInhibit(SDL_bool inhibit)
             const char *key = "reason";
             const char *reply = NULL;
             const char *reason = SDL_GetHint(SDL_HINT_SCREENSAVER_INHIBIT_ACTIVITY_NAME);
-            if (!reason || !reason[0]) {
+            if (reason == NULL || !reason[0]) {
                 reason = default_inhibit_reason;
             }
 
             msg = dbus.message_new_method_call(bus_name, path, interface, "Inhibit");
-            if (!msg) {
+            if (msg == NULL) {
                 return SDL_FALSE;
             }
 
@@ -481,10 +486,10 @@ SDL_DBus_ScreensaverInhibit(SDL_bool inhibit)
         if (inhibit) {
             const char *app = SDL_GetHint(SDL_HINT_APP_NAME);
             const char *reason = SDL_GetHint(SDL_HINT_SCREENSAVER_INHIBIT_ACTIVITY_NAME);
-            if (!app || !app[0]) {
+            if (app == NULL || !app[0]) {
                app  = "My SDL application";
             }
-            if (!reason || !reason[0]) {
+            if (reason == NULL || !reason[0]) {
                 reason = default_inhibit_reason;
             }
 
diff --git a/src/core/linux/SDL_evdev.c b/src/core/linux/SDL_evdev.c
index f5ab06253..d24b16e90 100644
--- a/src/core/linux/SDL_evdev.c
+++ b/src/core/linux/SDL_evdev.c
@@ -188,14 +188,14 @@ SDL_EVDEV_Init(void)
                    ROM. */
                 char* rest = (char*) devices;
                 char* spec;
-                while ((spec = strtok_r(rest, ",", &rest))) {
+                while ((spec = SDL_strtokr(rest, ",", &rest))) {
                     char* endofcls = 0;
-                    long cls = strtol(spec, &endofcls, 0);
-                    if (endofcls)
+                    long cls = SDL_strtol(spec, &endofcls, 0);
+                    if (endofcls) {
                         SDL_EVDEV_device_added(endofcls + 1, cls);
+                    }
                 }
-            }
-            else {
+            } else {
                 /* TODO: Scan the devices manually, like a caveman */
             }
         }
@@ -229,7 +229,7 @@ SDL_EVDEV_Quit(void)
         SDL_EVDEV_kbd_quit(_this->kbd);
 
         /* Remove existing devices */
-        while(_this->first != NULL) {
+        while (_this->first != NULL) {
             SDL_EVDEV_device_removed(_this->first->path);
         }
 
@@ -252,11 +252,13 @@ static void SDL_EVDEV_udev_callback(SDL_UDEV_deviceevent udev_event, int udev_cl
 
     switch(udev_event) {
     case SDL_UDEV_DEVICEADDED:
-        if (!(udev_class & (SDL_UDEV_DEVICE_MOUSE | SDL_UDEV_DEVICE_KEYBOARD | SDL_UDEV_DEVICE_TOUCHSCREEN | SDL_UDEV_DEVICE_TOUCHPAD)))
+        if (!(udev_class & (SDL_UDEV_DEVICE_MOUSE | SDL_UDEV_DEVICE_KEYBOARD | SDL_UDEV_DEVICE_TOUCHSCREEN | SDL_UDEV_DEVICE_TOUCHPAD))) {
             return;
+        }
 
-        if ((udev_class & SDL_UDEV_DEVICE_JOYSTICK))
+        if ((udev_class & SDL_UDEV_DEVICE_JOYSTICK)) {
             return;
+        }
 
         SDL_EVDEV_device_added(dev_path, udev_class);
         break;  
@@ -341,13 +343,15 @@ SDL_EVDEV_Poll(void)
                 case EV_ABS:
                     switch(events[i].code) {
                     case ABS_MT_SLOT:
-                        if (!item->is_touchscreen) /* FIXME: temp hack */
+                        if (!item->is_touchscreen) { /* FIXME: temp hack */
                             break;
+                        } 
                         item->touchscreen_data->current_slot = events[i].value;
                         break;
                     case ABS_MT_TRACKING_ID:
-                        if (!item->is_touchscreen) /* FIXME: temp hack */
+                        if (!item->is_touchscreen) { /* FIXME: temp hack */
                             break;
+                        }
                         if (events[i].value >= 0) {
                             item->touchscreen_data->slots[item->touchscreen_data->current_slot].tracking_id = events[i].value;
                             item->touchscreen_data->slots[item->touchscreen_data->current_slot].delta = EVDEV_TOUCH_SLOTDELTA_DOWN;
@@ -356,24 +360,27 @@ SDL_EVDEV_Poll(void)
                         }
                         break;
                     case ABS_MT_POSITION_X:
-                        if (!item->is_touchscreen) /* FIXME: temp hack */
+                        if (!item->is_touchscreen) { /* FIXME: temp hack */
                             break;
+                        }
                         item->touchscreen_data->slots[item->touchscreen_data->current_slot].x = events[i].value;
                         if (item->touchscreen_data->slots[item->touchscreen_data->current_slot].delta == EVDEV_TOUCH_SLOTDELTA_NONE) {
                             item->touchscreen_data->slots[item->touchscreen_data->current_slot].delta = EVDEV_TOUCH_SLOTDELTA_MOVE;
                         }
                         break;
                     case ABS_MT_POSITION_Y:
-                        if (!item->is_touchscreen) /* FIXME: temp hack */
+                        if (!item->is_touchscreen) { /* FIXME: temp hack */
                             break;
+                        }
                         item->touchscreen_data->slots[item->touchscreen_data->current_slot].y = events[i].value;
                         if (item->touchscreen_data->slots[item->touchscreen_data->current_slot].delta == EVDEV_TOUCH_SLOTDELTA_NONE) {
                             item->touchscreen_data->slots[item->touchscreen_data->current_slot].delta = EVDEV_TOUCH_SLOTDELTA_MOVE;
                         }
                         break;
                     case ABS_MT_PRESSURE:
-                        if (!item->is_touchscreen) /* FIXME: temp hack */
+                        if (!item->is_touchscreen) { /* FIXME: temp hack */
                             break;
+                        }
                         item->touchscreen_data->slots[item->touchscreen_data->current_slot].pressure = events[i].value;
                         if (item->touchscreen_data->slots[item->touchscreen_data->current_slot].delta == EVDEV_TOUCH_SLOTDELTA_NONE) {
                             item->touchscreen_data->slots[item->touchscreen_data->current_slot].delta = EVDEV_TOUCH_SLOTDELTA_MOVE;
@@ -381,8 +388,9 @@ SDL_EVDEV_Poll(void)
                         break;
                     case ABS_X:
                         if (item->is_touchscreen) {
-                            if (item->touchscreen_data->max_slots != 1)
+                            if (item->touchscreen_data->max_slots != 1) {
                                 break;
+                            }
                             item->touchscreen_data->slots[0].x = events[i].value;
                         } else if (!item->relative_mouse) {
                             /* FIXME: Normalize to input device's reported input range (EVIOCGABS) */
@@ -391,8 +399,9 @@ SDL_EVDEV_Poll(void)
                         break;
                     case ABS_Y:
                         if (item->is_touchscreen) {
-                            if (item->touchscreen_data->max_slots != 1)
+                            if (item->touchscreen_data->max_slots != 1) {
                                 break;
+                            }
                             item->touchscreen_data->slots[0].y = events[i].value;
                         } else if (!item->relative_mouse) {
                             /* FIXME: Normalize to input device's reported input range (EVIOCGABS) */
@@ -406,24 +415,28 @@ SDL_EVDEV_Poll(void)
                 case EV_REL:
                     switch(events[i].code) {
                     case REL_X:
-                        if (item->relative_mouse)
+                        if (item->relative_mouse) {
                             item->mouse_x += events[i].value;
+                        }
                         break;
                     case REL_Y:
-                        if (item->relative_mouse)
+                        if (item->relative_mouse) {
                             item->mouse_y += events[i].value;
+                        }
                         break;
                     case REL_WHEEL:
-                        if (!item->high_res_wheel)
+                        if (!item->high_res_wheel) {
                             item->mouse_wheel += events[i].value;
+                        }
                         break;
                     case REL_WHEEL_HI_RES:
                         SDL_assert(item->high_res_wheel);
                         item->mouse_wheel += events[i].value;
                         break;
                     case REL_HWHEEL:
-                        if (!item->high_res_hwheel)
+                        if (!item->high_res_hwheel) {
                             item->mouse_hwheel += events[i].value;
+                        }
                         break;
                     case REL_HWHEEL_HI_RES:
                         SDL_assert(item->high_res_hwheel);
@@ -449,10 +462,11 @@ SDL_EVDEV_Poll(void)
                             item->mouse_wheel = item->mouse_hwheel = 0;
                         }
 
-                        if (!item->is_touchscreen) /* FIXME: temp hack */
+                        if (!item->is_touchscreen) { /* FIXME: temp hack */
                             break;
+                        }
 
-                        for(j = 0; j < item->touchscreen_data->max_slots; j++) {
+                        for (j = 0; j < item->touchscreen_data->max_slots; j++) {
                             norm_x = (float)(item->touchscreen_data->slots[j].x - item->touchscreen_data->min_x) /
                                 (float)item->touchscreen_data->range_x;
                             norm_y = (float)(item->touchscreen_data->slots[j].y - item->touchscreen_data->min_y) /
@@ -488,12 +502,14 @@ SDL_EVDEV_Poll(void)
                             }
                         }
 
-                        if (item->out_of_sync)
+                        if (item->out_of_sync) {
                             item->out_of_sync = SDL_FALSE;
+                        }
                         break;
                     case SYN_DROPPED:
-                        if (item->is_touchscreen)
+                        if (item->is_touchscreen) {
                             item->out_of_sync = SDL_TRUE;
+                        }
                         SDL_EVDEV_sync_device(item);
                         break;
                     default:
@@ -536,12 +552,14 @@ SDL_EVDEV_init_touchscreen(SDL_evdevlist_item* item, int udev_class)
     char name[64];
     struct input_absinfo abs_info;
 
-    if (!item->is_touchscreen)
+    if (!item->is_touchscreen) {
         return 0;
+    }
 
     item->touchscreen_data = SDL_calloc(1, sizeof(*item->touchscreen_data));
-    if (item->touchscreen_data == NULL)
+    if (item->touchscreen_data == NULL) {
         return SDL_OutOfMemory();
+    }
 
     ret = ioctl(item->fd, EVIOCGNAME(sizeof(name)), name);
     if (ret < 0) {
@@ -611,7 +629,7 @@ SDL_EVDEV_init_touchscreen(SDL_evdevlist_item* item, int udev_class)
         return SDL_OutOfMemory();
     }
 
-    for(i = 0; i < item->touchscreen_data->max_slots; i++) {
+    for (i = 0; i < item->touchscreen_data->max_slots; i++) {
         item->touchscreen_data->slots[i].tracking_id = -1;
     }
 
@@ -630,8 +648,9 @@ SDL_EVDEV_init_touchscreen(SDL_evdevlist_item* item, int udev_class)
 
 static void
 SDL_EVDEV_destroy_touchscreen(SDL_evdevlist_item* item) {
-    if (!item->is_touchscreen)
+    if (!item->is_touchscreen) {
         return;
+    }
 
     SDL_DelTouch(item->fd);
     SDL_free(item->touchscreen_data->slots);
@@ -658,8 +677,9 @@ SDL_EVDEV_sync_device(SDL_evdevlist_item *item)
     size_t mt_req_size;
 
     /* TODO: sync devices other than touchscreen */
-    if (!item->is_touchscreen)
+    if (!item->is_touchscreen) {
         return;
+    }
 
     mt_req_size = sizeof(*mt_req_code) +
         sizeof(*mt_req_values) * item->touchscreen_data->max_slots;
@@ -677,7 +697,7 @@ SDL_EVDEV_sync_device(SDL_evdevlist_item *item)
         SDL_free(mt_req_code);
         return;
     }
-    for(i = 0; i < item->touchscreen_data->max_slots; i++) {
+    for (i = 0; i < item->touchscreen_data->max_slots; i++) {
         /*
          * This doesn't account for the very edge case of the user removing their
          * finger and replacing it on the screen during the time we're out of sync,
@@ -704,7 +724,7 @@ SDL_EVDEV_sync_device(SDL_evdevlist_item *item)
         SDL_free(mt_req_code);
         return;
     }
-    for(i = 0; i < item->touchscreen_data->max_slots; i++) {
+    for (i = 0; i < item->touchscreen_data->max_slots; i++) {
         if (item->touchscreen_data->slots[i].tracking_id >= 0 &&
             item->touchscreen_data->slots[i].x != mt_req_values[i]) {
             item->touchscreen_data->slots[i].x = mt_req_values[i];
@@ -722,7 +742,7 @@ SDL_EVDEV_sync_device(SDL_evdevlist_item *item)
         SDL_free(mt_req_code);
         return;
     }
-    for(i = 0; i < item->touchscreen_data->max_slots; i++) {
+    for (i = 0; i < item->touchscreen_data->max_slots; i++) {
         if (item->touchscreen_data->slots[i].tracking_id >= 0 &&
             item->touchscreen_data->slots[i].y != mt_req_values[i]) {
             item->touchscreen_data->slots[i].y = mt_req_values[i];
@@ -740,7 +760,7 @@ SDL_EVDEV_sync_device(SDL_evdevlist_item *item)
         SDL_free(mt_req_code);
         return;
     }
-    for(i = 0; i < item->touchscreen_data->max_slots; i++) {
+    for (i = 0; i < item->touchscreen_data->max_slots; i++) {
         if (item->touchscreen_data->slots[i].tracking_id >= 0 &&
             item->touchscreen_data->slots[i].pressure != mt_req_values[i]) {
             item->touchscreen_data->slots[i].pressure = mt_req_values[i];
diff --git a/src/core/linux/SDL_evdev_capabilities.c b/src/core/linux/SDL_evdev_capabilities.c
index e23d49973..cf5530f84 100644
--- a/src/core/linux/SDL_evdev_capabilities.c
+++ b/src/core/linux/SDL_evdev_capabilities.c
@@ -138,8 +138,9 @@ SDL_EVDEV_GuessDeviceClass(unsigned long bitmask_ev[NBITS(EV_MAX)],
     /* the first 32 bits are ESC, numbers, and Q to D; if we have any of
      * those, consider it a keyboard device; do not test KEY_RESERVED, though */
     keyboard_mask = 0xFFFFFFFE;
-    if ((bitmask_key[0] & keyboard_mask) != 0)
+    if ((bitmask_key[0] & keyboard_mask) != 0) {
         devclass |= SDL_UDEV_DEVICE_KEYBOARD; /* ID_INPUT_KEYBOARD */
+    }
 
     return devclass;
 }
diff --git a/src/core/linux/SDL_evdev_kbd.c b/src/core/linux/SDL_evdev_kbd.c
index f090bff41..f7f01deb4 100644
--- a/src/core/linux/SDL_evdev_kbd.c
+++ b/src/core/linux/SDL_evdev_kbd.c
@@ -270,13 +270,14 @@ static void kbd_unregister_emerg_cleanup()
         old_action_p = &(old_sigaction[signum]);
 
         /* Examine current signal action */
-        if (sigaction(signum, NULL, &cur_action))
+        if (sigaction(signum, NULL, &cur_action)) {
             continue;
+        }
 
         /* Check if action installed and not modifed */
-        if (!(cur_action.sa_flags & SA_SIGINFO)
-                || cur_action.sa_sigaction != &kbd_cleanup_signal_action)
+        if (!(cur_action.sa_flags & SA_SIGINFO) || cur_action.sa_sigaction != &kbd_cleanup_signal_action) {
             continue;
+        }
 
         /* Restore original action */
         sigaction(signum, old_action_p, NULL);
@@ -320,16 +321,16 @@ static void kbd_register_emerg_cleanup(SDL_EVDEV_keyboard_state * kbd)
         struct sigaction new_action;
         signum = fatal_signals[tabidx];   
         old_action_p = &(old_sigaction[signum]);
-        if (sigaction(signum, NULL, old_action_p))
+        if (sigaction(signum, NULL, old_action_p)) {
             continue;
+        }
 
         /* Skip SIGHUP and SIGPIPE if handler is already installed
          * - assume the handler will do the cleanup
          */
-        if ((signum == SIGHUP || signum == SIGPIPE)
-                && (old_action_p->sa_handler != SIG_DFL 
-                    || (void (*)(int))old_action_p->sa_sigaction != SIG_DFL))
+        if ((signum == SIGHUP || signum == SIGPIPE) && (old_action_p->sa_handler != SIG_DFL || (void(*)(int))old_action_p->sa_sigaction != SIG_DFL)) {
             continue;
+        }
 
         new_action = *old_action_p;
         new_action.sa_flags |= SA_SIGINFO;
@@ -347,7 +348,7 @@ SDL_EVDEV_kbd_init(void)
     char shift_state[ sizeof (long) ] = {TIOCL_GETSHIFTSTATE, 0};
 
     kbd = (SDL_EVDEV_keyboard_state *)SDL_calloc(1, sizeof(*kbd));
-    if (!kbd) {
+    if (kbd == NULL) {
         return NULL;
     }
 
@@ -413,7 +414,7 @@ SDL_EVDEV_kbd_init(void)
 void
 SDL_EVDEV_kbd_quit(SDL_EVDEV_keyboard_state *kbd)
 {
-    if (!kbd) {
+    if (kbd == NULL) {
         return;
     }
 
@@ -461,10 +462,12 @@ static void put_utf8(SDL_EVDEV_keyboard_state *kbd, uint c)
         put_queue(kbd, 0xc0 | (c >> 6));
         put_queue(kbd, 0x80 | (c & 0x3f));
     } else if (c < 0x10000) {
-        if (c >= 0xD800 && c < 0xE000)
+        if (c >= 0xD800 && c < 0xE000) {
             return;
-        if (c == 0xFFFF)
+        }
+        if (c == 0xFFFF) {
             return;
+        }
         /* 1110**** 10****** 10****** */
         put_queue(kbd, 0xe0 | (c >> 12));
         put_queue(kbd, 0x80 | ((c >> 6) & 0x3f));
@@ -499,8 +502,9 @@ static unsigned int handle_diacr(SDL_EVDEV_keyboard_state *kbd, unsigned int ch)
         }
     }
 
-    if (ch == ' ' || ch == d)
+    if (ch == ' ' || ch == d) {
         return d;
+    }
 
     put_utf8(kbd, d);
 
@@ -554,24 +558,27 @@ static void fn_enter(SDL_EVDEV_keyboard_state *kbd)
 
 static void fn_caps_toggle(SDL_EVDEV_keyboard_state *kbd)
 {
-    if (kbd->rep)
+    if (kbd->rep) {
         return;
+    }
 
     chg_vc_kbd_led(kbd, K_CAPSLOCK);
 }
 
 static void fn_caps_on(SDL_EVDEV_keyboard_state *kbd)
 {
-    if (kbd->rep)
+    if (kbd->rep) {
         return;
+    }
 
     set_vc_kbd_led(kbd, K_CAPSLOCK);
 }
 
 static void fn_num(SDL_EVDEV_keyboard_state *kbd)
 {
-    if (!kbd->rep)
+    if (!kbd->rep) {
         chg_vc_kbd_led(kbd, K_NUMLOCK);
+    }
 }
 
 static void fn_compose(SDL_EVDEV_keyboard_state *kbd)
@@ -589,12 +596,15 @@ static void k_ignore(SDL_EVDEV_keyboard_state *kbd, unsigned char value, char up
 
 static void k_spec(SDL_EVDEV_keyboard_state *kbd, unsigned char value, char up_flag)
 {
-    if (up_flag)
+    if (up_flag) {
         return;
-    if (value >= SDL_arraysize(fn_handler))
+    }
+    if (value >= SDL_arraysize(fn_handler)) {
         return;
-    if (fn_handler[value])
+    }
+    if (fn_handler[value]) {
         fn_handler[value](kbd);
+    }
 }
 
 static void k_lowercase(SDL_EVDEV_keyboard_state *kbd, unsigned char value, char up_flag)
@@ -603,11 +613,13 @@ static void k_lowercase(SDL_EVDEV_keyboard_state *kbd, unsigned char value, char
 
 static void k_self(SDL_EVDEV_keyboard_state *kbd, unsigned char value, char up_flag)
 {
-    if (up_flag)
-        return;        /* no action, if this is a key release */
+    if (up_flag) {
+        return; /* no action, if this is a key release */
+    } 
 
-    if (kbd->diacr)
+    if (kbd->diacr) {
         value = handle_diacr(kbd, value);
+    }
 
     if (kbd->dead_key_next) {
         kbd->dead_key_next = SDL_FALSE;
@@ -676,8 +688,9 @@ static void k_shift(SDL_EVDEV_keyboard_state *kbd, unsigned char value, char up_
      */
     if (value == KVAL(K_CAPSSHIFT)) {
         value = KVAL(K_SHIFT);
-        if (!up_flag)
+        if (!up_flag) {
             clr_vc_kbd_led(kbd, K_CAPSLOCK);
+        }
     }
 
     if (up_flag) {
@@ -685,8 +698,9 @@ static void k_shift(SDL_EVDEV_keyboard_state *kbd, unsigned char value, char up_
          * handle the case that two shift or control
          * keys are depressed simultaneously
          */
-        if (kbd->shift_down[value])
+        if (kbd->shift_down[value]) {
             kbd->shift_down[value]--;
+        }
     } else
         kbd->shift_down[value]++;
 
@@ -762,7 +776,7 @@ SDL_EVDEV_kbd_keycode(SDL_EVDEV_keyboard_state *kbd, unsigned int keycode, int d
     unsigned short *key_map;
     unsigned short keysym;
 
-    if (!kbd) {
+    if (kbd == NULL) {
         return;
     }
 
@@ -770,7 +784,7 @@ SDL_EVDEV_kbd_keycode(SDL_EVDEV_keyboard_state *kbd, unsigned int keycode, int d
 
     shift_final = (kbd->shift_state | kbd->slockstate) ^ kbd->lockstate;
     key_map = kbd->key_maps[shift_final];
-    if (!key_map) {
+    if (key_map == NULL) {
         /* Unsupported shift state (e.g. ctrl = 4, alt = 8), just reset to the default state */
         kbd->shift_state = 0;
         kbd->slockstate = 0;
diff --git a/src/core/linux/SDL_fcitx.c b/src/core/linux/SDL_fcitx.c
index f653279d7..5e5e8f06f 100644
--- a/src/core/linux/SDL_fcitx.c
+++ b/src/core/linux/SDL_fcitx.c
@@ -347,14 +347,30 @@ Fcitx_ModState(void)
     Uint32 fcitx_mods = 0;
     SDL_Keymod sdl_mods = SDL_GetModState();
 
-    if (sdl_mods & KMOD_SHIFT) fcitx_mods |= (1 << 0);
-    if (sdl_mods & KMOD_CAPS)   fcitx_mods |= (1 << 1);
-    if (sdl_mods & KMOD_CTRL)  fcitx_mods |= (1 << 2);
-    if (sdl_mods & KMOD_ALT)   fcitx_mods |= (1 << 3);
-    if (sdl_mods & KMOD_NUM)    fcitx_mods |= (1 << 4);
-    if (sdl_mods & KMOD_MODE)   fcitx_mods |= (1 << 7);
-    if (sdl_mods & KMOD_LGUI)   fcitx_mods |= (1 << 6);
-    if (sdl_mods & KMOD_RGUI)   fcitx_mods |= (1 << 28);
+    if (sdl_mods & KMOD_SHIFT) {
+        fcitx_mods |= (1 << 0);
+    }
+    if (sdl_mods & KMOD_CAPS) {
+        fcitx_mods |= (1 << 1);
+    }
+    if (sdl_mods & KMOD_CTRL) {
+        fcitx_mods |= (1 << 2);
+    }
+    if (sdl_mods & KMOD_ALT) {
+        fcitx_mods |= (1 << 3);
+    }
+    if (sdl_mods & KMOD_NUM) {
+        fcitx_mods |= (1 << 4);
+    }
+    if (sdl_mods & KMOD_MODE) {
+        fcitx_mods |= (1 << 7);
+    }
+    if (sdl_mods & KMOD_LGUI) {
+        fcitx_mods |= (1 << 6);
+    }
+    if (sdl_mods & KMOD_RGUI) {
+        fcitx_mods |= (1 << 28);
+    }
 
     return fcitx_mods;
 }
@@ -436,7 +452,7 @@ SDL_Fcitx_UpdateTextRect(const SDL_Rect *rect)
     }
 
     focused_win = SDL_GetKeyboardFocus();
-    if (!focused_win) {
+    if (focused_win == NULL) {
         return ;
     }
 
diff --git a/src/core/linux/SDL_ibus.c b/src/core/linux/SDL_ibus.c
index 94f7aa626..d56c5d5ce 100644
--- a/src/core/linux/SDL_ibus.c
+++ b/src/core/linux/SDL_ibus.c
@@ -65,14 +65,30 @@ IBus_ModState(void)
     SDL_Keymod sdl_mods = SDL_GetModState();
     
     /* Not sure about MOD3, MOD4 and HYPER mappings */
-    if (sdl_mods & KMOD_LSHIFT) ibus_mods |= IBUS_SHIFT_MASK;
-    if (sdl_mods & KMOD_CAPS)   ibus_mods |= IBUS_LOCK_MASK;
-    if (sdl_mods & KMOD_LCTRL)  ibus_mods |= IBUS_CONTROL_MASK;
-    if (sdl_mods & KMOD_LALT)   ibus_mods |= IBUS_MOD1_MASK;
-    if (sdl_mods & KMOD_NUM)    ibus_mods |= IBUS_MOD2_MASK;
-    if (sdl_mods & KMOD_MODE)   ibus_mods |= IBUS_MOD5_MASK;
-    if (sdl_mods & KMOD_LGUI)   ibus_mods |= IBUS_SUPER_MASK;
-    if (sdl_mods & KMOD_RGUI)   ibus_mods |= IBUS_META_MASK;
+    if (sdl_mods & KMOD_LSHIFT) {
+        ibus_mods |= IBUS_SHIFT_MASK;
+    }
+    if (sdl_mods & KMOD_CAPS) {
+        ibus_mods |= IBUS_LOCK_MASK;
+    }
+    if (sdl_mods & KMOD_LCTRL) {
+        ibus_mods |= IBUS_CONTROL_MASK;
+    }
+    if (sdl_mods & KMOD_LALT) {
+        ibus_mods |= IBUS_MOD1_MASK;
+    }
+    if (sdl_mods & KMOD_NUM) {
+        ibus_mods |= IBUS_MOD2_MASK;
+    }
+    if (sdl_mods & KMOD_MODE) {
+        ibus_mods |= IBUS_MOD5_MASK;
+    }
+    if (sdl_mods & KMOD_LGUI) {
+        ibus_mods |= IBUS_SUPER_MASK;
+    }
+    if (sdl_mods & KMOD_RGUI) {
+        ibus_mods |= IBUS_META_MASK;
+    }
 
     return ibus_mods;
 }
@@ -99,7 +115,7 @@ IBus_EnterVariant(DBusConnection *conn, DBusMessageIter *iter, SDL_DBusContext *
     }
 
     dbus->message_iter_get_basic(inside, &struct_id);
-    if (!struct_id || SDL_strncmp(struct_id, struct_id, id_size) != 0) {
+    if (struct_id == NULL || SDL_strncmp(struct_id, struct_id, id_size) != 0) {
         return SDL_FALSE;
     }
     return SDL_TRUE;
@@ -249,13 +265,12 @@ IBus_MessageHandler(DBusConnection *conn, DBusMessage *msg, void *user_data)
 
                 dbus->message_iter_init(msg, &iter);
                 has_dec_pos = IBus_GetDecorationPosition(conn, &iter, dbus, &start_pos, &end_pos);
-                if (!has_dec_pos)
-                {
+                if (!has_dec_pos) {
                     dbus->message_iter_init(msg, &iter);
                     has_pos = IBus_GetVariantCursorPos(conn, &iter, dbus, &pos);
                 }
 
-                if(has_dec_pos) {
+                if (has_dec_pos) {
                     SDL_SendEditingText(text, start_pos, end_pos - start_pos);
                 } else if (has_pos) {
                     SDL_SendEditingText(text, pos, -1);
@@ -299,15 +314,19 @@ IBus_ReadAddressFromFile(const char *file_path)
     FILE *addr_file;
 
     addr_file = fopen(file_path, "r");
-    if (!addr_file) {
+    if (addr_file == NULL) {
         return NULL;
     }
 
     while (fgets(addr_buf, sizeof(addr_buf), addr_file)) {
         if (SDL_strncmp(addr_buf, "IBUS_ADDRESS=", sizeof("IBUS_ADDRESS=")-1) == 0) {
             size_t sz = SDL_strlen(addr_buf);
-            if (addr_buf[sz-1] == '\n') addr_buf[sz-1] = 0;
-            if (addr_buf[sz-2] == '\r') addr_buf[sz-2] = 0;
+            if (addr_buf[sz - 1] == '\n') {
+                addr_buf[sz - 1] = 0;
+            }
+            if (addr_buf[sz - 2] == '\r') {
+                addr_buf[sz - 2] = 0;
+            }
             success = SDL_TRUE;
             break;
         }
@@ -341,7 +360,7 @@ IBus_GetDBusAddressFilename(void)
     }
     
     dbus = SDL_DBus_GetContext();
-    if (!dbus) {
+    if (dbus == NULL) {
         return NULL;
     }
     
@@ -355,7 +374,7 @@ IBus_GetDBusAddressFilename(void)
        and look up the address from a filepath using all those bits, eek. */
     disp_env = SDL_getenv("DISPLAY");
 
-    if (!disp_env || !*disp_env) {
+    if (disp_env == NULL || !*disp_env) {
         display = SDL_strdup(":0.0");
     } else {
         display = SDL_strdup(disp_env);
@@ -365,7 +384,7 @@ IBus_GetDBusAddressFilename(void)
     disp_num   = SDL_strrchr(display, ':');
     screen_num = SDL_strrchr(display, '.');
     
-    if (!disp_num) {
+    if (disp_num == NULL) {
         SDL_free(display);
         return NULL;
     }
@@ -393,7 +412,7 @@ IBus_GetDBusAddressFilename(void)
         SDL_strlcpy(config_dir, conf_env, sizeof(config_dir));
     } else {
         const char *home_env = SDL_getenv("HOME");
-        if (!home_env || !*home_env) {
+        if (home_env == NULL || !*home_env) {
             SDL_free(display);
             return NULL;
         }
@@ -461,7 +480,7 @@ IBus_SetupConnection(SDL_DBusContext *dbus, const char* addr)
         ibus_input_interface = IBUS_INPUT_INTERFACE;
         ibus_conn = dbus->connection_open_private(addr, NULL);
 
-        if (!ibus_conn) {
+        if (ibus_conn == NULL) {
             return SDL_FALSE;  /* oh well. */
         }
 
@@ -499,7 +518,9 @@ IBus_SetupConnection(SDL_DBusContext *dbus, const char* addr)
 static SDL_bool
 IBus_CheckConnection(SDL_DBusContext *dbus)
 {
-    if (!dbus) return SDL_FALSE;
+    if (dbus == NULL) {
+        return SDL_FALSE;
+    }
     
     if (ibus_conn && dbus->connection_get_is_connected(ibus_conn)) {
         return SDL_TRUE;
@@ -517,7 +538,9 @@ IBus_CheckConnection(SDL_DBusContext *dbus)
                 struct inotify_event *event = (struct inotify_event*) p;
                 if (event->len > 0) {
                     char *addr_file_no_path = SDL_strrchr(ibus_addr_file, '/');
-                    if (!addr_file_no_path) return SDL_FALSE;
+                    if (addr_file_no_path == NULL) {
+                        return SDL_FALSE;
+                    }
                  
                     if (SDL_strcmp(addr_file_no_path + 1, event->name) == 0) {
                         file_updated = SDL_TRUE;
@@ -553,7 +576,7 @@ SDL_IBus_Init(void)
         char *addr;
         char *addr_file_dir;
 
-        if (!addr_file) {
+        if (addr_file == NULL) {
             return SDL_FALSE;
         }
         
@@ -561,7 +584,7 @@ SDL_IBus_Init(void)
         ibus_addr_file = SDL_strdup(addr_file);
         
         addr = IBus_ReadAddressFromFile(addr_file);
-        if (!addr) {
+        if (addr == NULL) {
             SDL_free(addr_file);
             return SDL_FALSE;
         }
@@ -700,7 +723,7 @@ SDL_IBus_UpdateTextRect(const SDL_Rect *rect)
     }
 
     focused_win = SDL_GetKeyboardFocus();
-    if (!focused_win) {
+    if (focused_win == NULL) {
         return;
     }
 
diff --git a/src/core/linux/SDL_ime.c b/src/core/linux/SDL_ime.c
index 3ad4dbf43..e43fe8691 100644
--- a/src/core/linux/SDL_ime.c
+++ b/src/core/linux/SDL_ime.c
@@ -49,16 +49,17 @@ InitIME()
     const char *xmodifiers = SDL_getenv("XMODIFIERS");
 #endif
 
-    if (inited == SDL_TRUE)
+    if (inited == SDL_TRUE) {
         return;
+    }
 
     inited = SDL_TRUE;
 
     /* See if fcitx IME support is being requested */
 #ifdef HAVE_FCITX
-    if (!SDL_IME_Init_Real &&
+    if (SDL_IME_Init_Real == NULL &&
         ((im_module && SDL_strcmp(im_module, "fcitx") == 0) ||
-         (!im_module && xmodifiers && SDL_strstr(xmodifiers, "@im=fcitx") != NULL))) {
+         (im_module == NULL && xmodifiers && SDL_strstr(xmodifiers, "@im=fcitx") != NULL))) {
         SDL_IME_Init_Real = SDL_Fcitx_Init;
         SDL_IME_Quit_Real = SDL_Fcitx_Quit;
         SDL_IME_SetFocus_Real = SDL_Fcitx_SetFocus;
@@ -71,7 +72,7 @@ InitIME()
 
     /* default to IBus */
 #ifdef HAVE_IBUS_IBUS_H
-    if (!SDL_IME_Init_Real) {
+    if (SDL_IME_Init_Real == NULL) {
         SDL_IME_Init_Real = SDL_IBus_Init;
         SDL_IME_Quit_Real = SDL_IBus_Quit;
         SDL_IME_SetFocus_Real = SDL_IBus_SetFocus;
@@ -109,29 +110,33 @@ SDL_IME_Init(void)
 void
 SDL_IME_Quit(void)
 {
-    if (SDL_IME_Quit_Real)
+    if (SDL_IME_Quit_Real) {
         SDL_IME_Quit_Real();
+    }
 }
 
 void
 SDL_IME_SetFocus(SDL_bool focused)
 {
-    if (SDL_IME_SetFocus_Real)
+    if (SDL_IME_SetFocus_Real) {
         SDL_IME_SetFocus_Real(focused);
+    }
 }
 
 void
 SDL_IME_Reset(void)
 {
-    if (SDL_IME_Reset_Real)
+    if (SDL_IME_Reset_Real) {
         SDL_IME_Reset_Real();
+    }
 }
 
 SDL_bool
 SDL_IME_ProcessKeyEvent(Uint32 keysym, Uint32 keycode, Uint8 state)
 {
-    if (SDL_IME_ProcessKeyEvent_Real)
+    if (SDL_IME_ProcessKeyEvent_Real) {
         return SDL_IME_ProcessKeyEvent_Real(keysym, keycode, state);
+    }
 
     return SDL_FALSE;
 }
@@ -139,15 +144,17 @@ SDL_IME_ProcessKeyEvent(Uint32 keysym, Uint32 keycode, Uint8 state)
 void
 SDL_IME_UpdateTextRect(const SDL_Rect *rect)
 {
-    if (SDL_IME_UpdateTextRect_Real)
+    if (SDL_IME_UpdateTextRect_Real) {
         SDL_IME_UpdateTextRect_Real(rect);
+    }
 }
 
 void
 SDL_IME_PumpEvents()
 {
-    if (SDL_IME_PumpEvents_Real)
+    if (SDL_IME_PumpEvents_Real) {
         SDL_IME_PumpEvents_Real();
+    }
 }
 
 /* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/core/linux/SDL_threadprio.c b/src/core/linux/SDL_threadprio.c
index 865b89cd9..1648317d1 100644
--- a/src/core/linux/SDL_threadprio.c
+++ b/src/core/linux/SDL_threadprio.c
@@ -120,20 +120,20 @@ rtkit_initialize()
     dbus_conn = get_rtkit_dbus_connection();
 
     /* Try getting minimum nice level: this is often greater than PRIO_MIN (-20). */
-    if (!dbus_conn || !SDL_DBus_QueryPropertyOnConnection(dbus_conn, rtkit_dbus_node, rtkit_dbus_path, rtkit_dbus_interface, "MinNiceLevel",
-                                            DBUS_TYPE_INT32, &rtkit_min_nice_level)) {
+    if (dbus_conn == NULL || !SDL_DBus_QueryPropertyOnConnection(dbus_conn, rtkit_dbus_node, rtkit_dbus_path, rtkit_dbus_interface, "MinNiceLevel",
+                                                                 DBUS_TYPE_INT32, &rtkit_min_nice_level)) {
         rtkit_min_nice_level = -20;
     }
 
     /* Try getting maximum realtime priority: this can be less than the POSIX default (99). */
-    if (!dbus_conn || !SDL_DBus_QueryPropertyOnConnection(dbus_conn, rtkit_dbus_node, rtkit_dbus_path, rtkit_dbus_interface, "MaxRealtimePriority",
-                                            DBUS_TYPE_INT32, &rtkit_max_realtime_priority)) {
+    if (dbus_conn == NULL || !SDL_DBus_QueryPropertyOnConnection(dbus_conn, rtkit_dbus_node, rtkit_dbus_path, rtkit_dbus_interface, "MaxRealtimePriority",
+                                                                 DBUS_TYPE_INT32, &rtkit_max_realtime_priority)) {
         rtkit_max_realtime_priority = 99;
     }
 
     /* Try getting maximum rttime allowed by rtkit: exceeding this value will result in SIGKILL */
-    if (!dbus_conn || !SDL_DBus_QueryPropertyOnConnection(dbus_conn, rtkit_dbus_node, rtkit_dbus_path, rtkit_dbus_interface, "RTTimeUSecMax",
-                                            DBUS_TYPE_INT64, &rtkit_max_rttime_usec)) {
+    if (dbus_conn == NULL || !SDL_DBus_QueryPropertyOnConnection(dbus_conn, rtkit_dbus_node, rtkit_dbus_path, rtkit_dbus_interface, "RTTimeUSecMax",
+                                                                 DBUS_TYPE_INT64, &rtkit_max_rttime_usec)) {
         rtkit_max_rttime_usec = 200000;
     }
 }
@@ -172,8 +172,7 @@ rtkit_initialize_realtime_thread()
 
     // Requirement #1: Set RLIMIT_RTTIME
     err = getrlimit(nLimit, &rlimit);
-    if (err)
-    {
+    if (err) {
         return SDL_FALSE;
     }
 
@@ -181,21 +180,18 @@ rtkit_initialize_realtime_thread()
     rlimit.rlim_max = rtkit_max_rttime_usec;
     rlimit.rlim_cur = rlimit.rlim_max / 2;
     err = setrlimit(nLimit, &rlimit);
-    if (err)
-    {
+    if (err) {
         return SDL_FALSE;
     }
 
     // Requirement #2: Add SCHED_RESET_ON_FORK to the scheduler policy
     err = sched_getparam(nPid, &schedParam);
-    if (err)
-    {
+    if (err) {
         return SDL_FALSE;
     }
 
     err = sched_setscheduler(nPid, nSchedPolicy, &schedParam);
-    if (err)
-    {
+    if (err) {
         return SDL_FALSE;
     }
 
@@ -213,13 +209,14 @@ rtkit_setpriority_nice(pid_t thread, int nice_level)
     pthread_once(&rtkit_initialize_once, rtkit_initialize);
     dbus_conn = get_rtkit_dbus_connection();
 
-    if (nice < rtkit_min_nice_level)
+    if (nice < rtkit_min_nice_level) {
         nice = rtkit_min_nice_level;
+    }
 
-    if (!dbus_conn || !SDL_DBus_CallMethodOnConnection(dbus_conn,
-            rtkit_dbus_node, rtkit_dbus_path, rtkit_dbus_interface, "MakeThreadHighPriorityWithPID",
-            DBUS_TYPE_UINT64, &pid, DBUS_TYPE_UINT64, &tid, DBUS_TYPE_INT32, &nice, DBUS_TYPE_INVALID,
-            DBUS_TYPE_INVALID)) {
+    if (dbus_conn == NULL || !SDL_DBus_CallMethodOnConnection(dbus_conn,
+                                                              rtkit_dbus_node, rtkit_dbus_path, rtkit_dbus_interface, "MakeThreadHighPriorityWithPID",
+                                                              DBUS_TYPE_UINT64, &pid, DBUS_TYPE_UINT64, &tid, DBUS_TYPE_INT32, &nice, DBUS_TYPE_INVALID,
+                                                              DBUS_TYPE_INVALID)) {
         return SDL_FALSE;
     }
     return SDL_TRUE;
@@ -236,8 +233,9 @@ rtkit_setpriority_realtime(pid_t thread, int rt_priority)
     pthread_once(&rtkit_initialize_once, rtkit_initialize);
     dbus_conn = get_rtkit_dbus_connection();
 
-    if (priority > rtkit_max_realtime_priority)
+    if (priority > rtkit_max_realtime_priority) {
         priority = rtkit_max_realtime_priority;
+    }
 
     // We always perform the thread state changes necessary for rtkit.
     // This wastes some system calls if the state is already set but
@@ -247,10 +245,10 @@ rtkit_setpriority_realtime(pid_t thread, int rt_priority)
     // go through to determine whether it really needs to fail or not.
     rtkit_initialize_realtime_thread();
 
-    if (!dbus_conn || !SDL_DBus_CallMethodOnConnection(dbus_conn,
-            rtkit_dbus_node, rtkit_dbus_path, rtkit_dbus_interface, "MakeThreadRealtimeWithPID",
-            DBUS_TYPE_UINT64, &pid, DBUS_TYPE_UINT64, &tid, DBUS_TYPE_UINT32, &priority, DBUS_TYPE_INVALID,
-            DBUS_TYPE_INVALID)) {
+    if (dbus_conn == NULL || !SDL_DBus_CallMethodOnConnection(dbus_conn,
+                                                              rtkit_dbus_node, rtkit_dbus_path, rtkit_dbus_interface, "MakeThreadRealtimeWithPID",
+                                                              DBUS_TYPE_UINT64, &pid, DBUS_TYPE_UINT64, &tid, DBUS_TYPE_UINT32, &priority, DBUS_TYPE_INVALID,
+                                                              DBUS_TYPE_INVALID)) {
         return SDL_FALSE;
     }
     return SDL_TRUE;
diff --git a/src/core/linux/SDL_udev.c b/src/core/linux/SDL_udev.c
index 85cde8959..ce6c0597c 100644
--- a/src/core/linux/SDL_udev.c
+++ b/src/core/linux/SDL_udev.c
@@ -119,7 +119,7 @@ SDL_UDEV_Init(void)
 
     if (_this == NULL) {
         _this = (SDL_UDEV_PrivateData *) SDL_calloc(1, sizeof(*_this));
-        if(_this == NULL) {
+        if (_this == NULL) {
             return SDL_OutOfMemory();
         }
 
@@ -327,14 +327,13 @@ SDL_UDEV_LoadLibrary(void)
 #endif
 
     if (_this->udev_handle == NULL) {
-        for( i = 0 ; i < SDL_arraysize(SDL_UDEV_LIBS); i++) {
+        for ( i = 0 ; i < SDL_arraysize(SDL_UDEV_LIBS); i++) {
             _this->udev_handle = SDL_LoadObject(SDL_UDEV_LIBS[i]);
             if (_this->udev_handle != NULL) {
                 retval = SDL_UDEV_load_syms();
                 if (retval < 0) {
                     SDL_UDEV_UnloadLibrary();
-                }
-                else {
+                } else {
                     break;
                 }
             }
@@ -359,7 +358,7 @@ static void get_caps(struct udev_device *dev, struct udev_device *pdev, const ch
 
     SDL_memset(bitmask, 0, bitmask_len*sizeof(*bitmask));
     value = _this->syms.udev_device_get_sysattr_value(pdev, attr);
-    if (!value) {
+    if (value == NULL) {
         return;
     }
 
@@ -394,7 +393,7 @@ guess_device_class(struct udev_device *dev)
     while (pdev && !_this->syms.udev_device_get_sysattr_value(pdev, "capabilities/ev")) {
         pdev = _this->syms.udev_device_get_parent_with_subsystem_devtype(pdev, "input", NULL);
     }
-    if (!pdev) {
+    if (pdev == NULL) {
         return 0;
     }
 
diff --git a/src/core/openbsd/SDL_wscons_kbd.c b/src/core/openbsd/SDL_wscons_kbd.c
index 121867d6a..f17b4009d 100644
--- a/src/core/openbsd/SDL_wscons_kbd.c
+++ b/src/core/openbsd/SDL_wscons_kbd.c
@@ -233,14 +233,15 @@ static struct SDL_wscons_compose_tab_s {
 
 static keysym_t ksym_upcase(keysym_t ksym)
 {
-    if (ksym >= KS_f1 && ksym <= KS_f20)
-        return(KS_F1 - KS_f1 + ksym);
+    if (ksym >= KS_f1 && ksym <= KS_f20) {
+        return KS_F1 - KS_f1 + ksym;
+    }
 
-    if (KS_GROUP(ksym) == KS_GROUP_Ascii && ksym <= 0xff &&
-            latin1_to_upper[ksym] != 0x00)
-        return(latin1_to_upper[ksym]);
+    if (KS_GROUP(ksym) == KS_GROUP_Ascii && ksym <= 0xff && latin1_to_upper[ksym] != 0x00) {
+        return latin1_to_upper[ksym];
+    }
 
-    return(ksym);
+    return ksym;
 }
 static struct wscons_keycode_to_SDL {
     keysym_t sourcekey;
@@ -414,7 +415,7 @@ static SDL_WSCONS_input_data* SDL_WSCONS_Init_Keyboard(const char* dev)
 #endif
     SDL_WSCONS_input_data* input = (SDL_WSCONS_input_data*)SDL_calloc(1, sizeof(SDL_WSCONS_input_data));
 
-    if (!input) {
+    if (input == NULL) {
         return input;
     }
     input->fd = open(dev,O_RDWR | O_NONBLOCK | O_CLOEXEC);
@@ -491,10 +492,12 @@ static void put_utf8(SDL_WSCONS_input_data* input, uint c)
         put_queue(input, 0xc0 | (c >> 6));
         put_queue(input, 0x80 | (c & 0x3f));
     } else if (c < 0x10000) {
-        if (c >= 0xD800 && c <= 0xF500)
+        if (c >= 0xD800 && c <= 0xF500) {
             return;
-        if (c == 0xFFFF)
+        }
+        if (c == 0xFFFF) {
             return;
+        }
         /* 1110**** 10****** 10****** */
         put_queue(input, 0xe0 | (c >> 12));
         put_queue(input, 0x80 | ((c >> 6) & 0x3f));
@@ -511,7 +514,9 @@ static void put_utf8(SDL_WSCONS_input_data* input, uint c)
 static void Translate_to_text(SDL_WSCONS_input_data* input, keysym_t ksym)
 {
     if (KS_GROUP(ksym) == KS_GROUP_Keypad) {
-        if (SDL_isprint(ksym & 0xFF)) ksym &= 0xFF;
+        if (SDL_isprint(ksym & 0xFF)) {
+            ksym &= 0xFF;
+        }
     }
     switch(ksym) {
     case KS_Escape:
@@ -569,7 +574,9 @@ static void updateKeyboard(SDL_WSCONS_input_data* input)
     keysym_t *group;
     keysym_t ksym, result;
 
-    if (!input) return;
+    if (input == NULL) {
+        return;
+    }
     if ((n = read(input->fd, events, sizeof(events))) > 0) {
         n /= sizeof(struct wscons_event);
         for (i = 0; i < n; i++) {
@@ -578,21 +585,27 @@ static void updateKeyboard(SDL_WSCONS_input_data* input)
             case WSCONS_EVENT_KEY_DOWN: {
                 switch (input->keymap.map[events[i].value].group1[0]) {
                 case KS_Hold_Screen: {
-                    if (input->lockheldstate[0] >= 1) break;
+                    if (input->lockheldstate[0] >= 1) {
+                                break;
+                    }
                     input->ledstate ^= LED_SCR;
                     ioctl(input->fd, WSKBDIO_SETLEDS, &input->ledstate);
                     input->lockheldstate[0] = 1;
                     break;
                 }
                 case KS_Num_Lock: {
-                    if (input->lockheldstate[1] >= 1) break;
+                    if (input->lockheldstate[1] >= 1) {
+                                break;
+                    }
                     input->ledstate ^= LED_NUM;
                     ioctl(input->fd, WSKBDIO_SETLEDS, &input->ledstate);
                     input->lockheldstate[1] = 1;
                     break;
                 }
                 case KS_Caps_Lock: {
-                    if (input->lockheldstate[2] >= 1) break;
+                    if (input->lockheldstate[2] >= 1) {
+                                break;
+                    }
                     input->ledstate ^= LED_CAP;
                     ioctl(input->fd, WSKBDIO_SETLEDS, &input->ledstate);
                     input->lockheldstate[2] = 1;
@@ -600,7 +613,9 @@ static void updateKeyboard(SDL_WSCONS_input_data* input)
                 }
 #ifndef __NetBSD__
                 case KS_Mode_Lock: {
-                    if (input->lockheldstate[3] >= 1) break;
+                    if (input->lockheldstate[3] >= 1) {
+                                break;
+                    }
                     input->ledstate ^= 1 << 4;
                     ioctl(input->fd, WSKBDIO_SETLEDS, &input->ledstate);
                     input->lockheldstate[3] = 1;
@@ -608,50 +623,66 @@ static void updateKeyboard(SDL_WSCONS_input_data* input)
                 }
 #endif
                 case KS_Shift_Lock: {
-                    if (input->lockheldstate[4] >= 1) break;
+                    if (input->lockheldstate[4] >= 1) {
+                                break;
+                    }
                     input->ledstate ^= 1 << 5;
                     ioctl(input->fd, WSKBDIO_SETLEDS, &input->ledstate);
                     input->lockheldstate[4] = 1;
                     break;
                 }
                 case KS_Shift_L: {
-                    if (input->shiftheldstate[0]) break;
+                    if (input->shiftheldstate[0]) {
+                                break;
+                    }
                     input->shiftstate[0]++;
                     input->shiftheldstate[0] = 1;
                     break;
                 }
                 case KS_Shift_R: {
-                    if (input->shiftheldstate[1]) break;
+                    if (input->shiftheldstate[1]) {
+                                break;
+                    }
                     input->shiftstate[0]++;
                     input->shiftheldstate[1] = 1;
                     break;
                 }
                 case KS_Alt_L: {
-                    if (input->shiftheldstate[2]) break;
+                    if (input->shiftheldstate[2]) {
+                                break;
+                    }
                     input->shiftstate[1]++;
                     input->shiftheldstate[2] = 1;
                     break;
                 }
                 case KS_Alt_R: {
-                    if (input->shiftheldstate[3]) break;
+                    if (input->shiftheldstate[3]) {
+                                break;
+                    }
                     input->shiftstate[1]++;
                     input->shiftheldstate[3] = 1;
                     break;
                 }
                 case KS_Control_L: {
-                    if (input->shiftheldstate[4]) break;
+                    if (input->shiftheldstate[4]) {
+                                break;
+                    }
                     input->shiftstate[2]++;
                     input->shiftheldstate[4] = 1;
                     break;
                 }
                 case KS_Control_R: {
-                    if (input->shiftheldstate[5]) break;
+                    if (input->shiftheldstate[5]) {
+                                break;
+                    }
                     input->shiftstate[2]++;
                     input->shiftheldstate[5] = 1;
                     break;
                 }
                 case KS_Mode_switch: {
-                    if (input->shiftheldstate[6]) break;
+                    if (input->shiftheldstate[6]) {
+                                break;
+                    }
                     input->shiftstate[3]++;
                     input->shiftheldstate[6] = 1;
                     break;
@@ -662,60 +693,84 @@ static void updateKeyboard(SDL_WSCONS_input_data* input)
             case WSCONS_EVENT_KEY_UP: {
                 switch(input->keymap.map[events[i].value].group1[0]) {
                 case KS_Hold_Screen: {
-                    if (input->lockheldstate[0]) input->lockheldstate[0] = 0;
+                    if (input->lockheldstate[0]) {
+                                input->lockheldstate[0] = 0;
+                    }
                 }
                 break;
                 case KS_Num_Lock: {
-                    if (input->lockheldstate[1]) input->lockheldstate[1] = 0;
+                    if (input->lockheldstate[1]) {
+                                input->lockheldstate[1] = 0;
+                    }
                 }
                 break;
                 case KS_Caps_Lock: {
-                    if (input->lockheldstate[2]) input->lockheldstate[2] = 0;
+                    if (input->lockheldstate[2]) {
+                                input->lockheldstate[2] = 0;
+                    }
                 }
                 break;
 #ifndef __NetBSD__
                 case KS_Mode_Lock: {
-                    if (input->lockheldstate[3]) input->lockheldstate[3] = 0;
+                    if (input->lockheldstate[3]) {
+                                input->lockheldstate[3] = 0;
+                    }
                 }
                 break;
 #endif
                 case KS_Shift_Lock: {
-                    if (input->lockheldstate[4]) input->lockheldstate[4] = 0;
+                    if (input->lockheldstate[4]) {
+                                input->lockheldstate[4] = 0;
+                    }
                 }
                 break;
                 case KS_Shift_L: {
                     input->shiftheldstate[0] = 0;
-                    if (input->shiftstate[0]) input->shiftstate[0]--;
+                    if (input->shiftstate[0]) {
+                                input->shiftstate[0]--;
+                    }
                     break;
                 }
                 case KS_Shift_R: {
                     input->shiftheldstate[1] = 0;
-                    if (input->shiftstate[0]) input->shiftstate[0]--;
+                    if (input->shiftstate[0]) {
+                                input->shiftstate[0]--;
+                    }
                     break;
                 }
                 case KS_Alt_L: {
                     input->shiftheldstate[2] = 0;
-                    if (input->shiftstate[1]) input->shiftstate[1]--;
+                    if (input->shiftstate[1]) {
+                                input->shiftstate[1]--;
+                    }
                     break;
                 }
                 case KS_Alt_R: {
                     input->shiftheldstate[3] = 0;
-                    if (input->shiftstate[1]) input->shiftstate[1]--;
+                    if (input->shiftstate[1]) {
+                                input->shiftstate[1]--;
+                    }
                     break;
                 }
                 case KS_Control_L: {
                     input->shiftheldstate[4] = 0;
-                    if (input->shiftstate[2]) input->shiftstate[2]--;
+                    if (input->shiftstate[2]) {
+                                input->shiftstate[2]--;
+                    }
                     break;
                 }
                 case KS_Control_R: {
                     input->shiftheldstate[5] = 0;
-                    if (input->shiftstate[2]) input->shiftstate[2]--;
+                    if (input->shiftstate[2]) {
+                                input->shiftstate[2]--;
+                    }
                     break;
                 }
                 case KS_Mode_switch: {
                     input->shiftheldstate[6] = 0;
-                    if (input->shiftstate[3]) input->shiftstate[3]--;
+                    if (input->shiftstate[3]) {
+                                input->shiftstate[3]--;
+                    }
                     break;
                 }
                 }
@@ -733,7 +788,9 @@ static void updateKeyboard(SDL_WSCONS_input_data* input)
             else 
                 Translate_to_keycode(input, type, events[i].value);
 
-            if (type == WSCONS_EVENT_KEY_UP) continue;
+            if (type == WSCONS_EVENT_KEY_UP) {
+                continue;
+            }
 
             if (IS_ALTGR_MODE && !IS_CONTROL_HELD)
                 group = &input->keymap.map[events[i].value].group2[0];
@@ -778,7 +835,9 @@ static void updateKeyboard(SDL_WSCONS_input_data* input)
                 } else result = ksym;
                 break;
             }
-            if (result == KS_voidSymbol) continue;
+            if (result == KS_voidSymbol) {
+                continue;
+            }
 
             if (input->composelen > 0) {
                 if (input->composelen == 2 && group == &input->keymap.map[events[i].value].group2[0]) {
@@ -809,21 +868,24 @@ static void updateKeyboard(SDL_WSCONS_input_data* input)
 
             if (KS_GROUP(result) == KS_GROUP_Ascii) {
                 if (IS_CONTROL_HELD) {
-                    if ((result >= KS_at && result <= KS_z) || result == KS_space)
+                    if ((result >= KS_at && result <= KS_z) || result == KS_space) {
                         result = result & 0x1f;
-                    else if (result == KS_2)
+                    } else if (result == KS_2) {
                         result = 0x00;
-                    else if (result >= KS_3 && result <= KS_7)
+                    } else if (result >= KS_3 && result <= KS_7) {
                         result = KS_Escape + (result - KS_3);
-                    else if (result == KS_8)
-                        result = KS_Delete;
+                    } else if (result == KS_8) {
+                       result = KS_Delete;
+                    }
                 }
                 if (IS_ALT_HELD) {
                     if (input->encoding & KB_METAESC) {
                         Translate_to_keycode(input, WSCONS_EVENT_KEY_DOWN, KS_Escape);
                         Translate_to_text(input, result);
                         continue;
-                    } else result |= 0x80;
+                    } else {
+                       result |= 0x80;
+                    }
                 }
             }
             Translate_to_text(input,result);
@@ -835,7 +897,10 @@ static void updateKeyboard(SDL_WSCONS_input_data* input)
 void SDL_WSCONS_PumpEvents()
 {
     int i = 0;
-    for (i = 0; i < 4; i++)
+    for (i = 0; i < 4; i++) {
         updateKeyboard(inputs[i]);
-    if (mouseInputData != NULL) updateMouse(mouseInputData);
+    }
+    if (mouseInputData != NULL) {
+        updateMouse(mouseInputData);
+    }
 }
diff --git a/src/core/openbsd/SDL_wscons_mouse.c b/src/core/openbsd/SDL_wscons_mouse.c
index 42c83cec8..683acae0a 100644
--- a/src/core/openbsd/SDL_wscons_mouse.c
+++ b/src/core/openbsd/SDL_wscons_mouse.c
@@ -42,7 +42,9 @@ SDL_WSCONS_mouse_input_data* SDL_WSCONS_Init_Mouse()
 #endif
     SDL_WSCONS_mouse_input_data* mouseInputData = SDL_calloc(1, sizeof(SDL_WSCONS_mouse_input_data));
 
-    if (!mouseInputData) return NULL;
+    if (mouseInputData == NULL) {
+        return NULL;
+    }
     mouseInputData->fd = open("/dev/wsmouse",O_RDWR | O_NONBLOCK | O_CLOEXEC);
     if (mouseInputData->fd == -1) {free(mouseInputData); return NULL; }
 #ifdef WSMOUSEIO_SETMODE
@@ -61,11 +63,9 @@ void updateMouse(SDL_WSCONS_mouse_input_data* inputData)
     int n,i;
     SDL_Mouse* mouse = SDL_GetMouse();
 
-    if ((n = read(inputData->fd, events, sizeof(events))) > 0)
-    {
+    if ((n = read(inputData->fd, events, sizeof(events))) > 0) {
         n /= sizeof(struct wscons_event);
-        for (i = 0; i < n; i++)
-        {
+        for (i = 0; i < n; i++) {
             type = events[i].type;
             switch(type)
             {
@@ -128,7 +128,9 @@ void updateMouse(SDL_WSCONS_mouse_input_data* inputData)
 
 void SDL_WSCONS_Quit_Mouse(SDL_WSCONS_mouse_input_data* inputData)
 {
-    if (!inputData) return;
+    if (inputData == NULL) {
+        return;
+    }
     close(inputData->fd);
     free(inputData);
 }
diff --git a/src/core/windows/SDL_hid.c b/src/core/windows/SDL_hid.c
index d9dd04fbe..225fe703b 100644
--- a/src/core/windows/SDL_hid.c
+++ b/src/core/windows/SDL_hid.c
@@ -61,9 +61,9 @@ WIN_LoadHIDDLL(void)
     SDL_HidP_GetValueCaps = (HidP_GetValueCaps_t)GetProcAddress(s_pHIDDLL, "HidP_GetValueCaps");
     SDL_HidP_MaxDataListLength = (HidP_MaxDataListLength_t)GetProcAddress(s_pHIDDLL, "HidP_MaxDataListLength");
     SDL_HidP_GetData = (HidP_GetData_t)GetProcAddress(s_pHIDDLL, "HidP_GetData");
-    if (!SDL_HidD_GetManufacturerString || !SDL_HidD_GetProductString ||
-        !SDL_HidP_GetCaps || !SDL_HidP_GetButtonCaps ||
-        !SDL_HidP_GetValueCaps || !SDL_HidP_MaxDataListLength || !SDL_HidP_GetData) {
+    if (SDL_HidD_GetManufacturerString == NULL || SDL_HidD_GetProductString == NULL ||
+        SDL_HidP_GetCaps == NULL || SDL_HidP_GetButtonCaps == NULL ||
+        SDL_HidP_GetValueCaps == NULL || SDL_HidP_MaxDataListLength == NULL || SDL_HidP_GetData == NULL) {
         WIN_UnloadHIDDLL();
         return -1;
     }
diff --git a/src/core/windows/SDL_immdevice.c b/src/core/windows/SDL_immdevice.c
index 335596d95..f55a31b87 100644
--- a/src/core/windows/SDL_immdevice.c
+++ b/src/core/windows/SDL_immdevice.c
@@ -136,7 +136,7 @@ SDL_IMMDevice_Add(const SDL_bool iscapture, const char *devname, WAVEFORMATEXTEN
     }
 
     devidlist = (DevIdList *)SDL_malloc(sizeof(*devidlist));
-    if (!devidlist) {
+    if (devidlist == NULL) {
         return;  /* oh well. */
     }
 
@@ -442,7 +442,7 @@ EnumerateEndpointsForFlow(const SDL_bool iscapture)
     }
 
     items = (EndpointItem *)SDL_calloc(total, sizeof(EndpointItem));
-    if (!items) {
+    if (items == NULL) {
         return;  /* oh well. */
     }
 
diff --git a/src/core/windows/SDL_windows.c b/src/core/windows/SDL_windows.c
index 4ec9dbb64..f64d5544c 100644
--- a/src/core/windows/SDL_windows.c
+++ b/src/core/windows/SDL_windows.c
@@ -291,7 +291,7 @@ WIN_LookupAudioDeviceName(const WCHAR *name, const GUID *guid)
     }
 
     strw = (WCHAR *) SDL_malloc(len + sizeof (WCHAR));
-    if (!strw) {
+    if (strw == NULL) {
         RegCloseKey(hkey);
         return WIN_StringToUTF8(name);  /* oh well. */
     }
@@ -314,13 +314,13 @@ WIN_LookupAudioDeviceName(const WCHAR *name, const GUID *guid)
 BOOL
 WIN_IsEqualGUID(const GUID * a, const GUID * b)
 {
-    return (SDL_memcmp(a, b, sizeof (*a)) == 0);
+    return SDL_memcmp(a, b, sizeof(*a)) == 0;
 }
 
 BOOL
 WIN_IsEqualIID(REFIID a, REFIID b)
 {
-    return (SDL_memcmp(a, b, sizeof (*a)) == 0);
+    return SDL_memcmp(a, b, sizeof(*a)) == 0;
 }
 
 void
diff --git a/src/core/windows/SDL_xinput.c b/src/core/windows/SDL_xinput.c
index 8b9c26ef9..675ed608c 100644
--- a/src/core/windows/SDL_xinput.c
+++ b/src/core/windows/SDL_xinput.c
@@ -110,13 +110,13 @@ WIN_LoadXInputDLL(void)
 
     /* 100 is the ordinal for _XInputGetStateEx, which returns the same struct as XinputGetState, but with extra data in wButtons for the guide button, we think... */
     SDL_XInputGetState = (XInputGetState_t)GetProcAddress((HMODULE)s_pXInputDLL, (LPCSTR)100);
-    if (!SDL_XInputGetState) {
+    if (SDL_XInputGetState == NULL) {
         SDL_XInputGetState = (XInputGetState_t)GetProcAddress((HMODULE)s_pXInputDLL, "XInputGetState");
     }
     SDL_XInputSetState = (XInputSetState_t)GetProcAddress((HMODULE)s_pXInputDLL, "XInputSetState");
     SDL_XInputGetCapabilities = (XInputGetCapabilities_t)GetProcAddress((HMODULE)s_pXInputDLL, "XInputGetCapabilities");
     SDL_XInputGetBatteryInformation = (XInputGetBatteryInformation_t)GetProcAddress( (HMODULE)s_pXInputDLL, "XInputGetBatteryInformation" );
-    if (!SDL_XInputGetState || !SDL_XInputSetState || !SDL_XInputGetCapabilities) {
+    if (SDL_XInputGetState == NULL || SDL_XInputSetState == NULL || SDL_XInputGetCapabilities == NULL) {
         WIN_UnloadXInputDLL();
         return -1;
     }
diff --git a/src/core/winrt/SDL_winrtapp_common.cpp b/src/core/winrt/SDL_winrtapp_common.cpp
index 6e98a78d9..e5ada4c04 100644
--- a/src/core/winrt/SDL_winrtapp_common.cpp
+++ b/src/core/winrt/SDL_winrtapp_common.cpp
@@ -49,16 +49,11 @@ SDL_WinRTGetDeviceFamily()
 #if NTDDI_VERSION >= NTDDI_WIN10  /* !!! FIXME: I have no idea if this is the right test. This is a UWP API, I think. Older windows should...just return "mobile"? I don't know. --ryan. */
     Platform::String^ deviceFamily = Windows::System::Profile::AnalyticsInfo::VersionInfo->DeviceFamily;
 
-    if (deviceFamily->Equals("Windows.Desktop"))
-    {
+    if (deviceFamily->Equals("Windows.Desktop")) {
         return SDL_WINRT_DEVICEFAMILY_DESKTOP;
-    }
-    else if (deviceFamily->Equals("Windows.Mobile"))
-    {
+    } else if (deviceFamily->Equals("Windows.Mobile")) {
         return SDL_WINRT_DEVICEFAMILY_MOBILE;
-    }
-    else if (deviceFamily->Equals("Windows.Xbox"))
-    {
+    } else if (deviceFamily->Equals("Windows.Xbox")) {
         return SDL_WINRT_DEVICEFAMILY_XBOX;
     }
 #endif
diff --git a/src/core/winrt/SDL_winrtapp_direct3d.cpp b/src/core/winrt/SDL_winrtapp_direct3d.cpp
index 1f0962fca..db27e729b 100644
--- a/src/core/winrt/SDL_winrtapp_direct3d.cpp
+++ b/src/core/winrt/SDL_winrtapp_direct3d.cpp
@@ -104,8 +104,7 @@ IFrameworkView^ SDLApplicationSource::CreateView()
     // SDL_WinRTGlobalApp more than once.
     SDL_assert(!SDL_WinRTGlobalApp);
     SDL_WinRTApp ^ app = ref new SDL_WinRTApp();
-    if (!SDL_WinRTGlobalApp)
-    {
+    if (!SDL_WinRTGlobalApp) {
         SDL_WinRTGlobalApp = app;
     }
     return app;
@@ -353,13 +352,12 @@ void SDL_WinRTApp::Load(Platform::String^ entryPoint)
 void SDL_WinRTApp::Run()
 {
     SDL_SetMainReady();
-    if (WINRT_SDLAppEntryPoint)
-    {
+    if (WINRT_SDLAppEntryPoint) {
         // TODO, WinRT: pass the C-style main() a reasonably realistic
         // representation of command line arguments.
         int argc = 1;
         char **argv = (char **)SDL_malloc(2 * sizeof(*argv));
-        if (!argv) {
+        if (argv == NULL) {
             return;
         }
         argv[0] = SDL_strdup("WinRTApp");
diff --git a/src/cpuinfo/SDL_cpuinfo.c b/src/cpuinfo/SDL_cpuinfo.c
index 540f6a54e..a4fa5d6e3 100644
--- a/src/cpuinfo/SDL_cpuinfo.c
+++ b/src/cpuinfo/SDL_cpuinfo.c
@@ -336,8 +336,9 @@ CPU_haveAltiVec(void)
     int hasVectorUnit = 0;
     size_t length = sizeof(hasVectorUnit);
     int error = sysctl(selectors, 2, &hasVectorUnit, &length, NULL, 0);
-    if (0 == error)
+    if (0 == error) {
         altivec = (hasVectorUnit != 0);
+    }
 #elif defined(__FreeBSD__) && defined(__powerpc__)
     unsigned long cpufeatures = 0;
     elf_aux_info(AT_HWCAP, &cpufeatures, sizeof(cpufeatures));
@@ -378,13 +379,10 @@ CPU_haveARMSIMD(void)
     int fd;
 
     fd = open("/proc/self/auxv", O_RDONLY | O_CLOEXEC);
-    if (fd >= 0)
-    {
+    if (fd >= 0) {
         Elf32_auxv_t aux;
-        while (read(fd, &aux, sizeof aux) == sizeof aux)
-        {
-            if (aux.a_type == AT_PLATFORM)
-            {
+        while (read(fd, &aux, sizeof aux) == sizeof aux) {
+            if (aux.a_type == AT_PLATFORM) {
                 const char *plat = (const char *) aux.a_un.a_val;
                 if (plat) {
                     arm_simd = SDL_strncmp(plat, "v6l", 3) == 0 ||
@@ -403,16 +401,19 @@ CPU_haveARMSIMD(void)
 {
     _kernel_swi_regs regs;
     regs.r[0] = 0;
-    if (_kernel_swi(OS_PlatformFeatures, &regs, &regs) != NULL)
+    if (_kernel_swi(OS_PlatformFeatures, &regs, &regs) != NULL) {
         return 0;
+    }
 
-    if (!(regs.r[0] & (1<<31)))
+    if (!(regs.r[0] & (1 << 31))) {
         return 0;
+    }
 
     regs.r[0] = 34;
     regs.r[1] = 29;
-    if (_kernel_swi(OS_PlatformFeatures, &regs, &regs) != NULL)
+    if (_kernel_swi(OS_PlatformFeatures, &regs, &regs) != NULL) {
         return 0;
+    }
 
     return regs.r[0];
 }
@@ -434,8 +435,7 @@ readProcAuxvForNeon(void)
     int fd;
 
     fd = open("/proc/self/auxv", O_RDONLY | O_CLOEXEC);
-    if (fd >= 0)
-    {
+    if (fd >= 0) {
         Elf32_auxv_t aux;
         while (read(fd, &aux, sizeof (aux)) == sizeof (aux)) {
             if (aux.a_type == AT_HWCAP) {
@@ -481,13 +481,14 @@ CPU_haveNEON(void)
     return 1;  /* OpenBSD only supports ARMv7 CPUs that have NEON. */
 #elif defined(HAVE_ELF_AUX_INFO)
     unsigned long hasneon = 0;
-    if (elf_aux_info(AT_HWCAP, (void *)&hasneon, (int)sizeof(hasneon)) != 0)
+    if (elf_aux_info(AT_HWCAP, (void *)&hasneon, (int)sizeof(hasneon)) != 0) {
         return 0;
+    }
     return ((hasneon & HWCAP_NEON) == HWCAP_NEON);
 #elif defined(__QNXNTO__)
     return SYSPAGE_ENTRY(cpuinfo)->flags & ARM_CPU_FLAG_NEON;
 #elif (defined(__LINUX__) || defined(__ANDROID__)) && defined(HAVE_GETAUXVAL)
-    return ((getauxval(AT_HWCAP) & HWCAP_NEON) == HWCAP_NEON);
+    return (getauxval(AT_HWCAP) & HWCAP_NEON) == HWCAP_NEON;
 #elif defined(__LINUX__)
     return readProcAuxvForNeon();
 #elif defined(__ANDROID__)
@@ -556,7 +557,7 @@ CPU_have3DNow(void)
         cpuid(0x80000000, a, b, c, d);
         if (a >= 0x80000001) {
             cpuid(0x80000001, a, b, c, d);
-            return (d & 0x80000000);
+            return d & 0x80000000;
         }
     }
     return 0;
@@ -629,7 +630,7 @@ CPU_haveAVX2(void)
         int a, b, c, d;
         (void) a; (void) b; (void) c; (void) d;  /* compiler warnings... */
         cpuid(7, a, b, c, d);
-        return (b & 0x00000020);
+        return b & 0x00000020;
     }
     return 0;
 }
@@ -649,7 +650,7 @@ CPU_haveAVX512F(void)
         int a, b, c, d;
         (void) a; (void) b; (void) c; (void) d;  /* compiler warnings... */
         cpuid(7, a, b, c, d);
-        return (b & 0x00010000);
+        return b & 0x00010000;
     }
     return 0;
 }
@@ -839,10 +840,10 @@ SDL_GetCPUCacheLineSize(void)
     (void) a; (void) b; (void) c; (void) d;
    if (SDL_strcmp(cpuType, "GenuineIntel") == 0 || SDL_strcmp(cpuType, "CentaurHauls") == 0 || SDL_strcmp(cpuType, "  Shanghai  ") == 0) {
         cpuid(0x00000001, a, b, c, d);
-        return (((b >> 8) & 0xff) * 8);
+        return ((b >> 8) & 0xff) * 8;
     } else if (SDL_strcmp(cpuType, "AuthenticAMD") == 0 || SDL_strcmp(cpuType, "HygonGenuine") == 0) {
         cpuid(0x80000005, a, b, c, d);
-        return (c & 0xff);
+        return c & 0xff;
     } else {
         /* Just make a guess here... */
         return SDL_CACHELINE_SIZE;
diff --git a/src/events/SDL_clipboardevents.c b/src/events/SDL_clipboardevents.c
index a3247dd80..de5d0137a 100644
--- a/src/events/SDL_clipboardevents.c
+++ b/src/events/SDL_clipboardevents.c
@@ -40,7 +40,7 @@ SDL_SendClipboardUpdate(void)
 
         posted = (SDL_PushEvent(&event) > 0);
     }
-    return (posted);
+    return posted;
 }
 
 /* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/events/SDL_displayevents.c b/src/events/SDL_displayevents.c
index c6a701ab5..3eabf1ad0 100644
--- a/src/events/SDL_displayevents.c
+++ b/src/events/SDL_displayevents.c
@@ -31,7 +31,7 @@ SDL_SendDisplayEvent(SDL_VideoDisplay *display, Uint8 displayevent, int data1)
 {
     int posted;
 
-    if (!display) {
+    if (display == NULL) {
         return 0;
     }
     switch (displayevent) {
@@ -54,7 +54,7 @@ SDL_SendDisplayEvent(SDL_VideoDisplay *display, Uint8 displayevent, int data1)
         posted = (SDL_PushEvent(&event) > 0);
     }
 
-    return (posted);
+    return posted;
 }
 
 /* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/events/SDL_events.c b/src/events/SDL_events.c
index 493ae7665..189413231 100644
--- a/src/events/SDL_events.c
+++ b/src/events/SDL_events.c
@@ -556,7 +556,7 @@ SDL_StartEventLoop(void)
     }
     SDL_LockMutex(SDL_EventQ.lock);
 
-    if (!SDL_event_watchers_lock) {
+    if (SDL_event_watchers_lock == NULL) {
         SDL_event_watchers_lock = SDL_CreateMutex();
         if (SDL_event_watchers_lock == NULL) {
             SDL_UnlockMutex(SDL_EventQ.lock);
@@ -597,7 +597,7 @@ SDL_AddEvent(SDL_Event * event)
 
     if (SDL_EventQ.free == NULL) {
         entry = (SDL_EventEntry *)SDL_malloc(sizeof(*entry));
-        if (!entry) {
+        if (entry == NULL) {
             return 0;
         }
     } else {
@@ -672,7 +672,7 @@ static int
 SDL_SendWakeupEvent()
 {
     SDL_VideoDevice *_this = SDL_GetVideoDevice();
-    if (!_this || !_this->SendWakeupEvent) {
+    if (_this == NULL || !_this->SendWakeupEvent) {
         return 0;
     }
     if (!_this->wakeup_lock || SDL_LockMutex(_this->wakeup_lock) == 0) {
@@ -708,7 +708,7 @@ SDL_PeepEventsInternal(SDL_Event * events, int numevents, SDL_eventaction action
             if (action == SDL_GETEVENT) {
                 SDL_SetError("The event system has been shut down");
             }
-            return (-1);
+            return -1;
         }
         if (action == SDL_ADDEVENT) {
             for (i = 0; i < numevents; ++i) {
@@ -731,7 +731,7 @@ SDL_PeepEventsInternal(SDL_Event * events, int numevents, SDL_eventaction action
                 SDL_EventQ.wmmsg_used = NULL;
             }
 
-            for (entry = SDL_EventQ.head; entry && (!events || used < numevents); entry = next) {
+            for (entry = SDL_EventQ.head; entry && (events == NULL || used < numevents); entry = next) {
                 next = entry->next;
                 type = entry->event.type;
                 if (minType <= type && type <= maxType) {
@@ -764,7 +764,7 @@ SDL_PeepEventsInternal(SDL_Event * events, int numevents, SDL_eventaction action
                             /* Skip it, we don't want to include it */
                             continue;
                         }
-                        if (!events || action != SDL_GETEVENT) {
+                        if (events == NULL || action != SDL_GETEVENT) {
                             ++sentinels_expected;
                         }
                         if (SDL_AtomicGet(&SDL_sentinel_pending) > sentinels_expected) {
@@ -787,7 +787,7 @@ SDL_PeepEventsInternal(SDL_Event * events, int numevents, SDL_eventaction action
         SDL_SendWakeupEvent();
     }
 
-    return (used);
+    return used;
 }
 int
 SDL_PeepEvents(SDL_Event * events, int numevents, SDL_eventaction action,
@@ -799,13 +799,13 @@ SDL_PeepEvents(SDL_Event * events, int numevents, SDL_eventaction action,
 SDL_bool
 SDL_HasEvent(Uint32 type)
 {
-    return (SDL_PeepEvents(NULL, 0, SDL_PEEKEVENT, type, type) > 0);
+    return SDL_PeepEvents(NULL, 0, SDL_PEEKEVENT, type, type) > 0;
 }
 
 SDL_bool
 SDL_HasEvents(Uint32 minType, Uint32 maxType)
 {
-    return (SDL_PeepEvents(NULL, 0, SDL_PEEKEVENT, minType, maxType) > 0);
+    return SDL_PeepEvents(NULL, 0, SDL_PEEKEVENT, minType, maxType) > 0;
 }
 
 void
@@ -1128,7 +1128,7 @@ SDL_PushEvent(SDL_Event * event)
     event->common.timestamp = SDL_GetTicks();
 
     if (SDL_EventOK.callback || SDL_event_watchers_count > 0) {
-        if (!SDL_event_watchers_lock || SDL_LockMutex(SDL_event_watchers_lock) == 0) {
+        if (SDL_event_watchers_lock == NULL || SDL_LockMutex(SDL_event_watchers_lock) == 0) {
             if (SDL_EventOK.callback && !SDL_EventOK.callback(SDL_EventOK.userdata, event)) {
                 if (SDL_event_watchers_lock) {
                     SDL_UnlockMutex(SDL_event_watchers_lock);
@@ -1179,7 +1179,7 @@ SDL_PushEvent(SDL_Event * event)
 void
 SDL_SetEventFilter(SDL_EventFilter filter, void *userdata)
 {
-    if (!SDL_event_watchers_lock || SDL_LockMutex(SDL_event_watchers_lock) == 0) {
+    if (SDL_event_watchers_lock == NULL || SDL_LockMutex(SDL_event_watchers_lock) == 0) {
         /* Set filter and discard pending events */
         SDL_EventOK.callback = filter;
         SDL_EventOK.userdata = userdata;
@@ -1196,7 +1196,7 @@ SDL_GetEventFilter(SDL_EventFilter * filter, void **userdata)
 {
     SDL_EventWatcher event_ok;
 
-    if (!SDL_event_watchers_lock || SDL_LockMutex(SDL_event_watchers_lock) == 0) {
+    if (SDL_event_watchers_lock == NULL || SDL_LockMutex(SDL_event_watchers_lock) == 0) {
         event_ok = SDL_EventOK;
 
         if (SDL_event_watchers_lock) {
@@ -1218,7 +1218,7 @@ SDL_GetEventFilter(SDL_EventFilter * filter, void **userdata)
 void
 SDL_AddEventWatch(SDL_EventFilter filter, void *userdata)
 {
-    if (!SDL_event_watchers_lock || SDL_LockMutex(SDL_event_watchers_lock) == 0) {
+    if (SDL_event_watchers_lock == NULL || SDL_LockMutex(SDL_event_watchers_lock) == 0) {
         SDL_EventWatcher *event_watchers;
 
         event_watchers = SDL_realloc(SDL_event_watchers, (SDL_event_watchers_count + 1) * sizeof(*event_watchers));
@@ -1242,7 +1242,7 @@ SDL_AddEventWatch(SDL_EventFilter filter, void *userdata)
 void
 SDL_DelEventWatch(SDL_EventFilter filter, void *userdata)
 {
-    if (!SDL_event_watchers_lock || SDL_LockMutex(SDL_event_watchers_lock) == 0) {
+    if (SDL_event_watchers_lock == NULL || SDL_LockMutex(SDL_event_watchers_lock) == 0) {
         int i;
 
         for (i = 0; i < SDL_event_watchers_count; ++i) {
@@ -1355,7 +1355,7 @@ SDL_SendAppEvent(SDL_EventType eventType)
         event.type = eventType;
         posted = (SDL_PushEvent(&event) > 0);
     }
-    return (posted);
+    return posted;
 }
 
 int
@@ -1372,7 +1372,7 @@ SDL_SendSysWMEvent(SDL_SysWMmsg * message)
         posted = (SDL_PushEvent(&event) > 0);
     }
     /* Update internal event state */
-    return (posted);
+    return posted;
 }
 
 int
diff --git a/src/events/SDL_gesture.c b/src/events/SDL_gesture.c
index 2cdb0d594..2433a5b35 100644
--- a/src/events/SDL_gesture.c
+++ b/src/events/SDL_gesture.c
@@ -92,15 +92,18 @@ static void PrintPath(SDL_FloatPoint *path)
 int SDL_RecordGesture(SDL_TouchID touchId)
 {
     int i;
-    if (touchId < 0) recordAll = SDL_TRUE;
+    if (touchId < 0) {
+        recordAll = SDL_TRUE;
+    }
     for (i = 0; i < SDL_numGestureTouches; i++) {
         if ((touchId < 0) || (SDL_gestureTouch[i].id == touchId)) {
             SDL_gestureTouch[i].recording = SDL_TRUE;
-            if (touchId >= 0)
+            if (touchId >= 0) {
                 return 1;
+            }
         }
     }
-    return (touchId < 0);
+    return touchId < 0;
 }
 
 void SDL_GestureQuit()
@@ -195,7 +198,7 @@ static int SDL_AddDollarGesture_one(SDL_GestureTouch* inTouch, SDL_FloatPoint* p
         (SDL_DollarTemplate *)SDL_realloc(inTouch->dollarTemplate,
                                           (index + 1) *
                                           sizeof(SDL_DollarTemplate));
-    if (!dollarTemplate) {
+    if (dollarTemplate == NULL) {
         return SDL_OutOfMemory();
     }
     inTouch->dollarTemplate = dollarTemplate;
@@ -213,12 +216,15 @@ static int SDL_AddDollarGesture(SDL_GestureTouch* inTouch, SDL_FloatPoint* path)
     int index = -1;
     int i = 0;
     if (inTouch == NULL) {
-        if (SDL_numGestureTouches == 0) return SDL_SetError("no gesture touch devices registered");
+        if (SDL_numGestureTouches == 0) {
+            return SDL_SetError("no gesture touch devices registered");
+        }
         for (i = 0; i < SDL_numGestureTouches; i++) {
             inTouch = &SDL_gestureTouch[i];
             index = SDL_AddDollarGesture_one(inTouch, path);
-            if (index < 0)
+            if (index < 0) {
                 return -1;
+            }
         }
         /* Use the index of the last one added. */
         return index;
@@ -230,7 +236,9 @@ int SDL_LoadDollarTemplates(SDL_TouchID touchId, SDL_RWops *src)
 {
     int i,loaded = 0;
     SDL_GestureTouch *touch = NULL;
-    if (src == NULL) return 0;
+    if (src == NULL) {
+        return 0;
+    }
     if (touchId >= 0) {
         for (i = 0; i < SDL_numGestureTouches; i++) {
             if (SDL_gestureTouch[i].id == touchId) {
@@ -262,10 +270,10 @@ int SDL_LoadDollarTemplates(SDL_TouchID touchId, SDL_RWops *src)
 
         if (touchId >= 0) {
             /* printf("Adding loaded gesture to 1 touch\n"); */
-            if (SDL_AddDollarGesture(touch, templ.path) >= 0)
+            if (SDL_AddDollarGesture(touch, templ.path) >= 0) {
                 loaded++;
-        }
-        else {
+            }
+        } else {
             /* printf("Adding to: %i touches\n",SDL_numGestureTouches); */
             for (i = 0; i < SDL_numGestureTouches; i++) {
                 touch = &SDL_gestureTouch[i];
@@ -294,7 +302,7 @@ static float dollarDifference(SDL_FloatPoint* points,SDL_FloatPoint* templ,float
         dist += (float)(SDL_sqrt((p.x-templ[i].x)*(p.x-templ[i].x)+
                                  (p.y-templ[i].y)*(p.y-templ[i].y)));
     }
-    return dist/DOLLARNPOINTS;
+    return dist / DOLLARNPOINTS;
 
 }
 
@@ -318,8 +326,7 @@ static float bestDollarDifference(SDL_FloatPoint* points,SDL_FloatPoint* templ)
             f2 = f1;
             x1 = (float)(PHI*ta + (1-PHI)*tb);
             f1 = dollarDifference(points,templ,x1);
-        }
-        else {
+        } else {
             ta = x1;
             x1 = x2;
             f1 = f2;
@@ -333,7 +340,7 @@ static float bestDollarDifference(SDL_FloatPoint* points,SDL_FloatPoint* templ)
       else if (f1 >  f2)
           printf("Min angle (x2): %f\n",x2);
     */
-    return SDL_min(f1,f2);
+    return SDL_min(f1, f2);
 }
 
 /* DollarPath contains raw points, plus (possibly) the calculated length */
@@ -414,10 +421,18 @@ static int dollarNormalize(const SDL_DollarPath *path,SDL_FloatPoint *points, SD
                               (py - centroid.y)*SDL_cos(ang) + centroid.y);
 
 
-        if (points[i].x < xmin) xmin = points[i].x;
-        if (points[i].x > xmax) xmax = points[i].x;
-        if (points[i].y < ymin) ymin = points[i].y;
-        if (points[i].y > ymax) ymax = points[i].y;
+        if (points[i].x < xmin) {
+            xmin = points[i].x;
+        }
+        if (points[i].x > xmax) {
+            xmax = points[i].x;
+        }
+        if (points[i].y < ymin) {
+            ymin = points[i].y;
+        }
+        if (points[i].y > ymax) {
+            ymax = points[i].y;
+        }
     }
 
     /* Scale points to DOLLARSIZE, and translate to the origin */
@@ -457,7 +472,7 @@ int SDL_GestureAddTouch(SDL_TouchID touchId)
                                                                      (SDL_numGestureTouches + 1) *
                                                                      sizeof(SDL_GestureTouch));
 
-    if (!gestureTouch) {
+    if (gestureTouch == NULL) {
         return SDL_OutOfMemory();
     }
 
@@ -498,8 +513,9 @@ static SDL_GestureTouch * SDL_GetGestureTouch(SDL_TouchID id)
     int i;
     for (i = 0; i < SDL_numGestureTouches; i++) {
         /* printf("%i ?= %i\n",SDL_gestureTouch[i].id,id); */
-        if (SDL_gestureTouch[i].id == id)
+        if (SDL_gestureTouch[i].id == id) {
             return &SDL_gestureTouch[i];
+        }
     }
     return NULL;
 }
@@ -571,7 +587,9 @@ void SDL_GestureProcessEvent(SDL_Event* event)
         SDL_GestureTouch* inTouch = SDL_GetGestureTouch(event->tfinger.touchId);
 
         /* Shouldn't be possible */
-        if (inTouch == NULL) return;
+        if (inTouch == NULL) {
+            return;
+        }
 
         x = event->tfinger.x;
         y = event->tfinger.y;
@@ -591,26 +609,24 @@ void SDL_GestureProcessEvent(SDL_Event* event)
                 /* PrintPath(path); */
                 if (recordAll) {
                     index = SDL_AddDollarGesture(NULL,path);
-                    for (i = 0; i < SDL_numGestureTouches; i++)
+                    for (i = 0; i < SDL_numGestureTouches; i++) {
                         SDL_gestureTouch[i].recording = SDL_FALSE;
-                }
-                else {
+                    }
+                } else {
                     index = SDL_AddDollarGesture(inTouch,path);
                 }
 
                 if (index >= 0) {
                     SDL_SendDollarRecord(inTouch,inTouch->dollarTemplate[index].hash);
-                }
-                else {
+                } else {
                     SDL_SendDollarRecord(inTouch,-1);
                 }
-            }
-            else {
+            } else {
                 int bestTempl;
                 float error;
                 error = dollarRecognize(&inTouch->dollarPath,
                                         &bestTempl,inTouch);
-                if (bestTempl >= 0){
+                if (bestTempl >= 0) {
                     /* Send Event */
                     unsigned long gestureId = inTouch->dollarTemplate[bestTempl].hash;
                     SDL_SendGestureDollar(inTouch,gestureId,error);
@@ -625,8 +641,7 @@ void SDL_GestureProcessEvent(SDL_Event* event)
                 inTouch->centroid.y = (inTouch->centroid.y*(inTouch->numDownFingers+1)-
                                        y)/inTouch->numDownFingers;
             }
-        }
-        else if (event->type == SDL_FINGERMOTION) {
+        } else if (event->type == SDL_FINGERMOTION) {
             float dx = event->tfinger.dx;
             float dy = event->tfinger.dy;
 #if defined(ENABLE_DOLLAR)
@@ -671,7 +686,12 @@ void SDL_GestureProcessEvent(SDL_Event* event)
                 dtheta = (float)SDL_atan2(lv.x*v.y - lv.y*v.x,lv.x*v.x + lv.y*v.y);
 
                 dDist = (Dist - lDist);
-                if (lDist == 0) {dDist = 0;dtheta = 0;} /* To avoid impossible values */
+                if (lDist == 0) {
+                    /* To avoid impossible values */
+                    dDist = 0;
+                    dtheta = 0;
+                }
+
 
                 /* inTouch->gestureLast[j].dDist = dDist;
                 inTouch->gestureLast[j].dtheta = dtheta;
@@ -684,8 +704,7 @@ void SDL_GestureProcessEvent(SDL_Event* event)
                 printf("thetaSum = %f, distSum = %f\n",gdtheta,gdDist);
                 printf("id: %i dTheta = %f, dDist = %f\n",j,dtheta,dDist); */
                 SDL_SendGestureMulti(inTouch,dtheta,dDist);
-            }
-            else {
+            } else {
                 /* inTouch->gestureLast[j].dDist = 0;
                 inTouch->gestureLast[j].dtheta = 0;
                 inTouch->gestureLast[j].cv.x = 0;
@@ -695,8 +714,7 @@ void SDL_GestureProcessEvent(SDL_Event* event)
             inTouch->gestureLast[j].f.p.y = y;
             break;
             pressure? */
-        }
-        else if (event->type == SDL_FINGERDOWN) {
+        } else if (event->type == SDL_FINGERDOWN) {
 
             inTouch->numDownFingers++;
             inTouch->centroid.x = (inTouch->centroid.x*(inTouch->numDownFingers - 1)+
diff --git a/src/events/SDL_keyboard.c b/src/events/SDL_keyboard.c
index 30ec14c24..bcfe581a5 100644
--- a/src/events/SDL_keyboard.c
+++ b/src/events/SDL_keyboard.c
@@ -754,7 +754,7 @@ SDL_SetKeyboardFocus(SDL_Window * window)
 {
     SDL_Keyboard *keyboard = &SDL_keyboard;
 
-    if (keyboard->focus && !window) {
+    if (keyboard->focus && window == NULL) {
         /* We won't get anymore keyboard messages, so reset keyboard state */
         SDL_ResetKeyboard();
     }
@@ -763,7 +763,7 @@ SDL_SetKeyboardFocus(SDL_Window * window)
     if (keyboard->focus && keyboard->focus != window) {
 
         /* new window shouldn't think it has mouse captured. */
-        SDL_assert(!window || !(window->flags & SDL_WINDOW_MOUSE_CAPTURE));
+        SDL_assert(window == NULL || !(window->flags & SDL_WINDOW_MOUSE_CAPTURE));
 
         /* old window must lose an existing mouse capture. */
         if (keyboard->focus->flags & SDL_WINDOW_MOUSE_CAPTURE) {
@@ -939,7 +939,7 @@ SDL_SendKeyboardKeyInternal(Uint8 source, Uint8 state, SDL_Scancode scancode, SD
         SDL_MinimizeWindow(keyboard->focus);
     }
 
-    return (posted);
+    return posted;
 }
 
 int
@@ -1045,7 +1045,7 @@ SDL_SendKeyboardText(const char *text)
             posted |= (SDL_PushEvent(&event) > 0);
         }
     }
-    return (posted);
+    return posted;
 }
 
 int
@@ -1076,7 +1076,7 @@ SDL_SendEditingText(const char *text, int start, int length)
 
         posted = (SDL_PushEvent(&event) > 0);
     }
-    return (posted);
+    return posted;
 }
 
 void
@@ -1100,7 +1100,7 @@ SDL_GetModState(void)
 {
     SDL_Keyboard *keyboard = &SDL_keyboard;
 
-    return (SDL_Keymod) keyboard->modstate;
+    return (SDL_Keymod)keyboard->modstate;
 }
 
 void
@@ -1183,7 +1183,7 @@ SDL_Scancode SDL_GetScancodeFromName(const char *name)
 {
     int i;
 
-    if (!name || !*name) {
+    if (name == NULL || !*name) {
             SDL_InvalidParamError("name");
         return SDL_SCANCODE_UNKNOWN;
     }
@@ -1208,8 +1208,7 @@ SDL_GetKeyName(SDL_Keycode key)
     char *end;
 
     if (key & SDLK_SCANCODE_MASK) {
-        return
-            SDL_GetScancodeName((SDL_Scancode) (key & ~SDLK_SCANCODE_MASK));
+        return SDL_GetScancodeName((SDL_Scancode)(key & ~SDLK_SCANCODE_MASK));
     }
 
     switch (key) {
diff --git a/src/events/SDL_mouse.c b/src/events/SDL_mouse.c
index 994b6a6db..9cc692d72 100644
--- a/src/events/SDL_mouse.c
+++ b/src/events/SDL_mouse.c
@@ -225,7 +225,7 @@ SDL_MouseInit(void)
 
     mouse->cursor_shown = SDL_TRUE;
 
-    return (0);
+    return 0;
 }
 
 void
@@ -462,7 +462,7 @@ SDL_SetMouseSystemScale(int num_values, const float *values)
     }
 
     v = (float *)SDL_realloc(mouse->system_scale_values, num_values * sizeof(*values));
-    if (!v) {
+    if (v == NULL) {
         return SDL_OutOfMemory();
     }
     SDL_memcpy(v, values, num_values * sizeof(*values));
@@ -685,7 +685,7 @@ static SDL_MouseClickState *GetMouseClickState(SDL_Mouse *mouse, Uint8 button)
     if (button >= mouse->num_clickstates) {
         int i, count = button + 1;
         SDL_MouseClickState *clickstate = (SDL_MouseClickState *)SDL_realloc(mouse->clickstate, count * sizeof(*mouse->clickstate));
-        if (!clickstate) {
+        if (clickstate == NULL) {
             return NULL;
         }
         mouse->clickstate = clickstate;
@@ -708,7 +708,7 @@ SDL_PrivateSendMouseButton(SDL_Window * window, SDL_MouseID mouseID, Uint8 state
     SDL_MouseInputSource *source;
 
     source = GetMouseInputSource(mouse, mouseID);
-    if (!source) {
+    if (source == NULL) {
         return 0;
     }
     buttonstate = source->buttonstate;
@@ -1005,10 +1005,10 @@ SDL_GetGlobalMouseState(int *x, int *y)
         int tmpx, tmpy;
 
         /* make sure these are never NULL for the backend implementations... */
-        if (!x) {
+        if (x == NULL) {
             x = &tmpx;
         }
-        if (!y) {
+        if (y == NULL) {
             y = &tmpy;
         }
 
@@ -1268,7 +1268,7 @@ SDL_CreateCursor(const Uint8 * data, const Uint8 * mask,
                                    0x0000FF00,
                                    0x000000FF,
                                    0xFF000000);
-    if (!surface) {
+    if (surface == NULL) {
         return NULL;
     }
     for (y = 0; y < h; ++y) {
@@ -1302,7 +1302,7 @@ SDL_CreateColorCursor(SDL_Surface *surface, int hot_x, int hot_y)
     SDL_Surface *temp = NULL;
     SDL_Cursor *cursor;
 
-    if (!surface) {
+    if (surface == NULL) {
         SDL_InvalidParamError("surface");
         return NULL;
     }
@@ -1321,7 +1321,7 @@ SDL_CreateColorCursor(SDL_Surface *surface, int hot_x, int hot_y)
 
     if (surface->format->format != SDL_PIXELFORMAT_ARGB8888) {
         temp = SDL_ConvertSurfaceFormat(surface, SDL_PIXELFORMAT_ARGB8888, 0);
-        if (!temp) {
+        if (temp == NULL) {
             return NULL;
         }
         surface = temp;
@@ -1377,7 +1377,7 @@ SDL_SetCursor(SDL_Cursor * cursor)
                     break;
                 }
             }
-            if (!found) {
+            if (found == NULL) {
                 SDL_SetError("Cursor not associated with the current mouse");
                 return;
             }
@@ -1407,7 +1407,7 @@ SDL_GetCursor(void)
 {
     SDL_Mouse *mouse = SDL_GetMouse();
 
-    if (!mouse) {
+    if (mouse == NULL) {
         return NULL;
     }
     return mouse->cur_cursor;
@@ -1418,7 +1418,7 @@ SDL_GetDefaultCursor(void)
 {
     SDL_Mouse *mouse = SDL_GetMouse();
 
-    if (!mouse) {
+    if (mouse == NULL) {
         return NULL;
     }
     return mouse->def_cursor;
@@ -1430,7 +1430,7 @@ SDL_FreeCursor(SDL_Cursor * cursor)
     SDL_Mouse *mouse = SDL_GetMouse();
     SDL_Cursor *curr, *prev;
 
-    if (!cursor) {
+    if (cursor == NULL) {
         return;
     }
 
@@ -1464,7 +1464,7 @@ SDL_ShowCursor(int toggle)
     SDL_Mouse *mouse = SDL_GetMouse();
     SDL_bool shown;
 
-    if (!mouse) {
+    if (mouse == NULL) {
         return 0;
     }
 
diff --git a/src/events/SDL_touch.c b/src/events/SDL_touch.c
index bc77b7354..3a724799b 100644
--- a/src/events/SDL_touch.c
+++ b/src/events/SDL_touch.c
@@ -44,7 +44,7 @@ static SDL_TouchID  track_touchid;
 int
 SDL_TouchInit(void)
 {
-    return (0);
+    return 0;
 }
 
 int
@@ -150,7 +150,7 @@ SDL_Finger *
 SDL_GetTouchFinger(SDL_TouchID touchID, int index)
 {
     SDL_Touch *touch = SDL_GetTouch(touchID);
-    if (!touch) {
+    if (touch == NULL) {
         return NULL;
     }
     if (index < 0 || index >= touch->num_fingers) {
@@ -174,7 +174,7 @@ SDL_AddTouch(SDL_TouchID touchID, SDL_TouchDeviceType type, const char *name)
     /* Add the touch to the list of touch */
     touchDevices = (SDL_Touch **) SDL_realloc(SDL_touchDevices,
                                       (SDL_num_touch + 1) * sizeof(*touchDevices));
-    if (!touchDevices) {
+    if (touchDevices == NULL) {
         return SDL_OutOfMemory();
     }
 
@@ -212,7 +212,7 @@ SDL_AddFinger(SDL_Touch *touch, SDL_FingerID fingerid, float x, float y, float p
     if (touch->num_fingers == touch->max_fingers) {
         SDL_Finger **new_fingers;
         new_fingers = (SDL_Finger **)SDL_realloc(touch->fingers, (touch->max_fingers+1)*sizeof(*touch->fingers));
-        if (!new_fingers) {
+        if (new_fingers == NULL) {
             return SDL_OutOfMemory();
         }
         touch->fingers = new_fingers;
@@ -257,7 +257,7 @@ SDL_SendTouch(SDL_TouchID id, SDL_FingerID fingerid, SDL_Window * window,
     SDL_Mouse *mouse;
 
     SDL_Touch* touch = SDL_GetTouch(id);
-    if (!touch) {
+    if (touch == NULL) {
         return -1;
     }
 
@@ -279,10 +279,18 @@ SDL_SendTouch(SDL_TouchID id, SDL_FingerID fingerid, SDL_Window * window,
                         if (finger_touching == SDL_FALSE) {
                             int pos_x = (int)(x * (float)window->w);
                             int pos_y = (int)(y * (float)window->h);
-                            if (pos_x < 0) pos_x = 0;
-                            if (pos_x > window->w - 1) pos_x = window->w - 1;
-                            if (pos_y < 0) pos_y = 0;
-                            if (pos_y > window->h - 1) pos_y = window->h - 1;
+                            if (pos_x < 0) {
+                                pos_x = 0;
+                            }
+                            if (pos_x > window->w - 1) {
+                                pos_x = window->w - 1;
+                            }
+                            if (pos_y < 0) {
+                                pos_y = 0;
+                            }
+                            if (pos_y > window->h - 1) {
+                                pos_y = window->h - 1;
+                            }
                             SDL_SendMouseMotion(window, SDL_TOUCH_MOUSEID, 0, pos_x, pos_y);
                             SDL_SendMouseButton(window, SDL_TOUCH_MOUSEID, SDL_PRESSED, SDL_BUTTON_LEFT);
                         }
@@ -342,7 +350,7 @@ SDL_SendTouch(SDL_TouchID id, SDL_FingerID fingerid, SDL_Window * window,
             posted = (SDL_PushEvent(&event) > 0);
         }
     } else {
-        if (!finger) {
+        if (finger == NULL) {
             /* This finger is already up */
             return 0;
         }
@@ -379,7 +387,7 @@ SDL_SendTouchMotion(SDL_TouchID id, SDL_FingerID fingerid, SDL_Window * window,
     float xrel, yrel, prel;
 
     touch = SDL_GetTouch(id);
-    if (!touch) {
+    if (touch == NULL) {
         return -1;
     }
 
@@ -394,10 +402,18 @@ SDL_SendTouchMotion(SDL_TouchID id, SDL_FingerID fingerid, SDL_Window * window,
                     if (finger_touching == SDL_TRUE && track_touchid == id && track_fingerid == fingerid) {
                         int pos_x = (int)(x * (float)window->w);
                         int pos_y = (int)(y * (float)window->h);
-                        if (pos_x < 0) pos_x = 0;
-                        if (pos_x > window->w - 1) pos_x = window->w - 1;
-                        if (pos_y < 0) pos_y = 0;
-                        if (pos_y > window->h - 1) pos_y = window->h - 1;
+                        if (pos_x < 0) {
+                            pos_x = 0;
+                        }
+                        if (pos_x > window->w - 1) {
+                            pos_x = window->w - 1;
+                        }
+                        if (pos_y < 0) {
+                            pos_y = 0;
+                        }
+                        if (pos_y > window->h - 1) {
+                            pos_y = window->h - 1;
+                        }
                         SDL_SendMouseMotion(window, SDL_TOUCH_MOUSEID, 0, pos_x, pos_y);
                     }
                 }
@@ -414,7 +430,7 @@ SDL_SendTouchMotion(SDL_TouchID id, SDL_FingerID fingerid, SDL_Window * window,
     }
 
     finger = SDL_GetFinger(touch,fingerid);
-    if (!finger) {
+    if (finger == NULL) {
         return SDL_SendTouch(id, fingerid, window, SDL_TRUE, x, y, pressure);
     }
 
@@ -466,7 +482,7 @@ SDL_DelTouch(SDL_TouchID id)
 
     index = SDL_GetTouchIndex(id);
     touch = SDL_GetTouch(id);
-    if (!touch) {
+    if (touch == NULL) {
         return;
     }
 
diff --git a/src/events/SDL_windowevents.c b/src/events/SDL_windowevents.c
index 209295afc..e87f758c8 100644
--- a/src/events/SDL_windowevents.c
+++ b/src/events/SDL_windowevents.c
@@ -88,7 +88,7 @@ SDL_SendWindowEvent(SDL_Window * window, Uint8 windowevent, int data1,
 {
     int posted;
 
-    if (!window) {
+    if (window == NULL) {
         return 0;
     }
     switch (windowevent) {
diff --git a/src/file/SDL_rwops.c b/src/file/SDL_rwops.c
index ead504c10..7c4d683b0 100644
--- a/src/file/SDL_rwops.c
+++ b/src/file/SDL_rwops.c
@@ -87,8 +87,9 @@ windows_file_open(SDL_RWops * context, const char *filename, const char *mode)
     DWORD must_exist, truncate;
     int a_mode;
 
-    if (!context)
-        return -1;              /* failed (invalid call) */
+    if (context == NULL) {
+        return -1; /* failed (invalid call) */
+    }
 
     context->hidden.windowsio.h = INVALID_HANDLE_VALUE;   /* mark this as unusable */
     context->hidden.windowsio.buffer.data = NULL;
@@ -110,8 +111,10 @@ windows_file_open(SDL_RWops * context, const char *filename, const char *mode)
     w_right = (a_mode || SDL_strchr(mode, '+')
                || truncate) ? GENERIC_WRITE : 0;
 
-    if (!r_right && !w_right)   /* inconsistent mode */
-        return -1;              /* failed (invalid call) */
+    if (!r_right && !w_right) {
+        return -1; /* inconsistent mode */
+    }
+                  /* failed (invalid call) */
 
     context->hidden.windowsio.buffer.data =
         (char *) SDL_malloc(READAHEAD_BUFFER_SIZE);
@@ -155,7 +158,7 @@ windows_file_size(SDL_RWops * context)
 {
     LARGE_INTEGER size;
 
-    if (!context || context->hidden.windowsio.h == INVALID_HANDLE_VALUE) {
+    if (context == NULL || context->hidden.windowsio.h == INVALID_HANDLE_VALUE) {
         return SDL_SetError("windows_file_size: invalid context/file not opened");
     }
 
@@ -172,7 +175,7 @@ windows_file_seek(SDL_RWops * context, Sint64 offset, int whence)
     DWORD windowswhence;
     LARGE_INTEGER windowsoffset;
 
-    if (!context || context->hidden.windowsio.h == INVALID_HANDLE_VALUE) {
+    if (context == NULL || context->hidden.windowsio.h == INVALID_HANDLE_VALUE) {
         return SDL_SetError("windows_file_seek: invalid context/file not opened");
     }
 
@@ -213,7 +216,7 @@ windows_file_read(SDL_RWops * context, void *ptr, size_t size, size_t maxnum)
 
     total_need = size * maxnum;
 
-    if (!context || context->hidden.windowsio.h == INVALID_HANDLE_VALUE || !total_need) {
+    if (context == NULL || context->hidden.windowsio.h == INVALID_HANDLE_VALUE || !total_need) {
         return 0;
     }
 
@@ -254,7 +257,7 @@ windows_file_read(SDL_RWops * context, void *ptr, size_t size, size_t maxnum)
         }
         total_read += byte_read;
     }
-    return (total_read / size);
+    return total_read / size;
 }
 
 static size_t SDLCALL
@@ -268,7 +271,7 @@ windows_file_write(SDL_RWops * context, const void *ptr, size_t size,
 
     total_bytes = size * num;
 
-    if (!context || context->hidden.windowsio.h == INVALID_HANDLE_VALUE || !size || !total_bytes) {
+    if (context == NULL || context->hidden.windowsio.h == INVALID_HANDLE_VALUE || !size || !total_bytes) {
         return 0;
     }
 
@@ -501,7 +504,7 @@ mem_read(SDL_RWops * context, void *ptr, size_t size, size_t maxnum)
     SDL_memcpy(ptr, context->hidden.mem.here, total_bytes);
     context->hidden.mem.here += total_bytes;
 
-    return (total_bytes / size);
+    return total_bytes / size;
 }
 
 static size_t SDLCALL
@@ -538,7 +541,7 @@ SDL_RWops *
 SDL_RWFromFile(const char *file, const char *mode)
 {
     SDL_RWops *rwops = NULL;
-    if (!file || !*file || !mode || !*mode) {
+    if (file == NULL || !*file || mode == NULL || !*mode) {
         SDL_SetError("SDL_RWFromFile(): No file or no mode specified");
         return NULL;
     }
@@ -571,8 +574,10 @@ SDL_RWFromFile(const char *file, const char *mode)
 
     /* Try to open the file from the asset system */
     rwops = SDL_AllocRW();
-    if (!rwops)
-        return NULL;            /* SDL_SetError already setup by SDL_AllocRW() */
+    if (rwops == NULL) {
+        return NULL; /* SDL_SetError already setup by SDL_AllocRW() */
+    }
+
     if (Android_JNI_FileOpen(rwops, file, mode) < 0) {
         SDL_FreeRW(rwops);
         return NULL;
@@ -586,8 +591,10 @@ SDL_RWFromFile(const char *file, const char *mode)
 
 #elif defined(__WIN32__) || defined(__GDK__)
     rwops = SDL_AllocRW();
-    if (!rwops)
-        return NULL;            /* SDL_SetError already setup by SDL_AllocRW() */
+    if (rwops == NULL) {
+        return NULL; /* SDL_SetError already setup by SDL_AllocRW() */
+    }
+
     if (windows_file_open(rwops, file, mode) < 0) {
         SDL_FreeRW(rwops);
         return NULL;
@@ -655,7 +662,7 @@ SDL_RWops *
 SDL_RWFromMem(void *mem, int size)
 {
     SDL_RWops *rwops = NULL;
-    if (!mem) {
+    if (mem == NULL) {
       SDL_InvalidParamError("mem");
       return rwops;
     }
@@ -683,7 +690,7 @@ SDL_RWops *
 SDL_RWFromConstMem(const void *mem, int size)
 {
     SDL_RWops *rwops = NULL;
-    if (!mem) {
+    if (mem == NULL) {
       SDL_InvalidParamError("mem");
       return rwops;
     }
@@ -736,7 +743,7 @@ SDL_LoadFile_RW(SDL_RWops * src, size_t *datasize, int freesrc)
     size_t size_read, size_total;
     void *data = NULL, *newdata;
 
-    if (!src) {
+    if (src == NULL) {
         SDL_InvalidParamError("src");
         return NULL;
     }
@@ -752,7 +759,7 @@ SDL_LoadFile_RW(SDL_RWops * src, size_t *datasize, int freesrc)
         if ((((Sint64)size_total) + FILE_CHUNK_SIZE) > size) {
             size = (size_total + FILE_CHUNK_SIZE);
             newdata = SDL_realloc(data, (size_t)(size + 1));
-            if (!newdata) {
+            if (newdata == NULL) {
                 SDL_free(data);
                 data = NULL;
                 SDL_OutOfMemory();
@@ -890,49 +897,49 @@ SDL_ReadBE64(SDL_RWops * src)
 size_t
 SDL_WriteU8(SDL_RWops * dst, Uint8 value)
 {
-    return SDL_RWwrite(dst, &value, sizeof (value), 1);
+    return SDL_RWwrite(dst, &value, sizeof(value), 1);
 }
 
 size_t
 SDL_WriteLE16(SDL_RWops * dst, Uint16 value)
 {
     const Uint16 swapped = SDL_SwapLE16(value);
-    return SDL_RWwrite(dst, &swapped, sizeof (swapped), 1);
+    return SDL_RWwrite(dst, &swapped, sizeof(swapped), 1);
 }
 
 size_t
 SDL_WriteBE16(SDL_RWops * dst, Uint16 value)
 {
     const Uint16 swapped = SDL_SwapBE16(value);
-    return SDL_RWwrite(dst, &swapped, sizeof (swapped), 1);
+    return SDL_RWwrite(dst, &swapped, sizeof(swapped), 1);
 }
 
 size_t
 SDL_WriteLE32(SDL_RWops * dst, Uint32 value)
 {
     const Uint32 swapped = SDL_SwapLE32(value);
-    return SDL_RWwrite(dst, &swapped, sizeof (swapped), 1);
+    return SDL_RWwrite(dst, &swapped, sizeof(swapped), 1);
 }
 
 size_t
 SDL_WriteBE32(SDL_RWops * dst, Uint32 value)
 {
     const Uint32 swapped = SDL_SwapBE32(value);
-    return SDL_RWwrite(dst, &swapped, sizeof (swapped), 1);
+    return SDL_RWwrite(dst, &swapped, sizeof(swapped), 1);
 }
 
 size_t
 SDL_WriteLE64(SDL_RWops * dst, Uint64 value)
 {
     const Uint64 swapped = SDL_SwapLE64(value);
-    return SDL_RWwrite(dst, &swapped, sizeof (swapped), 1);
+    return SDL_RWwrite(dst, &swapped, sizeof(swapped), 1);
 }
 
 size_t
 SDL_WriteBE64(SDL_RWops * dst, Uint64 value)
 {
     const Uint64 swapped = SDL_SwapBE64(value);
-    return SDL_RWwrite(dst, &swapped, sizeof (swapped), 1);
+    return SDL_RWwrite(dst, &swapped, sizeof(swapped), 1);
 }
 
 /* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/filesystem/android/SDL_sysfilesystem.c b/src/filesystem/android/SDL_sysfilesystem.c
index 0ffe96b15..3214b689f 100644
--- a/src/filesystem/android/SDL_sysfilesystem.c
+++ b/src/filesystem/android/SDL_sysfilesystem.c
@@ -47,7 +47,7 @@ SDL_GetPrefPath(const char *org, const char *app)
     if (path) {
         size_t pathlen = SDL_strlen(path)+2;
         char *fullpath = (char *)SDL_malloc(pathlen);
-        if (!fullpath) {
+        if (fullpath == NULL) {
             SDL_OutOfMemory();
             return NULL;
         }
diff --git a/src/filesystem/emscripten/SDL_sysfilesystem.c b/src/filesystem/emscripten/SDL_sysfilesystem.c
index f007af625..955e8bfd3 100644
--- a/src/filesystem/emscripten/SDL_sysfilesystem.c
+++ b/src/filesystem/emscripten/SDL_sysfilesystem.c
@@ -47,17 +47,17 @@ SDL_GetPrefPath(const char *org, const char *app)
     char *ptr = NULL;
     size_t len = 0;
 
-    if (!app) {
+    if (app == NULL) {
         SDL_InvalidParamError("app");
         return NULL;
     }
-    if (!org) {
+    if (org == NULL) {
         org = "";
     }
 
     len = SDL_strlen(append) + SDL_strlen(org) + SDL_strlen(app) + 3;
     retval = (char *) SDL_malloc(len);
-    if (!retval) {
+    if (retval == NULL) {
         SDL_OutOfMemory();
         return NULL;
     }
@@ -71,8 +71,9 @@ SDL_GetPrefPath(const char *org, const char *app)
     for (ptr = retval+1; *ptr; ptr++) {
         if (*ptr == '/') {
             *ptr = '\0';
-            if (mkdir(retval, 0700) != 0 && errno != EEXIST)
+            if (mkdir(retval, 0700) != 0 && errno != EEXIST) {
                 goto error;
+            }
             *ptr = '/';
         }
     }
diff --git a/src/filesystem/haiku/SDL_sysfilesystem.cc b/src/filesystem/haiku/SDL_sysfilesystem.cc
index f359f36fe..e25a6e099 100644
--- a/src/filesystem/haiku/SDL_sysfilesystem.cc
+++ b/src/filesystem/haiku/SDL_sysfilesystem.cc
@@ -57,7 +57,7 @@ SDL_GetBasePath(void)
 
     const size_t len = SDL_strlen(str);
     char *retval = (char *) SDL_malloc(len + 2);
-    if (!retval) {
+    if (retval == NULL) {
         SDL_OutOfMemory();
         return NULL;
     }
@@ -77,11 +77,11 @@ SDL_GetPrefPath(const char *org, const char *app)
     const char *append = "/config/settings/";
     size_t len = SDL_strlen(home);
 
-    if (!app) {
+    if (app == NULL) {
         SDL_InvalidParamError("app");
         return NULL;
     }
-    if (!org) {
+    if (org == NULL) {
         org = "";
     }
 
@@ -90,7 +90,7 @@ SDL_GetPrefPath(const char *org, const char *app)
     }
     len += SDL_strlen(append) + SDL_strlen(org) + SDL_strlen(app) + 3;
     char *retval = (char *) SDL_malloc(len);
-    if (!retval) {
+    if (retval == NULL) {
         SDL_OutOfMemory();
     } else {
         if (*org) {
diff --git a/src/filesystem/ps2/SDL_sysfilesystem.c b/src/filesystem/ps2/SDL_sysfilesystem.c
index 21c24b61b..f2272c044 100644
--- a/src/filesystem/ps2/SDL_sysfilesystem.c
+++ b/src/filesystem/ps2/SDL_sysfilesystem.c
@@ -41,8 +41,9 @@ SDL_GetBasePath(void)
   getcwd(cwd, sizeof(cwd));
   len = SDL_strlen(cwd) + 1;
   retval = (char *) SDL_malloc(len);
-  if (retval)
+  if (retval) {
     SDL_memcpy(retval, cwd, len);
+  }
 
   return retval;
 }
@@ -56,15 +57,17 @@ static void recursive_mkdir(const char *dir) {
 
   snprintf(tmp, sizeof(tmp),"%s",dir);
   len = strlen(tmp);
-  if (tmp[len - 1] == '/')
+  if (tmp[len - 1] == '/') {
       tmp[len - 1] = 0;
+  }
 
   for (p = tmp + 1; *p; p++) {
     if (*p == '/') {
       *p = 0;
       // Just creating subfolders from current path
-      if (strstr(tmp, base) != NULL)
+      if (strstr(tmp, base) != NULL) {
         mkdir(tmp, S_IRWXU);
+      }
 
       *p = '/';
     }
@@ -80,11 +83,11 @@ SDL_GetPrefPath(const char *org, const char *app)
   char *retval = NULL;
   size_t len;
   char *base = SDL_GetBasePath();
-  if (!app) {
+  if (app == NULL) {
     SDL_InvalidParamError("app");
     return NULL;
   }
-  if(!org) {
+  if (org == NULL) {
     org = "";
   }
 
diff --git a/src/filesystem/psp/SDL_sysfilesystem.c b/src/filesystem/psp/SDL_sysfilesystem.c
index 4abb90ad7..cbce1a4ba 100644
--- a/src/filesystem/psp/SDL_sysfilesystem.c
+++ b/src/filesystem/psp/SDL_sysfilesystem.c
@@ -52,11 +52,11 @@ SDL_GetPrefPath(const char *org, const char *app)
     char *retval = NULL;
     size_t len;
     char *base = SDL_GetBasePath();
-    if (!app) {
+    if (app == NULL) {
         SDL_InvalidParamError("app");
         return NULL;
     }
-    if(!org) {
+    if (org == NULL) {
         org = "";
     }
 
diff --git a/src/filesystem/riscos/SDL_sysfilesystem.c b/src/filesystem/riscos/SDL_sysfilesystem.c
index 58ff9f161..8998a7d08 100644
--- a/src/filesystem/riscos/SDL_sysfilesystem.c
+++ b/src/filesystem/riscos/SDL_sysfilesystem.c
@@ -39,22 +39,23 @@ SDL_unixify_std(const char *ro_path, char *buffer, size_t buf_len, int filetype)
 {
     const char *const in_buf = buffer; /* = NULL if we allocate the buffer.  */
 
-    if (!buffer) {
+    if (buffer == NULL) {
         /* This matches the logic in __unixify, with an additional byte for the
          * extra path separator.
          */
         buf_len = SDL_strlen(ro_path) + 14 + 1;
         buffer = SDL_malloc(buf_len);
 
-        if (!buffer) {
+        if (buffer == NULL) {
             SDL_OutOfMemory();
             return NULL;
         }
     }
 
     if (!__unixify_std(ro_path, buffer, buf_len, filetype)) {
-        if (!in_buf)
+        if (in_buf == NULL) {
             SDL_free(buffer);
+        }
 
         SDL_SetError("Could not convert '%s' to a Unix-style path", ro_path);
         return NULL;
@@ -93,7 +94,7 @@ canonicalisePath(const char *path, const char *pathVar)
 
     regs.r[5] = 1 - regs.r[5];
     buf = SDL_malloc(regs.r[5]);
-    if (!buf) {
+    if (buf == NULL) {
         SDL_OutOfMemory();
         return NULL;
     }
@@ -123,8 +124,9 @@ createDirectoryRecursive(char *path)
             *ptr = '\0';
             error = _kernel_swi(OS_File, &regs, &regs);
             *ptr = '.';
-            if (error != NULL)
+            if (error != NULL) {
                 return error;
+            }
         }
     }
     return _kernel_swi(OS_File, &regs, &regs);
@@ -143,14 +145,15 @@ SDL_GetBasePath(void)
     }
 
     canon = canonicalisePath((const char *)regs.r[0], "Run$Path");
-    if (!canon) {
+    if (canon == NULL) {
         return NULL;
     }
 
     /* chop off filename. */
     ptr = SDL_strrchr(canon, '.');
-    if (ptr != NULL)
+    if (ptr != NULL) {
         *ptr = '\0';
+    }
 
     retval = SDL_unixify_std(canon, NULL, 0, __RISCOSIFY_FILETYPE_NOTSPECIFIED);
     SDL_free(canon);
@@ -164,22 +167,22 @@ SDL_GetPrefPath(const char *org, const char *app)
     size_t len;
     _kernel_oserror *error;
 
-    if (!app) {
+    if (app == NULL) {
         SDL_InvalidParamError("app");
         return NULL;
     }
-    if (!org) {
+    if (org == NULL) {
         org = "";
     }
 
     canon = canonicalisePath("<Choices$Write>", "Run$Path");
-    if (!canon) {
+    if (canon == NULL) {
         return NULL;
     }
 
     len = SDL_strlen(canon) + SDL_strlen(org) + SDL_strlen(app) + 4;
     dir = (char *) SDL_malloc(len);
-    if (!dir) {
+    if (dir == NULL) {
         SDL_OutOfMemory();
         SDL_free(canon);
         return NULL;
diff --git a/src/filesystem/unix/SDL_sysfilesystem.c b/src/filesystem/unix/SDL_sysfilesystem.c
index 00cbd183b..bd11fdaa5 100644
--- a/src/filesystem/unix/SDL_sysfilesystem.c
+++ b/src/filesystem/unix/SDL_sysfilesystem.c
@@ -52,8 +52,7 @@ readSymLink(const char *path)
     ssize_t len = 64;
     ssize_t rc = -1;
 
-    while (1)
-    {
+    while (1) {
         char *ptr = (char *) SDL_realloc(retval, (size_t) len);
         if (ptr == NULL) {
             SDL_OutOfMemory();
@@ -88,13 +87,13 @@ static char *search_path_for_binary(const char *bin)
     char *start = envr;
     char *ptr;
 
-    if (!envr) {
+    if (envr == NULL) {
         SDL_SetError("No $PATH set");
         return NULL;
     }
 
     envr = SDL_strdup(envr);
-    if (!envr) {
+    if (envr == NULL) {
         SDL_OutOfMemory();
         return NULL;
     }
@@ -143,7 +142,7 @@ SDL_GetBasePath(void)
     const int mib[] = { CTL_KERN, KERN_PROC, KERN_PROC_PATHNAME, -1 };
     if (sysctl(mib, SDL_arraysize(mib), fullpath, &buflen, NULL, 0) != -1) {
         retval = SDL_strdup(fullpath);
-        if (!retval) {
+        if (retval == NULL) {
             SDL_OutOfMemory();
             return NULL;
         }
@@ -157,13 +156,13 @@ SDL_GetBasePath(void)
     if (sysctl(mib, 4, NULL, &len, NULL, 0) != -1) {
         char *exe, *pwddst;
         char *realpathbuf = (char *) SDL_malloc(PATH_MAX + 1);
-        if (!realpathbuf) {
+        if (realpathbuf == NULL) {
             SDL_OutOfMemory();
             return NULL;
         }
 
         cmdline = SDL_malloc(len);
-        if (!cmdline) {
+        if (cmdline == NULL) {
             SDL_free(realpathbuf);
             SDL_OutOfMemory();
             return NULL;
@@ -201,7 +200,7 @@ SDL_GetBasePath(void)
             }
         }
 
-        if (!retval) {
+        if (retval == NULL) {
             SDL_free(realpathbuf);
         }
 
@@ -210,7 +209,7 @@ SDL_GetBasePath(void)
 #endif
 
     /* is a Linux-style /proc filesystem available? */
-    if (!retval && (access("/proc", F_OK) == 0)) {
+    if (retval == NULL && (access("/proc", F_OK) == 0)) {
         /* !!! FIXME: after 2.0.6 ships, let's delete this code and just
                       use the /proc/%llu version. There's no reason to have
                       two copies of this plus all the #ifdefs. --ryan. */
@@ -265,8 +264,9 @@ SDL_GetBasePath(void)
     if (retval != NULL) {
         /* try to shrink buffer... */
         char *ptr = (char *) SDL_realloc(retval, SDL_strlen(retval) + 1);
-        if (ptr != NULL)
-            retval = ptr;  /* oh well if it failed. */
+        if (ptr != NULL) {
+            retval = ptr; /* oh well if it failed. */
+        }
     }
 
     return retval;
@@ -288,18 +288,18 @@ SDL_GetPrefPath(const char *org, const char *app)
     char *ptr = NULL;
     size_t len = 0;
 
-    if (!app) {
+    if (app == NULL) {
         SDL_InvalidParamError("app");
         return NULL;
     }
-    if (!org) {
+    if (org == NULL) {
         org = "";
     }
 
-    if (!envr) {
+    if (envr == NULL) {
         /* You end up with "$HOME/.local/share/Game Name 2" */
         envr = SDL_getenv("HOME");
-        if (!envr) {
+        if (envr == NULL) {
             /* we could take heroic measures with /etc/passwd, but oh well. */
             SDL_SetError("neither XDG_DATA_HOME nor HOME environment is set");
             return NULL;
@@ -310,12 +310,13 @@ SDL_GetPrefPath(const char *org, const char *app)
     }
 
     len = SDL_strlen(envr);
-    if (envr[len - 1] == '/')
+    if (envr[len - 1] == '/') {
         append += 1;
+    }
 
     len += SDL_strlen(append) + SDL_strlen(org) + SDL_strlen(app) + 3;
     retval = (char *) SDL_malloc(len);
-    if (!retval) {
+    if (retval == NULL) {
         SDL_OutOfMemory();
         return NULL;
     }
@@ -329,8 +330,9 @@ SDL_GetPrefPath(const char *org, const char *app)
     for (ptr = retval+1; *ptr; ptr++) {
         if (*ptr == '/') {
             *ptr = '\0';
-            if (mkdir(retval, 0700) != 0 && errno != EEXIST)
+            if (mkdir(retval, 0700) != 0 && errno != EEXIST) {
                 goto error;
+            }
             *ptr = '/';
         }
     }
diff --git a/src/filesystem/vita/SDL_sysfilesystem.c b/src/filesystem/vita/SDL_sysfilesystem.c
index 1952cadf5..89304ba5b 100644
--- a/src/filesystem/vita/SDL_sysfilesystem.c
+++ b/src/filesystem/vita/SDL_sysfilesystem.c
@@ -55,11 +55,11 @@ SDL_GetPrefPath(const char *org, const char *app)
     char *ptr = NULL;
     size_t len = 0;
 
-    if (!app) {
+    if (app == NULL) {
         SDL_InvalidParamError("app");
         return NULL;
     }
-    if (!org) {
+    if (org == NULL) {
         org = "";
     }
 
@@ -67,7 +67,7 @@ SDL_GetPrefPath(const char *org, const char *app)
 
     len += SDL_strlen(org) + SDL_strlen(app) + 3;
     retval = (char *) SDL_malloc(len);
-    if (!retval) {
+    if (retval == NULL) {
         SDL_OutOfMemory();
         return NULL;
     }
diff --git a/src/filesystem/windows/SDL_sysfilesystem.c b/src/filesystem/windows/SDL_sysfilesystem.c
index 5d3099be6..b53731147 100644
--- a/src/filesystem/windows/SDL_sysfilesystem.c
+++ b/src/filesystem/windows/SDL_sysfilesystem.c
@@ -43,7 +43,7 @@ SDL_GetBasePath(void)
 
     while (SDL_TRUE) {
         void *ptr = SDL_realloc(path, buflen * sizeof (WCHAR));
-        if (!ptr) {
+        if (ptr == NULL) {
             SDL_free(path);
             SDL_OutOfMemory();
             return NULL;
@@ -101,11 +101,11 @@ SDL_GetPrefPath(const char *org, const char *app)
     size_t new_wpath_len = 0;
     BOOL api_result = FALSE;
 
-    if (!app) {
+    if (app == NULL) {
         SDL_InvalidParamError("app");
         return NULL;
     }
-    if (!org) {
+    if (org == NULL) {
         org = "";
     }
 
diff --git a/src/filesystem/winrt/SDL_sysfilesystem.cpp b/src/filesystem/winrt/SDL_sysfilesystem.cpp
index 115b45b1a..8603b26f5 100644
--- a/src/filesystem/winrt/SDL_sysfilesystem.cpp
+++ b/src/filesystem/winrt/SDL_sysfilesystem.cpp
@@ -111,7 +111,7 @@ SDL_WinRTGetFSPathUTF8(SDL_WinRT_Path pathType)
     }
 
     const wchar_t * ucs2Path = SDL_WinRTGetFSPathUNICODE(pathType);
-    if (!ucs2Path) {
+    if (ucs2Path == NULL) {
         return NULL;
     }
 
@@ -128,14 +128,14 @@ SDL_GetBasePath(void)
     size_t destPathLen;
     char * destPath = NULL;
 
-    if (!srcPath) {
+    if (srcPath == NULL) {
         SDL_SetError("Couldn't locate our basepath: %s", SDL_GetError());
         return NULL;
     }
 
     destPathLen = SDL_strlen(srcPath) + 2;
     destPath = (char *) SDL_malloc(destPathLen);
-    if (!destPath) {
+    if (destPath == NULL) {
         SDL_OutOfMemory();
         return NULL;
     }
@@ -161,16 +161,16 @@ SDL_GetPrefPath(const char *org, const char *app)
     size_t new_wpath_len = 0;
     BOOL api_result = FALSE;
 
-    if (!app) {
+    if (app == NULL) {
         SDL_InvalidParamError("app");
         return NULL;
     }
-    if (!org) {
+    if (org == NULL) {
         org = "";
     }
 
     srcPath = SDL_WinRTGetFSPathUNICODE(SDL_WINRT_PATH_LOCAL_FOLDER);
-    if ( ! srcPath) {
+    if (srcPath == NULL) {
         SDL_SetError("Unable to find a source path");
         return NULL;
     }
diff --git a/src/haptic/SDL_haptic.c b/src/haptic/SDL_haptic.c
index 3f87143ca..3c02ae65b 100644
--- a/src/haptic/SDL_haptic.c
+++ b/src/haptic/SDL_haptic.c
@@ -60,8 +60,7 @@ ValidHaptic(SDL_Haptic * haptic)
     valid = 0;
     if (haptic != NULL) {
         hapticlist = SDL_haptics;
-        while ( hapticlist )
-        {
+        while ( hapticlist ) {
             if (hapticlist == haptic) {
                 valid = 1;
                 break;
@@ -123,8 +122,7 @@ SDL_HapticOpen(int device_index)
     /* If the haptic is already open, return it
     * TODO: Should we create haptic instance IDs like the Joystick API?
     */
-    while ( hapticlist )
-    {
+    while ( hapticlist ) {
         if (device_index == hapticlist->index) {
             haptic = hapticlist;
             ++haptic->ref_count;
@@ -156,10 +154,12 @@ SDL_HapticOpen(int device_index)
     SDL_haptics = haptic;
 
     /* Disable autocenter and set gain to max. */
-    if (haptic->supported & SDL_HAPTIC_GAIN)
+    if (haptic->supported & SDL_HAPTIC_GAIN) {
         SDL_HapticSetGain(haptic, 100);
-    if (haptic->supported & SDL_HAPTIC_AUTOCENTER)
+    }
+    if (haptic->supported & SDL_HAPTIC_AUTOCENTER) {
         SDL_HapticSetAutocenter(haptic, 0);
+    }
 
     return haptic;
 }
@@ -184,8 +184,7 @@ SDL_HapticOpened(int device_index)
     opened = 0;
     hapticlist = SDL_haptics;
     /* TODO Should this use an instance ID? */
-    while ( hapticlist )
-    {
+    while ( hapticlist ) {
         if (hapticlist->index == (Uint8) device_index) {
             opened = 1;
             break;
@@ -216,8 +215,9 @@ SDL_HapticIndex(SDL_Haptic * haptic)
 int
 SDL_MouseIsHaptic(void)
 {
-    if (SDL_SYS_HapticMouse() < 0)
+    if (SDL_SYS_HapticMouse() < 0) {
         return SDL_FALSE;
+    }
     return SDL_TRUE;
 }
 
@@ -295,8 +295,7 @@ SDL_HapticOpenFromJoystick(SDL_Joystick * joystick)
 
     hapticlist = SDL_haptics;
     /* Check to see if joystick's haptic is already open */
-    while ( hapticlist )
-    {
+    while ( hapticlist ) {
         if (SDL_SYS_JoystickSameHaptic(hapticlist, joystick)) {
             haptic = hapticlist;
             ++haptic->ref_count;
@@ -362,17 +361,12 @@ SDL_HapticClose(SDL_Haptic * haptic)
     /* Remove from the list */
     hapticlist = SDL_haptics;
     hapticlistprev = NULL;
-    while ( hapticlist )
-    {
-        if (haptic == hapticlist)
-        {
-            if ( hapticlistprev )
-            {
+    while ( hapticlist ) {
+        if (haptic == hapticlist) {
+            if ( hapticlistprev ) {
                 /* unlink this entry */
                 hapticlistprev->next = hapticlist->next;
-            }
-            else
-            {
+            } else {
                 SDL_haptics = haptic->next;
             }
 
@@ -464,8 +458,9 @@ SDL_HapticEffectSupported(SDL_Haptic * haptic, SDL_HapticEffect * effect)
         return -1;
     }
 
-    if ((haptic->supported & effect->type) != 0)
+    if ((haptic->supported & effect->type) != 0) {
         return SDL_TRUE;
+    }
     return SDL_FALSE;
 }
 
@@ -646,10 +641,11 @@ SDL_HapticSetGain(SDL_Haptic * haptic, int gain)
         max_gain = SDL_atoi(env);
 
         /* Check for sanity. */
-        if (max_gain < 0)
+        if (max_gain < 0) {
             max_gain = 0;
-        else if (max_gain > 100)
+        } else if (max_gain > 100) {
             max_gain = 100;
+        }
 
         /* We'll scale it linearly with SDL_HAPTIC_GAIN_MAX */
         real_gain = (gain * max_gain) / 100;
@@ -747,7 +743,7 @@ SDL_HapticRumbleSupported(SDL_Haptic * haptic)
     }
 
     /* Most things can use SINE, but XInput only has LEFTRIGHT. */
-    return ((haptic->supported & (SDL_HAPTIC_SINE|SDL_HAPTIC_LEFTRIGHT)) != 0);
+    return (haptic->supported & (SDL_HAPTIC_SINE | SDL_HAPTIC_LEFTRIGHT)) != 0;
 }
 
 /*
diff --git a/src/haptic/android/SDL_syshaptic.c b/src/haptic/android/SDL_syshaptic.c
index dda573313..dd9ee1ebe 100644
--- a/src/haptic/android/SDL_syshaptic.c
+++ b/src/haptic/android/SDL_syshaptic.c
@@ -57,13 +57,13 @@ SDL_SYS_HapticInit(void)
         timeout = SDL_GetTicks() + 3000;
         Android_JNI_PollHapticDevices();
     }
-    return (numhaptics);
+    return numhaptics;
 }
 
 int
 SDL_SYS_NumHaptics(void)
 {
-    return (numhaptics);
+    return numhaptics;
 }
 
 static SDL_hapticlist_item *
@@ -136,19 +136,19 @@ OpenHaptic(SDL_Haptic *haptic, SDL_hapticlist_item *item)
 static SDL_hapticlist_item *
 OpenHapticByOrder(SDL_Haptic *haptic, int index)
 {
-    return OpenHaptic (haptic, HapticByOrder(index));
+    return OpenHaptic(haptic, HapticByOrder(index));
 }
 
 static SDL_hapticlist_item *
 OpenHapticByDevId(SDL_Haptic *haptic, int device_id)
 {
-    return OpenHaptic (haptic, HapticByDevId(device_id));
+    return OpenHaptic(haptic, HapticByDevId(device_id));
 }
 
 int
 SDL_SYS_HapticOpen(SDL_Haptic *haptic)
 {
-    return (OpenHapticByOrder(haptic, haptic->index) == NULL ? -1 : 0);
+    return OpenHapticByOrder(haptic, haptic->index) == NULL ? -1 : 0;
 }
 
 
@@ -171,14 +171,14 @@ SDL_SYS_JoystickIsHaptic(SDL_Joystick *joystick)
 int
 SDL_SYS_HapticOpenFromJoystick(SDL_Haptic *haptic, SDL_Joystick *joystick)
 {
-    return (OpenHapticByDevId(haptic, ((joystick_hwdata *)joystick->hwdata)->device_id) == NULL ? -1 : 0);
+    return OpenHapticByDevId(haptic, ((joystick_hwdata *)joystick->hwdata)->device_id) == NULL ? -1 : 0;
 }
 
 
 int
 SDL_SYS_JoystickSameHaptic(SDL_Haptic * haptic, SDL_Joystick * joystick)
 {
-    return (((SDL_hapticlist_item *)haptic->hwdata)->device_id == ((joystick_hwdata *)joystick->hwdata)->device_id ? 1 : 0);
+    return ((SDL_hapticlist_item *)haptic->hwdata)->device_id == ((joystick_hwdata *)joystick->hwdata)->device_id ? 1 : 0;
 }
 
 
diff --git a/src/haptic/darwin/SDL_syshaptic.c b/src/haptic/darwin/SDL_syshaptic.c
index 50905e19c..3c0ebb412 100644
--- a/src/haptic/darwin/SDL_syshaptic.c
+++ b/src/haptic/darwin/SDL_syshaptic.c
@@ -229,8 +229,7 @@ MacHaptic_MaybeAddDevice( io_object_t device )
     }
 
     /* Make sure we don't already have it */
-    for (item = SDL_hapticlist; item ; item = item->next)
-    {
+    for (item = SDL_hapticlist; item ; item = item->next) {
         if (IOObjectIsEqualTo((io_object_t) item->dev, device)) {
             /* Already added */
             return -1;
diff --git a/src/haptic/linux/SDL_syshaptic.c b/src/haptic/linux/SDL_syshaptic.c
index a9be7e0d3..7ae9c3ddb 100644
--- a/src/haptic/linux/SDL_syshaptic.c
+++ b/src/haptic/linux/SDL_syshaptic.c
@@ -85,8 +85,10 @@ static SDL_hapticlist_item *SDL_hapticlist = NULL;
 static SDL_hapticlist_item *SDL_hapticlist_tail = NULL;
 static int numhaptics = 0;
 
-#define EV_TEST(ev,f) \
-   if (test_bit((ev), features)) ret |= (f);
+#define EV_TEST(ev,f)                \
+   if (test_bit((ev), features)) {   \
+       ret |= (f);                   \
+   }
 /*
  * Test whether a device has haptic properties.
  * Returns available properties or 0 if there are none.
@@ -760,8 +762,9 @@ SDL_SYS_ToFFEffect(struct ff_effect *dest, SDL_HapticEffect * src)
 
         /* Header */
         dest->type = FF_CONSTANT;
-        if (SDL_SYS_ToDirection(&dest->direction, &constant->direction) == -1)
+        if (SDL_SYS_ToDirection(&dest->direction, &constant->direction) == -1) {
             return -1;
+        }
 
         /* Replay */
         dest->replay.length = (constant->length == SDL_HAPTIC_INFINITY) ?
@@ -795,8 +798,9 @@ SDL_SYS_ToFFEffect(struct ff_effect *dest, SDL_HapticEffect * src)
 
         /* Header */
         dest->type = FF_PERIODIC;
-        if (SDL_SYS_ToDirection(&dest->direction, &periodic->direction) == -1)
+        if (SDL_SYS_ToDirection(&dest->direction, &periodic->direction) == -1) {
             return -1;
+        }
 
         /* Replay */
         dest->replay.length = (periodic->length == SDL_HAPTIC_INFINITY) ?
@@ -808,17 +812,18 @@ SDL_SYS_ToFFEffect(struct ff_effect *dest, SDL_HapticEffect * src)
         dest->trigger.interval = CLAMP(periodic->interval);
 
         /* Periodic */
-        if (periodic->type == SDL_HAPTIC_SINE)
+        if (periodic->type == SDL_HAPTIC_SINE) {
             dest->u.periodic.waveform = FF_SINE;
         /* !!! FIXME: put this back when we have more bits in 2.1 */
         /* else if (periodic->type == SDL_HAPTIC_SQUARE)
             dest->u.periodic.waveform = FF_SQUARE; */
-        else if (periodic->type == SDL_HAPTIC_TRIANGLE)
+        } else if (periodic->type == SDL_HAPTIC_TRIANGLE) {
             dest->u.periodic.waveform = FF_TRIANGLE;
-        else if (periodic->type == SDL_HAPTIC_SAWTOOTHUP)
+        } else if (periodic->type == SDL_HAPTIC_SAWTOOTHUP) {
             dest->u.periodic.waveform = FF_SAW_UP;
-        else if (periodic->type == SDL_HAPTIC_SAWTOOTHDOWN)
+        } else if (periodic->type == SDL_HAPTIC_SAWTOOTHDOWN) {
             dest->u.periodic.waveform = FF_SAW_DOWN;
+        }
         dest->u.periodic.period = CLAMP(periodic->period);
         dest->u.periodic.magnitude = periodic->magnitude;
         dest->u.periodic.offset = periodic->offset;
@@ -842,14 +847,16 @@ SDL_SYS_ToFFEffect(struct ff_effect *dest, SDL_HapticEffect * src)
         condition = &src->condition;
 
         /* Header */
-        if (condition->type == SDL_HAPTIC_SPRING)
+        if (condition->type == SDL_HAPTIC_SPRING) {
             dest->type = FF_SPRING;
-        else if (condition->type == SDL_HAPTIC_DAMPER)
+        } else if (condition->type == SDL_HAPTIC_DAMPER) {
             dest->type = FF_DAMPER;
-        else if (condition->type == SDL_HAPTIC_INERTIA)
+        } else if (condition->type == SDL_HAPTIC_INERTIA) {
             dest->type = FF_INERTIA;
-        else if (condition->type == SDL_HAPTIC_FRICTION)
+        } else if (condition->type == SDL_HAPTIC_FRICTION) {
             dest->type = FF_FRICTION;
+        }
+        
         dest->direction = 0;    /* Handled by the condition-specifics. */
 
         /* Replay */
@@ -888,8 +895,9 @@ SDL_SYS_ToFFEffect(struct ff_effect *dest, SDL_HapticEffect * src)
 
         /* Header */
         dest->type = FF_RAMP;
-        if (SDL_SYS_ToDirection(&dest->direction, &ramp->direction) == -1)
+        if (SDL_SYS_ToDirection(&dest->direction, &ramp->direction) == -1) {
             return -1;
+        }
 
         /* Replay */
         dest->replay.length = (ramp->length == SDL_HAPTIC_INFINITY) ?
diff --git a/src/haptic/windows/SDL_dinputhaptic.c b/src/haptic/windows/SDL_dinputhaptic.c
index 2229c6916..a7900d60c 100644
--- a/src/haptic/windows/SDL_dinputhaptic.c
+++ b/src/haptic/windows/SDL_dinputhaptic.c
@@ -575,18 +575,22 @@ SDL_SYS_SetDirection(DIEFFECT * effect, SDL_HapticDirection * dir, int naxes)
     case SDL_HAPTIC_CARTESIAN:
         effect->dwFlags |= DIEFF_CARTESIAN;
         rglDir[0] = dir->dir[0];
-        if (naxes > 1)
+        if (naxes > 1) {
             rglDir[1] = dir->dir[1];
-        if (naxes > 2)
+        }
+        if (naxes > 2) {
             rglDir[2] = dir->dir[2];
+        }
         return 0;
     case SDL_HAPTIC_SPHERICAL:
         effect->dwFlags |= DIEFF_SPHERICAL;
         rglDir[0] = dir->dir[0];
-        if (naxes > 1)
+        if (naxes > 1) {
             rglDir[1] = dir->dir[1];
-        if (naxes > 2)
+        }
+        if (naxes > 2) {
             rglDir[2] = dir->dir[2];
+        }
         return 0;
     case SDL_HAPTIC_STEERING_AXIS:
         effect->dwFlags |= DIEFF_CARTESIAN;
@@ -1098,8 +1102,9 @@ SDL_DINPUT_HapticGetEffectStatus(SDL_Haptic * haptic, struct haptic_effect *effe
         return DI_SetError("Getting effect status", ret);
     }
 
-    if (status == 0)
+    if (status == 0) {
         return SDL_FALSE;
+    }
     return SDL_TRUE;
 }
 
diff --git a/src/haptic/windows/SDL_xinputhaptic.c b/src/haptic/windows/SDL_xinputhaptic.c
index 2622fb7a7..b70b48278 100644
--- a/src/haptic/windows/SDL_xinputhaptic.c
+++ b/src/haptic/windows/SDL_xinputhaptic.c
@@ -233,7 +233,7 @@ SDL_XINPUT_HapticOpen(SDL_Haptic * haptic, SDL_hapticlist_item *item)
 int
 SDL_XINPUT_JoystickSameHaptic(SDL_Haptic * haptic, SDL_Joystick * joystick)
 {
-    return (haptic->hwdata->userid == joystick->hwdata->userid);
+    return haptic->hwdata->userid == joystick->hwdata->userid;
 }
 
 int
diff --git a/src/hidapi/SDL_hidapi.c b/src/hidapi/SDL_hidapi.c
index 47818d4dc..1a3c4663b 100644
--- a/src/hidapi/SDL_hidapi.c
+++ b/src/hidapi/SDL_hidapi.c
@@ -185,7 +185,9 @@ static int SDL_inotify_init1(void) {
 #else
 static int SDL_inotify_init1(void) {
     int fd = inotify_init();
-    if (fd  < 0) return -1;
+    if (fd < 0) {
+        return -1;
+    }
     fcntl(fd, F_SETFL, O_NONBLOCK);
     fcntl(fd, F_SETFD, FD_CLOEXEC);
     return fd;
@@ -195,7 +197,7 @@ static int SDL_inotify_init1(void) {
 static int
 StrHasPrefix(const char *string, const char *prefix)
 {
-    return (SDL_strncmp(string, prefix, SDL_strlen(prefix)) == 0);
+    return SDL_strncmp(string, prefix, SDL_strlen(prefix)) == 0;
 }
 
 static int
@@ -324,8 +326,7 @@ HIDAPI_InitializeDiscovery()
                 SDL_HIDAPI_discovery.m_bCanGetNotifications = SDL_TRUE;
             }
         }
-    }
-    else
+    } else
 #endif /* SDL_USE_LIBUDEV */
     {
 #if defined(HAVE_INOTIFY)
@@ -421,15 +422,14 @@ HIDAPI_UpdateDiscovery()
                 if (pUdevDevice) {
                     const char *action = NULL;
                     action = usyms->udev_device_get_action(pUdevDevice);
-                    if (!action || SDL_strcmp(action, "add") == 0 || SDL_strcmp(action, "remove") == 0) {
+                    if (action == NULL || SDL_strcmp(action, "add") == 0 || SDL_strcmp(action, "remove") == 0) {
                         ++SDL_HIDAPI_discovery.m_unDeviceChangeCounter;
                     }
                     usyms->udev_device_unref(pUdevDevice);
                 }
             }
         }
-    }
-    else
+    } else
 #endif /* SDL_USE_LIBUDEV */
     {
 #if defined(HAVE_INOTIFY)
@@ -481,8 +481,9 @@ HIDAPI_ShutdownDiscovery()
     }
 
 #if defined(__WIN32__) || defined(__WINGDK__)
-    if (SDL_HIDAPI_discovery.m_hNotify)
+    if (SDL_HIDAPI_discovery.m_hNotify) {
         UnregisterDeviceNotification(SDL_HIDAPI_discovery.m_hNotify);
+    }
 
     if (SDL_HIDAPI_discovery.m_hwndMsg) {
         DestroyWindow(SDL_HIDAPI_discovery.m_hwndMsg);
@@ -509,8 +510,7 @@ HIDAPI_ShutdownDiscovery()
             SDL_UDEV_ReleaseUdevSyms();
             usyms = NULL;
         }
-    }
-    else
+    } else
 #endif /* SDL_USE_LIBUDEV */
     {
 #if defined(HAVE_INOTIFY)
@@ -808,14 +808,8 @@ SDL_libusb_get_string_descriptor(libusb_device_handle *dev,
                                  uint8_t descriptor_index, uint16_t lang_id,
                                  unsigned char *data, int length)
 {
-    return libusb_control_transfer(dev,
-                                   LIBUSB_ENDPOINT_IN | 0x0, /* Endpoint 0 IN */
-                                   LIBUSB_REQUEST_GET_DESCRIPTOR,
-                                   (LIBUSB_DT_STRING << 8) | descriptor_index,
-                                   lang_id,
-                                   data,
-                                   (uint16_t) length,
-                                   1000);
+    return libusb_control_transfer(dev, LIBUSB_ENDPOINT_IN | 0x0, LIBUSB_REQUEST_GET_DESCRIPTOR, (LIBUSB_DT_STRING << 8) | descriptor_index, lang_id,
+                                   data, (uint16_t)length, 1000); /* Endpoint 0 IN */
 }
 #define libusb_get_string_descriptor SDL_libusb_get_string_descriptor
 #endif /* __FreeBSD__ */
@@ -1240,7 +1234,7 @@ struct SDL_hid_device_info *SDL_hid_enumerate(unsigned short vendor_id, unsigned
 #endif
         for (usb_dev = usb_devs; usb_dev; usb_dev = usb_dev->next) {
             new_dev = (struct SDL_hid_device_info*) SDL_malloc(sizeof(struct SDL_hid_device_info));
-            if (!new_dev) {
+            if (new_dev == NULL) {
                 LIBUSB_hid_free_enumeration(usb_devs);
                 SDL_hid_free_enumeration(devs);
                 SDL_OutOfMemory();
@@ -1313,7 +1307,7 @@ struct SDL_hid_device_info *SDL_hid_enumerate(unsigned short vendor_id, unsigned
 #endif
             if (!bFound) {
                 new_dev = (struct SDL_hid_device_info*) SDL_malloc(sizeof(struct SDL_hid_device_info));
-                if (!new_dev) {
+                if (new_dev == NULL) {
 #ifdef HAVE_LIBUSB
                     if (libusb_ctx.libhandle) {
                         LIBUSB_hid_free_enumeration(usb_devs);
diff --git a/src/joystick/SDL_gamecontroller.c b/src/joystick/SDL_gamecontroller.c
index 26979a2ff..46a465803 100644
--- a/src/joystick/SDL_gamecontroller.c
+++ b/src/joystick/SDL_gamecontroller.c
@@ -168,7 +168,7 @@ SDL_LoadVIDPIDListFromHint(const char *hint, SDL_vidpid_list *list)
         spot = (char *)hint;
     }
 
-    if (!spot) {
+    if (spot == NULL) {
         return;
     }
 
@@ -176,7 +176,7 @@ SDL_LoadVIDPIDListFromHint(const char *hint, SDL_vidpid_list *list)
         entry = (Uint16)SDL_strtol(spot, &spot, 0);
         entry <<= 16;
         spot = SDL_strstr(spot, "0x");
-        if (!spot) {
+        if (spot == NULL) {
             break;
         }
         entry |= (Uint16)SDL_strtol(spot, &spot, 0);
@@ -222,9 +222,9 @@ static SDL_bool HasSameOutput(SDL_ExtendedGameControllerBind *a, SDL_ExtendedGam
     }
 
     if (a->outputType == SDL_CONTROLLER_BINDTYPE_AXIS) {
-        return (a->output.axis.axis == b->output.axis.axis);
+        return a->output.axis.axis == b->output.axis.axis;
     } else {
-        return (a->output.button == b->output.button);
+        return a->output.button == b->output.button;
     }
 }
 
@@ -266,7 +266,7 @@ static void HandleJoystickAxis(SDL_GameController *gamecontroller, int axis, int
         }
     }
 
-    if (last_match && (!match || !HasSameOutput(last_match, match))) {
+    if (last_match && (match == NULL || !HasSameOutput(last_match, match))) {
         /* Clear the last input that this axis generated */
         ResetOutput(gamecontroller, last_match);
     }
@@ -549,8 +549,7 @@ static ControllerMapping_t *SDL_CreateMappingForAndroidController(SDL_JoystickGU
         SDL_strlcat(mapping_string, "righttrigger:a5,", sizeof(mapping_string));
     }
 
-    return SDL_PrivateAddMappingForGUID(guid, mapping_string,
-                      &existing, SDL_CONTROLLER_MAPPING_PRIORITY_DEFAULT);
+    return SDL_PrivateAddMappingForGUID(guid, mapping_string, &existing, SDL_CONTROLLER_MAPPING_PRIORITY_DEFAULT);
 }
 #endif /* __ANDROID__ */
 
@@ -681,8 +680,7 @@ static ControllerMapping_t *SDL_CreateMappingForHIDAPIController(SDL_JoystickGUI
         }
     }
 
-    return SDL_PrivateAddMappingForGUID(guid, mapping_string,
-                      &existing, SDL_CONTROLLER_MAPPING_PRIORITY_DEFAULT);
+    return SDL_PrivateAddMappingForGUID(guid, mapping_string, &existing, SDL_CONTROLLER_MAPPING_PRIORITY_DEFAULT);
 }
 
 /*
@@ -696,8 +694,7 @@ static ControllerMapping_t *SDL_CreateMappingForRAWINPUTController(SDL_JoystickG
     SDL_strlcpy(mapping_string, "none,*,", sizeof(mapping_string));
     SDL_strlcat(mapping_string, "a:b0,b:b1,x:b2,y:b3,back:b6,guide:b10,start:b7,leftstick:b8,rightstick:b9,leftshoulder:b4,rightshoulder:b5,dpup:h0.1,dpdown:h0.4,dpleft:h0.8,dpright:h0.2,leftx:a0,lefty:a1,rightx:a2,righty:a3,lefttrigger:a4,righttrigger:a5,", sizeof(mapping_string));
 
-    return SDL_PrivateAddMappingForGUID(guid, mapping_string,
-                      &existing, SDL_CONTROLLER_MAPPING_PRIORITY_DEFAULT);
+    return SDL_PrivateAddMappingForGUID(guid, mapping_string, &existing, SDL_CONTROLLER_MAPPING_PRIORITY_DEFAULT);
 }
 
 /*
@@ -715,8 +712,7 @@ static ControllerMapping_t *SDL_CreateMappingForWGIController(SDL_JoystickGUID g
     SDL_strlcpy(mapping_string, "none,*,", sizeof(mapping_string));
     SDL_strlcat(mapping_string, "a:b0,b:b1,x:b2,y:b3,back:b6,start:b7,leftstick:b8,rightstick:b9,leftshoulder:b4,rightshoulder:b5,dpup:b10,dpdown:b12,dpleft:b13,dpright:b11,leftx:a1,lefty:a0~,rightx:a3,righty:a2~,lefttrigger:a4,righttrigger:a5,", sizeof(mapping_string));
 
-    return SDL_PrivateAddMappingForGUID(guid, mapping_string,
-                      &existing, SDL_CONTROLLER_MAPPING_PRIORITY_DEFAULT);
+    return SDL_PrivateAddMappingForGUID(guid, mapping_string, &existing, SDL_CONTROLLER_MAPPING_PRIORITY_DEFAULT);
 }
 
 /*
@@ -808,7 +804,7 @@ static ControllerMapping_t *SDL_PrivateGetControllerMappingForGUID(SDL_JoystickG
         return s_pXInputMapping;
     }
 #endif
-    if (!mapping) {
+    if (mapping == NULL) {
         if (SDL_IsJoystickHIDAPI(guid)) {
             mapping = SDL_CreateMappingForHIDAPIController(guid);
         } else if (SDL_IsJoystickRAWINPUT(guid)) {
@@ -847,13 +843,14 @@ SDL_GameControllerAxis SDL_GameControllerGetAxisFromString(const char *pchString
         ++pchString;
     }
 
-    if (!pchString || !pchString[0]) {
+    if (pchString == NULL || !pchString[0]) {
         return SDL_CONTROLLER_AXIS_INVALID;
     }
 
     for (entry = 0; map_StringForControllerAxis[entry]; ++entry) {
-        if (!SDL_strcasecmp(pchString, map_StringForControllerAxis[entry]))
-            return (SDL_GameControllerAxis) entry;
+        if (!SDL_strcasecmp(pchString, map_StringForControllerAxis[entry])) {
+            return (SDL_GameControllerAxis)entry;
+        }
     }
     return SDL_CONTROLLER_AXIS_INVALID;
 }
@@ -900,12 +897,14 @@ static const char* map_StringForControllerButton[] = {
 SDL_GameControllerButton SDL_GameControllerGetButtonFromString(const char *pchString)
 {
     int entry;
-    if (!pchString || !pchString[0])
+    if (pchString == NULL || !pchString[0]) {
         return SDL_CONTROLLER_BUTTON_INVALID;
+    }
 
     for (entry = 0; map_StringForControllerButton[entry]; ++entry) {
-        if (SDL_strcasecmp(pchString, map_StringForControllerButton[entry]) == 0)
-            return (SDL_GameControllerButton) entry;
+        if (SDL_strcasecmp(pchString, map_StringForControllerButton[entry]) == 0) {
+            return (SDL_GameControllerButton)entry;
+        }
     }
     return SDL_CONTROLLER_BUTTON_INVALID;
 }
@@ -1114,7 +1113,7 @@ static char *SDL_PrivateGetControllerGUIDFromMappingString(const char *pMapping)
     const char *pFirstComma = SDL_strchr(pMapping, ',');
     if (pFirstComma) {
         char *pchGUID = SDL_malloc(pFirstComma - pMapping + 1);
-        if (!pchGUID) {
+        if (pchGUID == NULL) {
             SDL_OutOfMemory();
             return NULL;
         }
@@ -1154,15 +1153,17 @@ static char *SDL_PrivateGetControllerNameFromMappingString(const char *pMapping)
     char *pchName;
 
     pFirstComma = SDL_strchr(pMapping, ',');
-    if (!pFirstComma)
+    if (pFirstComma == NULL) {
         return NULL;
+    }
 
     pSecondComma = SDL_strchr(pFirstComma + 1, ',');
-    if (!pSecondComma)
+    if (pSecondComma == NULL) {
         return NULL;
+    }
 
     pchName = SDL_malloc(pSecondComma - pFirstComma);
-    if (!pchName) {
+    if (pchName == NULL) {
         SDL_OutOfMemory();
         return NULL;
     }
@@ -1180,12 +1181,14 @@ static char *SDL_PrivateGetControllerMappingFromMappingString(const char *pMappi
     const char *pFirstComma, *pSecondComma;
 
     pFirstComma = SDL_strchr(pMapping, ',');
-    if (!pFirstComma)
+    if (pFirstComma == NULL) {
         return NULL;
+    }
 
     pSecondComma = SDL_strchr(pFirstComma + 1, ',');
-    if (!pSecondComma)
+    if (pSecondComma == NULL) {
         return NULL;
+    }
 
     return SDL_strdup(pSecondComma + 1); /* mapping is everything after the 3rd comma */
 }
@@ -1225,13 +1228,13 @@ SDL_PrivateAddMappingForGUID(SDL_JoystickGUID jGUID, const char *mappingString,
     Uint16 crc;
 
     pchName = SDL_PrivateGetControllerNameFromMappingString(mappingString);
-    if (!pchName) {
+    if (pchName == NULL) {
         SDL_SetError("Couldn't parse name from %s", mappingString);
         return NULL;
     }
 
     pchMapping = SDL_PrivateGetControllerMappingFromMappingString(mappingString);
-    if (!pchMapping) {
+    if (pchMapping == NULL) {
         SDL_free(pchName);
         SDL_SetError("Couldn't parse %s", mappingString);
         return NULL;
@@ -1288,7 +1291,7 @@ SDL_PrivateAddMappingForGUID(SDL_JoystickGUID jGUID, const char *mappingString,
         *existing = SDL_TRUE;
     } else {
         pControllerMapping = SDL_malloc(sizeof(*pControllerMapping));
-        if (!pControllerMapping) {
+        if (pControllerMapping == NULL) {
             SDL_free(pchName);
             SDL_free(pchMapping);
             SDL_OutOfMemory();
@@ -1331,7 +1334,7 @@ static ControllerMapping_t *SDL_PrivateGetControllerMappingForNameAndGUID(const
 
     mapping = SDL_PrivateGetControllerMappingForGUID(guid);
 #ifdef __LINUX__
-    if (!mapping && name) {
+    if (mapping == NULL && name) {
         if (SDL_strstr(name, "Xbox 360 Wireless Receiver")) {
             /* The Linux driver xpad.c maps the wireless dpad to buttons */
             SDL_bool existing;
@@ -1344,7 +1347,7 @@ static ControllerMapping_t *SDL_PrivateGetControllerMappingForNameAndGUID(const
     }
 #endif /* __LINUX__ */
 
-    if (!mapping) {
+    if (mapping == NULL) {
         mapping = s_pDefaultMapping;
     }
     return mapping;
@@ -1426,8 +1429,7 @@ static ControllerMapping_t *SDL_PrivateGenerateAutomaticControllerMapping(const
     SDL_PrivateAppendToMappingString(mapping, sizeof(mapping), "lefttrigger", &raw_map->lefttrigger);
     SDL_PrivateAppendToMappingString(mapping, sizeof(mapping), "righttrigger", &raw_map->righttrigger);
 
-    return SDL_PrivateAddMappingForGUID(guid, mapping,
-                      &existing, SDL_CONTROLLER_MAPPING_PRIORITY_DEFAULT);
+    return SDL_PrivateAddMappingForGUID(guid, mapping, &existing, SDL_CONTROLLER_MAPPING_PRIORITY_DEFAULT);
 }
 
 static ControllerMapping_t *SDL_PrivateGetControllerMapping(int device_index)
@@ -1441,13 +1443,13 @@ static ControllerMapping_t *SDL_PrivateGetControllerMapping(int device_index)
     if ((device_index < 0) || (device_index >= SDL_NumJoysticks())) {
         SDL_SetError("There are %d joysticks available", SDL_NumJoysticks());
         SDL_UnlockJoysticks();
-        return (NULL);
+        return NULL;
     }
 
     name = SDL_JoystickNameForIndex(device_index);
     guid = SDL_JoystickGetDeviceGUID(device_index);
     mapping = SDL_PrivateGetControllerMappingForNameAndGUID(name, guid);
-    if (!mapping) {
+    if (mapping == NULL) {
         SDL_GamepadMapping raw_map;
 
         SDL_zero(raw_map);
@@ -1544,7 +1546,7 @@ SDL_PrivateGameControllerAddMapping(const char *mappingString, SDL_ControllerMap
     SDL_bool existing = SDL_FALSE;
     ControllerMapping_t *pControllerMapping;
 
-    if (!mappingString) {
+    if (mappingString == NULL) {
         return SDL_InvalidParamError("mappingString");
     }
 
@@ -1611,7 +1613,7 @@ SDL_PrivateGameControllerAddMapping(const char *mappingString, SDL_ControllerMap
 #endif
 
     pchGUID = SDL_PrivateGetControllerGUIDFromMappingString(mappingString);
-    if (!pchGUID) {
+    if (pchGUID == NULL) {
         return SDL_SetError("Couldn't parse GUID from %s", mappingString);
     }
     if (!SDL_strcasecmp(pchGUID, "default")) {
@@ -1623,7 +1625,7 @@ SDL_PrivateGameControllerAddMapping(const char *mappingString, SDL_ControllerMap
     SDL_free(pchGUID);
 
     pControllerMapping = SDL_PrivateAddMappingForGUID(jGUID, mappingString, &existing, priority);
-    if (!pControllerMapping) {
+    if (pControllerMapping == NULL) {
         return -1;
     }
 
@@ -1691,7 +1693,7 @@ CreateMappingString(ControllerMapping_t *mapping, SDL_JoystickGUID guid)
     }
 
     pMappingString = SDL_malloc(needed);
-    if (!pMappingString) {
+    if (pMappingString == NULL) {
         SDL_OutOfMemory();
         return NULL;
     }
@@ -1778,8 +1780,9 @@ SDL_GameControllerLoadHints()
             char *pchNewLine = NULL;
 
             pchNewLine = SDL_strchr(pUserMappings, '\n');
-            if (pchNewLine)
+            if (pchNewLine) {
                 *pchNewLine = '\0';
+            }
 
             SDL_PrivateGameControllerAddMapping(pUserMappings, SDL_CONTROLLER_MAPPING_PRIORITY_USER);
 
@@ -1841,7 +1844,7 @@ SDL_GameControllerInitMappings(void)
     SDL_AddHintCallback(SDL_HINT_GAMECONTROLLER_IGNORE_DEVICES_EXCEPT,
                         SDL_GameControllerIgnoreDevicesExceptChanged, NULL);
 
-    return (0);
+    return 0;
 }
 
 int
@@ -1862,7 +1865,7 @@ SDL_GameControllerInit(void)
         }
     }
 
-    return (0);
+    return 0;
 }
 
 
@@ -1930,7 +1933,7 @@ SDL_GameControllerMappingForDeviceIndex(int joystick_index)
         /* allocate enough memory for GUID + ',' + name + ',' + mapping + \0 */
         needed = SDL_strlen(pchGUID) + 1 + SDL_strlen(mapping->name) + 1 + SDL_strlen(mapping->mapping) + 1;
         pMappingString = SDL_malloc(needed);
-        if (!pMappingString) {
+        if (pMappingString == NULL) {
             SDL_OutOfMemory();
             SDL_UnlockJoysticks();
             return NULL;
@@ -2085,14 +2088,14 @@ SDL_GameControllerOpen(int device_index)
                 gamecontroller = gamecontrollerlist;
                 ++gamecontroller->ref_count;
                 SDL_UnlockJoysticks();
-                return (gamecontroller);
+                return gamecontroller;
         }
         gamecontrollerlist = gamecontrollerlist->next;
     }
 
     /* Find a controller mapping */
     pSupportedController =  SDL_PrivateGetControllerMapping(device_index);
-    if (!pSupportedController) {
+    if (pSupportedController == NULL) {
         SDL_SetError("Couldn't find mapping for device (%d)", device_index);
         SDL_UnlockJoysticks();
         return NULL;
@@ -2146,7 +2149,7 @@ SDL_GameControllerOpen(int device_index)
 
     SDL_UnlockJoysticks();
 
-    return (gamecontroller);
+    return gamecontroller;
 }
 
 /*
@@ -2377,7 +2380,7 @@ int SDL_GameControllerSetSensorEnabled(SDL_GameController *gamecontroller, SDL_S
     SDL_Joystick *joystick = SDL_GameControllerGetJoystick(gamecontroller);
     int i;
 
-    if (!joystick) {
+    if (joystick == NULL) {
         return -1;
     }
 
@@ -2439,7 +2442,7 @@ SDL_GameControllerGetSensorDataRate(SDL_GameController *gamecontroller, SDL_Sens
     SDL_Joystick *joystick = SDL_GameControllerGetJoystick(gamecontroller);
     int i;
 
-    if (!joystick) {
+    if (joystick == NULL) {
         return 0.0f;
     }
 
@@ -2471,7 +2474,7 @@ SDL_GameControllerGetSensorDataWithTimestamp(SDL_GameController *gamecontroller,
     SDL_Joystick *joystick = SDL_GameControllerGetJoystick(gamecontroller);
     int i;
 
-    if (!joystick) {
+    if (joystick == NULL) {
         return -1;
     }
 
@@ -2507,7 +2510,7 @@ SDL_GameControllerPath(SDL_GameController *gamecontroller)
 {
     SDL_Joystick *joystick = SDL_GameControllerGetJoystick(gamecontroller);
 
-    if (!joystick) {
+    if (joystick == NULL) {
         return NULL;
     }
     return SDL_JoystickPath(joystick);
@@ -2518,7 +2521,7 @@ SDL_GameControllerGetType(SDL_GameController *gamecontroller)
 {
     SDL_Joystick *joystick = SDL_GameControllerGetJoystick(gamecontroller);
 
-    if (!joystick) {
+    if (joystick == NULL) {
         return SDL_CONTROLLER_TYPE_UNKNOWN;
     }
     return SDL_GetJoystickGameControllerTypeFromGUID(SDL_JoystickGetGUID(joystick), SDL_JoystickName(joystick));
@@ -2529,7 +2532,7 @@ SDL_GameControllerGetPlayerIndex(SDL_GameController *gamecontroller)
 {
     SDL_Joystick *joystick = SDL_GameControllerGetJoystick(gamecontroller);
 
-    if (!joystick) {
+    if (joystick == NULL) {
         return -1;
     }
     return SDL_JoystickGetPlayerIndex(joystick);
@@ -2543,7 +2546,7 @@ SDL_GameControllerSetPlayerIndex(SDL_GameController *gamecontroller, int player_
 {
     SDL_Joystick *joystick = SDL_GameControllerGetJoystick(gamecontroller);
 
-    if (!joystick) {
+    if (joystick == NULL) {
         return;
     }
     SDL_JoystickSetPlayerIndex(joystick, player_index);
@@ -2554,7 +2557,7 @@ SDL_GameControllerGetVendor(SDL_GameController *gamecontroller)
 {
     SDL_Joystick *joystick = SDL_GameControllerGetJoystick(gamecontroller);
 
-    if (!joystick) {
+    if (joystick == NULL) {
         return 0;
     }
     return SDL_JoystickGetVendor(joystick);
@@ -2565,7 +2568,7 @@ SDL_GameControllerGetProduct(SDL_GameController *gamecontroller)
 {
     SDL_Joystick *joystick = SDL_GameControllerGetJoystick(gamecontroller);
 
-    if (!joystick) {
+    if (joystick == NULL) {
         return 0;
     }
     return SDL_JoystickGetProduct(joystick);
@@ -2576,7 +2579,7 @@ SDL_GameControllerGetProductVersion(SDL_GameController *gamecontroller)
 {
     SDL_Joystick *joystick = SDL_GameControllerGetJoystick(gamecontroller);
 
-    if (!joystick) {
+    if (joystick == NULL) {
         return 0;
     }
     return SDL_JoystickGetProductVersion(joystick);
@@ -2587,7 +2590,7 @@ SDL_GameControllerGetFirmwareVersion(SDL_GameController *gamecontroller)
 {
     SDL_Joystick *joystick = SDL_GameControllerGetJoystick(gamecontroller);
 
-    if (!joystick) {
+    if (joystick == NULL) {
         return 0;
     }
     return SDL_JoystickGetFirmwareVersion(joystick);
@@ -2598,7 +2601,7 @@ SDL_GameControllerGetSerial(SDL_GameController *gamecontroller)
 {
     SDL_Joystick *joystick = SDL_GameControllerGetJoystick(gamecontroller);
 
-    if (!joystick) {
+    if (joystick == NULL) {
         return NULL;
     }
     return SDL_JoystickGetSerial(joystick);
@@ -2674,8 +2677,9 @@ SDL_GameControllerButtonBind SDL_GameControllerGetBindForAxis(SDL_GameController
 
     CHECK_GAMECONTROLLER_MAGIC(gamecontroller, bind);
 
-    if (axis == SDL_CONTROLLER_AXIS_INVALID)
+    if (axis == SDL_CONTROLLER_AXIS_INVALID) {
         return bind;
+    }
 
     for (i = 0; i < gamecontroller->num_bindings; ++i) {
         SDL_ExtendedGameControllerBind *binding = &gamecontroller->bindings[i];
@@ -2708,8 +2712,9 @@ SDL_GameControllerButtonBind SDL_GameControllerGetBindForButton(SDL_GameControll
 
     CHECK_GAMECONTROLLER_MAGIC(gamecontroller, bind);
 
-    if (button == SDL_CONTROLLER_BUTTON_INVALID)
+    if (button == SDL_CONTROLLER_BUTTON_INVALID) {
         return bind;
+    }
 
     for (i = 0; i < gamecontroller->num_bindings; ++i) {
         SDL_ExtendedGameControllerBind *binding = &gamecontroller->bindings[i];
@@ -2735,7 +2740,7 @@ SDL_GameControllerRumble(SDL_GameController *gamecontroller, Uint16 low_frequenc
 {
     SDL_Joystick *joystick = SDL_GameControllerGetJoystick(gamecontroller);
 
-    if (!joystick) {
+    if (joystick == NULL) {
         return -1;
     }
     return SDL_JoystickRumble(joystick, low_frequency_rumble, high_frequency_rumble, duration_ms);
@@ -2746,7 +2751,7 @@ SDL_GameControllerRumbleTriggers(SDL_GameController *gamecontroller, Uint16 left
 {
     SDL_Joystick *joystick = SDL_GameControllerGetJoystick(gamecontroller);
 
-    if (!joystick) {
+    if (joystick == NULL) {
         return -1;
     }
     return SDL_JoystickRumbleTriggers(joystick, left_rumble, right_rumble, duration_ms);
@@ -2757,7 +2762,7 @@ SDL_GameControllerHasLED(SDL_GameController *gamecontroller)
 {
     SDL_Joystick *joystick = SDL_GameControllerGetJoystick(gamecontroller);
 
-    if (!joystick) {
+    if (joystick == NULL) {
         return SDL_FALSE;
     }
     return SDL_JoystickHasLED(joystick);
@@ -2768,7 +2773,7 @@ SDL_GameControllerHasRumble(SDL_GameController *gamecontroller)
 {
     SDL_Joystick *joystick = SDL_GameControllerGetJoystick(gamecontroller);
 
-    if (!joystick) {
+    if (joystick == NULL) {
         return SDL_FALSE;
     }
     return SDL_JoystickHasRumble(joystick);
@@ -2779,7 +2784,7 @@ SDL_GameControllerHasRumbleTriggers(SDL_GameController *gamecontroller)
 {
     SDL_Joystick *joystick = SDL_GameControllerGetJoystick(gamecontroller);
 
-    if (!joystick) {
+    if (joystick == NULL) {
         return SDL_FALSE;
     }
     return SDL_JoystickHasRumbleTriggers(joystick);
@@ -2790,7 +2795,7 @@ SDL_GameControllerSetLED(SDL_GameController *gamecontroller, Uint8 red, Uint8 gr
 {
     SDL_Joystick *joystick = SDL_GameControllerGetJoystick(gamecontroller);
 
-    if (!joystick) {
+    if (joystick == NULL) {
         return -1;
     }
     return SDL_JoystickSetLED(joystick, red, green, blue);
@@ -2801,7 +2806,7 @@ SDL_GameControllerSendEffect(SDL_GameController *gamecontroller, const void *dat
 {
     SDL_Joystick *joystick = SDL_GameControllerGetJoystick(gamecontroller);
 
-    if (!joystick) {
+    if (joystick == NULL) {
         return -1;
     }
     return SDL_JoystickSendEffect(joystick, data, size);
@@ -2812,8 +2817,9 @@ SDL_GameControllerClose(SDL_GameController *gamecontroller)
 {
     SDL_GameController *gamecontrollerlist, *gamecontrollerlistprev;
 
-    if (!gamecontroller || gamecontroller->magic != &gamecontroller_magic)
+    if (gamecontroller == NULL || gamecontroller->magic != &gamecontroller_magic) {
         return;
+    }
 
     SDL_LockJoysticks();
 
@@ -2917,7 +2923,7 @@ SDL_PrivateGameControllerAxis(SDL_GameController *gamecontroller, SDL_GameContro
         posted = SDL_PushEvent(&event) == 1;
     }
 #endif /* !SDL_EVENTS_DISABLED */
-    return (posted);
+    return posted;
 }
 
 
@@ -2946,7 +2952,7 @@ SDL_PrivateGameControllerButton(SDL_GameController *gamecontroller, SDL_GameCont
         break;
     default:
         /* Invalid state -- bail */
-        return (0);
+        return 0;
     }
 #endif /* !SDL_EVENTS_DISABLED */
 
@@ -2957,12 +2963,12 @@ SDL_PrivateGameControllerButton(SDL_GameController *gamecontroller, SDL_GameCont
 
             if (gamecontroller->joystick->delayed_guide_button) {
                 /* Skip duplicate press */
-                return (0);
+                return 0;
             }
         } else {
             if (!SDL_TICKS_PASSED(now, gamecontroller->guide_button_down+SDL_MINIMUM_GUIDE_BUTTON_DELAY_MS)) {
                 gamecontroller->joystick->delayed_guide_button = SDL_TRUE;
-                return (0);
+                return 0;
             }
             gamecontroller->joystick->delayed_guide_button = SDL_FALSE;
         }
@@ -2978,7 +2984,7 @@ SDL_PrivateGameControllerButton(SDL_GameController *gamecontroller, SDL_GameCont
         posted = SDL_PushEvent(&event) == 1;
     }
 #endif /* !SDL_EVENTS_DISABLED */
-    return (posted);
+    return posted;
 }
 
 /*
@@ -3013,7 +3019,7 @@ SDL_GameControllerEventState(int state)
         }
         break;
     }
-    return (state);
+    return state;
 #endif /* SDL_EVENTS_DISABLED */
 }
 
diff --git a/src/joystick/SDL_joystick.c b/src/joystick/SDL_joystick.c
index 033929694..009e9a06c 100644
--- a/src/joystick/SDL_joystick.c
+++ b/src/joystick/SDL_joystick.c
@@ -264,7 +264,7 @@ SDL_SetJoystickIDForPlayerIndex(int player_index, SDL_JoystickID instance_id)
 
     if (player_index >= SDL_joystick_player_count) {
         SDL_JoystickID *new_players = (SDL_JoystickID *)SDL_realloc(SDL_joystick_players, (player_index + 1)*sizeof(*SDL_joystick_players));
-        if (!new_players) {
+        if (new_players == NULL) {
             SDL_OutOfMemory();
             return SDL_FALSE;
         }
@@ -316,7 +316,7 @@ SDL_JoystickInit(void)
     int i, status;
 
     /* Create the joystick list lock */
-    if (!SDL_joystick_lock) {
+    if (SDL_joystick_lock == NULL) {
         SDL_joystick_lock = SDL_CreateMutex();
     }
 
@@ -410,7 +410,7 @@ SDL_JoystickPathForIndex(int device_index)
     SDL_UnlockJoysticks();
 
     /* FIXME: Really we should reference count this path so it doesn't go away after unlock */
-    if (!path) {
+    if (path == NULL) {
         SDL_Unsupported();
     }
     return path;
@@ -1389,7 +1389,7 @@ static void UpdateEventsForDeviceRemoval(int device_index, Uint32 type)
     }
 
     events = SDL_small_alloc(SDL_Event, num_events, &isstack);
-    if (!events) {
+    if (events == NULL) {
         return;
     }
 
@@ -1910,10 +1910,10 @@ SDL_CreateJoystickName(Uint16 vendor, Uint16 product, const char *vendor_name, c
         return SDL_strdup(custom_name);
     }
 
-    if (!vendor_name) {
+    if (vendor_name == NULL) {
         vendor_name = "";
     }
-    if (!product_name) {
+    if (product_name == NULL) {
         product_name = "";
     }
 
@@ -1965,7 +1965,7 @@ SDL_CreateJoystickName(Uint16 vendor, Uint16 product, const char *vendor_name, c
         name = SDL_strdup("Controller");
     }
 
-    if (!name) {
+    if (name == NULL) {
         return NULL;
     }
 
@@ -2030,7 +2030,7 @@ SDL_CreateJoystickGUID(Uint16 bus, Uint16 vendor, Uint16 product, Uint16 version
 
     SDL_zero(guid);
 
-    if (!name) {
+    if (name == NULL) {
         name = "";
     }
 
@@ -2220,7 +2220,7 @@ SDL_bool
 SDL_IsJoystickXboxOne(Uint16 vendor_id, Uint16 product_id)
 {
     EControllerType eType = GuessControllerType(vendor_id, product_id);
-    return (eType == k_eControllerType_XBoxOneController);
+    return eType == k_eControllerType_XBoxOneController;
 }
 
 SDL_bool
@@ -2294,71 +2294,68 @@ SDL_bool
 SDL_IsJoystickPS4(Uint16 vendor_id, Uint16 product_id)
 {
     EControllerType eType = GuessControllerType(vendor_id, product_id);
-    return (eType == k_eControllerType_PS4Controller);
+    return eType == k_eControllerType_PS4Controller;
 }
 
 SDL_bool
 SDL_IsJoystickPS5(Uint16 vendor_id, Uint16 product_id)
 {
     EControllerType eType = GuessControllerType(vendor_id, product_id);
-    return (eType == k_eControllerType_PS5Controller);
+    return eType == k_eControllerType_PS5Controller;
 }
 
 SDL_bool
 SDL_IsJoystickNintendoSwitchPro(Uint16 vendor_id, Uint16 product_id)
 {
     EControllerType eType = GuessControllerType(vendor_id, product_id);
-    return (eType == k_eControllerType_SwitchProController ||
-            eType == k_eControllerType_SwitchInputOnlyController);
+    return eType == k_eControllerType_SwitchProController || eType == k_eControllerType_SwitchInputOnlyController;
 }
 
 SDL_bool
 SDL_IsJoystickNintendoSwitchProInputOnly(Uint16 vendor_id, Uint16 product_id)
 {
     EControllerType eType = GuessControllerType(vendor_id, product_id);
-    return (eType == k_eControllerType_SwitchInputOnlyController);
+    return eType == k_eControllerType_SwitchInputOnlyController;
 }
 
 SDL_bool
 SDL_IsJoystickNintendoSwitchJoyCon(Uint16 vendor_id, Uint16 product_id)
 {
     EControllerType eType = GuessControllerType(vendor_id, product_id);
-    return (eType == k_eControllerType_SwitchJoyConLeft ||
-            eType == k_eControllerType_SwitchJoyConRight);
+    return eType == k_eControllerType_SwitchJoyConLeft || eType == k_eControllerType_SwitchJoyConRight;
 }
 
 SDL_bool
 SDL_IsJoystickNintendoSwitchJoyConLeft(Uint16 vendor_id, Uint16 product_id)
 {
     EControllerType eType = GuessControllerType(vendor_id, product_id);
-    return (eType == k_eControllerType_SwitchJoyConLeft);
+    return eType == k_eControllerType_SwitchJoyConLeft;
 }
 
 SDL_bool
 SDL_IsJoystickNintendoSwitchJoyConRight(Uint16 vendor_id, Uint16 product_id)
 {
     EControllerType eType = GuessControllerType(vendor_id, product_id);
-    return (eType == k_eControllerType_SwitchJoyConRight);
+    return eType == k_eControllerType_SwitchJoyConRight;
 }
 
 SDL_bool
 SDL_IsJoystickNintendoSwitchJoyConGrip(Uint16 vendor_id, Uint16 product_id)
 {
-    return (vendor_id == USB_VENDOR_NINTENDO && product_id == USB_PRODUCT_NINTENDO_SWITCH_JOYCON_GRIP);
+    return vendor_id == USB_VENDOR_NINTENDO && product_id == USB_PRODUCT_NINTENDO_SWITCH_JOYCON_GRIP;
 }
 
 SDL_bool
 SDL_IsJoystickNintendoSwitchJoyConPair(Uint16 vendor_id, Uint16 product_id)
 {
-    return (vendor_id == USB_VENDOR_NINTENDO && product_id == USB_PRODUCT_NINTENDO_SWITCH_JOYCON_PAIR);
+    return vendor_id == USB_VENDOR_NINTENDO && product_id == USB_PRODUCT_NINTENDO_SWITCH_JOYCON_PAIR;
 }
 
 SDL_bool
 SDL_IsJoystickSteamController(Uint16 vendor_id, Uint16 product_id)
 {
     EControllerType eType = GuessControllerType(vendor_id, product_id);
-    return (eType == k_eControllerType_SteamController ||
-            eType == k_eControllerType_SteamControllerV2);
+    return eType == k_eControllerType_SteamController || eType == k_eControllerType_SteamControllerV2;
 }
 
 SDL_bool
diff --git a/src/joystick/android/SDL_sysjoystick.c b/src/joystick/android/SDL_sysjoystick.c
index a1c8b8898..fdf5f16fe 100644
--- a/src/joystick/android/SDL_sysjoystick.c
+++ b/src/joystick/android/SDL_sysjoystick.c
@@ -620,7 +620,7 @@ ANDROID_JoystickOpen(SDL_Joystick *joystick, int device_index)
     joystick->nbuttons = item->nbuttons;
     joystick->naxes = item->naxes;
 
-    return (0);
+    return 0;
 }
 
 static int
diff --git a/src/joystick/bsd/SDL_bsdjoystick.c b/src/joystick/bsd/SDL_bsdjoystick.c
index 598505e5f..7049062d5 100644
--- a/src/joystick/bsd/SDL_bsdjoystick.c
+++ b/src/joystick/bsd/SDL_bsdjoystick.c
@@ -321,8 +321,9 @@ CreateHwData(const char *path)
         hw->type = BSDJOY_UHID;
         {
             int ax;
-            for (ax = 0; ax < JOYAXE_count; ax++)
+            for (ax = 0; ax < JOYAXE_count; ax++) {
                 hw->axis_map[ax] = -1;
+            }
         }
         hw->repdesc = hid_get_report_desc(fd);
         if (hw->repdesc == NULL) {
@@ -356,8 +357,9 @@ CreateHwData(const char *path)
             SDL_SetError("%s: Cannot start HID parser", path);
             goto usberr;
         }
-        for (i = 0; i < JOYAXE_count; i++)
+        for (i = 0; i < JOYAXE_count; i++) {
             hw->axis_map[i] = -1;
+        }
 
         while (hid_get_item(hdata, &hitem) > 0) {
             switch (hitem.kind) {
@@ -395,9 +397,11 @@ CreateHwData(const char *path)
             }
         }
         hid_end_parse(hdata);
-        for (i = 0; i < JOYAXE_count; i++)
-            if (hw->axis_map[i] > 0)
+        for (i = 0; i < JOYAXE_count; i++) {
+            if (hw->axis_map[i] > 0) {
                 hw->axis_map[i] = hw->naxes++;
+            }
+        }
 
         if (hw->naxes == 0 && hw->nbuttons == 0 && hw->nhats == 0) {
             SDL_SetError("%s: Not a joystick, ignoring", path);
@@ -447,7 +451,7 @@ MaybeAddDevice(const char *path)
     }
 
     hw = CreateHwData(path);
-    if (!hw) {
+    if (hw == NULL) {
         return -1;
     }
 
@@ -477,7 +481,7 @@ MaybeAddDevice(const char *path)
         }
 #endif /* USB_GET_DEVICEINFO */
     }
-    if (!name) {
+    if (name == NULL) {
         name = SDL_strdup(path);
         guid = SDL_CreateJoystickGUIDForName(name);
     }
@@ -634,7 +638,7 @@ BSD_JoystickOpen(SDL_Joystick *joy, int device_index)
     }
 
     hw = CreateHwData(item->path);
-    if (!hw) {
+    if (hw == NULL) {
         return -1;
     }
 
@@ -739,16 +743,13 @@ BSD_JoystickUpdate(SDL_Joystick *joy)
                         else if (usage == HUG_DPAD_UP) {
                             dpad[0] = (Sint32) hid_get_data(REP_BUF_DATA(rep), &hitem);
                             SDL_PrivateJoystickHat(joy, 0, dpad_to_sdl(dpad));
-                        }
-                        else if (usage == HUG_DPAD_DOWN) {
+                        } else if (usage == HUG_DPAD_DOWN) {
                             dpad[1] = (Sint32) hid_get_data(REP_BUF_DATA(rep), &hitem);
                             SDL_PrivateJoystickHat(joy, 0, dpad_to_sdl(dpad));
-                        }
-                        else if (usage == HUG_DPAD_RIGHT) {
+                        } else if (usage == HUG_DPAD_RIGHT) {
                             dpad[2] = (Sint32) hid_get_data(REP_BUF_DATA(rep), &hitem);
                             SDL_PrivateJoystickHat(joy, 0, dpad_to_sdl(dpad));
-                        }
-                        else if (usage == HUG_DPAD_LEFT) {
+                        } else if (usage == HUG_DPAD_LEFT) {
                             dpad[3] = (Sint32) hid_get_data(REP_BUF_DATA(rep), &hitem);
                             SDL_PrivateJoystickHat(joy, 0, dpad_to_sdl(dpad));
                         }
diff --git a/src/joystick/darwin/SDL_iokitjoystick.c b/src/joystick/darwin/SDL_iokitjoystick.c
index de43c97f3..7b7f9c7ef 100644
--- a/src/joystick/darwin/SDL_iokitjoystick.c
+++ b/src/joystick/darwin/SDL_iokitjoystick.c
@@ -43,7 +43,7 @@ static recDevice *gpDeviceList = NULL;
 
 void FreeRumbleEffectData(FFEFFECT *effect)
 {
-    if (!effect) {
+    if (effect == NULL) {
         return;
     }
     SDL_free(effect->rgdwAxes);
@@ -59,7 +59,7 @@ FFEFFECT *CreateRumbleEffectData(Sint16 magnitude)
 
     /* Create the effect */
     effect = (FFEFFECT *)SDL_calloc(1, sizeof(*effect));
-    if (!effect) {
+    if (effect == NULL) {
         return NULL;
     }
     effect->dwSize = sizeof(*effect);
@@ -83,7 +83,7 @@ FFEFFECT *CreateRumbleEffectData(Sint16 magnitude)
     effect->dwFlags |= FFEFF_CARTESIAN;
 
     periodic = (FFPERIODIC *)SDL_calloc(1, sizeof(*periodic));
-    if (!periodic) {
+    if (periodic == NULL) {
         FreeRumbleEffectData(effect);
         return NULL;
     }
@@ -101,8 +101,9 @@ static recDevice *GetDeviceForIndex(int device_index)
     recDevice *device = gpDeviceList;
     while (device) {
         if (!device->removed) {
-            if (device_index == 0)
+            if (device_index == 0) {
                 break;
+            }
 
             --device_index;
         }
@@ -208,13 +209,10 @@ GetHIDScaledCalibratedState(recDevice * pDevice, recElement * pElement, SInt32 m
     const float deviceScale = max - min;
     const float readScale = pElement->maxReport - pElement->minReport;
     int returnValue = SDL_FALSE;
-    if (GetHIDElementState(pDevice, pElement, pValue))
-    {
+    if (GetHIDElementState(pDevice, pElement, pValue)) {
         if (readScale == 0) {
             returnValue = SDL_TRUE;           /* no scaling at all */
-        }
-        else
-        {
+        } else {
             *pValue = ((*pValue - pElement->minReport) * deviceScale / readScale) + min;
             returnValue = SDL_TRUE;
         }
@@ -547,7 +545,7 @@ JoystickDeviceWasAddedCallback(void *ctx, IOReturn res, void *sender, IOHIDDevic
     }
 
     device = (recDevice *) SDL_calloc(1, sizeof(recDevice));
-    if (!device) {
+    if (device == NULL) {
         SDL_OutOfMemory();
         return;
     }
@@ -580,7 +578,7 @@ JoystickDeviceWasAddedCallback(void *ctx, IOReturn res, void *sender, IOHIDDevic
     }
 
     /* Add device to the end of the list */
-    if ( !gpDeviceList ) {
+    if (gpDeviceList == NULL) {
         gpDeviceList = device;
     } else {
         recDevice *curdevice;
@@ -891,7 +889,7 @@ DARWIN_JoystickRumble(SDL_Joystick *joystick, Uint16 low_frequency_rumble, Uint1
     /* Scale and average the two rumble strengths */
     Sint16 magnitude = (Sint16)(((low_frequency_rumble / 2) + (high_frequency_rumble / 2)) / 2);
     
-    if (!device) {
+    if (device == NULL) {
         return SDL_SetError("Rumble failed, device disconnected");
     }
 
@@ -934,7 +932,7 @@ DARWIN_JoystickGetCapabilities(SDL_Joystick *joystick)
     recDevice *device = joystick->hwdata;
     Uint32 result = 0;
 
-    if (!device) {
+    if (device == NULL) {
         return 0;
     }
 
@@ -971,7 +969,7 @@ DARWIN_JoystickUpdate(SDL_Joystick *joystick)
     SInt32 value, range;
     int i, goodRead = SDL_FALSE;
 
-    if (!device) {
+    if (device == NULL) {
         return;
     }
 
diff --git a/src/joystick/emscripten/SDL_sysjoystick.c b/src/joystick/emscripten/SDL_sysjoystick.c
index c875e991b..389f2f466 100644
--- a/src/joystick/emscripten/SDL_sysjoystick.c
+++ b/src/joystick/emscripten/SDL_sysjoystick.c
@@ -77,11 +77,11 @@ Emscripten_JoyStickConnected(int eventType, const EmscriptenGamepadEvent *gamepa
 
     item->timestamp = gamepadEvent->timestamp;
 
-    for( i = 0; i < item->naxes; i++) {
+    for ( i = 0; i < item->naxes; i++) {
         item->axis[i] = gamepadEvent->axis[i];
     }
 
-    for( i = 0; i < item->nbuttons; i++) {
+    for ( i = 0; i < item->nbuttons; i++) {
         item->analogButton[i] = gamepadEvent->analogButton[i];
         item->digitalButton[i] = gamepadEvent->digitalButton[i];
     }
@@ -199,7 +199,7 @@ EMSCRIPTEN_JoystickInit(void)
 
     /* handle already connected gamepads */
     if (numjs > 0) {
-        for(i = 0; i < numjs; i++) {
+        for (i = 0; i < numjs; i++) {
             retval = emscripten_get_gamepad_status(i, &gamepadState);
             if (retval == EMSCRIPTEN_RESULT_SUCCESS) {
                 Emscripten_JoyStickConnected(EMSCRIPTEN_EVENT_GAMEPADCONNECTED,
@@ -213,7 +213,7 @@ EMSCRIPTEN_JoystickInit(void)
                                                       0,
                                                       Emscripten_JoyStickConnected);
 
-    if(retval != EMSCRIPTEN_RESULT_SUCCESS) {
+    if (retval != EMSCRIPTEN_RESULT_SUCCESS) {
         EMSCRIPTEN_JoystickQuit();
         return SDL_SetError("Could not set gamepad connect callback");
     }
@@ -221,7 +221,7 @@ EMSCRIPTEN_JoystickInit(void)
     retval = emscripten_set_gamepaddisconnected_callback(NULL,
                                                          0,
                                                          Emscripten_JoyStickDisconnected);
-    if(retval != EMSCRIPTEN_RESULT_SUCCESS) {
+    if (retval != EMSCRIPTEN_RESULT_SUCCESS) {
         EMSCRIPTEN_JoystickQuit();
         return SDL_SetError("Could not set gamepad disconnect callback");
     }
@@ -332,7 +332,7 @@ EMSCRIPTEN_JoystickOpen(SDL_Joystick *joystick, int device_index)
     joystick->nbuttons = item->nbuttons;
     joystick->naxes = item->naxes;
 
-    return (0);
+    return 0;
 }
 
 /* Function to update the state of a joystick - called as a device poll.
@@ -351,10 +351,10 @@ EMSCRIPTEN_JoystickUpdate(SDL_Joystick *joystick)
 
     if (item) {
         result = emscripten_get_gamepad_status(item->index, &gamepadState);
-        if( result == EMSCRIPTEN_RESULT_SUCCESS) {
-            if(gamepadState.timestamp == 0 || gamepadState.timestamp != item->timestamp) {
-                for(i = 0; i < item->nbuttons; i++) {
-                    if(item->digitalButton[i] != gamepadState.digitalButton[i]) {
+        if ( result == EMSCRIPTEN_RESULT_SUCCESS) {
+            if (gamepadState.timestamp == 0 || gamepadState.timestamp != item->timestamp) {
+                for (i = 0; i < item->nbuttons; i++) {
+                    if (item->digitalButton[i] != gamepadState.digitalButton[i]) {
                         buttonState = gamepadState.digitalButton[i]? SDL_PRESSED: SDL_RELEASED;
                         SDL_PrivateJoystickButton(item->joystick, i, buttonState);
                     }
@@ -364,8 +364,8 @@ EMSCRIPTEN_JoystickUpdate(SDL_Joystick *joystick)
                     item->digitalButton[i] = gamepadState.digitalButton[i];
                 }
 
-                for(i = 0; i < item->naxes; i++) {
-                    if(item->axis[i] != gamepadState.axis[i]) {
+                for (i = 0; i < item->naxes; i++) {
+                    if (item->axis[i] != gamepadState.axis[i]) {
                         /* do we need to do conversion? */
                         SDL_PrivateJoystickAxis(item->joystick, i,
                                                   (Sint16) (32767.*gamepadState.axis[i]));
diff --git a/src/joystick/haiku/SDL_haikujoystick.cc b/src/joystick/haiku/SDL_haikujoystick.cc
index cacaf7663..0beee319d 100644
--- a/src/joystick/haiku/SDL_haikujoystick.cc
+++ b/src/joystick/haiku/SDL_haikujoystick.cc
@@ -68,8 +68,7 @@ extern "C"
         numjoysticks = 0;
         SDL_memset(SDL_joyport, 0, (sizeof SDL_joyport));
         SDL_memset(SDL_joyname, 0, (sizeof SDL_joyname));
-        for (i = 0; (numjoysticks < MAX_JOYSTICKS) && (i < nports); ++i)
-        {
+        for (i = 0; (numjoysticks < MAX_JOYSTICKS) && (i < nports); ++i) {
             if (joystick.GetDeviceName(i, name) == B_OK) {
                 if (joystick.Open(name) != B_ERROR) {
                       BString stick_name;
diff --git a/src/joystick/hidapi/SDL_hidapi_gamecube.c b/src/joystick/hidapi/SDL_hidapi_gamecube.c
index 4e68f47b0..421932836 100644
--- a/src/joystick/hidapi/SDL_hidapi_gamecube.c
+++ b/src/joystick/hidapi/SDL_hidapi_gamecube.c
@@ -146,7 +146,7 @@ HIDAPI_DriverGameCube_InitDevice(SDL_HIDAPI_Device *device)
 #endif
 
     ctx = (SDL_DriverGameCube_Context *)SDL_calloc(1, sizeof(*ctx));
-    if (!ctx) {
+    if (ctx == NULL) {
         SDL_OutOfMemory();
         return SDL_FALSE;
     }
@@ -258,7 +258,7 @@ HIDAPI_DriverGameCube_HandleJoystickPacket(SDL_HIDAPI_Device *device, SDL_Driver
     }
 
     joystick = SDL_JoystickFromInstanceID(ctx->joysticks[i]);
-    if (!joystick) {
+    if (joystick == NULL) {
         /* Hasn't been opened yet, skip */
         return;
     }
diff --git a/src/joystick/hidapi/SDL_hidapi_luna.c b/src/joystick/hidapi/SDL_hidapi_luna.c
index c9cd2810e..173e0a02d 100644
--- a/src/joystick/hidapi/SDL_hidapi_luna.c
+++ b/src/joystick/hidapi/SDL_hidapi_luna.c
@@ -66,9 +66,7 @@ HIDAPI_DriverLuna_UnregisterHints(SDL_HintCallback callback, void *userdata)
 static SDL_bool
 HIDAPI_DriverLuna_IsEnabled(void)
 {
-    return SDL_GetHintBoolean(SDL_HINT_JOYSTICK_HIDAPI_LUNA,
-               SDL_GetHintBoolean(SDL_HINT_JOYSTICK_HIDAPI,
-                   SDL_HIDAPI_DEFAULT));
+    return SDL_GetHintBoolean(SDL_HINT_JOYSTICK_HIDAPI_LUNA, SDL_GetHintBoolean(SDL_HINT_JOYSTICK_HIDAPI, SDL_HIDAPI_DEFAULT));
 }
 
 static SDL_bool
@@ -83,7 +81,7 @@ HIDAPI_DriverLuna_InitDevice(SDL_HIDAPI_Device *device)
     SDL_DriverLuna_Context *ctx;
 
     ctx = (SDL_DriverLuna_Context *)SDL_calloc(1, sizeof(*ctx));
-    if (!ctx) {
+    if (ctx == NULL) {
         SDL_OutOfMemory();
         return SDL_FALSE;
     }
@@ -289,14 +287,11 @@ HIDAPI_DriverLuna_HandleBluetoothStatePacket(SDL_Joystick *joystick, SDL_DriverL
         int level = data[1] * 100 / 0xFF;
         if (level == 0) {
             SDL_PrivateJoystickBatteryLevel(joystick, SDL_JOYSTICK_POWER_EMPTY);
-        }
-        else if (level <= 20) {
+        } else if (level <= 20) {
             SDL_PrivateJoystickBatteryLevel(joystick, SDL_JOYSTICK_POWER_LOW);
-        }
-        else if (level <= 70) {
+        } else if (level <= 70) {
             SDL_PrivateJoystickBatteryLevel(joystick, SDL_JOYSTICK_POWER_MEDIUM);
-        }
-        else {
+        } else {
             SDL_PrivateJoystickBatteryLevel(joystick, SDL_JOYSTICK_POWER_FULL);
         }
 
@@ -416,7 +411,7 @@ HIDAPI_DriverLuna_UpdateDevice(SDL_HIDAPI_Device *device)
 #ifdef DEBUG_LUNA_PROTOCOL
         HIDAPI_DumpPacket("Amazon Luna packet: size = %d", data, size);
 #endif
-        if (!joystick) {
+        if (joystick == NULL) {
             continue;
         }
 
@@ -434,7 +429,7 @@ HIDAPI_DriverLuna_UpdateDevice(SDL_HIDAPI_Device *device)
         /* Read error, device is disconnected */
         HIDAPI_JoystickDisconnected(device, device->joysticks[0]);
     }
-    return (size >= 0);
+    return size >= 0;
 }
 
 static void
diff --git a/src/joystick/hidapi/SDL_hidapi_ps3.c b/src/joystick/hidapi/SDL_hidapi_ps3.c
index 10e3bc548..f77f91e16 100644
--- a/src/joystick/hidapi/SDL_hidapi_ps3.c
+++ b/src/joystick/hidapi/SDL_hidapi_ps3.c
@@ -145,7 +145,7 @@ HIDAPI_DriverPS3_InitDevice(SDL_HIDAPI_Device *device)
     }
 
     ctx = (SDL_DriverPS3_Context *)SDL_calloc(1, sizeof(*ctx));
-    if (!ctx) {
+    if (ctx == NULL) {
         SDL_OutOfMemory();
         return SDL_FALSE;
     }
@@ -228,7 +228,7 @@ HIDAPI_DriverPS3_SetDevicePlayerIndex(SDL_HIDAPI_Device *device, SDL_JoystickID
 {
     SDL_DriverPS3_Context *ctx = (SDL_DriverPS3_Context *)device->context;
 
-    if (!ctx) {
+    if (ctx == NULL) {
         return;
     }
 
@@ -511,7 +511,7 @@ HIDAPI_DriverPS3_UpdateDevice(SDL_HIDAPI_Device *device)
 #ifdef DEBUG_PS3_PROTOCOL
         HIDAPI_DumpPacket("PS3 packet: size = %d", data, size);
 #endif
-        if (!joystick) {
+        if (joystick == NULL) {
             continue;
         }
 
@@ -553,7 +553,7 @@ HIDAPI_DriverPS3_UpdateDevice(SDL_HIDAPI_Device *device)
         /* Read error, device is disconnected */
         HIDAPI_JoystickDisconnected(device, device->joysticks[0]);
     }
-    return (size >= 0);
+    return size >= 0;
 }
 
 static void
@@ -634,7 +634,7 @@ HIDAPI_DriverPS3ThirdParty_InitDevice(SDL_HIDAPI_Device *device)
     SDL_DriverPS3_Context *ctx;
 
     ctx = (SDL_DriverPS3_Context *)SDL_calloc(1, sizeof(*ctx));
-    if (!ctx) {
+    if (ctx == NULL) {
         SDL_OutOfMemory();
         return SDL_FALSE;
     }
@@ -842,7 +842,7 @@ HIDAPI_DriverPS3ThirdParty_UpdateDevice(SDL_HIDAPI_Device *device)
 #ifdef DEBUG_PS3_PROTOCOL
         HIDAPI_DumpPacket("PS3 packet: size = %d", data, size);
 #endif
-        if (!joystick) {
+        if (joystick == NULL) {
             continue;
         }
 
@@ -859,7 +859,7 @@ HIDAPI_DriverPS3ThirdParty_UpdateDevice(SDL_HIDAPI_Device *device)
         /* Read error, device is disconnected */
         HIDAPI_JoystickDisconnected(device, device->joysticks[0]);
     }
-    return (size >= 0);
+    return size >= 0;
 }
 
 static void
diff --git a/src/joystick/hidapi/SDL_hidapi_ps4.c b/src/joystick/hidapi/SDL_hidapi_ps4.c
index 63d720df5..ee04a9588 100644
--- a/src/joystick/hidapi/SDL_hidapi_ps4.c
+++ b/src/joystick/hidapi/SDL_hidapi_ps4.c
@@ -171,9 +171,7 @@ HIDAPI_DriverPS4_UnregisterHints(SDL_HintCallback callback, void *userdata)
 static SDL_bool
 HIDAPI_DriverPS4_IsEnabled(void)
 {
-    return SDL_GetHintBoolean(SDL_HINT_JOYSTICK_HIDAPI_PS4,
-               SDL_GetHintBoolean(SDL_HINT_JOYSTICK_HIDAPI,
-                   SDL_HIDAPI_DEFAULT));
+    return SDL_GetHintBoolean(SDL_HINT_JOYSTICK_HIDAPI_PS4, SDL_GetHintBoolean(SDL_HINT_JOYSTICK_HIDAPI, SDL_HIDAPI_DEFAULT));
 }
 
 static int ReadFeatureReport(SDL_hid_device *dev, Uint8 report_id, Uint8 *report, size_t length)
@@ -248,7 +246,7 @@ HIDAPI_DriverPS4_InitDevice(SDL_HIDAPI_Device *device)
     SDL_JoystickType joystick_type = SDL_JOYSTICK_TYPE_GAMECONTROLLER;
 
     ctx = (SDL_DriverPS4_Context *)SDL_calloc(1, sizeof(*ctx));
-    if (!ctx) {
+    if (ctx == NULL) {
         SDL_OutOfMemory();
         return SDL_FALSE;
     }
@@ -425,7 +423,7 @@ HIDAPI_DriverPS4_LoadCalibrationData(SDL_HIDAPI_Device *device)
         return;
     }
 
-    for( tries = 0; tries < 5; ++tries ) {
+    for ( tries = 0; tries < 5; ++tries ) {
         /* For Bluetooth controllers, this report switches them into advanced report mode */
         size = ReadFeatureReport(device->dev, k_ePS4FeatureReportIdGyroCalibration_USB, data, sizeof(data));
         if (size < 35) {
@@ -1076,7 +1074,7 @@ HIDAPI_DriverPS4_UpdateDevice(SDL_HIDAPI_Device *device)
         ++packet_count;
         ctx->last_packet = now;
 
-        if (!joystick) {
+        if (joystick == NULL) {
             continue;
         }
 
@@ -1150,7 +1148,7 @@ HIDAPI_DriverPS4_UpdateDevice(SDL_HIDAPI_Device *device)
         /* Read error, device is disconnected */
         HIDAPI_JoystickDisconnected(device, device->joysticks[0]);
     }
-    return (size >= 0);
+    return size >= 0;
 }
 
 static void
diff --git a/src/joystick/hidapi/SDL_hidapi_ps5.c b/src/joystick/hidapi/SDL_hidapi_ps5.c
index 7458adaf4..69535fd5c 100644
--- a/src/joystick/hidapi/SDL_hidapi_ps5.c
+++ b/src/joystick/hidapi/SDL_hidapi_ps5.c
@@ -254,9 +254,7 @@ HIDAPI_DriverPS5_UnregisterHints(SDL_HintCallback callback, void *userdata)
 static SDL_bool
 HIDAPI_DriverPS5_IsEnabled(void)
 {
-    return SDL_GetHintBoolean(SDL_HINT_JOYSTICK_HIDAPI_PS5,
-               SDL_GetHintBoolean(SDL_HINT_JOYSTICK_HIDAPI,
-                   SDL_HIDAPI_DEFAULT));
+    return SDL_GetHintBoolean(SDL_HINT_JOYSTICK_HIDAPI_PS5, SDL_GetHintBoolean(SDL_HINT_JOYSTICK_HIDAPI, SDL_HIDAPI_DEFAULT));
 }
 
 static int ReadFeatureReport(SDL_hid_device *dev, Uint8 report_id, Uint8 *report, size_t length)
@@ -349,7 +347,7 @@ HIDAPI_DriverPS5_InitDevice(SDL_HIDAPI_Device *device)
     SDL_JoystickType joystick_type = SDL_JOYSTICK_TYPE_GAMECONTROLLER;
 
     ctx = (SDL_DriverPS5_Context *)SDL_calloc(1, sizeof(*ctx));
-    if (!ctx) {
+    if (ctx == NULL) {
         SDL_OutOfMemory();
         return SDL_FALSE;
     }
@@ -1354,7 +1352,7 @@ HIDAPI_DriverPS5_UpdateDevice(SDL_HIDAPI_Device *device)
         ++packet_count;
         ctx->last_packet = now;
 
-        if (!joystick) {
+        if (joystick == NULL) {
             continue;
         }
 
@@ -1414,7 +1412,7 @@ HIDAPI_DriverPS5_UpdateDevice(SDL_HIDAPI_Device *device)
         /* Read error, device is disconnected */
         HIDAPI_JoystickDisconnected(device, device->joysticks[0]);
     }
-    return (size >= 0);
+    return size >= 0;
 }
 
 static void
diff --git a/src/joystick/hidapi/SDL_hidapi_rumble.c b/src/joystick/hidapi/SDL_hidapi_rumble.c
index e15ecf052..c4112459e 100644
--- a/src/joystick/hidapi/SDL_hidapi_rumble.c
+++ b/src/joystick/hidapi/SDL_hidapi_rumble.c
@@ -215,7 +215,7 @@ int SDL_HIDAPI_SendRumbleWithCallbackAndUnlock(SDL_HIDAPI_Device *device, const
     }
 
     request = (SDL_HIDAPI_RumbleRequest *)SDL_calloc(1, sizeof(*request));
-    if (!request) {
+    if (request == NULL) {
         SDL_HIDAPI_UnlockRumble();
         return SDL_OutOfMemory();
     }
diff --git a/src/joystick/hidapi/SDL_hidapi_shield.c b/src/joystick/hidapi/SDL_hidapi_shield.c
index 4fe00901c..a4dcdbd01 100644
--- a/src/joystick/hidapi/SDL_hidapi_shield.c
+++ b/src/joystick/hidapi/SDL_hidapi_shield.c
@@ -107,9 +107,7 @@ HIDAPI_DriverShield_UnregisterHints(SDL_HintCallback callback, void *userdata)
 static SDL_bool
 HIDAPI_DriverShield_IsEnabled(void)
 {
-    return SDL_GetHintBoolean(SDL_HINT_JOYSTICK_HIDAPI_SHIELD,
-               SDL_GetHintBoolean(SDL_HINT_JOYSTICK_HIDAPI,
-                   SDL_HIDAPI_DEFAULT));
+    return SDL_GetHintBoolean(SDL_HINT_JOYSTICK_HIDAPI_SHIELD, SDL_GetHintBoolean(SDL_HINT_JOYSTICK_HIDAPI, SDL_HIDAPI_DEFAULT));
 }
 
 static SDL_bool
@@ -124,7 +122,7 @@ HIDAPI_DriverShield_InitDevice(SDL_HIDAPI_Device *device)
     SDL_DriverShield_Context *ctx;
 
     ctx = (SDL_DriverShield_Context *)SDL_calloc(1, sizeof(*ctx));
-    if (!ctx) {
+    if (ctx == NULL) {
         SDL_OutOfMemory();
         return SDL_FALSE;
     }
@@ -508,7 +506,7 @@ HIDAPI_DriverShield_UpdateDevice(SDL_HIDAPI_Device *device)
         /* Byte 0 is HID report ID */
         switch (data[0]) {
             case k_ShieldReportIdControllerState:
-                if (!joystick) {
+                if (joystick == NULL) {
                     break;
                 }
                 if (size == 16) {
@@ -518,7 +516,7 @@ HIDAPI_DriverShield_UpdateDevice(SDL_HIDAPI_Device *device)
                 }
                 break;
             case k_ShieldReportIdControllerTouch:
-                if (!joystick) {
+                if (joystick == NULL) {
                     break;
                 }
                 HIDAPI_DriverShield_HandleTouchPacketV103(joystick, ctx, data, size);
@@ -582,7 +580,7 @@ HIDAPI_DriverShield_UpdateDevice(SDL_HIDAPI_Device *device)
         /* Read error, device is disconnected */
         HIDAPI_JoystickDisconnected(device, device->joysticks[0]);
     }
-    return (size >= 0);
+    return size >= 0;
 }
 
 static void
diff --git a/src/joystick/hidapi/SDL_hidapi_stadia.c b/src/joystick/hidapi/SDL_hidapi_stadia.c
index a6d54b2a5..6c6d0d5cc 100644
--- a/src/joystick/hidapi/SDL_hidapi_stadia.c
+++ b/src/joystick/hidapi/SDL_hidapi_stadia.c
@@ -62,9 +62,7 @@ HIDAPI_DriverStadia_UnregisterHints(SDL_HintCallback callback, void *userdata)
 static SDL_bool
 HIDAPI_DriverStadia_IsEnabled(void)
 {
-    return SDL_GetHintBoolean(SDL_HINT_JOYSTICK_HIDAPI_STADIA,
-               SDL_GetHintBoolean(SDL_HINT_JOYSTICK_HIDAPI,
-                   SDL_HIDAPI_DEFAULT));
+    return SDL_GetHintBoolean(SDL_HINT_JOYSTICK_HIDAPI_STADIA, SDL_GetHintBoolean(SDL_HINT_JOYSTICK_HIDAPI, SDL_HIDAPI_DEFAULT));
 }
 
 static SDL_bool
@@ -79,7 +77,7 @@ HIDAPI_DriverStadia_InitDevice(SDL_HIDAPI_Device *device)
     SDL_DriverStadia_Context *ctx;
 
     ctx = (SDL_DriverStadia_Context *)SDL_calloc(1, sizeof(*ctx));
-    if (!ctx) {
+    if (ctx == NULL) {
         SDL_OutOfMemory();
         return SDL_FALSE;
     }
@@ -283,7 +281,7 @@ HIDAPI_DriverStadia_UpdateDevice(SDL_HIDAPI_Device *device)
 #ifdef DEBUG_STADIA_PROTOCOL
         HIDAPI_DumpPacket("Google Stadia packet: size = %d", data, size);
 #endif
-        if (!joystick) {
+        if (joystick == NULL) {
             continue;
         }
 
@@ -294,7 +292,7 @@ HIDAPI_DriverStadia_UpdateDevice(SDL_HIDAPI_Device *device)
         /* Read error, device is disconnected */
         HIDAPI_JoystickDisconnected(device, device->joysticks[0]);
     }
-    return (size >= 0);
+    return size >= 0;
 }
 
 static void
diff --git a/src/joystick/hidapi/SDL_hidapi_steam.c b/src/joystick/hidapi/SDL_hidapi_steam.c
index 9221d12e8..23d3b8c43 100644
--- a/src/joystick/hidapi/SDL_hidapi_steam.c
+++ b/src/joystick/hidapi/SDL_hidapi_steam.c
@@ -203,8 +203,9 @@ static uint8_t GetSegmentHeader( int nSegmentNumber, bool bLastPacket )
 {
     uint8_t header = REPORT_SEGMENT_DATA_FLAG;
     header |= nSegmentNumber;
-    if ( bLastPacket )
+    if (bLastPacket) {
         header |= REPORT_SEGMENT_LAST_FLAG;
+    }
     
     return header;
 }
@@ -212,8 +213,9 @@ static uint8_t GetSegmentHeader( int nSegmentNumber, bool bLastPacket )
 static void hexdump( const uint8_t *ptr, int len )
 {
     int i;
-    for ( i = 0; i < len ; ++i )
+    for (i = 0; i < len; ++i) {
         printf("%02x ", ptr[i]);
+    }
     printf("\n");
 }
 
@@ -236,21 +238,18 @@ static void InitializeSteamControllerPacketAssembler( SteamControllerPacketAssem
 //     Complete packet size on completion
 static int WriteSegmentToSteamControllerPacketAssembler( SteamControllerPacketAssembler *pAssembler, const uint8_t *pSegment, int nSegmentLength )
 {
-    if ( pAssembler->bIsBle )
-    {
+    if ( pAssembler->bIsBle ) {
         uint8_t uSegmentHeader = pSegment[ 1 ];
         int nSegmentNumber = uSegmentHeader & 0x07;
 
         HEXDUMP( pSegment, nSegmentLength );
 
-        if ( pSegment[ 0 ] != BLE_REPORT_NUMBER )
-        {
+        if ( pSegment[ 0 ] != BLE_REPORT_NUMBER ) {
             // We may get keyboard/mouse input events until controller stops sending them
             return 0;
         }
         
-        if ( nSegmentLength != MAX_REPORT_SEGMENT_SIZE )
-        {
+        if ( nSegmentLength != MAX_REPORT_SEGMENT_SIZE ) {
             printf( "Bad segment size! %d\n", (int)nSegmentLength );
             hexdump( pSegment, nSegmentLength );
             ResetSteamControllerPacketAssembler( pAssembler );
@@ -259,18 +258,15 @@ static int WriteSegmentToSteamControllerPacketAssembler( SteamControllerPacketAs
         
         DPRINTF("GOT PACKET HEADER = 0x%x\n", uSegmentHeader);
         
-        if ( ( uSegmentHeader & REPORT_SEGMENT_DATA_FLAG ) == 0 )
-        {
+        if ( ( uSegmentHeader & REPORT_SEGMENT_DATA_FLAG ) == 0 ) {
             // We get empty segments, just ignore them
             return 0;
         }
         
-        if ( nSegmentNumber != pAssembler->nExpectedSegmentNumber )
-        {
+        if ( nSegmentNumber != pAssembler->nExpectedSegmentNumber ) {
             ResetSteamControllerPacketAssembler( pAssembler );
             
-            if ( nSegmentNumber )
-            {
+            if ( nSegmentNumber ) {
                 // This happens occasionally
                 DPRINTF("Bad segment number, got %d, expected %d\n",
                     nSegmentNumber, pAssembler->nExpectedSegmentNumber );
@@ -282,16 +278,13 @@ static int WriteSegmentToSteamControllerPacketAssembler( SteamControllerPacketAs
                pSegment + 2, // ignore header and report number
                MAX_REPORT_SEGMENT_PAYLOAD_SIZE );
         
-        if ( uSegmentHeader & REPORT_SEGMENT_LAST_FLAG )
-        {
+        if ( uSegmentHeader & REPORT_SEGMENT_LAST_FLAG ) {
             pAssembler->nExpectedSegmentNumber = 0;
             return ( nSegmentNumber + 1 ) * MAX_REPORT_SEGMENT_PAYLOAD_SIZE;
         }
         
         pAssembler->nExpectedSegmentNumber++;
-    }
-    else
-    {
+    } else {
         // Just pass through
         SDL_memcpy( pAssembler->uBuffer,
                pSegment,
@@ -311,20 +304,19 @@ static int SetFeatureReport( SDL_hid_device *dev, unsigned char uBuffer[65], int
     
     DPRINTF("SetFeatureReport %p %p %d\n", dev, uBuffer, nActualDataLen);
 
-    if ( bBle )
-    {
+    if ( bBle ) {
         int nSegmentNumber = 0;
         uint8_t uPacketBuffer[ MAX_REPORT_SEGMENT_SIZE ];
         unsigned char *pBufferPtr = uBuffer + 1;
 
-        if ( nActualDataLen < 1 )
+        if (nActualDataLen < 1) {
             return -1;
+        }
         
         // Skip report number in data
         nActualDataLen--;
         
-        while ( nActualDataLen > 0 )
-        {
+        while ( nActualDataLen > 0 ) {
             int nBytesInPacket = nActualDataLen > MAX_REPORT_SEGMENT_PAYLOAD_SIZE ? MAX_REPORT_SEGMENT_PAYLOAD_SIZE : nActualDataLen;
             
             nActualDataLen -= nBytesInPacket;
@@ -353,8 +345,7 @@ static int GetFeatureReport( SDL_hid_device *dev, unsigned char uBuffer[65] )
 
     DPRINTF("GetFeatureReport( %p %p )\n", dev, uBuffer );
 
-    if ( bBle )
-    {
+    if ( bBle ) {
         int nRetries = 0;
         uint8_t uSegmentBuffer[ MAX_REPORT_SEGMENT_SIZE + 1 ];
         uint8_t ucBytesToRead = MAX_REPORT_SEGMENT_SIZE;
@@ -371,8 +362,7 @@ static int GetFeatureReport( SDL_hid_device *dev, unsigned char uBuffer[65] )
         ++ucDataStartOffset;
 #endif
 
-        while( nRetries < BLE_MAX_READ_RETRIES )
-        {
+        while ( nRetries < BLE_MAX_READ_RETRIES ) {
             SDL_memset( uSegmentBuffer, 0, sizeof( uSegmentBuffer ) );
             uSegmentBuffer[ 0 ] = BLE_REPORT_NUMBER;
             nRet = SDL_hid_get_feature_report( dev, uSegmentBuffer, ucBytesToRead );
@@ -386,14 +376,12 @@ static int GetFeatureReport( SDL_hid_device *dev, unsigned char uBuffer[65] )
             else
                 nRetries++;
 
-            if ( nRet > 0 )
-            {
+            if ( nRet > 0 ) {
                 int nPacketLength = WriteSegmentToSteamControllerPacketAssembler( &assembler,
                                                                                  uSegmentBuffer + ucDataStartOffset,
                                                                                  nRet - ucDataStartOffset );
                 
-                if ( nPacketLength > 0 && nPacketLength < 65 )
-                {
+                if ( nPacketLength > 0 && nPacketLength < 65 ) {
                     // Leave space for "report number"
                     uBuffer[ 0 ] = 0;
                     SDL_memcpy( uBuffer + 1, assembler.uBuffer, nPacketLength );
@@ -416,14 +404,16 @@ static int ReadResponse( SDL_hid_device *dev, uint8_t uBuffer[65], int nExpected
 
     DPRINTF("ReadResponse( %p %p %d )\n", dev, uBuffer, nExpectedResponse );
 
-    if ( nRet < 0 )
+    if (nRet < 0) {
         return nRet;
+    }
     
     DPRINTF("ReadResponse got %d bytes of data: ", nRet );
     HEXDUMP( uBuffer, nRet );
     
-    if ( uBuffer[1] != nExpectedResponse )
+    if (uBuffer[1] != nExpectedResponse) {
         return -1;
+    }
     
     return nRet;
 }
@@ -447,35 +437,34 @@ static bool ResetSteamController( SDL_hid_device *dev, bool bSuppressErrorSpew,
     buf[0] = 0;
     buf[1] = ID_GET_ATTRIBUTES_VALUES;
     res = SetFeatureReport( dev, buf, 2 );
-    if ( res < 0 )
-    {
-        if ( !bSuppressErrorSpew )
-            printf( "GET_ATTRIBUTES_VALUES failed for controller %p\n", dev );
+    if ( res < 0 ) {
+        if (!bSuppressErrorSpew) {
+            printf("GET_ATTRIBUTES_VALUES failed for controller %p\n", dev);
+        }
         return false;
     }
     
     // Retrieve GET_ATTRIBUTES_VALUES result
     // Wireless controller endpoints without a connected controller will return nAttrs == 0
     res = ReadResponse( dev, buf, ID_GET_ATTRIBUTES_VALUES );
-    if ( res < 0 || buf[1] != ID_GET_ATTRIBUTES_VALUES )
-    {
+    if ( res < 0 || buf[1] != ID_GET_ATTRIBUTES_VALUES ) {
         HEXDUMP(buf, res);
-        if ( !bSuppressErrorSpew )
-            printf( "Bad GET_ATTRIBUTES_VALUES response for controller %p\n", dev );
+        if (!bSuppressErrorSpew) {
+            printf("Bad GET_ATTRIBUTES_VALUES response for controller %p\n", dev);
+        }
         return false;
     }
     
     nAttributesLength = buf[ 2 ];
-    if ( nAttributesLength > res )
-    {
-        if ( !bSuppressErrorSpew )
-            printf( "Bad GET_ATTRIBUTES_VALUES response for controller %p\n", dev );
+    if ( nAttributesLength > res ) {
+        if (!bSuppressErrorSpew) {
+            printf("Bad GET_ATTRIBUTES_VALUES response for controller %p\n", dev);
+        }
         return false;
     }
 
     msg = (FeatureReportMsg *)&buf[1];
-    for ( i = 0; i < (int)msg->header.length / sizeof( ControllerAttribute ); ++i )
-    {
+    for ( i = 0; i < (int)msg->header.length / sizeof( ControllerAttribute ); ++i ) {
         uint8_t unAttribute = msg->payload.getAttributes.attributes[i].attributeTag;
         uint32_t unValue = msg->payload.getAttributes.attributes[i].attributeValue;
 
@@ -494,8 +483,7 @@ static bool ResetSteamController( SDL_hid_device *dev, bool bSuppressErrorSpew,
             break;
         }
     }
-    if ( punUpdateRateUS )
-    {
+    if ( punUpdateRateUS ) {
         *punUpdateRateUS = unUpdateRateUS;
     }
 
@@ -503,10 +491,10 @@ static bool ResetSteamController( SDL_hid_device *dev, bool bSuppressErrorSpew,
     buf[0] = 0;
     buf[1] = ID_CLEAR_DIGITAL_MAPPINGS;
     res = SetFeatureReport( dev, buf, 2 );
-    if ( res < 0 )
-    {
-        if ( !bSuppressErrorSpew )
-            printf( "CLEAR_DIGITAL_MAPPINGS failed for controller %p\n", dev );
+    if ( res < 0 ) {
+        if (!bSuppressErrorSpew) {
+            printf("CLEAR_DIGITAL_MAPPINGS failed for controller %p\n", dev);
+        }
         return false;
     }
     
@@ -515,10 +503,10 @@ static bool ResetSteamController( SDL_hid_device *dev, bool bSuppressErrorSpew,
     buf[1] = ID_LOAD_DEFAULT_SETTINGS;
     buf[2] = 0;
     res = SetFeatureReport( dev, buf, 3 );
-    if ( res < 0 )
-    {
-        if ( !bSuppressErrorSpew )
-            printf( "LOAD_DEFAULT_SETTINGS failed for controller %p\n", dev );
+    if ( res < 0 ) {
+        if (!bSuppressErrorSpew) {
+            printf("LOAD_DEFAULT_SETTINGS failed for controller %p\n", dev);
+        }
         return false;
     }
     
@@ -545,10 +533,10 @@ buf[3+nSettings*3+2] = ((uint16_t)VALUE)>>8; \
     buf[2] = nSettings*3;
     
     res = SetFeatureReport( dev, buf, 3+nSettings*3 );
-    if ( res < 0 )
-    {
-        if ( !bSuppressErrorSpew )
-            printf( "SET_SETTINGS failed for controller %p\n", dev );
+    if ( res < 0 ) {
+        if (!bSuppressErrorSpew) {
+            printf("SET_SETTINGS failed for controller %p\n", dev);
+        }
         return false;
     }
     
@@ -556,37 +544,32 @@ buf[3+nSettings*3+2] = ((uint16_t)VALUE)>>8; \
     // Wait for ID_CLEAR_DIGITAL_MAPPINGS to be processed on the controller
     bool bMappingsCleared = false;
     int iRetry;
-    for ( iRetry = 0; iRetry < 2; ++iRetry )
-    {
+    for ( iRetry = 0; iRetry < 2; ++iRetry ) {
         SDL_memset( buf, 0, 65 );
         buf[1] = ID_GET_DIGITAL_MAPPINGS;
         buf[2] = 1; // one byte - requesting from index 0
         buf[3] = 0;
         res = SetFeatureReport( dev, buf, 4 );
-        if ( res < 0 )
-        {
+        if ( res < 0 ) {
             printf( "GET_DIGITAL_MAPPINGS failed for controller %p\n", dev );
             return false;
         }
         
         res = ReadResponse( dev, buf, ID_GET_DIGITAL_MAPPINGS );
-        if ( res < 0 || buf[1] != ID_GET_DIGITAL_MAPPINGS )
-        {
+        if ( res < 0 || buf[1] != ID_GET_DIGITAL_MAPPINGS ) {
             printf( "Bad GET_DIGITAL_MAPPINGS response for controller %p\n", dev );
             return false;
         }
         
         // If the length of the digital mappings result is not 1 (index byte, no mappings) then clearing hasn't executed
-        if ( buf[2] == 1 && buf[3] == 0xFF )
-        {
+        if ( buf[2] == 1 && buf[3] == 0xFF ) {
             bMappingsCleared = true;
             break;
         }
         usleep( CONTROLLER_CONFIGURATION_DELAY_US );
     }
     
-    if ( !bMappingsCleared && !bSuppressErrorSpew )
-    {
+    if ( !bMappingsCleared && !bSuppressErrorSpew ) {
         printf( "Warning: CLEAR_DIGITAL_MAPPINGS never completed for controller %p\n", dev );
     }
     
@@ -602,10 +585,10 @@ buf[3+nSettings*3+2] = ((uint16_t)VALUE)>>8; \
     buf[8] = MOUSE_BTN_RIGHT;
     
     res = SetFeatureReport( dev, buf, 9 );
-    if ( res < 0 )
-    {
-        if ( !bSuppressErrorSpew )
-            printf( "SET_DIGITAL_MAPPINGS failed for controller %p\n", dev );
+    if ( res < 0 ) {
+        if (!bSuppressErrorSpew) {
+            printf("SET_DIGITAL_MAPPINGS failed for controller %p\n", dev);
+        }
         return false;
     }
 #endif // ENABLE_MOUSE_MODE
@@ -659,12 +642,9 @@ static void CloseSteamController( SDL_hid_device *dev )
 //---------------------------------------------------------------------------
 static float RemapValClamped( float val, float A, float B, float C, float D)
 {
-    if ( A == B )
-    {
+    if ( A == B ) {
         return ( val - B ) >= 0.0f ? D : C;
-    }
-    else
-    {
+    } else {
         float cVal = (val - A) / (B - A);
         cVal = clamp( cVal, 0.0f, 1.0f );
 
@@ -717,65 +697,52 @@ static void FormatStatePacketUntilGyro( SteamControllerStateInternal_t *pState,
     pState->ulButtons &= ~0xFFFF000000LL;
 
     // The firmware uses this bit to tell us what kind of data is packed into the left two axises
-    if (pStatePacket->ButtonTriggerData.ulButtons & STEAM_LEFTPAD_FINGERDOWN_MASK)
-    {
+    if (pStatePacket->ButtonTriggerData.ulButtons & STEAM_LEFTPAD_FINGERDOWN_MASK) {
         // Finger-down bit not set; "left pad" is actually trackpad
         pState->sLeftPadX = pState->sPrevLeftPad[0] = pStatePacket->sLeftPadX;
         pState->sLeftPadY = pState->sPrevLeftPad[1] = pStatePacket->sLeftPadY;
 
-        if (pStatePacket->ButtonTriggerData.ulButtons & STEAM_LEFTPAD_AND_JOYSTICK_MASK)
-        {
+        if (pStatePacket->ButtonTriggerData.ulButtons & STEAM_LEFTPAD_AND_JOYSTICK_MASK) {
             // The controller is interleaving both stick and pad data, both are active
             pState->sLeftStickX = pState->sPrevLeftStick[0];
             pState->sLeftStickY = pState->sPrevLeftStick[1];
-        }
-        else
-        {
+        } else {
             // The stick is not active
             pState->sPrevLeftStick[0] = 0;
             pState->sPrevLeftStick[1] = 0;
         }
-    }
-    else
-    {
+    } else {
         // Finger-down bit not set; "left pad" is actually joystick
 
         // XXX there's a firmware bug where sometimes padX is 0 and padY is a large number (acutally the battery voltage)
         // If that happens skip this packet and report last frames stick
 /*
-        if ( m_eControllerType == k_eControllerType_SteamControllerV2 && pStatePacket->sLeftPadY > 900 )
-        {
+        if ( m_eControllerType == k_eControllerType_SteamControllerV2 && pStatePacket->sLeftPadY > 900 ) {
             pState->sLeftStickX = pState->sPrevLeftStick[0];
             pState->sLeftStickY = pState->sPrevLeftStick[1];
-        }
-        else
+        } else
 */
         {
             pState->sPrevLeftStick[0] = pState->sLeftStickX = pStatePacket->sLeftPadX;
             pState->sPrevLeftStick[1] = pState->sLeftStickY = pStatePacket->sLeftPadY;
         }
 /*
-        if (m_eControllerType == k_eControllerType_SteamControllerV2)
-        {
+        if (m_eControllerType == k_eControllerType_SteamControllerV2) {
             UpdateV2JoystickCap(&state);
         }
 */
 
-        if (pStatePacket->ButtonTriggerData.ulButtons & STEAM_LEFTPAD_AND_JOYSTICK_MASK)
-        {
+        if (pStatePacket->ButtonTriggerData.ulButtons & STEAM_LEFTPAD_AND_JOYSTICK_MASK) {
             // The controller is interleaving both stick and pad data, both are active
             pState->sLeftPadX = pState->sPrevLeftPad[0];
             pState->sLeftPadY = pState->sPrevLeftPad[1];
-        }
-        else
-        {
+        } else {
             // The trackpad is not active
             pState->sPrevLeftPad[0] = 0;
             pState->sPrevLeftPad[1] = 0;
 
             // Old controllers send trackpad click for joystick button when trackpad is not active
-            if (pState->ulButtons & STEAM_BUTTON_LEFTPAD_CLICKED_MASK)
-            {
+            if (pState->ulButtons & STEAM_BUTTON_LEFTPAD_CLICKED_MASK) {
                 pState->ulButtons &= ~STEAM_BUTTON_LEFTPAD_CLICKED_MASK;
                 pState->ulButtons |= STEAM_JOYSTICK_BUTTON_MASK;
             }
@@ -784,8 +751,9 @@ static void FormatStatePacketUntilGyro( SteamControllerStateInternal_t *pState,
 
     // Fingerdown bit indicates if the packed left axis data was joystick or pad,
     // but if we are interleaving both, the left finger is definitely on the pad.
-    if (pStatePacket->ButtonTriggerData.ulButtons & STEAM_LEFTPAD_AND_JOYSTICK_MASK)
+    if (pStatePacket->ButtonTriggerData.ulButtons & STEAM_LEFTPAD_AND_JOYSTICK_MASK) {
         pState->ulButtons |= STEAM_LEFTPAD_FINGERDOWN_MASK;
+    }
 
     pState->sRightPadX = pStatePacket->sRightPadX;
     pState->sRightPadY = pStatePacket->sRightPadY;
@@ -831,35 +799,30 @@ static bool UpdateBLESteamControllerState( const uint8_t *pData, int nDataSize,
     pState->unPacketNum++;
     ucOptionDataMask = ( *pData++ & 0xF0 );
     ucOptionDataMask |= (uint32_t)(*pData++) << 8;
-    if ( ucOptionDataMask & k_EBLEButtonChunk1 )
-    {
+    if ( ucOptionDataMask & k_EBLEButtonChunk1 ) {
         SDL_memcpy( &pState->ulButtons, pData, 3 );
         pData += 3;
     }
-    if ( ucOptionDataMask & k_EBLEButtonChunk2 )
-    {
+    if ( ucOptionDataMask & k_EBLEButtonChunk2 ) {
         // The middle 2 bytes of the button bits over the wire are triggers when over the wire and non-SC buttons in the internal controller state packet
         pState->sTriggerL = (unsigned short)RemapValClamped( (float)(( pData[ 0 ] << 7 ) | pData[ 0 ]), 0, STEAMCONTROLLER_TRIGGER_MAX_ANALOG, 0, SDL_MAX_SINT16 );
         pState->sTriggerR = (unsigned short)RemapValClamped( (float)(( pData[ 1 ] << 7 ) | pData[ 1 ]), 0, STEAMCONTROLLER_TRIGGER_MAX_ANALOG, 0, SDL_MAX_SINT16 );
         pData += 2;
     }
-    if ( ucOptionDataMask & k_EBLEButtonChunk3 )
-    {
+    if ( ucOptionDataMask & k_EBLEButtonChunk3 ) {
         uint8_t *pButtonByte = (uint8_t *)&pState->ulButtons;
         pButtonByte[ 5 ] = *pData++;
         pButtonByte[ 6 ] = *pData++;
         pButtonByte[ 7 ] = *pData++;
     }
-    if ( ucOptionDataMask & k_EBLELeftJoystickChunk )
-    {
+    if ( ucOptionDataMask & k_EBLELeftJoystickChunk ) {
         // This doesn't handle any of the special headcrab stuff for raw joystick which is OK for now since that FW doesn't support
         // this protocol yet either
         int nLength = sizeof( pState->sLeftStickX ) + sizeof( pState->sLeftStickY );
         SDL_memcpy( &pState->sLeftStickX, pData, nLength );
         pData += nLength;
     }
-    if ( ucOptionDataMask & k_EBLELeftTrackpadChunk )
-    {
+    if ( ucOptionDataMask & k_EBLELeftTrackpadChunk ) {
         int nLength = sizeof( pState->sLeftPadX ) + sizeof( pState->sLeftPadY );
         int nPadOffset;
         SDL_memcpy( &pState->sLeftPadX, pData, nLength );
@@ -873,8 +836,7 @@ static bool UpdateBLESteamControllerState( const uint8_t *pData, int nDataSize,
         pState->sLeftPadY = clamp( pState->sLeftPadY + nPadOffset, SDL_MIN_SINT16, SDL_MAX_SINT16 );
         pData += nLength;
     }
-    if ( ucOptionDataMask & k_EBLERightTrackpadChunk )
-    {
+    if ( ucOptionDataMask & k_EBLERightTrackpadChunk ) {
         int nLength = sizeof( pState->sRightPadX ) + sizeof( pState->sRightPadY );
         int nPadOffset = 0;
 
@@ -890,20 +852,17 @@ static bool UpdateBLESteamControllerState( const uint8_t *pData, int nDataSize,
         pState->sRightPadY = clamp( pState->sRightPadY + nPadOffset, SDL_MIN_SINT16, SDL_MAX_SINT16 );
         pData += nLength;
     }
-    if ( ucOptionDataMask & k_EBLEIMUAccelChunk )
-    {
+    if ( ucOptionDataMask & k_EBLEIMUAccelChunk ) {
         int nLength = sizeof( pState->sAccelX ) + sizeof( pState->sAccelY ) + sizeof( pState->sAccelZ );
         SDL_memcpy( &pState->sAccelX, pData, nLength );
         pData += nLength;
     }
-    if ( ucOptionDataMask & k_EBLEIMUGyroChunk )
-    {
+    if ( ucOptionDataMask & k_EBLEIMUGyroChunk ) {
         int nLength = sizeof( pState->sAccelX ) + sizeof( pState->sAccelY ) + sizeof( pState->sAccelZ );
         SDL_memcpy( &pState->sGyroX, pData, nLength );
         pData += nLength;
     }
-    if ( ucOptionDataMask & k_EBLEIMUQuatChunk )
-    {
+    if ( ucOptionDataMask & k_EBLEIMUQuatChunk ) {
         int nLength = sizeof( pState->sGyroQuatW ) + sizeof( pState->sGyroQuatX ) + sizeof( pState->sGyroQuatY ) + sizeof( pState->sGyroQuatZ );
         SDL_memcpy( &pState->sGyroQuatW, pData, nLength );
         pData += nLength;
@@ -919,10 +878,8 @@ static bool UpdateSteamControllerState( const uint8_t *pData, int nDataSize, Ste
 {
     ValveInReport_t *pInReport = (ValveInReport_t*)pData;
 
-    if ( pInReport->header.unReportVersion != k_ValveInReportMsgVersion )
-    {
-        if ( ( pData[ 0 ] & 0x0F ) == k_EBLEReportState )
-        {
+    if ( pInReport->header.unReportVersion != k_ValveInReportMsgVersion ) {
+        if ( ( pData[ 0 ] & 0x0F ) == k_EBLEReportState ) {
             return UpdateBLESteamControllerState( pData, nDataSize, pState );
         }
         return false;
@@ -934,13 +891,13 @@ static bool UpdateSteamControllerState( const uint8_t *pData, int nDataSize, Ste
         return false;
     }
 
-    if ( pInReport->header.ucType == ID_CONTROLLER_STATE )
-    {
+    if ( pInReport->header.ucType == ID_CONTROLLER_STATE ) {
         ValveControllerStatePacket_t *pStatePacket = &pInReport->payload.controllerState;
 
         // No new data to process; indicate that we received a state packet, but otherwise do nothing.
-        if ( pState->unPacketNum == pStatePacket->unPacketNum )
+        if (pState->unPacketNum == pStatePacket->unPacketNum) {
             return true;
+        }
 
         FormatStatePacketUntilGyro( pState, pStatePacket );
 
@@ -957,15 +914,14 @@ static bool UpdateSteamControllerState( const uint8_t *pData, int nDataSize, Ste
         pState->sGyroY = pStatePacket->sGyroY;
         pState->sGyroZ = pStatePacket->sGyroZ;
 
-    }
-    else if ( pInReport->header.ucType == ID_CONTROLLER_BLE_STATE )
-    {
+    } else if ( pInReport->header.ucType == ID_CONTROLLER_BLE_STATE ) {
         ValveControllerBLEStatePacket_t *pBLEStatePacket = &pInReport->payload.controllerBLEState;
         ValveControllerStatePacket_t *pStatePacket = &pInReport->payload.controllerState;
 
         // No new data to process; indicate that we received a state packet, but otherwise do nothing.
-        if ( pState->unPacketNum == pStatePacket->unPacketNum )
+        if (pState->unPacketNum == pStatePacket->unPacketNum) {
             return true;
+        }
 
         FormatStatePacketUntilGyro( pState, pStatePacket );
 
@@ -1041,7 +997,7 @@ HIDAPI_DriverSteam_InitDevice(SDL_HIDAPI_Device *device)
     SDL_DriverSteam_Context *ctx;
 
     ctx = (SDL_DriverSteam_Context *)SDL_calloc(1, sizeof(*ctx));
-    if (!ctx) {
+    if (ctx == NULL) {
         SDL_OutOfMemory();
         return SDL_FALSE;
     }
@@ -1171,8 +1127,7 @@ HIDAPI_DriverSteam_UpdateDevice(SDL_HIDAPI_Device *device)
         return SDL_FALSE;
     }
 
-    for (;;)
-    {
+    for (;;) {
         uint8_t data[128];
         int r, nPacketLength;
         const Uint8 *pPacket;
@@ -1182,7 +1137,7 @@ HIDAPI_DriverSteam_UpdateDevice(SDL_HIDAPI_Device *device)
             break;
         }
 
-        if (!joystick) {
+        if (joystick == NULL) {
             continue;
         }
 
diff --git a/src/joystick/hidapi/SDL_hidapi_switch.c b/src/joystick/hidapi/SDL_hidapi_switch.c
index 901761fac..aedb66a4a 100644
--- a/src/joystick/hidapi/SDL_hidapi_switch.c
+++ b/src/joystick/hidapi/SDL_hidapi_switch.c
@@ -400,9 +400,9 @@ static SDL_bool WritePacket(SDL_DriverSwitch_Context *ctx, void *pBuf, Uint8 ucL
         ucLen = (Uint8)unWriteSize;
     }
     if (ctx->m_bSyncWrite) {
-        return (SDL_hid_write(ctx->device->dev, (Uint8 *)pBuf, ucLen) >= 0);
+        return SDL_hid_write(ctx->device->dev, (Uint8 *)pBuf, ucLen) >= 0;
     } else {
-        return (WriteOutput(ctx, (Uint8 *)pBuf, ucLen) >= 0);
+        return WriteOutput(ctx, (Uint8 *)pBuf, ucLen) >= 0;
     }
 }
 
@@ -411,7 +411,7 @@ static SDL_bool WriteSubcommand(SDL_DriverSwitch_Context *ctx, ESwitchSubcommand
     SwitchSubcommandInputPacket_t *reply = NULL;
     int nTries;
 
-    for (nTries = 1; !reply && nTries <= ctx->m_nMaxWriteAttempts; ++nTries) {
+    for (nTries = 1; reply == NULL && nTries <= ctx->m_nMaxWriteAttempts; ++nTries) {
         SwitchSubcommandOutputPacket_t commandPacket;
         ConstructSubcommand(ctx, ucCommandID, pBuf, ucLen, &commandPacket);
 
@@ -435,7 +435,7 @@ static SDL_bool WriteProprietary(SDL_DriverSwitch_Context *ctx, ESwitchProprieta
     for (nTries = 1; nTries <= ctx->m_nMaxWriteAttempts; ++nTries) {
         SwitchProprietaryOutputPacket_t packet;
 
-        if ((!pBuf && ucLen > 0) || ucLen > sizeof(packet.rgucProprietaryData)) {
+        if ((pBuf == NULL && ucLen > 0) || ucLen > sizeof(packet.rgucProprietaryData)) {
             return SDL_FALSE;
         }
 
@@ -596,8 +596,9 @@ static SDL_bool BReadDeviceInfo(SDL_DriverSwitch_Context *ctx)
 
         ctx->m_eControllerType = CalculateControllerType(ctx, (ESwitchDeviceInfoControllerType)status->ucDeviceType);
 
-        for (i = 0; i < sizeof (ctx->m_rgucMACAddress); ++i)
-            ctx->m_rgucMACAddress[i] = status->rgucMACAddress[ sizeof(ctx->m_rgucMACAddress) - i - 1 ];
+        for (i = 0; i < sizeof(ctx->m_rgucMACAddress); ++i) {
+            ctx->m_rgucMACAddress[i] = status->rgucMACAddress[sizeof(ctx->m_rgucMACAddress) - i - 1];
+        }
 
         return SDL_TRUE;
     }
@@ -776,14 +777,14 @@ static SDL_bool LoadStickCalibration(SDL_DriverSwitch_Context *ctx, Uint8 input_
     }
 
     for (stick = 0; stick < 2; ++stick) {
-        for(axis = 0; axis < 2; ++axis) {
+        for (axis = 0; axis < 2; ++axis) {
             ctx->m_StickExtents[stick].axis[axis].sMin = -(Sint16)(ctx->m_StickCalData[stick].axis[axis].sMin * 0.7f);
             ctx->m_StickExtents[stick].axis[axis].sMax = (Sint16)(ctx->m_StickCalData[stick].axis[axis].sMax * 0.7f);
         }
     }
 
     for (stick = 0; stick < 2; ++stick) {
-        for(axis = 0; axis < 2; ++axis) {
+        for (axis = 0; axis < 2; ++axis) {
             ctx->m_SimpleStickExtents[stick].axis[axis].sMin = (Sint16)(SDL_MIN_SINT16 * 0.5f);
             ctx->m_SimpleStickExtents[stick].axis[axis].sMax = (Sint16)(SDL_MAX_SINT16 * 0.5f);
         }
@@ -869,7 +870,8 @@ static Sint16 ApplyStickCalibration(SDL_DriverSwitch_Context *ctx, int nStick, i
         ctx->m_StickExtents[nStick].axis[nAxis].sMin = sRawValue;
     }
 
-    return (Sint16)HIDAPI_RemapVal(sRawValue, ctx->m_StickExtents[nStick].axis[nAxis].sMin, ctx->m_StickExtents[nStick].axis[nAxis].sMax, SDL_MIN_SINT16, SDL_MAX_SINT16);
+    return (Sint16)HIDAPI_RemapVal(sRawValue, ctx->m_StickExtents[nStick].axis[nAxis].sMin, ctx->m_StickExtents[nStick].axis[nAxis].sMax,
+                                   SDL_MIN_SINT16, SDL_MAX_SINT16);
 }
 
 static Sint16 ApplySimpleStickCalibration(SDL_DriverSwitch_Context *ctx, int nStick, int nAxis, Sint16 sRawValue)
@@ -886,7 +888,8 @@ static Sint16 ApplySimpleStickCalibration(SDL_DriverSwitch_Context *ctx, int nSt
         ctx->m_SimpleStickExtents[nStick].axis[nAxis].sMin = sRawValue;
     }
 
-    return (Sint16)HIDAPI_RemapVal(sRawValue, ctx->m_SimpleStickExtents[nStick].axis[nAxis].sMin, ctx->m_SimpleStickExtents[nStick].axis[nAxis].sMax, SDL_MIN_SINT16, SDL_MAX_SINT16);
+    return (Sint16)HIDAPI_RemapVal(sRawValue, ctx->m_SimpleStickExtents[nStick].axis[nAxis].sMin, ctx->m_SimpleStickExtents[nStick].axis[nAxis].sMax,
+                                   SDL_MIN_SINT16, SDL_MAX_SINT16);
 }
 
 static void SDLCALL SDL_GameControllerButtonReportingHintChanged(void *userdata, const char *name, const char *oldValue, const char *hint)
@@ -1051,9 +1054,7 @@ HIDAPI_DriverNintendoClassic_UnregisterHints(SDL_HintCallback callback, void *us
 static SDL_bool
 HIDAPI_DriverNintendoClassic_IsEnabled(void)
 {
-    return SDL_GetHintBoolean(SDL_HINT_JOYSTICK_HIDAPI_NINTENDO_CLASSIC,
-               SDL_GetHintBoolean(SDL_HINT_JOYSTICK_HIDAPI,
-                   SDL_HIDAPI_DEFAULT));
+    return SDL_GetHintBoolean(SDL_HINT_JOYSTICK_HIDAPI_NINTENDO_CLASSIC, SDL_GetHintBoolean(SDL_HINT_JOYSTICK_HIDAPI, SDL_HIDAPI_DEFAULT));
 }
 
 static SDL_bool
@@ -1097,9 +1098,7 @@ HIDAPI_DriverJoyCons_UnregisterHints(SDL_HintCallback callback, void *userdata)
 static SDL_bool
 HIDAPI_DriverJoyCons_IsEnabled(void)
 {
-    return SDL_GetHintBoolean(SDL_HINT_JOYSTICK_HIDAPI_JOY_CONS,
-               SDL_GetHintBoolean(SDL_HINT_JOYSTICK_HIDAPI,
-                   SDL_HIDAPI_DEFAULT));
+    return SDL_GetHintBoolean(SDL_HINT_JOYSTICK_HIDAPI_JOY_CONS, SDL_GetHintBoolean(SDL_HINT_JOYSTICK_HIDAPI, SDL_HIDAPI_DEFAULT));
 }
 
 static SDL_bool
@@ -1139,9 +1138,7 @@ HIDAPI_DriverSwitch_UnregisterHints(SDL_HintCallback callback, void *userdata)
 static SDL_bool
 HIDAPI_DriverSwitch_IsEnabled(void)
 {
-    return SDL_GetHintBoolean(SDL_HINT_JOYSTICK_HIDAPI_SWITCH,
-               SDL_GetHintBoolean(SDL_HINT_JOYSTICK_HIDAPI,
-                   SDL_HIDAPI_DEFAULT));
+    return SDL_GetHintBoolean(SDL_HINT_JOYSTICK_HIDAPI_SWITCH, SDL_GetHintBoolean(SDL_HINT_JOYSTICK_HIDAPI, SDL_HIDAPI_DEFAULT));
 }
 
 static SDL_bool
@@ -1232,7 +1229,7 @@ HIDAPI_DriverSwitch_InitDevice(SDL_HIDAPI_Device *device)
     SDL_DriverSwitch_Context *ctx;
 
     ctx = (SDL_DriverSwitch_Context *)SDL_calloc(1, sizeof(*ctx));
-    if (!ctx) {
+    if (ctx == NULL) {
         SDL_OutOfMemory();
         return SDL_FALSE;
     }
@@ -2142,7 +2139,7 @@ HIDAPI_DriverSwitch_UpdateDevice(SDL_HIDAPI_Device *device)
         ++packet_count;
         ctx->m_unLastInput = now;
 
-        if (!joystick) {
+        if (joystick == NULL) {
             continue;
         }
 
@@ -2201,7 +2198,7 @@ HIDAPI_DriverSwitch_UpdateDevice(SDL_HIDAPI_Device *device)
         /* Read error, device is disconnected */
         HIDAPI_JoystickDisconnected(device, device->joysticks[0]);
     }
-    return (size >= 0);
+    return size >= 0;
 }
 
 static void
diff --git a/src/joystick/hidapi/SDL_hidapi_wii.c b/src/joystick/hidapi/SDL_hidapi_wii.c
index 3b4e79411..3149f2766 100644
--- a/src/joystick/hidapi/SDL_hidapi_wii.c
+++ b/src/joystick/hidapi/SDL_hidapi_wii.c
@@ -216,13 +216,13 @@ static SDL_bool WriteOutput(SDL_DriverWii_Context *ctx, const Uint8 *data, int s
     }
 #endif
     if (sync) {
-        return (SDL_hid_write(ctx->device->dev, data, size) >= 0);
+        return SDL_hid_write(ctx->device->dev, data, size) >= 0;
     } else {
         /* Use the rumble thread for general asynchronous writes */
         if (SDL_HIDAPI_LockRumble() < 0) {
             return SDL_FALSE;
         }
-        return (SDL_HIDAPI_SendRumbleAndUnlock(ctx->device, data, size) >= 0);
+        return SDL_HIDAPI_SendRumbleAndUnlock(ctx->device, data, size) >= 0;
     }
 }
 
@@ -234,7 +234,7 @@ static SDL_bool ReadInputSync(SDL_DriverWii_Context *ctx, EWiiInputReportIDs exp
     int nRead = 0;
     while ((nRead = ReadInput(ctx)) != -1) {
         if (nRead > 0) {
-            if (ctx->m_rgucReadBuffer[0] == expectedID && (!isMine || isMine(ctx->m_rgucReadBuffer))) {
+            if (ctx->m_rgucReadBuffer[0] == expectedID && (isMine == NULL || isMine(ctx->m_rgucReadBuffer))) {
                 return SDL_TRUE;
             }
         } else {
@@ -734,7 +734,7 @@ HIDAPI_DriverWii_InitDevice(SDL_HIDAPI_Device *device)
     SDL_DriverWii_Context *ctx;
 
     ctx = (SDL_DriverWii_Context *)SDL_calloc(1, sizeof(*ctx));
-    if (!ctx) {
+    if (ctx == NULL) {
         SDL_OutOfMemory();
         return SDL_FALSE;
     }
@@ -1529,7 +1529,7 @@ HIDAPI_DriverWii_UpdateDevice(SDL_HIDAPI_Device *device)
         /* Read error, device is disconnected */
         HIDAPI_JoystickDisconnected(device, device->joysticks[0]);
     }
-    return (size >= 0);
+    return size >= 0;
 }
 
 static void
diff --git a/src/joystick/hidapi/SDL_hidapi_xbox360.c b/src/joystick/hidapi/SDL_hidapi_xbox360.c
index 191ccb97f..ddc53a3bb 100644
--- a/src/joystick/hidapi/SDL_hidapi_xbox360.c
+++ b/src/joystick/hidapi/SDL_hidapi_xbox360.c
@@ -64,9 +64,7 @@ static SDL_bool
 HIDAPI_DriverXbox360_IsEnabled(void)
 {
     return SDL_GetHintBoolean(SDL_HINT_JOYSTICK_HIDAPI_XBOX_360,
-               SDL_GetHintBoolean(SDL_HINT_JOYSTICK_HIDAPI_XBOX,
-                   SDL_GetHintBoolean(SDL_HINT_JOYSTICK_HIDAPI,
-                       SDL_HIDAPI_DEFAULT)));
+                              SDL_GetHintBoolean(SDL_HINT_JOYSTICK_HIDAPI_XBOX, SDL_GetHintBoolean(SDL_HINT_JOYSTICK_HIDAPI, SDL_HIDAPI_DEFAULT)));
 }
 
 static SDL_bool
@@ -149,7 +147,7 @@ HIDAPI_DriverXbox360_InitDevice(SDL_HIDAPI_Device *device)
     SDL_DriverXbox360_Context *ctx;
 
     ctx = (SDL_DriverXbox360_Context *)SDL_calloc(1, sizeof(*ctx));
-    if (!ctx) {
+    if (ctx == NULL) {
         SDL_OutOfMemory();
         return SDL_FALSE;
     }
@@ -347,7 +345,7 @@ HIDAPI_DriverXbox360_UpdateDevice(SDL_HIDAPI_Device *device)
 #ifdef DEBUG_XBOX_PROTOCOL
         HIDAPI_DumpPacket("Xbox 360 packet: size = %d", data, size);
 #endif
-        if (!joystick) {
+        if (joystick == NULL) {
             continue;
         }
 
@@ -360,7 +358,7 @@ HIDAPI_DriverXbox360_UpdateDevice(SDL_HIDAPI_Device *device)
         /* Read error, device is disconnected */
         HIDAPI_JoystickDisconnected(device, device->joysticks[0]);
     }
-    return (size >= 0);
+    return size >= 0;
 }
 
 static void
diff --git a/src/joystick/hidapi/SDL_hidapi_xbox360w.c b/src/joystick/hidapi/SDL_hidapi_xbox360w.c
index f0a1d2931..5c1d8bd7f 100644
--- a/src/joystick/hidapi/SDL_hidapi_xbox360w.c
+++ b/src/joystick/hidapi/SDL_hidapi_xbox360w.c
@@ -67,10 +67,7 @@ static SDL_bool
 HIDAPI_DriverXbox360W_IsEnabled(void)
 {
     return SDL_GetHintBoolean(SDL_HINT_JOYSTICK_HIDAPI_XBOX_360_WIRELESS,
-               SDL_GetHintBoolean(SDL_HINT_JOYSTICK_HIDAPI_XBOX_360,
-                   SDL_GetHintBoolean(SDL_HINT_JOYSTICK_HIDAPI_XBOX,
-                       SDL_GetHintBoolean(SDL_HINT_JOYSTICK_HIDAPI,
-                           SDL_HIDAPI_DEFAULT))));
+                              SDL_GetHintBoolean(SDL_HINT_JOYSTICK_HIDAPI_XBOX_360, SDL_GetHintBoolean(SDL_HINT_JOYSTICK_HIDAPI_XBOX, SDL_GetHintBoolean(SDL_HINT_JOYSTICK_HIDAPI, SDL_HIDAPI_DEFAULT))));
 }
 
 static SDL_bool
@@ -146,7 +143,7 @@ HIDAPI_DriverXbox360W_InitDevice(SDL_HIDAPI_Device *device)
     HIDAPI_SetDeviceName(device, "Xbox 360 Wireless Controller");
 
     ctx = (SDL_DriverXbox360W_Context *)SDL_calloc(1, sizeof(*ctx));
-    if (!ctx) {
+    if (ctx == NULL) {
         SDL_OutOfMemory();
         return SDL_FALSE;
     }
@@ -175,7 +172,7 @@ HIDAPI_DriverXbox360W_SetDevicePlayerIndex(SDL_HIDAPI_Device *device, SDL_Joysti
 {
     SDL_DriverXbox360W_Context *ctx = (SDL_DriverXbox360W_Context *)device->context;
 
-    if (!ctx) {
+    if (ctx == NULL) {
         return;
     }
 
@@ -360,7 +357,7 @@ HIDAPI_DriverXbox360W_UpdateDevice(SDL_HIDAPI_Device *device)
         /* Read error, device is disconnected */
         HIDAPI_JoystickDisconnected(device, device->joysticks[0]);
     }
-    return (size >= 0);
+    return size >= 0;
 }
 
 static void
diff --git a/src/joystick/hidapi/SDL_hidapi_xboxone.c b/src/joystick/hidapi/SDL_hidapi_xboxone.c
index 1a5798e91..3c1e00ed7 100644
--- a/src/joystick/hidapi/SDL_hidapi_xboxone.c
+++ b/src/joystick/hidapi/SDL_hidapi_xboxone.c
@@ -140,7 +140,7 @@ typedef struct {
 static SDL_bool
 ControllerHasColorLED(Uint16 vendor_id, Uint16 product_id)
 {
-    return (vendor_id == USB_VENDOR_MICROSOFT && product_id == USB_PRODUCT_XBOX_ONE_ELITE_SERIES_2);
+    return vendor_id == USB_VENDOR_MICROSOFT && product_id == USB_PRODUCT_XBOX_ONE_ELITE_SERIES_2;
 }
 
 static SDL_bool
@@ -357,9 +357,7 @@ static SDL_bool
 HIDAPI_DriverXboxOne_IsEnabled(void)
 {
     return SDL_GetHintBoolean(SDL_HINT_JOYSTICK_HIDAPI_XBOX_ONE,
-               SDL_GetHintBoolean(SDL_HINT_JOYSTICK_HIDAPI_XBOX,
-                   SDL_GetHintBoolean(SDL_HINT_JOYSTICK_HIDAPI,
-                       SDL_HIDAPI_DEFAULT)));
+                              SDL_GetHintBoolean(SDL_HINT_JOYSTICK_HIDAPI_XBOX, SDL_GetHintBoolean(SDL_HINT_JOYSTICK_HIDAPI, SDL_HIDAPI_DEFAULT)));
 }
 
 static SDL_bool
@@ -380,7 +378,7 @@ HIDAPI_DriverXboxOne_InitDevice(SDL_HIDAPI_Device *device)
     SDL_DriverXboxOne_Context *ctx;
 
     ctx = (SDL_DriverXboxOne_Context *)SDL_calloc(1, sizeof(*ctx));
-    if (!ctx) {
+    if (ctx == NULL) {
         SDL_OutOfMemory();
         return SDL_FALSE;
     }
@@ -1105,7 +1103,7 @@ HIDAPI_DriverXboxOne_UpdateDevice(SDL_HIDAPI_Device *device)
         if (ctx->bluetooth) {
             switch (data[0]) {
             case 0x01:
-                if (!joystick) {
+                if (joystick == NULL) {
                     break;
                 }
                 if (size >= 16) {
@@ -1117,13 +1115,13 @@ HIDAPI_DriverXboxOne_UpdateDevice(SDL_HIDAPI_Device *device)
                 }
                 break;
             case 0x02:
-                if (!joystick) {
+                if (joystick == NULL) {
                     break;
                 }
                 HIDAPI_DriverXboxOneBluetooth_HandleGuidePacket(joystick, ctx, data, size);
                 break;
             case 0x04:
-                if (!joystick) {
+                if (joystick == NULL) {
                     break;
                 }
                 HIDAPI_DriverXboxOneBluetooth_HandleBatteryPacket(joystick, ctx, data, size);
@@ -1171,7 +1169,7 @@ HIDAPI_DriverXboxOne_UpdateDevice(SDL_HIDAPI_Device *device)
                 break;
             case 0x03:
                 /* Controller status update */
-                if (!joystick) {
+                if (joystick == NULL) {
                     /* We actually want to handle this packet any time it arrives */
                     /*break;*/
                 }
@@ -1184,7 +1182,7 @@ HIDAPI_DriverXboxOne_UpdateDevice(SDL_HIDAPI_Device *device)
                 /* Unknown chatty controller information, sent by both sides */
                 break;
             case 0x07:
-                if (!joystick) {
+                if (joystick == NULL) {
                     break;
                 }
                 HIDAPI_DriverXboxOne_HandleModePacket(joystick, ctx, data, size);
@@ -1199,7 +1197,7 @@ HIDAPI_DriverXboxOne_UpdateDevice(SDL_HIDAPI_Device *device)
                    The controller sends that in response to this request:
                     0x1E 0x30 0x07 0x01 0x04
                 */
-                if (!joystick) {
+                if (joystick == NULL) {
                     break;
                 }
 #ifdef SET_SERIAL_AFTER_OPEN
@@ -1218,7 +1216,7 @@ HIDAPI_DriverXboxOne_UpdateDevice(SDL_HIDAPI_Device *device)
 #endif
                     break;
                 }
-                if (!joystick) {
+                if (joystick == NULL) {
                     break;
                 }
                 HIDAPI_DriverXboxOne_HandleStatePacket(joystick, ctx, data, size);
@@ -1253,7 +1251,7 @@ HIDAPI_DriverXboxOne_UpdateDevice(SDL_HIDAPI_Device *device)
         /* Read error, device is disconnected */
         HIDAPI_JoystickDisconnected(device, device->joysticks[0]);
     }
-    return (size >= 0);
+    return size >= 0;
 }
 
 static void
diff --git a/src/joystick/hidapi/SDL_hidapijoystick.c b/src/joystick/hidapi/SDL_hidapijoystick.c
index 2ed4aee86..ae3f2cc2d 100644
--- a/src/joystick/hidapi/SDL_hidapijoystick.c
+++ b/src/joystick/hidapi/SDL_hidapijoystick.c
@@ -394,7 +394,7 @@ HIDAPI_SetupDeviceDriver(SDL_HIDAPI_Device *device, SDL_bool *removed)
             for (curr = SDL_HIDAPI_devices; curr && curr != device; curr = curr->next) {
                 continue;
             }
-            if (!curr) {
+            if (curr == NULL) {
                 *removed = SDL_TRUE;
                 if (dev) {
                     SDL_hid_close(dev);
@@ -402,7 +402,7 @@ HIDAPI_SetupDeviceDriver(SDL_HIDAPI_Device *device, SDL_bool *removed)
                 return;
             }
 
-            if (!dev) {
+            if (dev == NULL) {
                 SDL_LogDebug(SDL_LOG_CATEGORY_INPUT,
                              "HIDAPI_SetupDeviceDriver() couldn't open %s: %s\n",
                              device->path, SDL_GetError());
@@ -518,7 +518,7 @@ static SDL_bool
 HIDAPI_AddJoystickInstanceToDevice(SDL_HIDAPI_Device *device, SDL_JoystickID joystickID)
 {
     SDL_JoystickID *joysticks = (SDL_JoystickID *)SDL_realloc(device->joysticks, (device->num_joysticks + 1)*sizeof(*device->joysticks));
-    if (!joysticks) {
+    if (joysticks == NULL) {
         return SDL_FALSE;
     }
 
@@ -588,7 +588,7 @@ HIDAPI_HasConnectedUSBDevice(const char *serial)
 {
     SDL_HIDAPI_Device *device;
 
-    if (!serial) {
+    if (serial == NULL) {
         return SDL_FALSE;
     }
 
@@ -613,7 +613,7 @@ HIDAPI_DisconnectBluetoothDevice(const char *serial)
 {
     SDL_HIDAPI_Device *device;
 
-    if (!serial) {
+    if (serial == NULL) {
         return;
     }
 
@@ -718,7 +718,7 @@ HIDAPI_ConvertString(const wchar_t *wide_string)
 
     if (wide_string) {
         string = SDL_iconv_string("UTF-8", "WCHAR_T", (char*)wide_string, (SDL_wcslen(wide_string)+1)*sizeof(wchar_t));
-        if (!string) {
+        if (string == NULL) {
             switch (sizeof(wchar_t)) {
             case 2:
                 string = SDL_iconv_string("UTF-8", "UCS-2-INTERNAL", (char*)wide_string, (SDL_wcslen(wide_string)+1)*sizeof(wchar_t));
@@ -744,7 +744,7 @@ HIDAPI_AddDevice(const struct SDL_hid_device_info *info, int num_children, SDL_H
     }
 
     device = (SDL_HIDAPI_Device *)SDL_calloc(1, sizeof(*device));
-    if (!device) {
+    if (device == NULL) {
         return NULL;
     }
     device->path = SDL_strdup(info->path);
@@ -908,7 +908,7 @@ HIDAPI_CreateCombinedJoyCons()
         if (joycons[0] && joycons[1]) {
             SDL_hid_device_info info;
             SDL_HIDAPI_Device **children = (SDL_HIDAPI_Device **)SDL_malloc(2 * sizeof(SDL_HIDAPI_Device *));
-            if (!children) {
+            if (children == NULL) {
                 return SDL_FALSE;
             }
             children[0] = joycons[0];
@@ -1300,13 +1300,13 @@ HIDAPI_JoystickOpen(SDL_Joystick *joystick, int device_index)
     SDL_HIDAPI_Device *device = HIDAPI_GetDeviceByIndex(device_index, &joystickID);
     struct joystick_hwdata *hwdata;
 
-    if (!device || !device->driver) {
+    if (device == NULL || !device->driver) {
         /* This should never happen - validated before being called */
         return SDL_SetError("Couldn't find HIDAPI device at index %d\n", device_index);
     }
 
     hwdata = (struct joystick_hwdata *)SDL_calloc(1, sizeof(*hwdata));
-    if (!hwdata) {
+    if (hwdata == NULL) {
         return SDL_OutOfMemory();
     }
     hwdata->device = device;
diff --git a/src/joystick/linux/SDL_sysjoystick.c b/src/joystick/linux/SDL_sysjoystick.c
index 5d3a994f5..a03401b3a 100644
--- a/src/joystick/linux/SDL_sysjoystick.c
+++ b/src/joystick/linux/SDL_sysjoystick.c
@@ -177,7 +177,7 @@ GuessIsJoystick(int fd)
         (ioctl(fd, EVIOCGBIT(EV_KEY, sizeof(keybit)), keybit) < 0) ||
         (ioctl(fd, EVIOCGBIT(EV_REL, sizeof(relbit)), relbit) < 0) ||
         (ioctl(fd, EVIOCGBIT(EV_ABS, sizeof(absbit)), absbit) < 0)) {
-        return (0);
+        return 0;
     }
 
     devclass = SDL_EVDEV_GuessDeviceClass(evbit, absbit, keybit, relbit);
@@ -217,7 +217,7 @@ IsJoystick(const char *path, int fd, char **name_return, SDL_JoystickGUID *guid)
     }
 
     name = SDL_CreateJoystickName(inpid.vendor, inpid.product, NULL, product_string);
-    if (!name) {
+    if (name == NULL) {
         return 0;
     }
 
@@ -489,7 +489,7 @@ static void SteamControllerDisconnectedCallback(int device_instance)
 static int
 StrHasPrefix(const char *string, const char *prefix)
 {
-    return (SDL_strncmp(string, prefix, SDL_strlen(prefix)) == 0);
+    return SDL_strncmp(string, prefix, SDL_strlen(prefix)) == 0;
 }
 
 static int
@@ -517,7 +517,7 @@ IsJoystickJSNode(const char *node)
     if (last_slash) {
         node = last_slash + 1;
     }
-    return (StrHasPrefix(node, "js") && StrIsInteger(node + 2));
+    return StrHasPrefix(node, "js") && StrIsInteger(node + 2);
 }
 
 static SDL_bool
@@ -527,7 +527,7 @@ IsJoystickEventNode(const char *node)
     if (last_slash) {
         node = last_slash + 1;
     }
-    return (StrHasPrefix(node, "event") && StrIsInteger(node + 5));
+    return StrHasPrefix(node, "event") && StrIsInteger(node + 5);
 }
 
 static SDL_bool
@@ -548,7 +548,9 @@ static int SDL_inotify_init1(void) {
 #else
 static int SDL_inotify_init1(void) {
     int fd = inotify_init();
-    if (fd  < 0) return -1;
+    if (fd < 0) {
+        return -1;
+    }
     fcntl(fd, F_SETFL, O_NONBLOCK);
     fcntl(fd, F_SETFD, FD_CLOEXEC);
     return fd;
@@ -582,8 +584,7 @@ LINUX_InotifyJoystickDetect(void)
 
                 if (buf.event.mask & (IN_CREATE | IN_MOVED_TO | IN_ATTRIB)) {
                     MaybeAddDevice(path);
-                }
-                else if (buf.event.mask & (IN_DELETE | IN_MOVED_FROM)) {
+                } else if (buf.event.mask & (IN_DELETE | IN_MOVED_FROM)) {
                     MaybeRemoveDevice(path);
                 }
             }
@@ -659,7 +660,7 @@ sort_entries(const void *_a, const void *_b)
             }
         }
     }
-    return (numA - numB);
+    return numA - numB;
 }
 
 static void
@@ -702,14 +703,12 @@ LINUX_JoystickDetect(void)
 #if SDL_USE_LIBUDEV
     if (enumeration_method == ENUMERATION_LIBUDEV) {
         SDL_UDEV_Poll();
-    }
-    else
+    } else
 #endif
 #ifdef HAVE_INOTIFY
     if (inotify_fd >= 0 && last_joy_detect_time != 0) {
         LINUX_InotifyJoystickDetect();
-    }
-    else
+    } else
 #endif
     {
         LINUX_FallbackJoystickDetect();
@@ -786,8 +785,7 @@ LINUX_JoystickInit(void)
 
         /* Force a scan to build the initial device list */
         SDL_UDEV_Scan();
-    }
-    else
+    } else
 #endif
     {
 #if defined(HAVE_INOTIFY)
@@ -887,13 +885,13 @@ allocate_hatdata(SDL_Joystick *joystick)
         (struct hwdata_hat *) SDL_malloc(joystick->nhats *
                                          sizeof(struct hwdata_hat));
     if (joystick->hwdata->hats == NULL) {
-        return (-1);
+        return -1;
     }
     for (i = 0; i < joystick->nhats; ++i) {
         joystick->hwdata->hats[i].axis[0] = 1;
         joystick->hwdata->hats[i].axis[1] = 1;
     }
-    return (0);
+    return 0;
 }
 
 static int
@@ -905,13 +903,13 @@ allocate_balldata(SDL_Joystick *joystick)
         (struct hwdata_ball *) SDL_malloc(joystick->nballs *
                                           sizeof(struct hwdata_ball));
     if (joystick->hwdata->balls == NULL) {
-        return (-1);
+        return -1;
     }
     for (i = 0; i < joystick->nballs; ++i) {
         joystick->hwdata->balls[i].axis[0] = 0;
         joystick->hwdata->balls[i].axis[1] = 0;
     }
-    return (0);
+    return 0;
 }
 
 static SDL_bool
@@ -924,22 +922,24 @@ GuessIfAxesAreDigitalHat(struct input_absinfo *absinfo_x, struct input_absinfo *
      * other continuous analog axis, so we have to guess. */
 
     /* If both axes are missing, they're not anything. */
-    if (!absinfo_x && !absinfo_y)
+    if (absinfo_x == NULL && absinfo_y == NULL) {
         return SDL_FALSE;
+    }
 
     /* If the hint says so, treat all hats as digital. */
-    if (SDL_GetHintBoolean(SDL_HINT_LINUX_DIGITAL_HATS, SDL_FALSE))
+    if (SDL_GetHintBoolean(SDL_HINT_LINUX_DIGITAL_HATS, SDL_FALSE)) {
         return SDL_TRUE;
+    }
 
     /* If both axes have ranges constrained between -1 and 1, they're definitely digital. */
-    if ((!absinfo_x || (absinfo_x->minimum == -1 && absinfo_x->maximum == 1)) &&
-        (!absinfo_y || (absinfo_y->minimum == -1 && absinfo_y->maximum == 1)))
+    if ((absinfo_x == NULL || (absinfo_x->minimum == -1 && absinfo_x->maximum == 1)) && (absinfo_y == NULL || (absinfo_y->minimum == -1 && absinfo_y->maximum == 1))) {
         return SDL_TRUE;
+    }
 
     /* If both axes lack fuzz, flat, and resolution values, they're probably digital. */
-    if ((!absinfo_x || (!absinfo_x->fuzz && !absinfo_x->flat && !absinfo_x->resolution)) &&
-        (!absinfo_y || (!absinfo_y->fuzz && !absinfo_y->flat && !absinfo_y->resolution)))
+    if ((absinfo_x == NULL || (!absinfo_x->fuzz && !absinfo_x->flat && !absinfo_x->resolution)) && (absinfo_y == NULL || (!absinfo_y->fuzz && !absinfo_y->flat && !absinfo_y->resolution))) {
         return SDL_TRUE;
+    }
 
     /* Otherwise, treat them as analog. */
     return SDL_FALSE;
@@ -988,10 +988,12 @@ ConfigJoystick(SDL_Joystick *joystick, int fd)
             int hat_y = -1;
             struct input_absinfo absinfo_x;
             struct input_absinfo absinfo_y;
-            if (test_bit(i, absbit))
+            if (test_bit(i, absbit)) {
                 hat_x = ioctl(fd, EVIOCGABS(i), &absinfo_x);
-            if (test_bit(i + 1, absbit))
+            }
+            if (test_bit(i + 1, absbit)) {
                 hat_y = ioctl(fd, EVIOCGABS(i + 1), &absinfo_y);
+            }
             if (GuessIfAxesAreDigitalHat((hat_x < 0 ? (void*)0 : &absinfo_x),
                                          (hat_y < 0 ? (void*)0 : &absinfo_y))) {
                 const int hat_index = (i - ABS_HAT0X) / 2;
diff --git a/src/joystick/n3ds/SDL_sysjoystick.c b/src/joystick/n3ds/SDL_sysjoystick.c
index 933f64ee0..848bef350 100644
--- a/src/joystick/n3ds/SDL_sysjoystick.c
+++ b/src/joystick/n3ds/SDL_sysjoystick.c
@@ -195,7 +195,7 @@ static SDL_bool
 N3DS_JoystickGetGamepadMapping(int device_index, SDL_GamepadMapping *out)
 {
     /* There is only one possible mapping. */
-    *out = (SDL_GamepadMapping){
+    *out = (SDL_GamepadMapping) {
         .a = { EMappingKind_Button, 0 },
         .b = { EMappingKind_Button, 1 },
         .x = { EMappingKind_Button, 10 },
diff --git a/src/joystick/ps2/SDL_sysjoystick.c b/src/joystick/ps2/SDL_sysjoystick.c
index 3847d79c5..d86f97231 100644
--- a/src/joystick/ps2/SDL_sysjoystick.c
+++ b/src/joystick/ps2/SDL_sysjoystick.c
@@ -60,8 +60,9 @@ static struct JoyInfo joyInfo[MAX_CONTROLLERS];
 
 static inline int16_t convert_u8_to_s16(uint8_t val)
 {
-   if (val == 0)
+   if (val == 0) {
       return -0x7fff;
+   }
    return val * 0x0101 - 0x8000;
 }
 
@@ -95,11 +96,13 @@ static int PS2_JoystickInit(void)
     uint32_t port = 0;
     uint32_t slot = 0;
 
-    if(init_joystick_driver(true) < 0)
+    if (init_joystick_driver(true) < 0) {
         return -1;
+   }
 
-   for (port = 0; port < PS2_MAX_PORT; port++)
+   for (port = 0; port < PS2_MAX_PORT; port++) {
         mtapPortOpen(port);
+   }
     /* it can fail - we dont care, we will check it more strictly when padPortOpen */
 
     for (slot = 0; slot < PS2_MAX_SLOT; slot++) {
@@ -116,7 +119,7 @@ static int PS2_JoystickInit(void)
             */
 
             struct JoyInfo *info = &joyInfo[enabled_pads];
-            if(padPortOpen(port, slot, (void *)info->padBuf) > 0) {
+            if (padPortOpen(port, slot, (void *)info->padBuf) > 0) {
                 info->port = (uint8_t)port;
                 info->slot = (uint8_t)slot;
                 info->opened = 1;
@@ -142,8 +145,9 @@ static void PS2_JoystickDetect()
 /* Function to get the device-dependent name of a joystick */
 static const char *PS2_JoystickGetDeviceName(int index)
 {
-    if (index >= 0 && index < enabled_pads)
+    if (index >= 0 && index < enabled_pads) {
         return "PS2 Controller";
+    }
 
     SDL_SetError("No joystick available with that index");
     return NULL;
@@ -285,8 +289,9 @@ static void PS2_JoystickUpdate(SDL_Joystick *joystick)
                     mask = (1 << i);
                     previous = info->btns & mask;
                     current = pressed_buttons & mask;
-                    if (previous != current)
+                    if (previous != current) {
                         SDL_PrivateJoystickButton(joystick, i, current ? SDL_PRESSED : SDL_RELEASED);
+                    }
                 }
             }
             info->btns = pressed_buttons;
@@ -300,8 +305,9 @@ static void PS2_JoystickUpdate(SDL_Joystick *joystick)
             for (i = 0; i < PS2_TOTAL_AXIS; i++) {
                 previous_axis = info->analog_state[i];
                 current_axis = all_axis[i];
-                if (previous_axis != current_axis)
+                if (previous_axis != current_axis) {
                     SDL_PrivateJoystickAxis(joystick, i, convert_u8_to_s16(current_axis));
+                }
                 
                 info->analog_state[i] = current_axis;
             }
diff --git a/src/joystick/psp/SDL_sysjoystick.c b/src/joystick/psp/SDL_sysjoystick.c
index 06c0f285b..ab8490b76 100644
--- a/src/joystick/psp/SDL_sysjoystick.c
+++ b/src/joystick/psp/SDL_sysjoystick.c
@@ -89,8 +89,7 @@ static int PSP_JoystickInit(void)
 
     /* Create an accurate map from analog inputs (0 to 255)
        to SDL joystick positions (-32768 to 32767) */
-    for (i = 0; i < 128; i++)
-    {
+    for (i = 0; i < 128; i++) {
         float t = (float)i/127.0f;
         analog_map[i+128] = calc_bezier_y(t);
         analog_map[127-i] = -1 * analog_map[i+128];
@@ -111,11 +110,12 @@ static void PSP_JoystickDetect(void)
 /* Function to get the device-dependent name of a joystick */
 static const char *PSP_JoystickGetDeviceName(int device_index)
 {
-    if (device_index == 0)
+    if (device_index == 0) {
         return "PSP builtin joypad";
+    }
 
     SDL_SetError("No joystick available with that index");
-    return(NULL);
+    return NULL;
 }
 
 static const char *PSP_JoystickGetDevicePath(int index)
@@ -210,11 +210,11 @@ static void PSP_JoystickUpdate(SDL_Joystick *joystick)
     y = pad.Ly;
 
     /* Axes */
-    if(old_x != x) {
+    if (old_x != x) {
         SDL_PrivateJoystickAxis(joystick, 0, analog_map[x]);
         old_x = x;
     }
-    if(old_y != y) {
+    if (old_y != y) {
         SDL_PrivateJoystickAxis(joystick, 1, analog_map[y]);
         old_y = y;
     }
@@ -222,7 +222,7 @@ static void PSP_JoystickUpdate(SDL_Joystick *joystick)
     /* Buttons */
     changed = old_buttons ^ buttons;
     old_buttons = buttons;
-    if(changed) {
+    if (changed) {
         for (i = 0; i < SDL_arraysize(button_map); i++) {
             if (changed & button_map[i]) {
                 SDL_PrivateJoystickButton(
diff --git a/src/joystick/virtual/SDL_virtualjoystick.c b/src/joystick/virtual/SDL_virtualjoystick.c
index 9a6d9430e..ef3170927 100644
--- a/src/joystick/virtual/SDL_virtualjoystick.c
+++ b/src/joystick/virtual/SDL_virtualjoystick.c
@@ -38,8 +38,9 @@ VIRTUAL_HWDataForIndex(int device_index)
 {
     joystick_hwdata *vjoy = g_VJoys;
     while (vjoy) {
-        if (device_index == 0)
+        if (device_index == 0) {
             break;
+        }
         --device_index;
         vjoy = vjoy->next;
     }
@@ -53,7 +54,7 @@ VIRTUAL_FreeHWData(joystick_hwdata *hwdata)
     joystick_hwdata * cur = g_VJoys;
     joystick_hwdata * prev = NULL;
  
-    if (!hwdata) {
+    if (hwdata == NULL) {
         return;
     }
 
@@ -104,7 +105,7 @@ SDL_JoystickAttachVirtualInner(const SDL_VirtualJoystickDesc *desc)
     int axis_triggerleft = -1;
     int axis_triggerright = -1;
 
-    if (!desc) {
+    if (desc == NULL) {
         return SDL_InvalidParamError("desc");
     }
     if (desc->version != SDL_VIRTUAL_JOYSTICK_DESC_VERSION) {
@@ -113,7 +114,7 @@ SDL_JoystickAttachVirtualInner(const SDL_VirtualJoystickDesc *desc)
     }
 
     hwdata = SDL_calloc(1, sizeof(joystick_hwdata));
-    if (!hwdata) {
+    if (hwdata == NULL) {
         VIRTUAL_FreeHWData(hwdata);
         return SDL_OutOfMemory();
     }
@@ -253,7 +254,7 @@ SDL_JoystickDetachVirtualInner(int device_index)
 {
     SDL_JoystickID instance_id;
     joystick_hwdata *hwdata = VIRTUAL_HWDataForIndex(device_index);
-    if (!hwdata) {
+    if (hwdata == NULL) {
         return SDL_SetError("Virtual joystick data not found");
     }
     instance_id = hwdata->instance_id;
@@ -270,7 +271,7 @@ SDL_JoystickSetVirtualAxisInner(SDL_Joystick *joystick, int axis, Sint16 value)
 
     SDL_LockJoysticks();
 
-    if (!joystick || !joystick->hwdata) {
+    if (joystick == NULL || !joystick->hwdata) {
         SDL_UnlockJoysticks();
         return SDL_SetError("Invalid joystick");
     }
@@ -295,7 +296,7 @@ SDL_JoystickSetVirtualButtonInner(SDL_Joystick *joystick, int button, Uint8 valu
 
     SDL_LockJoysticks();
 
-    if (!joystick || !joystick->hwdata) {
+    if (joystick == NULL || !joystick->hwdata) {
         SDL_UnlockJoysticks();
         return SDL_SetError("Invalid joystick");
     }
@@ -320,7 +321,7 @@ SDL_JoystickSetVirtualHatInner(SDL_Joystick *joystick, int hat, Uint8 value)
 
     SDL_LockJoysticks();
 
-    if (!joystick || !joystick->hwdata) {
+    if (joystick == NULL || !joystick->hwdata) {
         SDL_UnlockJoysticks();
         return SDL_SetError("Invalid joystick");
     }
@@ -368,7 +369,7 @@ static const char *
 VIRTUAL_JoystickGetDeviceName(int device_index)
 {
     joystick_hwdata *hwdata = VIRTUAL_HWDataForIndex(device_index);
-    if (!hwdata) {
+    if (hwdata == NULL) {
         return NULL;
     }
     return hwdata->name;
@@ -404,7 +405,7 @@ static SDL_JoystickGUID
 VIRTUAL_JoystickGetDeviceGUID(int device_index)
 {
     joystick_hwdata *hwdata = VIRTUAL_HWDataForIndex(device_index);
-    if (!hwdata) {
+    if (hwdata == NULL) {
         SDL_JoystickGUID guid;
         SDL_zero(guid);
         return guid;
@@ -417,7 +418,7 @@ static SDL_JoystickID
 VIRTUAL_JoystickGetDeviceInstanceID(int device_index)
 {
     joystick_hwdata *hwdata = VIRTUAL_HWDataForIndex(device_index);
-    if (!hwdata) {
+    if (hwdata == NULL) {
         return -1;
     }
     return hwdata->instance_id;
@@ -428,7 +429,7 @@ static int
 VIRTUAL_JoystickOpen(SDL_Joystick *joystick, int device_index)
 {
     joystick_hwdata *hwdata = VIRTUAL_HWDataForIndex(device_index);
-    if (!hwdata) {
+    if (hwdata == NULL) {
         return SDL_SetError("No such device");
     }
     joystick->instance_id = hwdata->instance_id;
@@ -552,7 +553,7 @@ VIRTUAL_JoystickUpdate(SDL_Joystick *joystick)
     joystick_hwdata *hwdata;
     int i;
 
-    if (!joystick) {
+    if (joystick == NULL) {
         return;
     }
     if (!joystick->hwdata) {
diff --git a/src/joystick/vita/SDL_sysjoystick.c b/src/joystick/vita/SDL_sysjoystick.c
index 994655fc6..c5dc86270 100644
--- a/src/joystick/vita/SDL_sysjoystick.c
+++ b/src/joystick/vita/SDL_sysjoystick.c
@@ -118,8 +118,7 @@ int VITA_JoystickInit(void)
 
     /* Create an accurate map from analog inputs (0 to 255)
        to SDL joystick positions (-32768 to 32767) */
-    for (i = 0; i < 128; i++)
-    {
+    for (i = 0; i < 128; i++) {
         float t = (float)i/127.0f;
         analog_map[i+128] = calc_bezier_y(t);
         analog_map[127-i] = -1 * analog_map[i+128];
@@ -137,10 +136,8 @@ int VITA_JoystickInit(void)
 
     // On Vita TV, port 0 and 1 are the same controller
     // and that is the first one, so start at port 2
-    for (i=2; i<=4; i++)
-    {
-        if (myPortInfo.port[i]!=SCE_CTRL_TYPE_UNPAIRED)
-        {
+    for (i=2; i<=4; i++) {
+        if (myPortInfo.port[i]!=SCE_CTRL_TYPE_UNPAIRED) {
             SDL_PrivateJoystickAdded(SDL_numjoysticks);
             SDL_numjoysticks++;
         }
@@ -165,17 +162,21 @@ SDL_JoystickID VITA_JoystickGetDeviceInstanceID(int device_index)
 
 const char *VITA_JoystickGetDeviceName(int index)
 {
-    if (index == 0)
+    if (index == 0) {
         return "PSVita Controller";
+    }
 
-    if (index == 1)
+    if (index == 1) {
         return "PSVita Controller";
+    }
 
-    if (index == 2)
+    if (index == 2) {
         return "PSVita Controller";
+    }
 
-    if (index == 3)
+    if (index == 3) {
         return "PSVita Controller";
+    }
 
     SDL_SetError("No joystick available with that index");
     return NULL;
diff --git a/src/joystick/windows/SDL_dinputjoystick.c b/src/joystick/windows/SDL_dinputjoystick.c
index 9c5a46bd0..1b6cc9405 100644
--- a/src/joystick/windows/SDL_dinputjoystick.c
+++ b/src/joystick/windows/SDL_dinputjoystick.c
@@ -272,7 +272,7 @@ QueryDeviceName(LPDIRECTINPUTDEVICE8 device, char** device_name)
 {
     DIPROPSTRING dipstr;
 
-    if (!device || !device_name) {
+    if (!device || device_name == NULL) {
         return SDL_FALSE;
     }
 
@@ -295,7 +295,7 @@ QueryDevicePath(LPDIRECTINPUTDEVICE8 device, char** device_path)
 {
     DIPROPGUIDANDPATH dippath;
 
-    if (!device || !device_path) {
+    if (!device || device_path == NULL) {
         return SDL_FALSE;
     }
 
@@ -321,7 +321,7 @@ QueryDeviceInfo(LPDIRECTINPUTDEVICE8 device, Uint16* vendor_id, Uint16* product_
 {
     DIPROPDWORD dipdw;
 
-    if (!device || !vendor_id || !product_id) {
+    if (!device || vendor_id == NULL || product_id == NULL) {
         return SDL_FALSE;
     }
 
@@ -343,7 +343,7 @@ QueryDeviceInfo(LPDIRECTINPUTDEVICE8 device, Uint16* vendor_id, Uint16* product_
 
 void FreeRumbleEffectData(DIEFFECT *effect)
 {
-    if (!effect) {
+    if (effect == NULL) {
         return;
     }
     SDL_free(effect->rgdwAxes);
@@ -359,7 +359,7 @@ DIEFFECT *CreateRumbleEffectData(Sint16 magnitude)
 
     /* Create the effect */
     effect = (DIEFFECT *)SDL_calloc(1, sizeof(*effect));
-    if (!effect) {
+    if (effect == NULL) {
         return NULL;
     }
     effect->dwSize = sizeof(*effect);
@@ -383,7 +383,7 @@ DIEFFECT *CreateRumbleEffectData(Sint16 magnitude)
     effect->dwFlags |= DIEFF_CARTESIAN;
 
     periodic = (DIPERIODIC *)SDL_calloc(1, sizeof(*periodic));
-    if (!periodic) {
+    if (periodic == NULL) {
         FreeRumbleEffectData(effect);
         return NULL;
     }
@@ -443,7 +443,7 @@ SDL_DINPUT_JoystickInit(void)
 static BOOL CALLBACK
 EnumJoystickDetectCallback(LPCDIDEVICEINSTANCE pDeviceInstance, LPVOID pContext)
 {
-#define CHECK(expression) { if(!(expression)) goto err; }
+#define CHECK(expression) { if (!(expression)) goto err; }
     JoyStick_DeviceData *pNewJoystick = NULL;
     JoyStick_DeviceData *pPrevJoystick = NULL;
     Uint16 vendor = 0;
@@ -470,8 +470,7 @@ EnumJoystickDetectCallback(LPCDIDEVICEINSTANCE pDeviceInstance, LPVOID pContext)
             /* if we are replacing the front of the list then update it */
             if (pNewJoystick == *(JoyStick_DeviceData**)pContext) {
                 *(JoyStick_DeviceData**)pContext = pNewJoystick->pNext;
-            }
-            else if (pPrevJoystick) {
+            } else if (pPrevJoystick) {
                 pPrevJoystick->pNext = pNewJoystick->pNext;
             }
 
@@ -556,7 +555,7 @@ typedef struct
 static BOOL CALLBACK
 EnumJoystickPresentCallback(LPCDIDEVICEINSTANCE pDeviceInstance, LPVOID pContext)
 {
-#define CHECK(expression) { if(!(expression)) goto err; }
+#define CHECK(expression) { if (!(expression)) goto err; }
     Joystick_PresentData *pData = (Joystick_PresentData *)pContext;
     Uint16 vendor = 0;
     Uint16 product = 0;
@@ -692,10 +691,12 @@ SortDevFunc(const void *a, const void *b)
     const input_t *inputA = (const input_t*)a;
     const input_t *inputB = (const input_t*)b;
 
-    if (inputA->ofs < inputB->ofs)
+    if (inputA->ofs < inputB->ofs) {
         return -1;
-    if (inputA->ofs > inputB->ofs)
+    }
+    if (inputA->ofs > inputB->ofs) {
         return 1;
+    }
     return 0;
 }
 
@@ -967,16 +968,18 @@ TranslatePOV(DWORD value)
         SDL_HAT_UP | SDL_HAT_LEFT
     };
 
-    if (LOWORD(value) == 0xFFFF)
+    if (LOWORD(value) == 0xFFFF) {
         return SDL_HAT_CENTERED;
+    }
 
     /* Round the value up: */
     value += 4500 / 2;
     value %= 36000;
     value /= 4500;
 
-    if (value >= 8)
-        return SDL_HAT_CENTERED;        /* shouldn't happen */
+    if (value >= 8) {
+        return SDL_HAT_CENTERED; /* shouldn't happen */
+    }
 
     return HAT_VALS[value];
 }
@@ -1087,8 +1090,9 @@ UpdateDINPUTJoystickState_Buffered(SDL_Joystick * joystick)
         for (j = 0; j < joystick->hwdata->NumInputs; ++j) {
             const input_t *in = &joystick->hwdata->Inputs[j];
 
-            if (evtbuf[i].dwOfs != in->ofs)
+            if (evtbuf[i].dwOfs != in->ofs) {
                 continue;
+            }
 
             switch (in->type) {
             case AXIS:
diff --git a/src/joystick/windows/SDL_rawinputjoystick.c b/src/joystick/windows/SDL_rawinputjoystick.c
index fc738b07f..2583a8400 100644
--- a/src/joystick/windows/SDL_rawinputjoystick.c
+++ b/src/joystick/windows/SDL_rawinputjoystick.c
@@ -258,8 +258,9 @@ static void RAWINPUT_FillMatchState(WindowsMatchState *state, Uint64 match_state
         ((match_state & (1<<SDL_CONTROLLER_BUTTON_DPAD_RIGHT)) ? XINPUT_GAMEPAD_DPAD_RIGHT : 0);
     */
 
-    if (state->xinput_buttons)
+    if (state->xinput_buttons) {
         state->any_data = SDL_TRUE;
+    }
 #endif
 
 #ifdef SDL_JOYSTICK_RAWINPUT_WGI
@@ -296,8 +297,9 @@ static void RAWINPUT_FillMatchState(WindowsMatchState *state, Uint64 match_state
         ((match_state & (1<<SDL_CONTROLLER_BUTTON_DPAD_LEFT)) ? GamepadButtons_DPadLeft : 0) |
         ((match_state & (1<<SDL_CONTROLLER_BUTTON_DPAD_RIGHT)) ? GamepadButtons_DPadRight : 0); */
 
-    if (state->wgi_buttons)
+    if (state->wgi_buttons) {
         state->any_data = SDL_TRUE;
+    }
 #endif
 
 }
@@ -471,11 +473,13 @@ static void
 RAWINPUT_UpdateWindowsGamingInput()
 {
     int ii;
-    if (!wgi_state.gamepad_statics)
+    if (!wgi_state.gamepad_statics) {
         return;
+    }
 
-    if (!wgi_state.dirty)
+    if (!wgi_state.dirty) {
         return;
+    }
 
     wgi_state.dirty = SDL_FALSE;
 
@@ -519,7 +523,7 @@ RAWINPUT_UpdateWindowsGamingInput()
                                 return;
                             }
                             gamepad_state = SDL_calloc(1, sizeof(*gamepad_state));
-                            if (!gamepad_state) {
+                            if (gamepad_state == NULL) {
                                 SDL_OutOfMemory();
                                 return;
                             }
@@ -702,8 +706,9 @@ RAWINPUT_DeviceFromHandle(HANDLE hDevice)
     SDL_RAWINPUT_Device *curr;
 
     for (curr = SDL_RAWINPUT_devices; curr; curr = curr->next) {
-        if (curr->hDevice == hDevice)
+        if (curr->hDevice == hDevice) {
             return curr;
+        }
     }
     return NULL;
 }
@@ -711,7 +716,7 @@ RAWINPUT_DeviceFromHandle(HANDLE hDevice)
 static void
 RAWINPUT_AddDevice(HANDLE hDevice)
 {
-#define CHECK(expression) { if(!(expression)) goto err; }
+#define CHECK(expression) { if (!(expression)) goto err; }
     SDL_RAWINPUT_Device *device = NULL;
     SDL_RAWINPUT_Device *curr, *last;
     RID_DEVICE_INFO rdi;
@@ -1076,7 +1081,7 @@ RAWINPUT_JoystickOpen(SDL_Joystick *joystick, int device_index)
     ULONG i;
 
     ctx = (RAWINPUT_DeviceContext *)SDL_calloc(1, sizeof(RAWINPUT_DeviceContext));
-    if (!ctx) {
+    if (ctx == NULL) {
         return SDL_OutOfMemory();
     }
     joystick->hwdata = ctx;
@@ -1089,7 +1094,7 @@ RAWINPUT_JoystickOpen(SDL_Joystick *joystick, int device_index)
 #ifdef SDL_JOYSTICK_RAWINPUT_XINPUT
         xinput_device_change = SDL_TRUE;
         ctx->xinput_enabled = SDL_GetHintBoolean(SDL_HINT_JOYSTICK_RAWINPUT_CORRELATE_XINPUT, SDL_TRUE);
-        if (ctx->xinput_enabled && (WIN_LoadXInputDLL() < 0 || !XINPUTGETSTATE)) {
+        if (ctx->xinput_enabled && (WIN_LoadXInputDLL() < 0 || XINPUTGETSTATE == NULL)) {
             ctx->xinput_enabled = SDL_FALSE;
         }
         ctx->xinput_slot = XUSER_INDEX_ANY;
@@ -1285,7 +1290,7 @@ RAWINPUT_JoystickRumble(SDL_Joystick *joystick, Uint16 low_frequency_rumble, Uin
     if (!rumbled && ctx->xinput_correlated) {
         XINPUT_VIBRATION XVibration;
 
-        if (!XINPUTSETSTATE) {
+        if (XINPUTSETSTATE == NULL) {
             return SDL_Unsupported();
         }
 
@@ -1638,10 +1643,12 @@ RAWINPUT_UpdateOtherAPIs(SDL_Joystick *joystick)
                             correlated = SDL_TRUE;
                             RAWINPUT_MarkWindowsGamingInputSlotUsed(ctx->wgi_slot, ctx);
                             /* If the generalized Guide button was using us, it doesn't need to anymore */
-                            if (guide_button_candidate.joystick == joystick)
+                            if (guide_button_candidate.joystick == joystick) {
                                 guide_button_candidate.joystick = NULL;
-                            if (guide_button_candidate.last_joystick == joystick)
+                            }
+                            if (guide_button_candidate.last_joystick == joystick) {
                                 guide_button_candidate.last_joystick = NULL;
+                            }
                         }
                     } else {
                         /* someone else also possibly correlated to this device, start over */
@@ -1732,10 +1739,12 @@ RAWINPUT_UpdateOtherAPIs(SDL_Joystick *joystick)
                                 correlated = SDL_TRUE;
                                 RAWINPUT_MarkXInputSlotUsed(ctx->xinput_slot);
                                 /* If the generalized Guide button was using us, it doesn't need to anymore */
-                                if (guide_button_candidate.joystick == joystick)
+                                if (guide_button_candidate.joystick == joystick) {
                                     guide_button_candidate.joystick = NULL;
-                                if (guide_button_candidate.last_joystick == joystick)
+                                }
+                                if (guide_button_candidate.last_joystick == joystick) {
                                     guide_button_candidate.last_joystick = NULL;
+                                }
                             }
                         } else {
                             /* someone else also possibly correlated to this device, start over */
@@ -1847,10 +1856,12 @@ RAWINPUT_JoystickClose(SDL_Joystick *joystick)
     RAWINPUT_DeviceContext *ctx = joystick->hwdata;
 
 #ifdef SDL_JOYSTICK_RAWINPUT_MATCHING
-    if (guide_button_candidate.joystick == joystick)
+    if (guide_button_candidate.joystick == joystick) {
         guide_button_candidate.joystick = NULL;
-    if (guide_button_candidate.last_joystick == joystick)
+    }
+    if (guide_button_candidate.last_joystick == joystick) {
         guide_button_candidate.last_joystick = NULL;
+    }
 #endif
 
     if (ctx) {
diff --git a/src/joystick/windows/SDL_windows_gaming_input.c b/src/joystick/windows/SDL_windows_gaming_input.c
index 3a89d1154..c86c22873 100644
--- a/src/joystick/windows/SDL_windows_gaming_input.c
+++ b/src/joystick/windows/SDL_windows_gaming_input.c
@@ -216,7 +216,7 @@ typedef struct RawGameControllerDelegate {
 
 static HRESULT STDMETHODCALLTYPE IEventHandler_CRawGameControllerVtbl_QueryInterface(__FIEventHandler_1_Windows__CGaming__CInput__CRawGameController * This, REFIID riid, void **ppvObject)
 {
-    if (!ppvObject) {
+    if (ppvObject == NULL) {
         return E_INVALIDARG;
     }
 
@@ -306,7 +306,7 @@ static HRESULT STDMETHODCALLTYPE IEventHandler_CRawGameControllerVtbl_InvokeAdde
             }
             __x_ABI_CWindows_CGaming_CInput_CIRawGameController2_Release(controller2);
         }
-        if (!name) {
+        if (name == NULL) {
             name = SDL_strdup("");
         }
 
@@ -664,7 +664,7 @@ WGI_JoystickOpen(SDL_Joystick *joystick, int device_index)
     boolean wireless = SDL_FALSE;
 
     hwdata = (struct joystick_hwdata *)SDL_calloc(1, sizeof(*hwdata));
-    if (!hwdata) {
+    if (hwdata == NULL) {
         return SDL_OutOfMemory();
     }
     joystick->hwdata = hwdata;
diff --git a/src/joystick/windows/SDL_windowsjoystick.c b/src/joystick/windows/SDL_windowsjoystick.c
index ccd8f37bb..4d8d45187 100644
--- a/src/joystick/windows/SDL_windowsjoystick.c
+++ b/src/joystick/windows/SDL_windowsjoystick.c
@@ -252,11 +252,13 @@ SDL_CleanupDeviceNotification(SDL_DeviceNotificationData *data)
     RAWINPUT_UnregisterNotifications();
 #endif
 
-    if (data->hNotify)
+    if (data->hNotify) {
         UnregisterDeviceNotification(data->hNotify);
+    }
 
-    if (data->messageWindow)
+    if (data->messageWindow) {
         DestroyWindow(data->messageWindow);
+    }
 
     UnregisterClass(data->wincl.lpszClassName, data->wincl.hInstance);
 
@@ -400,18 +402,18 @@ static int
 SDL_StartJoystickThread(void)
 {
     s_mutexJoyStickEnum = SDL_CreateMutex();
-    if (!s_mutexJoyStickEnum) {
+    if (s_mutexJoyStickEnum == NULL) {
         return -1;
     }
 
     s_condJoystickThread = SDL_CreateCond();
-    if (!s_condJoystickThread) {
+    if (s_condJoystickThread == NULL) {
         return -1;
     }
 
     s_bJoystickThreadQuit = SDL_FALSE;
     s_joystickThread = SDL_CreateThreadInternal(SDL_JoystickThread, "SDL_joystick", 64 * 1024, NULL);
-    if (!s_joystickThread) {
+    if (s_joystickThread == NULL) {
         return -1;
     }
     return 0;
@@ -420,7 +422,7 @@ SDL_StartJoystickThread(void)
 static void
 SDL_StopJoystickThread(void)
 {
-    if (!s_joystickThread) {
+    if (s_joystickThread == NULL) {
         return;
     }
 
@@ -594,8 +596,9 @@ WINDOWS_JoystickGetDeviceName(int device_index)
     JoyStick_DeviceData *device = SYS_Joystick;
     int index;
 
-    for (index = device_index; index > 0; index--)
+    for (index = device_index; index > 0; index--) {
         device = device->pNext;
+    }
 
     return device->joystickname;
 }
@@ -606,8 +609,9 @@ WINDOWS_JoystickGetDevicePath(int device_index)
     JoyStick_DeviceData *device = SYS_Joystick;
     int index;
 
-    for (index = device_index; index > 0; index--)
+    for (index = device_index; index > 0; index--) {
         device = device->pNext;
+    }
 
     return device->path;
 }
@@ -618,8 +622,9 @@ WINDOWS_JoystickGetDevicePlayerIndex(int device_index)
     JoyStick_DeviceData *device = SYS_Joystick;
     int index;
 
-    for (index = device_index; index > 0; index--)
+    for (index = device_index; index > 0; index--) {
         device = device->pNext;
+    }
 
     return device->bXInputDevice ? (int)device->XInputUserId : -1;
 }
@@ -636,8 +641,9 @@ WINDOWS_JoystickGetDeviceGUID(int device_index)
     JoyStick_DeviceData *device = SYS_Joystick;
     int index;
 
-    for (index = device_index; index > 0; index--)
+    for (index = device_index; index > 0; index--) {
         device = device->pNext;
+    }
 
     return device->guid;
 }
@@ -649,8 +655,9 @@ WINDOWS_JoystickGetDeviceInstanceID(int device_index)
     JoyStick_DeviceData *device = SYS_Joystick;
     int index;
 
-    for (index = device_index; index > 0; index--)
+    for (index = device_index; index > 0; index--) {
         device = device->pNext;
+    }
 
     return device->nInstanceID;
 }
@@ -666,8 +673,9 @@ WINDOWS_JoystickOpen(SDL_Joystick *joystick, int device_index)
     JoyStick_DeviceData *device = SYS_Joystick;
     int index;
 
-    for (index = device_index; index > 0; index--)
+    for (index = device_index; index > 0; index--) {
         device = device->pNext;
+    }
 
     /* allocate memory for system specific hardware data */
     joystick->instance_id = device->nInstanceID;
diff --git a/src/joystick/windows/SDL_xinputjoystick.c b/src/joystick/windows/SDL_xinputjoystick.c
index 4fa3555b9..091c641df 100644
--- a/src/joystick/windows/SDL_xinputjoystick.c
+++ b/src/joystick/windows/SDL_xinputjoystick.c
@@ -49,7 +49,7 @@ SDL_XInputUseOldJoystickMapping()
 #ifdef __WINRT__
     /* TODO: remove this __WINRT__ block, but only after integrating with UWP/WinRT's HID API */
     /* FIXME: Why are Win8/10 different here? -flibit */
-    return (NTDDI_VERSION < NTDDI_WIN10);
+    return NTDDI_VERSION < NTDDI_WIN10;
 #elif defined(__XBOXONE__) || defined(__XBOXSERIES__)
     return SDL_FALSE;
 #else
@@ -57,7 +57,7 @@ SDL_XInputUseOldJoystickMapping()
     if (s_XInputUseOldJoystickMapping < 0) {
         s_XInputUseOldJoystickMapping = SDL_GetHintBoolean(SDL_HINT_XINPUT_USE_OLD_JOYSTICK_MAPPING, SDL_FALSE);
     }
-    return (s_XInputUseOldJoystickMapping > 0);
+    return s_XInputUseOldJoystickMapping > 0;
 #endif
 }
 
@@ -248,11 +248,13 @@ AddXInputDevice(Uint8 userid, BYTE SubType, JoyStick_DeviceData **pContext)
     JoyStick_DeviceData *pPrevJoystick = NULL;
     JoyStick_DeviceData *pNewJoystick = *pContext;
 
-    if (SDL_XInputUseOldJoystickMapping() && SubType != XINPUT_DEVSUBTYPE_GAMEPAD)
+    if (SDL_XInputUseOldJoystickMapping() && SubType != XINPUT_DEVSUBTYPE_GAMEPAD) {
         return;
+    }
 
-    if (SubType == XINPUT_DEVSUBTYPE_UNKNOWN)
+    if (SubType == XINPUT_DEVSUBTYPE_UNKNOWN) {
         return;
+    }
 
     while (pNewJoystick) {
         if (pNewJoystick->bXInputDevice && (pNewJoystick->XInputUserId == userid) && (pNewJoystick->SubType == SubType)) {
@@ -273,7 +275,7 @@ AddXInputDevice(Uint8 userid, BYTE SubType, JoyStick_DeviceData **pContext)
     }
 
     pNewJoystick = (JoyStick_DeviceData *)SDL_calloc(1, sizeof(JoyStick_DeviceData));
-    if (!pNewJoystick) {
+    if (pNewJoystick == NULL) {
         return; /* better luck next time? */
     }
 
@@ -521,8 +523,9 @@ SDL_XINPUT_JoystickUpdate(SDL_Joystick * joystick)
     XINPUT_STATE_EX XInputState;
     XINPUT_BATTERY_INFORMATION_EX XBatteryInformation;
 
-    if (!XINPUTGETSTATE)
+    if (!XINPUTGETSTATE) {
         return;
+    }
 
     result = XINPUTGETSTATE(joystick->hwdata->userid, &XInputState);
     if (result == ERROR_DEVICE_NOT_CONNECTED) {
diff --git a/src/loadso/dlopen/SDL_sysloadso.c b/src/loadso/dlopen/SDL_sysloadso.c
index 3b55a6e81..54337b92e 100644
--- a/src/loadso/dlopen/SDL_sysloadso.c
+++ b/src/loadso/dlopen/SDL_sysloadso.c
@@ -52,7 +52,7 @@ SDL_LoadObject(const char *sofile)
     if (handle == NULL) {
         SDL_SetError("Failed loading %s: %s", sofile, loaderror);
     }
-    return (handle);
+    return handle;
 }
 
 void *
@@ -73,7 +73,7 @@ SDL_LoadFunction(void *handle, const char *name)
                          (const char *) dlerror());
         }
     }
-    return (symbol);
+    return symbol;
 }
 
 void
diff --git a/src/loadso/dummy/SDL_sysloadso.c b/src/loadso/dummy/SDL_sysloadso.c
index da45a842f..feb1630ae 100644
--- a/src/loadso/dummy/SDL_sysloadso.c
+++ b/src/loadso/dummy/SDL_sysloadso.c
@@ -32,7 +32,7 @@ SDL_LoadObject(const char *sofile)
 {
     const char *loaderror = "SDL_LoadObject() not implemented";
     SDL_SetError("Failed loading %s: %s", sofile, loaderror);
-    return (NULL);
+    return NULL;
 }
 
 void *
@@ -40,7 +40,7 @@ SDL_LoadFunction(void *handle, const char *name)
 {
     const char *loaderror = "SDL_LoadFunction() not implemented";
     SDL_SetError("Failed loading %s: %s", name, loaderror);
-    return (NULL);
+    return NULL;
 }
 
 void
diff --git a/src/loadso/windows/SDL_sysloadso.c b/src/loadso/windows/SDL_sysloadso.c
index 1157ed3b5..3db6be2d0 100644
--- a/src/loadso/windows/SDL_sysloadso.c
+++ b/src/loadso/windows/SDL_sysloadso.c
@@ -35,7 +35,7 @@ SDL_LoadObject(const char *sofile)
     void *handle;
     LPTSTR tstr;
 
-    if (!sofile) {
+    if (sofile == NULL) {
         SDL_InvalidParamError("sofile");
         return NULL;
     }
diff --git a/src/locale/SDL_locale.c b/src/locale/SDL_locale.c
index 5aaf87284..c9fa4787a 100644
--- a/src/locale/SDL_locale.c
+++ b/src/locale/SDL_locale.c
@@ -33,7 +33,7 @@ build_locales_from_csv_string(char *csv)
     SDL_Locale *loc;
     SDL_Locale *retval;
 
-    if (!csv || !csv[0]) {
+    if (csv == NULL || !csv[0]) {
         return NULL;  /* nothing to report */
     }
 
@@ -49,7 +49,7 @@ build_locales_from_csv_string(char *csv)
     alloclen = slen + (num_locales * sizeof (SDL_Locale));
 
     loc = retval = (SDL_Locale *) SDL_calloc(1, alloclen);
-    if (!retval) {
+    if (retval == NULL) {
         SDL_OutOfMemory();
         return NULL;  /* oh well */
     }
@@ -57,7 +57,10 @@ build_locales_from_csv_string(char *csv)
     SDL_strlcpy(ptr, csv, slen);
 
     while (SDL_TRUE) {  /* parse out the string */
-        while (*ptr == ' ') ptr++;  /* skip whitespace. */
+        while (*ptr == ' ') {
+            ptr++; /* skip whitespace. */
+        }
+
         if (*ptr == '\0') {
             break;
         }
diff --git a/src/locale/unix/SDL_syslocale.c b/src/locale/unix/SDL_syslocale.c
index b9a377439..518856a36 100644
--- a/src/locale/unix/SDL_syslocale.c
+++ b/src/locale/unix/SDL_syslocale.c
@@ -74,7 +74,7 @@ SDL_SYS_GetPreferredLocales(char *buf, size_t buflen)
 
     SDL_assert(buflen > 0);
     tmp = SDL_small_alloc(char, buflen, &isstack);
-    if (!tmp) {
+    if (tmp == NULL) {
         SDL_OutOfMemory();
         return;
     }
diff --git a/src/locale/vita/SDL_syslocale.c b/src/locale/vita/SDL_syslocale.c
index 0a057cbfa..cde912cf8 100644
--- a/src/locale/vita/SDL_syslocale.c
+++ b/src/locale/vita/SDL_syslocale.c
@@ -59,8 +59,9 @@ SDL_SYS_GetPreferredLocales(char *buf, size_t buflen)
     sceAppUtilInit(&initParam, &bootParam);
     sceAppUtilSystemParamGetInt(SCE_SYSTEM_PARAM_ID_LANG, &language);
 
-    if (language < 0 || language > SCE_SYSTEM_PARAM_LANG_TURKISH)
+    if (language < 0 || language > SCE_SYSTEM_PARAM_LANG_TURKISH) {
         language = SCE_SYSTEM_PARAM_LANG_ENGLISH_US; // default to english
+    }
 
     SDL_strlcpy(buf, vita_locales[language], buflen);
 
diff --git a/src/locale/windows/SDL_syslocale.c b/src/locale/windows/SDL_syslocale.c
index 2d033f476..3bbaa1e68 100644
--- a/src/locale/windows/SDL_syslocale.c
+++ b/src/locale/windows/SDL_syslocale.c
@@ -68,7 +68,7 @@ SDL_SYS_GetPreferredLocales_vista(char *buf, size_t buflen)
     pGetUserPreferredUILanguages(MUI_LANGUAGE_NAME, &numlangs, NULL, &wbuflen);
 
     wbuf = SDL_small_alloc(WCHAR, wbuflen, &isstack);
-    if (!wbuf) {
+    if (wbuf == NULL) {
         SDL_OutOfMemory();
         return;
     }
diff --git a/src/locale/winrt/SDL_syslocale.c b/src/locale/winrt/SDL_syslocale.c
index 1af2a95fc..55de84521 100644
--- a/src/locale/winrt/SDL_syslocale.c
+++ b/src/locale/winrt/SDL_syslocale.c
@@ -40,8 +40,7 @@ SDL_SYS_GetPreferredLocales(char *buf, size_t buflen)
     ret = GetSystemDefaultLocaleName(wbuffer, SDL_arraysize(wbuffer));
 # endif
 
-    if (ret > 0)
-    {
+    if (ret > 0) {
         /* Need to convert LPWSTR to LPSTR, that is wide char to char. */
         int i;
 
diff --git a/src/main/dummy/SDL_dummy_main.c b/src/main/dummy/SDL_dummy_main.c
index b78d8db14..4abe47d07 100644
--- a/src/main/dummy/SDL_dummy_main.c
+++ b/src/main/dummy/SDL_dummy_main.c
@@ -11,7 +11,7 @@
 int
 main(int argc, char *argv[])
 {
-    return (SDL_main(argc, argv));
+    return SDL_main(argc, argv);
 }
 #else
 /* Nothing to do on this platform */
diff --git a/src/main/haiku/SDL_BeApp.cc b/src/main/haiku/SDL_BeApp.cc
index a5e1428cc..1fb6fe1b2 100644
--- a/src/main/haiku/SDL_BeApp.cc
+++ b/src/main/haiku/SDL_BeApp.cc
@@ -65,8 +65,9 @@ StartBeApp(void *unused)
             BAppFileInfo app_info(&f);
             if (app_info.InitCheck() == B_OK) {
                 char sig[B_MIME_TYPE_LENGTH];
-                if (app_info.GetSignature(sig) == B_OK)
+                if (app_info.GetSignature(sig) == B_OK) {
                     signature = strndup(sig, B_MIME_TYPE_LENGTH);
+                }
             }
         }
     }
@@ -75,7 +76,7 @@ StartBeApp(void *unused)
 
     App->Run();
     delete App;
-    return (0);
+    return 0;
 }
 
 /* Initialize the Be Application, if it's not already started */
@@ -116,7 +117,7 @@ SDL_InitBeApp(void)
     ++SDL_BeAppActive;
 
     /* The app is running, and we're ready to go */
-    return (0);
+    return 0;
 }
 
 /* Quit the Be Application, if there's nothing left to do */
@@ -147,7 +148,7 @@ SDL_QuitBeApp(void)
 void SDL_BApp::ClearID(SDL_BWin *bwin) {
     _SetSDLWindow(NULL, bwin->GetID());
     int32 i = _GetNumWindowSlots() - 1;
-    while(i >= 0 && GetSDLWindow(i) == NULL) {
+    while (i >= 0 && GetSDLWindow(i) == NULL) {
         _PopBackWindow();
         --i;
     }
diff --git a/src/main/ngage/SDL_ngage_main.cpp b/src/main/ngage/SDL_ngage_main.cpp
index 6dbf2f141..dc83a8b65 100644
--- a/src/main/ngage/SDL_ngage_main.cpp
+++ b/src/main/ngage/SDL_ngage_main.cpp
@@ -58,13 +58,10 @@ TInt E32Main()
 
     newHeap = User::ChunkHeap(NULL, heapSize, heapSize, KMinHeapGrowBy);
 
-    if (NULL == newHeap)
-    {
+    if (newHeap == NULL) {
         ret = 3;
         goto cleanup;
-    }
-    else
-    {
+    } else {
         oldHeap = User::SwitchHeap(newHeap);
         /* Call stdlib main */
         SDL_SetMainReady();
diff --git a/src/main/ps2/SDL_ps2_main.c b/src/main/ps2/SDL_ps2_main.c
index e9a4b513d..0525797d2 100644
--- a/src/main/ps2/SDL_ps2_main.c
+++ b/src/main/ps2/SDL_ps2_main.c
@@ -28,9 +28,9 @@
 __attribute__((weak))
 void reset_IOP() {
     SifInitRpc(0);
-    while(!SifIopReset(NULL, 0)) {
+    while (!SifIopReset(NULL, 0)) {
     }
-    while(!SifIopSync()){
+    while (!SifIopSync()) {
     }
 }
 
@@ -59,7 +59,7 @@ static void waitUntilDeviceIsReady(char *path)
     int ret = -1;
     int retries = 50;
 
-    while(ret != 0 && retries > 0) {
+    while (ret != 0 && retries > 0) {
         ret = stat(path, &buffer);
         /* Wait until the device is ready */
         nopdelay();
diff --git a/src/main/psp/SDL_psp_main.c b/src/main/psp/SDL_psp_main.c
index 8eb173fb4..6e7bc8eef 100644
--- a/src/main/psp/SDL_psp_main.c
+++ b/src/main/psp/SDL_psp_main.c
@@ -47,8 +47,9 @@ int sdl_psp_setup_callbacks(void)
     int thid;
     thid = sceKernelCreateThread("update_thread",
                      sdl_psp_callback_thread, 0x11, 0xFA0, 0, 0);
-    if(thid >= 0)
+    if (thid >= 0) {
         sceKernelStartThread(thid, 0, 0);
+    }
     return thid;
 }
 
diff --git a/src/main/windows/SDL_windows_main.c b/src/main/windows/SDL_windows_main.c
index 70fb9b9b7..dd477aec3 100644
--- a/src/main/windows/SDL_windows_main.c
+++ b/src/main/windows/SDL_windows_main.c
@@ -56,13 +56,13 @@ main_getcmdline(void)
 
     /* Parse it into argv and argc */
     argv = (char **)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, (argc + 1) * sizeof(*argv));
-    if (!argv) {
+    if (argv == NULL) {
         return OutOfMemory();
     }
     for (i = 0; i < argc; ++i) {
         DWORD len;
         char *arg = WIN_StringToUTF8W(argvw[i]);
-        if (!arg) {
+        if (arg == NULL) {
             return OutOfMemory();
         }
         len = (DWORD)SDL_strlen(arg);
diff --git a/src/misc/SDL_url.c b/src/misc/SDL_url.c
index eb258d962..8091bd8d2 100644
--- a/src/misc/SDL_url.c
+++ b/src/misc/SDL_url.c
@@ -26,7 +26,7 @@ extern int SDL_SYS_OpenURL(const char *url);
 int
 SDL_OpenURL(const char *url)
 {
-    if (!url) {
+    if (url == NULL) {
         return SDL_InvalidParamError("url");
     }
     return SDL_SYS_OpenURL(url);
diff --git a/src/power/emscripten/SDL_syspower.c b/src/power/emscripten/SDL_syspower.c
index 4bac68602..75352ef0d 100644
--- a/src/power/emscripten/SDL_syspower.c
+++ b/src/power/emscripten/SDL_syspower.c
@@ -33,8 +33,9 @@ SDL_GetPowerInfo_Emscripten(SDL_PowerState *state, int *seconds, int *percent)
     EmscriptenBatteryEvent batteryState;
     int haveBattery = 0;
 
-    if (emscripten_get_battery_status(&batteryState) == EMSCRIPTEN_RESULT_NOT_SUPPORTED)
+    if (emscripten_get_battery_status(&batteryState) == EMSCRIPTEN_RESULT_NOT_SUPPORTED) {
         return SDL_FALSE;
+    }
 
     haveBattery = batteryState.level != 1.0 || !batteryState.charging || batteryState.chargingTime != 0.0;
 
diff --git a/src/power/linux/SDL_syspower.c b/src/power/linux/SDL_syspower.c
index c33ab5c94..d14a77d51 100644
--- a/src/power/linux/SDL_syspower.c
+++ b/src/power/linux/SDL_syspower.c
@@ -303,11 +303,13 @@ next_string(char **_ptr, char **_str)
     }
 
     str = ptr;
-    while ((*ptr != ' ') && (*ptr != '\n') && (*ptr != '\0'))
+    while ((*ptr != ' ') && (*ptr != '\n') && (*ptr != '\0')) {
         ptr++;
+    }
 
-    if (*ptr != '\0')
+    if (*ptr != '\0') {
         *(ptr++) = '\0';
+    }
 
     *_str = str;
     *_ptr = ptr;
@@ -319,7 +321,7 @@ int_string(char *str, int *val)
 {
     char *endptr = NULL;
     *val = (int) SDL_strtol(str, &endptr, 0);
-    return ((*str != '\0') && (*endptr == '\0'));
+    return (*str != '\0') && (*endptr == '\0');
 }
 
 /* http://lxr.linux.no/linux+v2.6.29/drivers/char/apm-emulation.c */
@@ -439,7 +441,7 @@ SDL_GetPowerInfo_Linux_sys_class_power_supply(SDL_PowerState *state, int *second
     DIR *dirp;
 
     dirp = opendir(base);
-    if (!dirp) {
+    if (dirp == NULL) {
         return SDL_FALSE;
     }
 
@@ -633,9 +635,9 @@ SDL_GetPowerInfo_Linux_org_freedesktop_upower(SDL_PowerState *state, int *second
     char **paths = NULL;
     int i, numpaths = 0;
 
-    if (!dbus || !SDL_DBus_CallMethodOnConnection(dbus->system_conn, UPOWER_DBUS_NODE, UPOWER_DBUS_PATH, UPOWER_DBUS_INTERFACE, "EnumerateDevices",
-            DBUS_TYPE_INVALID,
-            DBUS_TYPE_ARRAY, DBUS_TYPE_OBJECT_PATH, &paths, &numpaths, DBUS_TYPE_INVALID)) {
+    if (dbus == NULL || !SDL_DBus_CallMethodOnConnection(dbus->system_conn, UPOWER_DBUS_NODE, UPOWER_DBUS_PATH, UPOWER_DBUS_INTERFACE, "EnumerateDevices",
+                                                         DBUS_TYPE_INVALID,
+                                                         DBUS_TYPE_ARRAY, DBUS_TYPE_OBJECT_PATH, &paths, &numpaths, DBUS_TYPE_INVALID)) {
         return SDL_FALSE;  /* try a different approach than UPower. */
     }
 
diff --git a/src/power/windows/SDL_syspower.c b/src/power/windows/SDL_syspower.c
index 666b563a7..02e4fa849 100644
--- a/src/power/windows/SDL_syspower.c
+++ b/src/power/windows/SDL_syspower.c
@@ -34,8 +34,7 @@ SDL_GetPowerInfo_Windows(SDL_PowerState * state, int *seconds, int *percent)
     SDL_bool need_details = SDL_FALSE;
 
     /* This API should exist back to Win95. */
-    if (!GetSystemPowerStatus(&status))
-    {
+    if (!GetSystemPowerStatus(&status)) {
         /* !!! FIXME: push GetLastError() into SDL_GetError() */
         *state = SDL_POWERSTATE_UNKNOWN;
     } else if (status.BatteryFlag == 0xFF) {    /* unknown state */
diff --git a/src/render/SDL_render.c b/src/render/SDL_render.c
index 5f821b33e..f49272e46 100644
--- a/src/render/SDL_render.c
+++ b/src/render/SDL_render.c
@@ -336,7 +336,7 @@ AllocateRenderCommand(SDL_Renderer *renderer)
         retval->next = NULL;
     } else {
         retval = SDL_calloc(1, sizeof (*retval));
-        if (!retval) {
+        if (retval == NULL) {
             SDL_OutOfMemory();
             return NULL;
         }
@@ -969,7 +969,7 @@ SDL_CreateRenderer(SDL_Window * window, int index, Uint32 flags)
     Android_ActivityMutex_Lock_Running();
 #endif
 
-    if (!window) {
+    if (window == NULL) {
         SDL_InvalidParamError("window");
         goto error;
     }
@@ -1005,7 +1005,7 @@ SDL_CreateRenderer(SDL_Window * window, int index, Uint32 flags)
             }
         }
 
-        if (!renderer) {
+        if (renderer == NULL) {
             for (index = 0; index < n; ++index) {
                 const SDL_RenderDriver *driver = render_drivers[index];
 
@@ -1019,7 +1019,7 @@ SDL_CreateRenderer(SDL_Window * window, int index, Uint32 flags)
                 }
             }
         }
-        if (!renderer) {
+        if (renderer == NULL) {
             SDL_SetError("Couldn't find matching render driver");
             goto error;
         }
@@ -1032,7 +1032,7 @@ SDL_CreateRenderer(SDL_Window * window, int index, Uint32 flags)
         /* Create a new renderer instance */
         renderer = render_drivers[index]->CreateRenderer(window, flags);
         batching = SDL_FALSE;
-        if (!renderer) {
+        if (renderer == NULL) {
             goto error;
         }
     }
@@ -1257,7 +1257,7 @@ static SDL_ScaleMode SDL_GetScaleMode(void)
 {
     const char *hint = SDL_GetHint(SDL_HINT_RENDER_SCALE_QUALITY);
 
-    if (!hint || SDL_strcasecmp(hint, "nearest") == 0) {
+    if (hint == NULL || SDL_strcasecmp(hint, "nearest") == 0) {
         return SDL_ScaleModeNearest;
     } else if (SDL_strcasecmp(hint, "linear") == 0) {
         return SDL_ScaleModeLinear;
@@ -1299,7 +1299,7 @@ SDL_CreateTexture(SDL_Renderer * renderer, Uint32 format, int access, int w, int
         return NULL;
     }
     texture = (SDL_Texture *) SDL_calloc(1, sizeof(*texture));
-    if (!texture) {
+    if (texture == NULL) {
         SDL_OutOfMemory();
         return NULL;
     }
@@ -1391,7 +1391,7 @@ SDL_CreateTextureFromSurface(SDL_Renderer * renderer, SDL_Surface * surface)
 
     CHECK_RENDERER_MAGIC(renderer, NULL);
 
-    if (!surface) {
+    if (surface == NULL) {
         SDL_InvalidParamError("SDL_CreateTextureFromSurface(): surface");
         return NULL;
     }
@@ -1455,7 +1455,7 @@ SDL_CreateTextureFromSurface(SDL_Renderer * renderer, SDL_Surface * surface)
 
     texture = SDL_CreateTexture(renderer, format, SDL_TEXTUREACCESS_STATIC,
                                 surface->w, surface->h);
-    if (!texture) {
+    if (texture == NULL) {
         return NULL;
     }
 
@@ -1499,7 +1499,7 @@ SDL_CreateTextureFromSurface(SDL_Renderer * renderer, SDL_Surface * surface)
 
         /* Set up a destination surface for the texture update */
         dst_fmt = SDL_AllocFormat(format);
-        if (!dst_fmt) {
+        if (dst_fmt == NULL) {
            SDL_DestroyTexture(texture);
            return NULL;
         }
@@ -1730,7 +1730,7 @@ SDL_UpdateTextureYUV(SDL_Texture * texture, const SDL_Rect * rect,
         const size_t alloclen = rect->h * temp_pitch;
         if (alloclen > 0) {
             void *temp_pixels = SDL_malloc(alloclen);
-            if (!temp_pixels) {
+            if (temp_pixels == NULL) {
                 return SDL_OutOfMemory();
             }
             SDL_SW_CopyYUVToRGB(texture->yuv, rect, native->format,
@@ -1771,7 +1771,7 @@ SDL_UpdateTextureNative(SDL_Texture * texture, const SDL_Rect * rect,
         const size_t alloclen = rect->h * temp_pitch;
         if (alloclen > 0) {
             void *temp_pixels = SDL_malloc(alloclen);
-            if (!temp_pixels) {
+            if (temp_pixels == NULL) {
                 return SDL_OutOfMemory();
             }
             SDL_ConvertPixels(rect->w, rect->h,
@@ -1792,7 +1792,7 @@ SDL_UpdateTexture(SDL_Texture * texture, const SDL_Rect * rect,
 
     CHECK_TEXTURE_MAGIC(texture, -1);
 
-    if (!pixels) {
+    if (pixels == NULL) {
         return SDL_InvalidParamError("pixels");
     }
     if (!pitch) {
@@ -1867,7 +1867,7 @@ SDL_UpdateTextureYUVPlanar(SDL_Texture * texture, const SDL_Rect * rect,
         const size_t alloclen = rect->h * temp_pitch;
         if (alloclen > 0) {
             void *temp_pixels = SDL_malloc(alloclen);
-            if (!temp_pixels) {
+            if (temp_pixels == NULL) {
                 return SDL_OutOfMemory();
             }
             SDL_SW_CopyYUVToRGB(texture->yuv, rect, native->format,
@@ -1918,7 +1918,7 @@ SDL_UpdateTextureNVPlanar(SDL_Texture * texture, const SDL_Rect * rect,
         const size_t alloclen = rect->h * temp_pitch;
         if (alloclen > 0) {
             void *temp_pixels = SDL_malloc(alloclen);
-            if (!temp_pixels) {
+            if (temp_pixels == NULL) {
                 return SDL_OutOfMemory();
             }
             SDL_SW_CopyYUVToRGB(texture->yuv, rect, native->format,
@@ -1944,19 +1944,19 @@ int SDL_UpdateYUVTexture(SDL_Texture * texture, const SDL_Rect * rect,
 
     CHECK_TEXTURE_MAGIC(texture, -1);
 
-    if (!Yplane) {
+    if (Yplane == NULL) {
         return SDL_InvalidParamError("Yplane");
     }
     if (!Ypitch) {
         return SDL_InvalidParamError("Ypitch");
     }
-    if (!Uplane) {
+    if (Uplane == NULL) {
         return SDL_InvalidParamError("Uplane");
     }
     if (!Upitch) {
         return SDL_InvalidParamError("Upitch");
     }
-    if (!Vplane) {
+    if (Vplane == NULL) {
         return SDL_InvalidParamError("Vplane");
     }
     if (!Vpitch) {
@@ -2010,13 +2010,13 @@ int SDL_UpdateNVTexture(SDL_Texture * texture, const SDL_Rect * rect,
 
     CHECK_TEXTURE_MAGIC(texture, -1);
 
-    if (!Yplane) {
+    if (Yplane == NULL) {
         return SDL_InvalidParamError("Yplane");
     }
     if (!Ypitch) {
         return SDL_InvalidParamError("Ypitch");
     }
-    if (!UVplane) {
+    if (UVplane == NULL) {
         return SDL_InvalidParamError("UVplane");
     }
     if (!UVpitch) {
@@ -2095,7 +2095,7 @@ SDL_LockTexture(SDL_Texture * texture, const SDL_Rect * rect,
         return SDL_SetError("SDL_LockTexture(): texture must be streaming");
     }
 
-    if (!rect) {
+    if (rect == NULL) {
         full_rect.x = 0;
         full_rect.y = 0;
         full_rect.w = texture->w;
@@ -2230,7 +2230,7 @@ SDL_UnlockTexture(SDL_Texture * texture)
 SDL_bool
 SDL_RenderTargetSupported(SDL_Renderer *renderer)
 {
-    if (!renderer || !renderer->SetRenderTarget) {
+    if (renderer == NULL || !renderer->SetRenderTarget) {
         return SDL_FALSE;
     }
     return (renderer->info.flags & SDL_RENDERER_TARGETTEXTURE) != 0;
@@ -2344,7 +2344,7 @@ UpdateLogicalSize(SDL_Renderer *renderer, SDL_bool flush_viewport_cmd)
     }
 
     hint = SDL_GetHint(SDL_HINT_RENDER_LOGICAL_SIZE_MODE);
-    if (hint && (*hint == '1' || SDL_strcasecmp(hint, "overscan") == 0))  {
+    if (hint && (*hint == '1' || SDL_strcasecmp(hint, "overscan") == 0)) {
 #if SDL_VIDEO_RENDER_D3D
         SDL_bool overscan_supported = SDL_TRUE;
         /* Unfortunately, Direct3D 9 doesn't support negative viewport numbers
@@ -2742,7 +2742,7 @@ RenderDrawPointsWithRects(SDL_Renderer * renderer,
     }
 
     frects = SDL_small_alloc(SDL_FRect, count, &isstack);
-    if (!frects) {
+    if (frects == NULL) {
         return SDL_OutOfMemory();
     }
 
@@ -2771,7 +2771,7 @@ SDL_RenderDrawPoints(SDL_Renderer * renderer,
 
     CHECK_RENDERER_MAGIC(renderer, -1);
 
-    if (!points) {
+    if (points == NULL) {
         return SDL_InvalidParamError("SDL_RenderDrawPoints(): points");
     }
     if (count < 1) {
@@ -2789,7 +2789,7 @@ SDL_RenderDrawPoints(SDL_Renderer * renderer,
         retval = RenderDrawPointsWithRects(renderer, points, count);
     } else {
         fpoints = SDL_small_alloc(SDL_FPoint, count, &isstack);
-        if (!fpoints) {
+        if (fpoints == NULL) {
             return SDL_OutOfMemory();
         }
         for (i = 0; i < count; ++i) {
@@ -2818,7 +2818,7 @@ RenderDrawPointsWithRectsF(SDL_Renderer * renderer,
     }
 
     frects = SDL_small_alloc(SDL_FRect, count, &isstack);
-    if (!frects) {
+    if (frects == NULL) {
         return SDL_OutOfMemory();
     }
 
@@ -2844,7 +2844,7 @@ SDL_RenderDrawPointsF(SDL_Renderer * renderer,
 
     CHECK_RENDERER_MAGIC(renderer, -1);
 
-    if (!points) {
+    if (points == NULL) {
         return SDL_InvalidParamError("SDL_RenderDrawPointsF(): points");
     }
     if (count < 1) {
@@ -2938,7 +2938,7 @@ static int RenderDrawLineBresenham(SDL_Renderer *renderer, int x1, int y1, int x
     }
 
     points = SDL_small_alloc(SDL_FPoint, numpixels, &isstack);
-    if (!points) {
+    if (points == NULL) {
         return SDL_OutOfMemory();
     }
     for (i = 0; i < numpixels; ++i) {
@@ -2982,7 +2982,7 @@ RenderDrawLinesWithRectsF(SDL_Renderer * renderer,
     SDL_bool draw_last = SDL_FALSE;
 
     frects = SDL_small_alloc(SDL_FRect, count-1, &isstack);
-    if (!frects) {
+    if (frects == NULL) {
         return SDL_OutOfMemory();
     }
 
@@ -3053,7 +3053,7 @@ SDL_RenderDrawLines(SDL_Renderer * renderer,
 
     CHECK_RENDERER_MAGIC(renderer, -1);
 
-    if (!points) {
+    if (points == NULL) {
         return SDL_InvalidParamError("SDL_RenderDrawLines(): points");
     }
     if (count < 2) {
@@ -3068,7 +3068,7 @@ SDL_RenderDrawLines(SDL_Renderer * renderer,
 #endif
 
     fpoints = SDL_small_alloc(SDL_FPoint, count, &isstack);
-    if (!fpoints) {
+    if (fpoints == NULL) {
         return SDL_OutOfMemory();
     }
 
@@ -3092,7 +3092,7 @@ SDL_RenderDrawLinesF(SDL_Renderer * renderer,
 
     CHECK_RENDERER_MAGIC(renderer, -1);
 
-    if (!points) {
+    if (points == NULL) {
         return SDL_InvalidParamError("SDL_RenderDrawLinesF(): points");
     }
     if (count < 2) {
@@ -3266,7 +3266,7 @@ SDL_RenderDrawRectF(SDL_Renderer * renderer, const SDL_FRect * rect)
     CHECK_RENDERER_MAGIC(renderer, -1);
 
     /* If 'rect' == NULL, then outline the whole surface */
-    if (!rect) {
+    if (rect == NULL) {
         RenderGetViewportSize(renderer, &frect);
         rect = &frect;
     }
@@ -3292,7 +3292,7 @@ SDL_RenderDrawRects(SDL_Renderer * renderer,
 
     CHECK_RENDERER_MAGIC(renderer, -1);
 
-    if (!rects) {
+    if (rects == NULL) {
         return SDL_InvalidParamError("SDL_RenderDrawRects(): rects");
     }
     if (count < 1) {
@@ -3322,7 +3322,7 @@ SDL_RenderDrawRectsF(SDL_Renderer * renderer,
 
     CHECK_RENDERER_MAGIC(renderer, -1);
 
-    if (!rects) {
+    if (rects == NULL) {
         return SDL_InvalidParamError("SDL_RenderDrawRectsF(): rects");
     }
     if (count < 1) {
@@ -3371,7 +3371,7 @@ SDL_RenderFillRectF(SDL_Renderer * renderer, const SDL_FRect * rect)
     CHECK_RENDERER_MAGIC(renderer, -1);
 
     /* If 'rect' == NULL, then outline the whole surface */
-    if (!rect) {
+    if (rect == NULL) {
         RenderGetViewportSize(renderer, &frect);
         rect = &frect;
     }
@@ -3389,7 +3389,7 @@ SDL_RenderFillRects(SDL_Renderer * renderer,
 
     CHECK_RENDERER_MAGIC(renderer, -1);
 
-    if (!rects) {
+    if (rects == NULL) {
         return SDL_InvalidParamError("SDL_RenderFillRects(): rects");
     }
     if (count < 1) {
@@ -3404,7 +3404,7 @@ SDL_RenderFillRects(SDL_Renderer * renderer,
 #endif
 
     frects = SDL_small_alloc(SDL_FRect, count, &isstack);
-    if (!frects) {
+    if (frects == NULL) {
         return SDL_OutOfMemory();
     }
     for (i = 0; i < count; ++i) {
@@ -3432,7 +3432,7 @@ SDL_RenderFillRectsF(SDL_Renderer * renderer,
 
     CHECK_RENDERER_MAGIC(renderer, -1);
 
-    if (!rects) {
+    if (rects == NULL) {
         return SDL_InvalidParamError("SDL_RenderFillRectsF(): rects");
     }
     if (count < 1) {
@@ -3447,7 +3447,7 @@ SDL_RenderFillRectsF(SDL_Renderer * renderer,
 #endif
 
     frects = SDL_small_alloc(SDL_FRect, count, &isstack);
-    if (!frects) {
+    if (frects == NULL) {
         return SDL_OutOfMemory();
     }
     for (i = 0; i < count; ++i) {
@@ -3999,7 +3999,7 @@ SDL_SW_RenderGeometryRaw(SDL_Renderer *renderer,
             x2 = xy2_[0]; y2 = xy2_[1];
 
             /* Check if triangle A B C is rectangle */
-            if ((x0 == x2 && y1 == y2) || (y0 == y2 && x1 == x2)){
+            if ((x0 == x2 && y1 == y2) || (y0 == y2 && x1 == x2)) {
                 /* ok */
             } else {
                 is_quad = 0;
@@ -4012,7 +4012,7 @@ SDL_SW_RenderGeometryRaw(SDL_Renderer *renderer,
             x2 = xy2_[0]; y2 = xy2_[1];
 
             /* Check if triangle A B C2 is rectangle */
-            if ((x0 == x2 && y1 == y2) || (y0 == y2 && x1 == x2)){
+            if ((x0 == x2 && y1 == y2) || (y0 == y2 && x1 == x2)) {
                 /* ok */
             } else {
                 is_quad = 0;
@@ -4121,7 +4121,7 @@ SDL_SW_RenderGeometryRaw(SDL_Renderer *renderer,
             prev[1] = k1;
             prev[2] = k2;
         }
-    } /* End for(), next triangle */
+    } /* End for (), next triangle */
 
     if (prev[0] != -1) {
         /* flush the last triangle */
@@ -4173,15 +4173,15 @@ SDL_RenderGeometryRaw(SDL_Renderer *renderer,
         }
     }
 
-    if (!xy) {
+    if (xy == NULL) {
         return SDL_InvalidParamError("xy");
     }
 
-    if (!color) {
+    if (color == NULL) {
         return SDL_InvalidParamError("color");
     }
 
-    if (texture && !uv) {
+    if (texture && uv == NULL) {
         return SDL_InvalidParamError("uv");
     }
 
diff --git a/src/render/SDL_yuv_sw.c b/src/render/SDL_yuv_sw.c
index 10fe54e69..2db8c708d 100644
--- a/src/render/SDL_yuv_sw.c
+++ b/src/render/SDL_yuv_sw.c
@@ -49,7 +49,7 @@ SDL_SW_CreateYUVTexture(Uint32 format, int w, int h)
     }
 
     swdata = (SDL_SW_YUVTexture *) SDL_calloc(1, sizeof(*swdata));
-    if (!swdata) {
+    if (swdata == NULL) {
         SDL_OutOfMemory();
         return NULL;
     }
@@ -125,7 +125,7 @@ SDL_SW_CreateYUVTexture(Uint32 format, int w, int h)
     }
 
     /* We're all done.. */
-    return (swdata);
+    return swdata;
 }
 
 int
@@ -346,8 +346,7 @@ SDL_SW_LockYUVTexture(SDL_SW_YUVTexture * swdata, const SDL_Rect * rect,
         if (rect
             && (rect->x != 0 || rect->y != 0 || rect->w != swdata->w
                 || rect->h != swdata->h)) {
-            return SDL_SetError
-                ("YV12, IYUV, NV12, NV21 textures only support full surface locks");
+            return SDL_SetError("YV12, IYUV, NV12, NV21 textures only support full surface locks");
         }
         break;
     }
@@ -407,7 +406,7 @@ SDL_SW_CopyYUVToRGB(SDL_SW_YUVTexture * swdata, const SDL_Rect * srcrect,
                 SDL_CreateRGBSurfaceFrom(pixels, w, h, bpp, pitch, Rmask,
                                          Gmask, Bmask, Amask);
             if (!swdata->display) {
-                return (-1);
+                return -1;
             }
         }
         if (!swdata->stretch) {
@@ -418,7 +417,7 @@ SDL_SW_CopyYUVToRGB(SDL_SW_YUVTexture * swdata, const SDL_Rect * srcrect,
                 SDL_CreateRGBSurface(0, swdata->w, swdata->h, bpp, Rmask,
                                      Gmask, Bmask, Amask);
             if (!swdata->stretch) {
-                return (-1);
+                return -1;
             }
         }
         pixels = swdata->stretch->pixels;
diff --git a/src/render/direct3d/SDL_render_d3d.c b/src/render/direct3d/SDL_render_d3d.c
index e68e4d86e..1bb62c317 100644
--- a/src/render/direct3d/SDL_render_d3d.c
+++ b/src/render/direct3d/SDL_render_d3d.c
@@ -551,7 +551,7 @@ D3D_CreateTexture(SDL_Renderer * renderer, SDL_Texture * texture)
     DWORD usage;
 
     texturedata = (D3D_TextureData *) SDL_calloc(1, sizeof(*texturedata));
-    if (!texturedata) {
+    if (texturedata == NULL) {
         return SDL_OutOfMemory();
     }
     texturedata->scaleMode = (texture->scaleMode == SDL_ScaleModeNearest) ? D3DTEXF_POINT : D3DTEXF_LINEAR;
@@ -590,7 +590,7 @@ D3D_RecreateTexture(SDL_Renderer * renderer, SDL_Texture * texture)
     D3D_RenderData *data = (D3D_RenderData *)renderer->driverdata;
     D3D_TextureData *texturedata = (D3D_TextureData *)texture->driverdata;
 
-    if (!texturedata) {
+    if (texturedata == NULL) {
         return 0;
     }
 
@@ -618,7 +618,7 @@ D3D_UpdateTexture(SDL_Renderer * renderer, SDL_Texture * texture,
     D3D_RenderData *data = (D3D_RenderData *)renderer->driverdata;
     D3D_TextureData *texturedata = (D3D_TextureData *) texture->driverdata;
 
-    if (!texturedata) {
+    if (texturedata == NULL) {
         return SDL_SetError("Texture is not currently available");
     }
 
@@ -655,7 +655,7 @@ D3D_UpdateTextureYUV(SDL_Renderer * renderer, SDL_Texture * texture,
     D3D_RenderData *data = (D3D_RenderData *)renderer->driverdata;
     D3D_TextureData *texturedata = (D3D_TextureData *) texture->driverdata;
 
-    if (!texturedata) {
+    if (texturedata == NULL) {
         return SDL_SetError("Texture is not currently available");
     }
 
@@ -680,7 +680,7 @@ D3D_LockTexture(SDL_Renderer * renderer, SDL_Texture * texture,
     D3D_TextureData *texturedata = (D3D_TextureData *)texture->driverdata;
     IDirect3DDevice9 *device = data->device;
 
-    if (!texturedata) {
+    if (texturedata == NULL) {
         return SDL_SetError("Texture is not currently available");
     }
 #if SDL_HAVE_YUV
@@ -731,7 +731,7 @@ D3D_UnlockTexture(SDL_Renderer * renderer, SDL_Texture * texture)
     D3D_RenderData *data = (D3D_RenderData *)renderer->driverdata;
     D3D_TextureData *texturedata = (D3D_TextureData *)texture->driverdata;
 
-    if (!texturedata) {
+    if (texturedata == NULL) {
         return;
     }
 #if SDL_HAVE_YUV
@@ -741,8 +741,7 @@ D3D_UnlockTexture(SDL_Renderer * renderer, SDL_Texture * texture)
             (void *) ((Uint8 *) texturedata->pixels + rect->y * texturedata->pitch +
                       rect->x * SDL_BYTESPERPIXEL(texture->format));
         D3D_UpdateTexture(renderer, texture, rect, pixels, texturedata->pitch);
-    }
-    else
+    } else
 #endif
     {
         IDirect3DTexture9_UnlockRect(texturedata->texture.staging, 0);
@@ -761,7 +760,7 @@ D3D_SetTextureScaleMode(SDL_Renderer * renderer, SDL_Texture * texture, SDL_Scal
 {
     D3D_TextureData *texturedata = (D3D_TextureData *)texture->driverdata;
 
-    if (!texturedata) {
+    if (texturedata == NULL) {
         return;
     }
 
@@ -789,7 +788,7 @@ D3D_SetRenderTargetInternal(SDL_Renderer * renderer, SDL_Texture * texture)
     }
 
     texturedata = (D3D_TextureData *)texture->driverdata;
-    if (!texturedata) {
+    if (texturedata == NULL) {
         return SDL_SetError("Texture is not currently available");
     }
 
@@ -812,11 +811,11 @@ D3D_SetRenderTargetInternal(SDL_Renderer * renderer, SDL_Texture * texture)
     }
 
     result = IDirect3DTexture9_GetSurfaceLevel(texturedata->texture.texture, 0, &data->currentRenderTarget);
-    if(FAILED(result)) {
+    if (FAILED(result)) {
         return D3D_SetError("GetSurfaceLevel()", result);
     }
     result = IDirect3DDevice9_SetRenderTarget(data->device, 0, data->currentRenderTarget);
-    if(FAILED(result)) {
+    if (FAILED(result)) {
         return D3D_SetError("SetRenderTarget()", result);
     }
 
@@ -848,7 +847,7 @@ D3D_QueueDrawPoints(SDL_Renderer * renderer, SDL_RenderCommand *cmd, const SDL_F
     Vertex *verts = (Vertex *) SDL_AllocateRenderVertices(renderer, vertslen, 0, &cmd->data.draw.first);
     int i;
 
-    if (!verts) {
+    if (verts == NULL) {
         return -1;
     }
 
@@ -874,7 +873,7 @@ D3D_QueueGeometry(SDL_Renderer *renderer, SDL_RenderCommand *cmd, SDL_Texture *t
     int count = indices ? num_indices : num_vertices;
     Vertex *verts = (Vertex *) SDL_AllocateRenderVertices(renderer, count * sizeof (Vertex), 0, &cmd->data.draw.first);
 
-    if (!verts) {
+    if (verts == NULL) {
         return -1;
     }
 
@@ -974,7 +973,7 @@ SetupTextureState(D3D_RenderData *data, SDL_Texture * texture, LPDIRECT3DPIXELSH
 
     SDL_assert(*shader == NULL);
 
-    if (!texturedata) {
+    if (texturedata == NULL) {
         return SDL_SetError("Texture is not currently available");
     }
 
@@ -1031,7 +1030,7 @@ SetDrawState(D3D_RenderData *data, const SDL_RenderCommand *cmd)
             IDirect3DDevice9_SetTexture(data->device, 0, NULL);
         }
 #if SDL_HAVE_YUV
-        if ((!newtexturedata || !newtexturedata->yuv) && (oldtexturedata && oldtexturedata->yuv)) {
+        if ((newtexturedata == NULL || !newtexturedata->yuv) && (oldtexturedata && oldtexturedata->yuv)) {
             IDirect3DDevice9_SetTexture(data->device, 1, NULL);
             IDirect3DDevice9_SetTexture(data->device, 2, NULL);
         }
@@ -1422,7 +1421,7 @@ D3D_DestroyTexture(SDL_Renderer * renderer, SDL_Texture * texture)
 #endif
     }
 
-    if (!data) {
+    if (data == NULL) {
         return;
     }
 
@@ -1597,13 +1596,13 @@ D3D_CreateRenderer(SDL_Window * window, Uint32 flags)
     int displayIndex;
 
     renderer = (SDL_Renderer *) SDL_calloc(1, sizeof(*renderer));
-    if (!renderer) {
+    if (renderer == NULL) {
         SDL_OutOfMemory();
         return NULL;
     }
 
     data = (D3D_RenderData *) SDL_calloc(1, sizeof(*data));
-    if (!data) {
+    if (data == NULL) {
         SDL_free(renderer);
         SDL_OutOfMemory();
         return NULL;
diff --git a/src/render/direct3d11/SDL_render_d3d11.c b/src/render/direct3d11/SDL_render_d3d11.c
index 8369e54f6..9d02297e4 100644
--- a/src/render/direct3d11/SDL_render_d3d11.c
+++ b/src/render/direct3d11/SDL_render_d3d11.c
@@ -391,7 +391,7 @@ D3D11_CreateBlendState(SDL_Renderer * renderer, SDL_BlendMode blendMode)
     }
 
     blendModes = (D3D11_BlendMode *)SDL_realloc(data->blendModes, (data->blendModesCount + 1) * sizeof(*blendModes));
-    if (!blendModes) {
+    if (blendModes == NULL) {
         SAFE_RELEASE(blendState);
         SDL_OutOfMemory();
         return NULL;
@@ -450,7 +450,7 @@ D3D11_CreateDeviceResources(SDL_Renderer * renderer)
     }
 
     CreateDXGIFactoryFunc = (PFN_CREATE_DXGI_FACTORY)SDL_LoadFunction(data->hDXGIMod, "CreateDXGIFactory");
-    if (!CreateDXGIFactoryFunc) {
+    if (CreateDXGIFactoryFunc == NULL) {
         result = E_FAIL;
         goto done;
     }
@@ -1102,7 +1102,7 @@ D3D11_CreateTexture(SDL_Renderer * renderer, SDL_Texture * texture)
     }
 
     textureData = (D3D11_TextureData*) SDL_calloc(1, sizeof(*textureData));
-    if (!textureData) {
+    if (textureData == NULL) {
         SDL_OutOfMemory();
         return -1;
     }
@@ -1272,7 +1272,7 @@ D3D11_DestroyTexture(SDL_Renderer * renderer,
 {
     D3D11_TextureData *data = (D3D11_TextureData *)texture->driverdata;
 
-    if (!data) {
+    if (data == NULL) {
         return;
     }
 
@@ -1382,7 +1382,7 @@ D3D11_UpdateTexture(SDL_Renderer * renderer, SDL_Texture * texture,
     D3D11_RenderData *rendererData = (D3D11_RenderData *)renderer->driverdata;
     D3D11_TextureData *textureData = (D3D11_TextureData *)texture->driverdata;
 
-    if (!textureData) {
+    if (textureData == NULL) {
         return SDL_SetError("Texture is not currently available");
     }
 
@@ -1428,7 +1428,7 @@ D3D11_UpdateTextureYUV(SDL_Renderer * renderer, SDL_Texture * texture,
     D3D11_RenderData *rendererData = (D3D11_RenderData *)renderer->driverdata;
     D3D11_TextureData *textureData = (D3D11_TextureData *)texture->driverdata;
 
-    if (!textureData) {
+    if (textureData == NULL) {
         return SDL_SetError("Texture is not currently available");
     }
 
@@ -1453,7 +1453,7 @@ D3D11_UpdateTextureNV(SDL_Renderer * renderer, SDL_Texture * texture,
     D3D11_RenderData *rendererData = (D3D11_RenderData *)renderer->driverdata;
     D3D11_TextureData *textureData = (D3D11_TextureData *)texture->driverdata;
 
-    if (!textureData) {
+    if (textureData == NULL) {
         return SDL_SetError("Texture is not currently available");
     }
 
@@ -1478,7 +1478,7 @@ D3D11_LockTexture(SDL_Renderer * renderer, SDL_Texture * texture,
     D3D11_TEXTURE2D_DESC stagingTextureDesc;
     D3D11_MAPPED_SUBRESOURCE textureMemory;
 
-    if (!textureData) {
+    if (textureData == NULL) {
         return SDL_SetError("Texture is not currently available");
     }
 #if SDL_HAVE_YUV
@@ -1559,7 +1559,7 @@ D3D11_UnlockTexture(SDL_Renderer * renderer, SDL_Texture * texture)
     D3D11_RenderData *rendererData = (D3D11_RenderData *) renderer->driverdata;
     D3D11_TextureData *textureData = (D3D11_TextureData *) texture->driverdata;
     
-    if (!textureData) {
+    if (textureData == NULL) {
         return;
     }
 #if SDL_HAVE_YUV
@@ -1596,7 +1596,7 @@ D3D11_SetTextureScaleMode(SDL_Renderer * renderer, SDL_Texture * texture, SDL_Sc
 {
     D3D11_TextureData *textureData = (D3D11_TextureData *) texture->driverdata;
     
-    if (!textureData) {
+    if (textureData == NULL) {
         return;
     }
 
@@ -1642,7 +1642,7 @@ D3D11_QueueDrawPoints(SDL_Renderer * renderer, SDL_RenderCommand *cmd, const SDL
     color.b = cmd->data.draw.b;
     color.a = cmd->data.draw.a;
 
-    if (!verts) {
+    if (verts == NULL) {
         return -1;
     }
 
@@ -1670,7 +1670,7 @@ D3D11_QueueGeometry(SDL_Renderer *renderer, SDL_RenderCommand *cmd, SDL_Texture
     int count = indices ? num_indices : num_vertices;
     VertexPositionColor *verts = (VertexPositionColor *) SDL_AllocateRenderVertices(renderer, count * sizeof (VertexPositionColor), 0, &cmd->data.draw.first);
 
-    if (!verts) {
+    if (verts == NULL) {
         return -1;
     }
 
@@ -1882,8 +1882,7 @@ D3D11_GetCurrentRenderTargetView(SDL_Renderer * renderer)
     D3D11_RenderData *data = (D3D11_RenderData *)renderer->driverdata;
     if (data->currentOffscreenRenderTargetView) {
         return data->currentOffscreenRenderTargetView;
-    }
-    else {
+    } else {
         return data->mainRenderTargetView;
     }
 }
@@ -1951,9 +1950,9 @@ D3D11_SetDrawState(SDL_Renderer * renderer, const SDL_RenderCommand *cmd, ID3D11
                 break;
             }
         }
-        if (!blendState) {
+        if (blendState == NULL) {
             blendState = D3D11_CreateBlendState(renderer, blendMode);
-            if (!blendState) {
+            if (blendState == NULL) {
                 return -1;
             }
         }
@@ -2369,13 +2368,13 @@ D3D11_CreateRenderer(SDL_Window * window, Uint32 flags)
     D3D11_RenderData *data;
 
     renderer = (SDL_Renderer *) SDL_calloc(1, sizeof(*renderer));
-    if (!renderer) {
+    if (renderer == NULL) {
         SDL_OutOfMemory();
         return NULL;
     }
 
     data = (D3D11_RenderData *) SDL_calloc(1, sizeof(*data));
-    if (!data) {
+    if (data == NULL) {
         SDL_free(renderer);
         SDL_OutOfMemory();
         return NULL;
diff --git a/src/render/direct3d11/SDL_render_winrt.cpp b/src/render/direct3d11/SDL_render_winrt.cpp
index 9784c32c4..7fb4fa673 100644
--- a/src/render/direct3d11/SDL_render_winrt.cpp
+++ b/src/render/direct3d11/SDL_render_winrt.cpp
@@ -47,7 +47,7 @@ extern "C" void *
 D3D11_GetCoreWindowFromSDLRenderer(SDL_Renderer * renderer)
 {
     SDL_Window * sdlWindow = renderer->window;
-    if ( ! renderer->window ) {
+    if (renderer->window == NULL) {
         return NULL;
     }
 
diff --git a/src/render/direct3d12/SDL_render_d3d12.c b/src/render/direct3d12/SDL_render_d3d12.c
index 79cf30ef0..2f7fcd490 100644
--- a/src/render/direct3d12/SDL_render_d3d12.c
+++ b/src/render/direct3d12/SDL_render_d3d12.c
@@ -268,7 +268,7 @@ static const GUID SDL_IID_ID3D12InfoQueue = { 0x0742a90b, 0xc387, 0x483f, { 0xb9
 UINT
 D3D12_Align(UINT location, UINT alignment)
 {
-    return ((location + (alignment - 1)) & ~(alignment - 1));
+    return (location + (alignment - 1)) & ~(alignment - 1);
 }
 
 Uint32
@@ -404,8 +404,7 @@ D3D12_CPUtoGPUHandle(ID3D12DescriptorHeap * heap, D3D12_CPU_DESCRIPTOR_HANDLE CP
 static void
 D3D12_WaitForGPU(D3D12_RenderData * data)
 {
-    if (data->commandQueue && data->fence && data->fenceEvent)
-    {
+    if (data->commandQueue && data->fence && data->fenceEvent) {
         D3D_CALL(data->commandQueue, Signal, data->fence, data->fenceValue);
         if (D3D_CALL(data->fence, GetCompletedValue) < data->fenceValue) {
             D3D_CALL(data->fence, SetEventOnCompletion,
@@ -648,7 +647,7 @@ D3D12_CreatePipelineState(SDL_Renderer * renderer,
     }
 
     pipelineStates = (D3D12_PipelineState*)SDL_realloc(data->pipelineStates, (data->pipelineStateCount + 1) * sizeof(*pipelineStates));
-    if (!pipelineStates) {
+    if (pipelineStates == NULL) {
         SAFE_RELEASE(pipelineState);
         SDL_OutOfMemory();
         return NULL;
@@ -766,7 +765,7 @@ D3D12_CreateDeviceResources(SDL_Renderer* renderer)
         }
     }
 #endif
-    if (!CreateEventExFunc) {
+    if (CreateEventExFunc == NULL) {
         result = E_FAIL;
         goto done;
     }
@@ -779,7 +778,7 @@ D3D12_CreateDeviceResources(SDL_Renderer* renderer)
     }
 
     CreateDXGIFactoryFunc = (PFN_CREATE_DXGI_FACTORY)SDL_LoadFunction(data->hDXGIMod, "CreateDXGIFactory2");
-    if (!CreateDXGIFactoryFunc) {
+    if (CreateDXGIFactoryFunc == NULL) {
         result = E_FAIL;
         goto done;
     }
@@ -823,7 +822,7 @@ D3D12_CreateDeviceResources(SDL_Renderer* renderer)
 
         /* If the debug hint is set, also create the DXGI factory in debug mode */
         DXGIGetDebugInterfaceFunc = (PFN_CREATE_DXGI_FACTORY)SDL_LoadFunction(data->hDXGIMod, "DXGIGetDebugInterface1");
-        if (!DXGIGetDebugInterfaceFunc) {
+        if (DXGIGetDebugInterfaceFunc == NULL) {
             result = E_FAIL;
             goto done;
         }
@@ -1474,12 +1473,11 @@ D3D12_CreateTexture(SDL_Renderer * renderer, SDL_Texture * texture)
     D3D12_SHADER_RESOURCE_VIEW_DESC resourceViewDesc;
 
     if (textureFormat == DXGI_FORMAT_UNKNOWN) {
-        return SDL_SetError("%s, An unsupported SDL pixel format (0x%x) was specified",
-            __FUNCTION__, texture->format);
+        return SDL_SetError("%s, An unsupported SDL pixel format (0x%x) was specified", __FUNCTION__, texture->format);
     }
 
     textureData = (D3D12_TextureData*) SDL_calloc(1, sizeof(*textureData));
-    if (!textureData) {
+    if (textureData == NULL) {
         SDL_OutOfMemory();
         return -1;
     }
@@ -1666,7 +1664,7 @@ D3D12_DestroyTexture(SDL_Renderer * renderer,
     D3D12_RenderData *rendererData = (D3D12_RenderData*)renderer->driverdata;
     D3D12_TextureData *textureData = (D3D12_TextureData *)texture->driverdata;
 
-    if (!textureData) {
+    if (textureData == NULL) {
         return;
     }
 
@@ -1850,7 +1848,7 @@ D3D12_UpdateTexture(SDL_Renderer * renderer, SDL_Texture * texture,
     D3D12_RenderData *rendererData = (D3D12_RenderData *)renderer->driverdata;
     D3D12_TextureData *textureData = (D3D12_TextureData *)texture->driverdata;
 
-    if (!textureData) {
+    if (textureData == NULL) {
         return SDL_SetError("Texture is not currently available");
     }
 
@@ -1896,7 +1894,7 @@ D3D12_UpdateTextureYUV(SDL_Renderer * renderer, SDL_Texture * texture,
     D3D12_RenderData *rendererData = (D3D12_RenderData *)renderer->driverdata;
     D3D12_TextureData *textureData = (D3D12_TextureData *)texture->driverdata;
 
-    if (!textureData) {
+    if (textureData == NULL) {
         return SDL_SetError("Texture is not currently available");
     }
 
@@ -1921,7 +1919,7 @@ D3D12_UpdateTextureNV(SDL_Renderer * renderer, SDL_Texture * texture,
     D3D12_RenderData *rendererData = (D3D12_RenderData *)renderer->driverdata;
     D3D12_TextureData *textureData = (D3D12_TextureData *)texture->driverdata;
 
-    if (!textureData) {
+    if (textureData == NULL) {
         return SDL_SetError("Texture is not currently available");
     }
 
@@ -1951,7 +1949,7 @@ D3D12_LockTexture(SDL_Renderer * renderer, SDL_Texture * texture,
     BYTE *textureMemory;
     int bpp;
 
-    if (!textureData) {
+    if (textureData == NULL) {
         return SDL_SetError("Texture is not currently available");
     }
 #if SDL_HAVE_YUV
@@ -2043,8 +2041,7 @@ D3D12_LockTexture(SDL_Renderer * renderer, SDL_Texture * texture,
     pitchedDesc.Depth = 1;
     if (pitchedDesc.Format == DXGI_FORMAT_R8_UNORM) {
         bpp = 1;
-    }
-    else {
+    } else {
         bpp = 4;
     }
     pitchedDesc.RowPitch = D3D12_Align(rect->w * bpp, D3D12_TEXTURE_DATA_PITCH_ALIGNMENT);
@@ -2075,7 +2072,7 @@ D3D12_UnlockTexture(SDL_Renderer * renderer, SDL_Texture * texture)
     D3D12_TEXTURE_COPY_LOCATION dstLocation;
     int bpp;
     
-    if (!textureData) {
+    if (textureData == NULL) {
         return;
     }
 #if SDL_HAVE_YUV
@@ -2103,8 +2100,7 @@ D3D12_UnlockTexture(SDL_Renderer * renderer, SDL_Texture * texture)
     pitchedDesc.Depth = 1;
     if (pitchedDesc.Format == DXGI_FORMAT_R8_UNORM) {
         bpp = 1;
-    }
-    else {
+    } else {
         bpp = 4;
     }
     pitchedDesc.RowPitch = D3D12_Align(textureData->lockedRect.w * bpp, D3D12_TEXTURE_DATA_PITCH_ALIGNMENT);
@@ -2149,7 +2145,7 @@ D3D12_SetTextureScaleMode(SDL_Renderer * renderer, SDL_Texture * texture, SDL_Sc
 {
     D3D12_TextureData *textureData = (D3D12_TextureData *) texture->driverdata;
     
-    if (!textureData) {
+    if (textureData == NULL) {
         return;
     }
 
@@ -2210,7 +2206,7 @@ D3D12_QueueDrawPoints(SDL_Renderer * renderer, SDL_RenderCommand *cmd, const SDL
     color.b = cmd->data.draw.b;
     color.a = cmd->data.draw.a;
 
-    if (!verts) {
+    if (verts == NULL) {
         return -1;
     }
 
@@ -2238,7 +2234,7 @@ D3D12_QueueGeometry(SDL_Renderer *renderer, SDL_RenderCommand *cmd, SDL_Texture
     int count = indices ? num_indices : num_vertices;
     VertexPositionColor *verts = (VertexPositionColor *) SDL_AllocateRenderVertices(renderer, count * sizeof (VertexPositionColor), 0, &cmd->data.draw.first);
 
-    if (!verts) {
+    if (verts == NULL) {
         return -1;
     }
 
@@ -2614,8 +2610,8 @@ D3D12_SetCopyState(SDL_Renderer * renderer, const SDL_RenderCommand *cmd, const
         D3D12_TransitionResource(rendererData, textureData->mainTextureV, textureData->mainResourceStateV, D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE);
         textureData->mainResourceStateV = D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE;
 
-        return D3D12_SetDrawState(renderer, cmd, shader, D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE,
-            SDL_arraysize(shaderResources), shaderResources, textureSampler, matrix);
+        return D3D12_SetDrawState(renderer, cmd, shader, D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE, SDL_arraysize(shaderResources), shaderResources,
+                                  textureSampler, matrix);
     } else if (textureData->nv12) {
         D3D12_CPU_DESCRIPTOR_HANDLE shaderResources[] = {
             textureData->mainTextureResourceView,
@@ -2643,14 +2639,14 @@ D3D12_SetCopyState(SDL_Renderer * renderer, const SDL_RenderCommand *cmd, const
         D3D12_TransitionResource(rendererData, textureData->mainTextureNV, textureData->mainResourceStateNV, D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE);
         textureData->mainResourceStateNV = D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE;
 
-        return D3D12_SetDrawState(renderer, cmd, shader, D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE,
-            SDL_arraysize(shaderResources), shaderResources, textureSampler, matrix);
+        return D3D12_SetDrawState(renderer, cmd, shader, D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE, SDL_arraysize(shaderResources), shaderResources,
+                                  textureSampler, matrix);
     }
 #endif /* SDL_HAVE_YUV */
     D3D12_TransitionResource(rendererData, textureData->mainTexture, textureData->mainResourceState, D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE);
     textureData->mainResourceState = D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE;
-    return D3D12_SetDrawState(renderer, cmd, SHADER_RGB, D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE,
-                              1, &textureData->mainTextureResourceView, textureSampler, matrix);
+    return D3D12_SetDrawState(renderer, cmd, SHADER_RGB, D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE, 1, &textureData->mainTextureResourceView,
+                              textureSampler, matrix);
 }
 
 static void
@@ -3045,13 +3041,13 @@ D3D12_CreateRenderer(SDL_Window * window, Uint32 flags)
     D3D12_RenderData *data;
 
     renderer = (SDL_Renderer *) SDL_calloc(1, sizeof(*renderer));
-    if (!renderer) {
+    if (renderer == NULL) {
         SDL_OutOfMemory();
         return NULL;
     }
 
     data = (D3D12_RenderData *) SDL_calloc(1, sizeof(*data));
-    if (!data) {
+    if (data == NULL) {
         SDL_free(renderer);
         SDL_OutOfMemory();
         return NULL;
diff --git a/src/render/opengl/SDL_render_gl.c b/src/render/opengl/SDL_render_gl.c
index 4f6f1e5d5..bdb0d2ba1 100644
--- a/src/render/opengl/SDL_render_gl.c
+++ b/src/render/opengl/SDL_render_gl.c
@@ -173,8 +173,7 @@ GL_ClearErrors(SDL_Renderer *renderer)
 {
     GL_RenderData *data = (GL_RenderData *) renderer->driverdata;
 
-    if (!data->debug_enabled)
-    {
+    if (!data->debug_enabled) {
         return;
     }
     if (data->GL_ARB_debug_output_supported) {
@@ -201,8 +200,7 @@ GL_CheckAllErrors (const char *prefix, SDL_Renderer *renderer, const char *file,
     GL_RenderData *data = (GL_RenderData *) renderer->driverdata;
     int ret = 0;
 
-    if (!data->debug_enabled)
-    {
+    if (!data->debug_enabled) {
         return 0;
     }
     if (data->GL_ARB_debug_output_supported) {
@@ -313,7 +311,7 @@ GL_GetFBO(GL_RenderData *data, Uint32 w, Uint32 h)
         result = result->next;
     }
 
-    if (!result) {
+    if (result == NULL) {
         result = SDL_malloc(sizeof(GL_FBOList));
         if (result) {
             result->w = w;
@@ -478,7 +476,7 @@ GL_CreateTexture(SDL_Renderer * renderer, SDL_Texture * texture)
     }
 
     data = (GL_TextureData *) SDL_calloc(1, sizeof(*data));
-    if (!data) {
+    if (data == NULL) {
         return SDL_OutOfMemory();
     }
 
@@ -580,8 +578,7 @@ GL_CreateTexture(SDL_Renderer * renderer, SDL_Texture * texture)
         renderdata->glTexImage2D(textype, 0, internalFormat, texture_w,
                                  texture_h, 0, format, type, data->pixels);
         renderdata->glPixelStorei(GL_UNPACK_CLIENT_STORAGE_APPLE, GL_FALSE);
-    }
-    else
+    } else
 #endif
     {
         renderdata->glTexImage2D(textype, 0, internalFormat, texture_w,
@@ -938,7 +935,7 @@ GL_QueueDrawPoints(SDL_Renderer * renderer, SDL_RenderCommand *cmd, const SDL_FP
     GLfloat *verts = (GLfloat *) SDL_AllocateRenderVertices(renderer, count * 2 * sizeof (GLfloat), 0, &cmd->data.draw.first);
     int i;
 
-    if (!verts) {
+    if (verts == NULL) {
         return -1;
     }
 
@@ -959,7 +956,7 @@ GL_QueueDrawLines(SDL_Renderer * renderer, SDL_RenderCommand *cmd, const SDL_FPo
     const size_t vertlen = (sizeof (GLfloat) * 2) * count;
     GLfloat *verts = (GLfloat *) SDL_AllocateRenderVertices(renderer, vertlen, 0, &cmd->data.draw.first);
 
-    if (!verts) {
+    if (verts == NULL) {
         return -1;
     }
     cmd->data.draw.count = count;
@@ -1005,7 +1002,7 @@ GL_QueueGeometry(SDL_Renderer *renderer, SDL_RenderCommand *cmd, SDL_Texture *te
     size_t sz = 2 * sizeof(GLfloat) + 4 * sizeof(Uint8) + (texture ? 2 : 0) * sizeof(GLfloat);
 
     verts = (GLfloat *) SDL_AllocateRenderVertices(renderer, count * sz, 0, &cmd->data.draw.first);
-    if (!verts) {
+    if (verts == NULL) {
         return -1;
     }
 
@@ -1459,7 +1456,7 @@ GL_RenderReadPixels(SDL_Renderer * renderer, const SDL_Rect * rect,
 
     temp_pitch = rect->w * SDL_BYTESPERPIXEL(temp_format);
     temp_pixels = SDL_malloc(rect->h * temp_pitch);
-    if (!temp_pixels) {
+    if (temp_pixels == NULL) {
         return SDL_OutOfMemory();
     }
 
@@ -1526,7 +1523,7 @@ GL_DestroyTexture(SDL_Renderer * renderer, SDL_Texture * texture)
         renderdata->drawstate.target = NULL;
     }
 
-    if (!data) {
+    if (data == NULL) {
         return;
     }
     if (data->texture) {
@@ -1760,13 +1757,13 @@ GL_CreateRenderer(SDL_Window * window, Uint32 flags)
 #endif
 
     renderer = (SDL_Renderer *) SDL_calloc(1, sizeof(*renderer));
-    if (!renderer) {
+    if (renderer == NULL) {
         SDL_OutOfMemory();
         goto error;
     }
 
     data = (GL_RenderData *) SDL_calloc(1, sizeof(*data));
-    if (!data) {
+    if (data == NULL) {
         SDL_free(renderer);
         SDL_OutOfMemory();
         goto error;
@@ -1861,7 +1858,7 @@ GL_CreateRenderer(SDL_Window * window, Uint32 flags)
     }
 
     hint = SDL_getenv("GL_ARB_texture_non_power_of_two");
-    if (!hint || *hint != '0') {
+    if (hint == NULL || *hint != '0') {
         SDL_bool isGL2 = SDL_FALSE;
         const char *verstr = (const char *)data->glGetString(GL_VERSION);
         if (verstr) {
diff --git a/src/render/opengl/SDL_shaders_gl.c b/src/render/opengl/SDL_shaders_gl.c
index 4db083555..4c06350be 100644
--- a/src/render/opengl/SDL_shaders_gl.c
+++ b/src/render/opengl/SDL_shaders_gl.c
@@ -479,7 +479,7 @@ CompileShaderProgram(GL_ShaderContext *ctx, int index, GL_ShaderData *data)
     }
     ctx->glUseProgramObjectARB(0);
 
-    return (ctx->glGetError() == GL_NO_ERROR);
+    return ctx->glGetError() == GL_NO_ERROR;
 }
 
 static void
@@ -498,7 +498,7 @@ GL_CreateShaderContext(void)
     int i;
 
     ctx = (GL_ShaderContext *)SDL_calloc(1, sizeof(*ctx));
-    if (!ctx) {
+    if (ctx == NULL) {
         return NULL;
     }
 
diff --git a/src/render/opengles/SDL_render_gles.c b/src/render/opengles/SDL_render_gles.c
index ba08a46e2..462b3fef3 100644
--- a/src/render/opengles/SDL_render_gles.c
+++ b/src/render/opengles/SDL_render_gles.c
@@ -329,7 +329,7 @@ GLES_CreateTexture(SDL_Renderer * renderer, SDL_Texture * texture)
     }
 
     data = (GLES_TextureData *) SDL_calloc(1, sizeof(*data));
-    if (!data) {
+    if (data == NULL) {
         return SDL_OutOfMemory();
     }
 
@@ -424,7 +424,7 @@ GLES_UpdateTexture(SDL_Renderer * renderer, SDL_Texture * texture,
     src = (Uint8 *)pixels;
     if (pitch != srcPitch) {
         blob = (Uint8 *)SDL_malloc(srcPitch * rect->h);
-        if (!blob) {
+        if (blob == NULL) {
             return SDL_OutOfMemory();
         }
         src = blob;
@@ -544,7 +544,7 @@ GLES_QueueDrawPoints(SDL_Renderer * renderer, SDL_RenderCommand *cmd, const SDL_
     GLfloat *verts = (GLfloat *) SDL_AllocateRenderVertices(renderer, count * 2 * sizeof (GLfloat), 0, &cmd->data.draw.first);
     int i;
 
-    if (!verts) {
+    if (verts == NULL) {
         return -1;
     }
 
@@ -565,7 +565,7 @@ GLES_QueueDrawLines(SDL_Renderer * renderer, SDL_RenderCommand *cmd, const SDL_F
     const size_t vertlen = (sizeof (GLfloat) * 2) * count;
     GLfloat *verts = (GLfloat *) SDL_AllocateRenderVertices(renderer, vertlen, 0, &cmd->data.draw.first);
 
-    if (!verts) {
+    if (verts == NULL) {
         return -1;
     }
     cmd->data.draw.count = count;
@@ -611,7 +611,7 @@ GLES_QueueGeometry(SDL_Renderer *renderer, SDL_RenderCommand *cmd, SDL_Texture *
     int sz = 2 + 4 + (texture ? 2 : 0);
 
     verts = (GLfloat *) SDL_AllocateRenderVertices(renderer, count * sz * sizeof (GLfloat), 0, &cmd->data.draw.first);
-    if (!verts) {
+    if (verts == NULL) {
         return -1;
     }
 
@@ -918,7 +918,7 @@ GLES_RenderReadPixels(SDL_Renderer * renderer, const SDL_Rect * rect,
 
     temp_pitch = rect->w * SDL_BYTESPERPIXEL(temp_format);
     temp_pixels = SDL_malloc(rect->h * temp_pitch);
-    if (!temp_pixels) {
+    if (temp_pixels == NULL) {
         return SDL_OutOfMemory();
     }
 
@@ -979,7 +979,7 @@ GLES_DestroyTexture(SDL_Renderer * renderer, SDL_Texture * texture)
         renderdata->drawstate.target = NULL;
     }
 
-    if (!data) {
+    if (data == NULL) {
         return;
     }
     if (data->texture) {
@@ -1095,13 +1095,13 @@ GLES_CreateRenderer(SDL_Window * window, Uint32 flags)
     }
 
     renderer = (SDL_Renderer *) SDL_calloc(1, sizeof(*renderer));
-    if (!renderer) {
+    if (renderer == NULL) {
         SDL_OutOfMemory();
         goto error;
     }
 
     data = (GLES_RenderData *) SDL_calloc(1, sizeof(*data));
-    if (!data) {
+    if (data == NULL) {
         GLES_DestroyRenderer(renderer);
         SDL_OutOfMemory();
         goto error;
diff --git a/src/render/opengles2/SDL_render_gles2.c b/src/render/opengles2/SDL_render_gles2.c
index 41bf300f4..c5cfae6a9 100644
--- a/src/render/opengles2/SDL_render_gles2.c
+++ b/src/render/opengles2/SDL_render_gles2.c
@@ -421,7 +421,7 @@ GLES2_CacheProgram(GLES2_RenderData *data, GLuint vertex, GLuint fragment)
 
     /* Create a program cache entry */
     entry = (GLES2_ProgramCacheEntry *)SDL_calloc(1, sizeof(GLES2_ProgramCacheEntry));
-    if (!entry) {
+    if (entry == NULL) {
         SDL_OutOfMemory();
         return NULL;
     }
@@ -500,7 +500,7 @@ GLES2_CacheShader(GLES2_RenderData *data, GLES2_ShaderType type, GLenum shader_t
     const GLchar *shader_src_list[3];
     const GLchar *shader_body = GLES2_GetShader(type);
 
-    if (!shader_body) {
+    if (shader_body == NULL) {
         SDL_SetError("No shader body src");
         return 0;
     }
@@ -711,7 +711,7 @@ GLES2_SelectProgram(GLES2_RenderData *data, GLES2_ImageSource source, int w, int
 
     /* Generate a matching program */
     program = GLES2_CacheProgram(data, vertex, fragment);
-    if (!program) {
+    if (program == NULL) {
         goto fault;
     }
 
@@ -746,7 +746,7 @@ GLES2_QueueDrawPoints(SDL_Renderer * renderer, SDL_RenderCommand *cmd, const SDL
     color.b = cmd->data.draw.b;
     color.a = cmd->data.draw.a;
 
-    if (!verts) {
+    if (verts == NULL) {
         return -1;
     }
 
@@ -780,7 +780,7 @@ GLES2_QueueDrawLines(SDL_Renderer * renderer, SDL_RenderCommand *cmd, const SDL_
     color.b = cmd->data.draw.b;
     color.a = cmd->data.draw.a;
 
-    if (!verts) {
+    if (verts == NULL) {
         return -1;
     }
 
@@ -839,7 +839,7 @@ GLES2_QueueGeometry(SDL_Renderer *renderer, SDL_RenderCommand *cmd, SDL_Texture
 
     if (texture) {
         SDL_Vertex *verts = (SDL_Vertex *) SDL_AllocateRenderVertices(renderer, count * sizeof (*verts), 0, &cmd->data.draw.first);
-        if (!verts) {
+        if (verts == NULL) {
             return -1;
         }
 
@@ -879,7 +879,7 @@ GLES2_QueueGeometry(SDL_Renderer *renderer, SDL_RenderCommand *cmd, SDL_Texture
 
     } else {
         SDL_VertexSolid *verts = (SDL_VertexSolid *) SDL_AllocateRenderVertices(renderer, count * sizeof (*verts), 0, &cmd->data.draw.first);
-        if (!verts) {
+        if (verts == NULL) {
             return -1;
         }
 
@@ -1455,7 +1455,7 @@ GLES2_CreateTexture(SDL_Renderer *renderer, SDL_Texture *texture)
 
     /* Allocate a texture struct */
     data = (GLES2_TextureData *)SDL_calloc(1, sizeof(GLES2_TextureData));
-    if (!data) {
+    if (data == NULL) {
         return SDL_OutOfMemory();
     }
     data->texture = 0;
@@ -1591,12 +1591,11 @@ GLES2_TexSubImage2D(GLES2_RenderData *data, GLenum target, GLint xoffset, GLint
     src = (Uint8 *)pixels;
     if (pitch != src_pitch) {
         blob = (Uint8 *)SDL_malloc(src_pitch * height);
-        if (!blob) {
+        if (blob == NULL) {
             return SDL_OutOfMemory();
         }
         src = blob;
-        for (y = 0; y < height; ++y)
-        {
+        for (y = 0; y < height; ++y) {
             SDL_memcpy(src, pixels, src_pitch);
             src += src_pitch;
             pixels = (Uint8 *)pixels + pitch;
@@ -1609,7 +1608,7 @@ GLES2_TexSubImage2D(GLES2_RenderData *data, GLenum target, GLint xoffset, GLint
         int i;
         Uint32 *src32 = (Uint32 *)src;
         blob2 = (Uint32 *)SDL_malloc(src_pitch * height);
-        if (!blob2) {
+        if (blob2 == NULL) {
             if (blob) {
                 SDL_free(blob);
             }
@@ -1946,7 +1945,7 @@ GLES2_RenderReadPixels(SDL_Renderer * renderer, const SDL_Rect * rect,
     }
 
     temp_pixels = SDL_malloc(buflen);
-    if (!temp_pixels) {
+    if (temp_pixels == NULL) {
         return SDL_OutOfMemory();
     }
 
@@ -2110,13 +2109,13 @@ GLES2_CreateRenderer(SDL_Window *window, Uint32 flags)
 
     /* Create the renderer struct */
     renderer = (SDL_Renderer *)SDL_calloc(1, sizeof(SDL_Renderer));
-    if (!renderer) {
+    if (renderer == NULL) {
         SDL_OutOfMemory();
         goto error;
     }
 
     data = (GLES2_RenderData *)SDL_calloc(1, sizeof(GLES2_RenderData));
-    if (!data) {
+    if (data == NULL) {
         SDL_free(renderer);
         SDL_OutOfMemory();
         goto error;
diff --git a/src/render/opengles2/SDL_shaders_gles2.c b/src/render/opengles2/SDL_shaders_gles2.c
index cd7f6f12a..e59b73389 100644
--- a/src/render/opengles2/SDL_shaders_gles2.c
+++ b/src/render/opengles2/SDL_shaders_gles2.c
@@ -382,12 +382,15 @@ GLES2_ShaderIncludeType GLES2_GetTexCoordPrecisionEnumFromHint()
     const char *texcoord_hint = SDL_GetHint("SDL_RENDER_OPENGLES2_TEXCOORD_PRECISION");
     GLES2_ShaderIncludeType value = GLES2_SHADER_FRAGMENT_INCLUDE_BEST_TEXCOORD_PRECISION;
     if (texcoord_hint) {
-        if (SDL_strcmp(texcoord_hint, "undefined") == 0)
+        if (SDL_strcmp(texcoord_hint, "undefined") == 0) {
             return GLES2_SHADER_FRAGMENT_INCLUDE_UNDEF_PRECISION;
-        if (SDL_strcmp(texcoord_hint, "high") == 0)
+        }
+        if (SDL_strcmp(texcoord_hint, "high") == 0) {
             return GLES2_SHADER_FRAGMENT_INCLUDE_HIGH_TEXCOORD_PRECISION;
-        if (SDL_strcmp(texcoord_hint, "medium") == 0)
+        }
+        if (SDL_strcmp(texcoord_hint, "medium") == 0) {
             return GLES2_SHADER_FRAGMENT_INCLUDE_MEDIUM_TEXCOORD_PRECISION;
+        }
     }
     return value;
 }
diff --git a/src/render/ps2/SDL_render_ps2.c b/src/render/ps2/SDL_render_ps2.c
index f385f5354..6070523f4 100644
--- a/src/render/ps2/SDL_render_ps2.c
+++ b/src/render/ps2/SDL_render_ps2.c
@@ -66,7 +66,9 @@ static int vsync_handler()
 /* Copy of gsKit_sync_flip, but without the 'flip' */
 static void gsKit_sync(GSGLOBAL *gsGlobal)
 {
-   if (!gsGlobal->FirstFrame) WaitSema(vsync_sema_id);
+   if (!gsGlobal->FirstFrame) {
+      WaitSema(vsync_sema_id);
+   }
    while (PollSema(vsync_sema_id) >= 0)
    	;
 }
@@ -74,10 +76,8 @@ static void gsKit_sync(GSGLOBAL *gsGlobal)
 /* Copy of gsKit_sync_flip, but without the 'sync' */
 static void gsKit_flip(GSGLOBAL *gsGlobal)
 {
-   if (!gsGlobal->FirstFrame)
-   {
-      if (gsGlobal->DoubleBuffering == GS_SETTING_ON)
-      {
+   if (!gsGlobal->FirstFrame) {
+      if (gsGlobal->DoubleBuffering == GS_SETTING_ON) {
          GS_SET_DISPFB2( gsGlobal->ScreenBuffer[
                gsGlobal->ActiveBuffer & 1] / 8192,
                gsGlobal->Width / 64, gsGlobal->PSM, 0, 0 );
@@ -111,16 +111,16 @@ PS2_CreateTexture(SDL_Renderer * renderer, SDL_Texture * texture)
 {
     GSTEXTURE* ps2_tex = (GSTEXTURE*) SDL_calloc(1, sizeof(GSTEXTURE));
 
-    if (!ps2_tex)
+    if (ps2_tex == NULL) {
         return SDL_OutOfMemory();
+    }
 
     ps2_tex->Width = texture->w;
     ps2_tex->Height = texture->h;
     ps2_tex->PSM = PixelFormatToPS2PSM(texture->format);
     ps2_tex->Mem = memalign(128, gsKit_texture_size_ee(ps2_tex->Width, ps2_tex->Height, ps2_tex->PSM));
 
-    if (!ps2_tex->Mem)
-    {
+    if (!ps2_tex->Mem) {
         SDL_free(ps2_tex);
         return SDL_OutOfMemory();
     }
@@ -215,7 +215,7 @@ PS2_QueueDrawPoints(SDL_Renderer * renderer, SDL_RenderCommand *cmd, const SDL_F
     gs_rgbaq rgbaq;
     int i;
 
-    if (!vertices) {
+    if (vertices == NULL) {
         return -1;
     }
 
@@ -250,7 +250,7 @@ PS2_QueueGeometry(SDL_Renderer *renderer, SDL_RenderCommand *cmd, SDL_Texture *t
     if (texture) {
         GSPRIMSTQPOINT *vertices = (GSPRIMSTQPOINT *) SDL_AllocateRenderVertices(renderer, count * sizeof (GSPRIMSTQPOINT), 4, &cmd->data.draw.first);
         
-        if (!vertices) {
+        if (vertices == NULL) {
             return -1;
         }
 
@@ -283,7 +283,7 @@ PS2_QueueGeometry(SDL_Renderer *renderer, SDL_RenderCommand *cmd, SDL_Texture *t
     } else {
         GSPRIMPOINT *vertices = (GSPRIMPOINT *) SDL_AllocateRenderVertices(renderer, count * sizeof (GSPRIMPOINT), 4, &cmd->data.draw.first);
 
-        if (!vertices) {
+        if (vertices == NULL) {
             return -1;
         }
 
@@ -333,7 +333,7 @@ PS2_RenderSetClipRect(SDL_Renderer *renderer, SDL_RenderCommand *cmd)
 
     const SDL_Rect *rect = &cmd->data.cliprect.rect;
 
-    if(cmd->data.cliprect.enabled){
+    if (cmd->data.cliprect.enabled) {
         gsKit_set_scissor(data->gsGlobal, GS_SETREG_SCISSOR(rect->x, rect->y, rect->w, rect->h));
     } else {
         gsKit_set_scissor(data->gsGlobal, GS_SCISSOR_RESET);
@@ -521,18 +521,20 @@ PS2_RenderPresent(SDL_Renderer * renderer)
     PS2_RenderData *data = (PS2_RenderData *) renderer->driverdata;
 
     if (data->gsGlobal->DoubleBuffering == GS_SETTING_OFF) {
-		if (data->vsync == 2) // Dynamic
+		if (data->vsync == 2) { // Dynamic
             gsKit_sync(data->gsGlobal);
-        else if (data->vsync == 1)
+        } else if (data->vsync == 1) {
             gsKit_vsync_wait();
+        }
 		gsKit_queue_exec(data->gsGlobal);
     } else {
 		gsKit_queue_exec(data->gsGlobal);
 		gsKit_finish();
-		if (data->vsync == 2) // Dynamic
+		if (data->vsync == 2) { // Dynamic
             gsKit_sync(data->gsGlobal);
-        else if (data->vsync == 1)
+        } else if (data->vsync == 1) {
             gsKit_vsync_wait();
+        }
 		gsKit_flip(data->gsGlobal);
 	}
 	gsKit_TexManager_nextFrame(data->gsGlobal);
@@ -546,11 +548,13 @@ PS2_DestroyTexture(SDL_Renderer * renderer, SDL_Texture * texture)
     GSTEXTURE *ps2_texture = (GSTEXTURE *) texture->driverdata;
     PS2_RenderData *data = (PS2_RenderData *)renderer->driverdata;
 
-    if (data == NULL)
+    if (data == NULL) {
         return;
+    }
 
-    if(ps2_texture == NULL)
+    if (ps2_texture == NULL) {
         return;
+    }
 
     // Free from vram
     gsKit_TexManager_free(data->gsGlobal, ps2_texture);
@@ -574,8 +578,9 @@ PS2_DestroyRenderer(SDL_Renderer * renderer)
         SDL_free(data);
     }
 
-    if (vsync_sema_id >= 0)
+    if (vsync_sema_id >= 0) {
         DeleteSema(vsync_sema_id);
+    }
 
     SDL_free(renderer);
 }
@@ -599,13 +604,13 @@ PS2_CreateRenderer(SDL_Window * window, Uint32 flags)
     SDL_bool dynamicVsync;
 
     renderer = (SDL_Renderer *) SDL_calloc(1, sizeof(*renderer));
-    if (!renderer) {
+    if (renderer == NULL) {
         SDL_OutOfMemory();
         return NULL;
     }
 
     data = (PS2_RenderData *) SDL_calloc(1, sizeof(*data));
-    if (!data) {
+    if (data == NULL) {
         PS2_DestroyRenderer(renderer);
         SDL_OutOfMemory();
         return NULL;
diff --git a/src/render/psp/SDL_render_psp.c b/src/render/psp/SDL_render_psp.c
index 9a4e5c7bb..8c199acb3 100644
--- a/src/render/psp/SDL_render_psp.c
+++ b/src/render/psp/SDL_render_psp.c
@@ -182,19 +182,22 @@ static int
 TextureNextPow2(unsigned int w)
 {
     unsigned int n = 2;
-    if(w == 0)
+    if (w == 0) {
         return 0;
+    }
 
-    while(w > n)
+    while (w > n) {
         n <<= 1;
+    }
 
     return n;
 }
 
 static void psp_on_vblank(u32 sub, PSP_RenderData *data)
 {
-   if (data)
+   if (data) {
       data->vblank_not_reached = SDL_FALSE;
+   }
 }
 
 
@@ -218,10 +221,10 @@ PixelFormatToPSPFMT(Uint32 format)
 ///SECTION render target LRU management
 static void
 LRUTargetRelink(PSP_TextureData* psp_texture) {
-    if(psp_texture->prevhotw) {
+    if (psp_texture->prevhotw) {
         psp_texture->prevhotw->nexthotw = psp_texture->nexthotw;
     }
-    if(psp_texture->nexthotw) {
+    if (psp_texture->nexthotw) {
         psp_texture->nexthotw->prevhotw = psp_texture->prevhotw;
     }
 }
@@ -229,11 +232,11 @@ LRUTargetRelink(PSP_TextureData* psp_texture) {
 static void
 LRUTargetPushFront(PSP_RenderData* data, PSP_TextureData* psp_texture) {
     psp_texture->nexthotw = data->most_recent_target;
-    if(data->most_recent_target) {
+    if (data->most_recent_target) {
         data->most_recent_target->prevhotw = psp_texture;
     }
     data->most_recent_target = psp_texture;
-    if(!data->least_recent_target) {
+    if (!data->least_recent_target) {
         data->least_recent_target = psp_texture;
     }
 }
@@ -241,10 +244,10 @@ LRUTargetPushFront(PSP_RenderData* data, PSP_TextureData* psp_texture) {
 static void
 LRUTargetRemove(PSP_RenderData* data, PSP_TextureData* psp_texture) {
     LRUTargetRelink(psp_texture);
-    if(data->most_recent_target == psp_texture) {
+    if (data->most_recent_target == psp_texture) {
         data->most_recent_target = psp_texture->nexthotw;
     }
-    if(data->least_recent_target == psp_texture) {
+    if (data->least_recent_target == psp_texture) {
         data->least_recent_target = psp_texture->prevhotw;
     }
     psp_texture->prevhotw = NULL;
@@ -253,7 +256,7 @@ LRUTargetRemove(PSP_RenderData* data, PSP_TextureData* psp_texture) {
 
 static void
 LRUTargetBringFront(PSP_RenderData* data, PSP_TextureData* psp_texture) {
-    if(data->most_recent_target == psp_texture) {
+    if (data->most_recent_target == psp_texture) {
         return; //nothing to do
     }
     LRUTargetRemove(data, psp_texture);
@@ -262,7 +265,7 @@ LRUTargetBringFront(PSP_RenderData* data, PSP_TextureData* psp_texture) {
 
 static void
 TextureStorageFree(void* storage) {
-    if(InVram(storage)) {
+    if (InVram(storage)) {
         vfree(storage);
     } else {
         SDL_free(storage);
@@ -279,8 +282,9 @@ TextureSwizzle(PSP_TextureData *psp_texture, void* dst)
     unsigned int *src = NULL;
     unsigned char *data = NULL;
 
-    if(psp_texture->swizzled)
+    if (psp_texture->swizzled) {
         return 1;
+    }
 
     bytewidth = psp_texture->textureWidth*(psp_texture->bits>>3);
     height = psp_texture->size / bytewidth;
@@ -291,21 +295,21 @@ TextureSwizzle(PSP_TextureData *psp_texture, void* dst)
     src = (unsigned int*) psp_texture->data;
 
     data = dst;
-    if(!data) {
+    if (data == NULL) {
         data = SDL_malloc(psp_texture->size);
     }
 
-    if(!data) {
+    if (data == NULL) {
         return SDL_OutOfMemory();
     }
 
-    for(j = 0; j < height; j++, blockaddress += 16)
+    for (j = 0; j < height; j++, blockaddress += 16)
     {
         unsigned int *block;
 
         block = (unsigned int*)&data[blockaddress];
 
-        for(i = 0; i < rowblocks; i++)
+        for (i = 0; i < rowblocks; i++)
         {
             *block++ = *src++;
             *block++ = *src++;
@@ -314,8 +318,9 @@ TextureSwizzle(PSP_TextureData *psp_texture, void* dst)
             block += 28;
         }
 
-        if((j & 0x7) == 0x7)
+        if ((j & 0x7) == 0x7) {
             blockaddress += rowblocksadd;
+        }
     }
 
     TextureStorageFree(psp_texture->data);
@@ -338,8 +343,9 @@ TextureUnswizzle(PSP_TextureData *psp_texture, void* dst)
     unsigned char *data = NULL;
     unsigned char *ydst = NULL;
 
-    if(!psp_texture->swizzled)
+    if (!psp_texture->swizzled) {
         return 1;
+    }
 
     bytewidth = psp_texture->textureWidth*(psp_texture->bits>>3);
     height = psp_texture->size / bytewidth;
@@ -354,26 +360,27 @@ TextureUnswizzle(PSP_TextureData *psp_texture, void* dst)
 
     data = dst;
 
-    if(!data) {
+    if (data == NULL) {
         data = SDL_malloc(psp_texture->size);
     }
 
-    if(!data)
+    if (data == NULL) {
         return SDL_OutOfMemory();
+    }
 
     ydst = (unsigned char *)data;
 
-    for(blocky = 0; blocky < heightblocks; ++blocky)
+    for (blocky = 0; blocky < heightblocks; ++blocky)
     {
         unsigned char *xdst = ydst;
 
-        for(blockx = 0; blockx < widthblocks; ++blockx)
+        for (blockx = 0; blockx < widthblocks; ++blockx)
         {
             unsigned int *block;
 
             block = (unsigned int*)xdst;
 
-            for(j = 0; j < 8; ++j)
+            for (j = 0; j < 8; ++j)
             {
                 *(block++) = *(src++);
                 *(block++) = *(src++);
@@ -402,10 +409,10 @@ static int
 TextureSpillToSram(PSP_RenderData* data, PSP_TextureData* psp_texture)
 {
     // Assumes the texture is in VRAM
-    if(psp_texture->swizzled) {
+    if (psp_texture->swizzled) {
         //Texture was swizzled in vram, just copy to system memory
         void* sdata = SDL_malloc(psp_texture->size);
-        if(!sdata) {
+        if (sdata == NULL) {
             return SDL_OutOfMemory();
         }
 
@@ -423,7 +430,7 @@ TexturePromoteToVram(PSP_RenderData* data, PSP_TextureData* psp_texture, SDL_boo
 {
     // Assumes texture in sram and a large enough continuous block in vram
     void* tdata = vramalloc(psp_texture->size);
-    if(psp_texture->swizzled && target) {
+    if (psp_texture->swizzled && target) {
         return TextureUnswizzle(psp_texture, tdata);
     } else {
         SDL_memcpy(tdata, psp_texture->data, psp_texture->size);
@@ -436,8 +443,8 @@ TexturePromoteToVram(PSP_RenderData* data, PSP_TextureData* psp_texture, SDL_boo
 static int
 TextureSpillLRU(PSP_RenderData* data, size_t wanted) {
     PSP_TextureData* lru = data->least_recent_target;
-    if(lru) {
-        if(TextureSpillToSram(data, lru) < 0) {
+    if (lru) {
+        if (TextureSpillToSram(data, lru) < 0) {
             return -1;
         }
         LRUTargetRemove(data, lru);
@@ -451,8 +458,8 @@ TextureSpillLRU(PSP_RenderData* data, size_t wanted) {
 static int
 TextureSpillTargetsForSpace(PSP_RenderData* data, size_t size)
 {
-    while(vlargestblock() < size) {
-        if(TextureSpillLRU(data, size) < 0) {
+    while (vlargestblock() < size) {
+        if (TextureSpillLRU(data, size) < 0) {
             return -1;
         }
     }
@@ -463,12 +470,12 @@ static int
 TextureBindAsTarget(PSP_RenderData* data, PSP_TextureData* psp_texture) {
     unsigned int dstFormat;
 
-    if(!InVram(psp_texture->data)) {
+    if (!InVram(psp_texture->data)) {
         // Bring back the texture in vram
-        if(TextureSpillTargetsForSpace(data, psp_texture->size) < 0) {
+        if (TextureSpillTargetsForSpace(data, psp_texture->size) < 0) {
             return -1;
         }
-        if(TexturePromoteToVram(data, psp_texture, SDL_TRUE) < 0) {
+        if (TexturePromoteToVram(data, psp_texture, SDL_TRUE) < 0) {
             return -1;
         }
     }
@@ -477,7 +484,7 @@ TextureBindAsTarget(PSP_RenderData* data, PSP_TextureData* psp_texture) {
 
     // Stencil alpha dst hack
     dstFormat = psp_texture->format;
-    if(dstFormat == GU_PSM_5551) {
+    if (dstFormat == GU_PSM_5551) {
         sceGuEnable(GU_STENCIL_TEST);
         sceGuStencilOp(GU_REPLACE, GU_REPLACE, GU_REPLACE);
         sceGuStencilFunc(GU_GEQUAL, 0xff, 0xff);
@@ -502,8 +509,9 @@ PSP_CreateTexture(SDL_Renderer * renderer, SDL_Texture * texture)
     PSP_RenderData *data = renderer->driverdata;
     PSP_TextureData* psp_texture = (PSP_TextureData*) SDL_calloc(1, sizeof(*psp_texture));
 
-    if(!psp_texture)
+    if (psp_texture == NULL) {
         return SDL_OutOfMemory();
+    }
 
     psp_texture->swizzled = SDL_FALSE;
     psp_texture->width = texture->w;
@@ -531,21 +539,20 @@ PSP_CreateTexture(SDL_Renderer * renderer, SDL_Texture * texture)
 
     psp_texture->pitch = psp_texture->textureWidth * SDL_BYTESPERPIXEL(texture->format);
     psp_texture->size = psp_texture->textureHeight*psp_texture->pitch;
-    if(texture->access & SDL_TEXTUREACCESS_TARGET) {
-        if(TextureSpillTargetsForSpace(renderer->driverdata, psp_texture->size) < 0){
+    if (texture->access & SDL_TEXTUREACCESS_TARGET) {
+        if (TextureSpillTargetsForSpace(renderer->driverdata, psp_texture->size) < 0) {
             SDL_free(psp_texture);
             return -1;
         }
         psp_texture->data = vramalloc(psp_texture->size);
-        if(psp_texture->data) {
+        if (psp_texture->data) {
             LRUTargetPushFront(data, psp_texture);
         }
     } else {
         psp_texture->data = SDL_calloc(1, psp_texture->size);
     }
 
-    if(!psp_texture->data)
-    {
+    if (!psp_texture->data) {
         SDL_free(psp_texture);
         return SDL_OutOfMemory();
     }
@@ -569,8 +576,7 @@ TextureActivate(SDL_Texture * texture)
     int scaleMode = (texture->scaleMode == SDL_ScaleModeNearest) ? GU_NEAREST : GU_LINEAR;
 
     /* Swizzling is useless with small textures. */
-    if (TextureShouldSwizzle(psp_texture, texture))
-    {
+    if (TextureShouldSwizzle(psp_texture, texture)) {
         TextureSwizzle(psp_texture, NULL);
     }
 
@@ -662,7 +668,7 @@ PSP_QueueDrawPoints(SDL_Renderer * renderer, SDL_RenderCommand *cmd, const SDL_F
     VertV *verts = (VertV *) SDL_AllocateRenderVertices(renderer, count * sizeof (VertV), 4, &cmd->data.draw.first);
     int i;
 
-    if (!verts) {
+    if (verts == NULL) {
         return -1;
     }
 
@@ -692,7 +698,7 @@ PSP_QueueGeometry(SDL_Renderer *renderer, SDL_RenderCommand *cmd, SDL_Texture *t
     if (texture == NULL) {
         VertCV *verts;
         verts = (VertCV *) SDL_AllocateRenderVertices(renderer, count * sizeof (VertCV), 4, &cmd->data.draw.first);
-        if (!verts) {
+        if (verts == NULL) {
             return -1;
         }
 
@@ -725,7 +731,7 @@ PSP_QueueGeometry(SDL_Renderer *renderer, SDL_RenderCommand *cmd, SDL_Texture *t
         PSP_TextureData *psp_texture = (PSP_TextureData *) texture->driverdata;
         VertTCV *verts;
         verts = (VertTCV *) SDL_AllocateRenderVertices(renderer, count * sizeof (VertTCV), 4, &cmd->data.draw.first);
-        if (!verts) {
+        if (verts == NULL) {
             return -1;
         }
 
@@ -771,7 +777,7 @@ PSP_QueueFillRects(SDL_Renderer * renderer, SDL_RenderCommand *cmd, const SDL_FR
     VertV *verts = (VertV *) SDL_AllocateRenderVertices(renderer, count * 2 * sizeof (VertV), 4, &cmd->data.draw.first);
     int i;
 
-    if (!verts) {
+    if (verts == NULL) {
         return -1;
     }
 
@@ -806,10 +812,9 @@ PSP_QueueCopy(SDL_Renderer * renderer, SDL_RenderCommand *cmd, SDL_Texture * tex
     const float u1 = srcrect->x + srcrect->w;
     const float v1 = srcrect->y + srcrect->h;
 
-    if((MathAbs(u1) - MathAbs(u0)) < 64.0f)
-    {
+    if ((MathAbs(u1) - MathAbs(u0)) < 64.0f) {
         verts = (VertTV *) SDL_AllocateRenderVertices(renderer, 2 * sizeof (VertTV), 4, &cmd->data.draw.first);
-        if (!verts) {
+        if (verts == NULL) {
             return -1;
         }
 
@@ -828,9 +833,7 @@ PSP_QueueCopy(SDL_Renderer * renderer, SDL_RenderCommand *cmd, SDL_Texture * tex
         verts->y = y + height;
         verts->z = 0;
         verts++;
-    }
-    else
-    {
+    } else {
         float start, end;
         float curU = u0;
         float curX = x;
@@ -840,18 +843,19 @@ PSP_QueueCopy(SDL_Renderer * renderer, SDL_RenderCommand *cmd, SDL_Texture * tex
         size_t i;
         float ustep = (u1 - u0)/width * slice;
 
-        if(ustep < 0.0f)
+        if (ustep < 0.0f) {
             ustep = -ustep;
+        }
 
         cmd->data.draw.count = count;
 
         verts = (VertTV *) SDL_AllocateRenderVertices(renderer, count * 2 * sizeof (VertTV), 4, &cmd->data.draw.first);
-        if (!verts) {
+        if (verts == NULL) {
             return -1;
         }
 
 
-        for(i = 0, start = 0, end = width; i < count; i++, start += slice)
+        for (i = 0, start = 0, end = width; i < count; i++, start += slice)
         {
             const float polyWidth = ((curX + slice) > endX) ? (endX - curX) : slice;
             const float sourceWidth = ((curU + ustep) > u1) ? (u1 - curU) : ustep;
@@ -900,7 +904,7 @@ PSP_QueueCopyEx(SDL_Renderer * renderer, SDL_RenderCommand *cmd, SDL_Texture * t
     float u1 = srcrect->x + srcrect->w;
     float v1 = srcrect->y + srcrect->h;
 
-    if (!verts) {
+    if (verts == NULL) {
         return -1;
     }
 
@@ -986,16 +990,16 @@ StartDrawing(SDL_Renderer * renderer)
     PSP_RenderData *data = (PSP_RenderData *) renderer->driverdata;
 
     // Check if we need to start GU displaylist
-    if(!data->displayListAvail) {
+    if (!data->displayListAvail) {
         sceGuStart(GU_DIRECT, DisplayList);
         data->displayListAvail = SDL_TRUE;
         //ResetBlendState(&data->blendState);
     }
 
     // Check if we need a draw buffer change
-    if(renderer->target != data->boundTarget) {
+    if (renderer->target != data->boundTarget) {
         SDL_Texture* texture = renderer->target;
-        if(texture) {
+        if (texture) {
             PSP_TextureData* psp_texture = (PSP_TextureData*) texture->driverdata;
             // Set target, registering LRU
             TextureBindAsTarget(data, psp_texture);
@@ -1044,16 +1048,16 @@ PSP_SetBlendState(PSP_RenderData* data, PSP_BlendState* state)
         }
     }
 
-    if(state->color != current->color) {
+    if (state->color != current->color) {
         sceGuColor(state->color);
     }
 
-    if(state->shadeModel != current->shadeModel) {
+    if (state->shadeModel != current->shadeModel) {
         sceGuShadeModel(state->shadeModel);
     }
 
-    if(state->texture != current->texture) {
-        if(state->texture != NULL) {
+    if (state->texture != current->texture) {
+        if (state->texture != NULL) {
             TextureActivate(state->texture);
             sceGuEnable(GU_TEXTURE_2D);
         } else {
@@ -1078,7 +1082,7 @@ PSP_RunCommandQueue(SDL_Renderer * renderer, SDL_RenderCommand *cmd, void *verti
        rendering backends report a reasonable maximum, so the higher level can flush
        if we appear to be exceeding that. */
     gpumem = (Uint8 *) sceGuGetMemory(vertsize);
-    if (!gpumem) {
+    if (gpumem == NULL) {
         return SDL_SetError("Couldn't obtain a %d-byte vertex buffer!", (int) vertsize);
     }
     SDL_memcpy(gpumem, vertices, vertsize);
@@ -1099,7 +1103,7 @@ PSP_RunCommandQueue(SDL_Renderer * renderer, SDL_RenderCommand *cmd, void *verti
 
             case SDL_RENDERCMD_SETCLIPRECT: {
                 const SDL_Rect *rect = &cmd->data.cliprect.rect;
-                if(cmd->data.cliprect.enabled){
+                if (cmd->data.cliprect.enabled) {
                     sceGuEnable(GU_SCISSOR_TEST);
                     sceGuScissor(rect->x, rect->y, rect->w, rect->h);
                 } else {
@@ -1264,8 +1268,9 @@ PSP_RenderPresent(SDL_Renderer * renderer)
     sceGuFinish();
     sceGuSync(0,0);
 
-    if ((data->vsync) && (data->vblank_not_reached))
+    if ((data->vsync) && (data->vblank_not_reached)) {
         sceDisplayWaitVblankStart();
+    }
     data->vblank_not_reached = SDL_TRUE;
 
     data->backbuffer = data->frontbuffer;
@@ -1280,11 +1285,13 @@ PSP_DestroyTexture(SDL_Renderer * renderer, SDL_Texture * texture)
     PSP_RenderData *renderdata = (PSP_RenderData *) renderer->driverdata;
     PSP_TextureData *psp_texture = (PSP_TextureData *) texture->driverdata;
 
-    if (renderdata == NULL)
+    if (renderdata == NULL) {
         return;
+    }
 
-    if(psp_texture == NULL)
+    if (psp_texture == NULL) {
         return;
+    }
 
     LRUTargetRemove(renderdata, psp_texture);
     TextureStorageFree(psp_texture->data);
@@ -1297,8 +1304,9 @@ PSP_DestroyRenderer(SDL_Renderer * renderer)
 {
     PSP_RenderData *data = (PSP_RenderData *) renderer->driverdata;
     if (data) {
-        if (!data->initialized)
+        if (!data->initialized) {
             return;
+        }
 
         StartDrawing(renderer);
 
@@ -1335,13 +1343,13 @@ PSP_CreateRenderer(SDL_Window * window, Uint32 flags)
     void* doublebuffer = NULL;
 
     renderer = (SDL_Renderer *) SDL_calloc(1, sizeof(*renderer));
-    if (!renderer) {
+    if (renderer == NULL) {
         SDL_OutOfMemory();
         return NULL;
     }
 
     data = (PSP_RenderData *) SDL_calloc(1, sizeof(*data));
-    if (!data) {
+    if (data == NULL) {
         PSP_DestroyRenderer(renderer);
         SDL_OutOfMemory();
         return NULL;
diff --git a/src/render/software/SDL_blendfillrect.c b/src/render/software/SDL_blendfillrect.c
index 569c15058..d06823243 100644
--- a/src/render/software/SDL_blendfillrect.c
+++ b/src/render/software/SDL_blendfillrect.c
@@ -219,7 +219,7 @@ SDL_BlendFillRect(SDL_Surface * dst, const SDL_Rect * rect,
 {
     SDL_Rect clipped;
 
-    if (!dst) {
+    if (dst == NULL) {
         return SDL_InvalidParamError("SDL_BlendFillRect(): dst");
     }
 
@@ -290,7 +290,7 @@ SDL_BlendFillRects(SDL_Surface * dst, const SDL_Rect * rects, int count,
                 SDL_BlendMode blendMode, Uint8 r, Uint8 g, Uint8 b, Uint8 a) = NULL;
     int status = 0;
 
-    if (!dst) {
+    if (dst == NULL) {
         return SDL_InvalidParamError("SDL_BlendFillRects(): dst");
     }
 
@@ -334,7 +334,7 @@ SDL_BlendFillRects(SDL_Surface * dst, const SDL_Rect * rects, int count,
         break;
     }
 
-    if (!func) {
+    if (func == NULL) {
         if (!dst->format->Amask) {
             func = SDL_BlendFillRect_RGB;
         } else {
diff --git a/src/render/software/SDL_blendline.c b/src/render/software/SDL_blendline.c
index 4921bf101..f7631c292 100644
--- a/src/render/software/SDL_blendline.c
+++ b/src/render/software/SDL_blendline.c
@@ -808,12 +808,12 @@ SDL_BlendLine(SDL_Surface * dst, int x1, int y1, int x2, int y2,
 {
     BlendLineFunc func;
 
-    if (!dst) {
+    if (dst == NULL) {
         return SDL_InvalidParamError("SDL_BlendLine(): dst");
     }
 
     func = SDL_CalculateBlendLineFunc(dst->format);
-    if (!func) {
+    if (func == NULL) {
         return SDL_SetError("SDL_BlendLine(): Unsupported surface format");
     }
 
@@ -837,12 +837,12 @@ SDL_BlendLines(SDL_Surface * dst, const SDL_Point * points, int count,
     SDL_bool draw_end;
     BlendLineFunc func;
 
-    if (!dst) {
+    if (dst == NULL) {
         return SDL_SetError("SDL_BlendLines(): Passed NULL destination surface");
     }
 
     func = SDL_CalculateBlendLineFunc(dst->format);
-    if (!func) {
+    if (func == NULL) {
         return SDL_SetError("SDL_BlendLines(): Unsupported surface format");
     }
 
diff --git a/src/render/software/SDL_blendpoint.c b/src/render/software/SDL_blendpoint.c
index 613169b7b..ffbf86677 100644
--- a/src/render/software/SDL_blendpoint.c
+++ b/src/render/software/SDL_blendpoint.c
@@ -217,7 +217,7 @@ int
 SDL_BlendPoint(SDL_Surface * dst, int x, int y, SDL_BlendMode blendMode, Uint8 r,
                Uint8 g, Uint8 b, Uint8 a)
 {
-    if (!dst) {
+    if (dst == NULL) {
         return SDL_InvalidParamError("SDL_BlendPoint(): dst");
     }
 
@@ -286,7 +286,7 @@ SDL_BlendPoints(SDL_Surface * dst, const SDL_Point * points, int count,
                 SDL_BlendMode blendMode, Uint8 r, Uint8 g, Uint8 b, Uint8 a) = NULL;
     int status = 0;
 
-    if (!dst) {
+    if (dst == NULL) {
         return SDL_InvalidParamError("SDL_BlendPoints(): dst");
     }
 
@@ -332,7 +332,7 @@ SDL_BlendPoints(SDL_Surface * dst, const SDL_Point * points, int count,
         break;
     }
 
-    if (!func) {
+    if (func == NULL) {
         if (!dst->format->Amask) {
             func = SDL_BlendPoint_RGB;
         } else {
diff --git a/src/render/software/SDL_drawline.c b/src/render/software/SDL_drawline.c
index e309f1619..76f4b600b 100644
--- a/src/render/software/SDL_drawline.c
+++ b/src/render/software/SDL_drawline.c
@@ -143,12 +143,12 @@ SDL_DrawLine(SDL_Surface * dst, int x1, int y1, int x2, int y2, Uint32 color)
 {
     DrawLineFunc func;
 
-    if (!dst) {
+    if (dst == NULL) {
         return SDL_InvalidParamError("SDL_DrawLine(): dst");
     }
 
     func = SDL_CalculateDrawLineFunc(dst->format);
-    if (!func) {
+    if (func == NULL) {
         return SDL_SetError("SDL_DrawLine(): Unsupported surface format");
     }
 
@@ -172,12 +172,12 @@ SDL_DrawLines(SDL_Surface * dst, const SDL_Point * points, int count,
     SDL_bool draw_end;
     DrawLineFunc func;
 
-    if (!dst) {
+    if (dst == NULL) {
         return SDL_InvalidParamError("SDL_DrawLines(): dst");
     }
 
     func = SDL_CalculateDrawLineFunc(dst->format);
-    if (!func) {
+    if (func == NULL) {
         return SDL_SetError("SDL_DrawLines(): Unsupported surface format");
     }
 
diff --git a/src/render/software/SDL_drawpoint.c b/src/render/software/SDL_drawpoint.c
index b99838ac6..5c1607543 100644
--- a/src/render/software/SDL_drawpoint.c
+++ b/src/render/software/SDL_drawpoint.c
@@ -29,7 +29,7 @@
 int
 SDL_DrawPoint(SDL_Surface * dst, int x, int y, Uint32 color)
 {
-    if (!dst) {
+    if (dst == NULL) {
         return SDL_InvalidParamError("SDL_DrawPoint(): dst");
     }
 
@@ -70,7 +70,7 @@ SDL_DrawPoints(SDL_Surface * dst, const SDL_Point * points, int count,
     int i;
     int x, y;
 
-    if (!dst) {
+    if (dst == NULL) {
         return SDL_InvalidParamError("SDL_DrawPoints(): dst");
     }
 
diff --git a/src/render/software/SDL_render_sw.c b/src/render/software/SDL_render_sw.c
index 6ba77d46e..9141a7ad2 100644
--- a/src/render/software/SDL_render_sw.c
+++ b/src/render/software/SDL_render_sw.c
@@ -142,8 +142,9 @@ SW_UpdateTexture(SDL_Renderer * renderer, SDL_Texture * texture,
     int row;
     size_t length;
 
-    if(SDL_MUSTLOCK(surface))
+    if (SDL_MUSTLOCK(surface)) {
         SDL_LockSurface(surface);
+    }
     src = (Uint8 *) pixels;
     dst = (Uint8 *) surface->pixels +
                         rect->y * surface->pitch +
@@ -154,8 +155,9 @@ SW_UpdateTexture(SDL_Renderer * renderer, SDL_Texture * texture,
         src += pitch;
         dst += surface->pitch;
     }
-    if(SDL_MUSTLOCK(surface))
+    if (SDL_MUSTLOCK(surface)) {
         SDL_UnlockSurface(surface);
+    }
     return 0;
 }
 
@@ -207,7 +209,7 @@ SW_QueueDrawPoints(SDL_Renderer * renderer, SDL_RenderCommand *cmd, const SDL_FP
     SDL_Point *verts = (SDL_Point *) SDL_AllocateRenderVertices(renderer, count * sizeof (SDL_Point), 0, &cmd->data.draw.first);
     int i;
 
-    if (!verts) {
+    if (verts == NULL) {
         return -1;
     }
 
@@ -227,7 +229,7 @@ SW_QueueFillRects(SDL_Renderer * renderer, SDL_RenderCommand *cmd, const SDL_FRe
     SDL_Rect *verts = (SDL_Rect *) SDL_AllocateRenderVertices(renderer, count * sizeof (SDL_Rect), 0, &cmd->data.draw.first);
     int i;
 
-    if (!verts) {
+    if (verts == NULL) {
         return -1;
     }
 
@@ -249,7 +251,7 @@ SW_QueueCopy(SDL_Renderer * renderer, SDL_RenderCommand *cmd, SDL_Texture * text
 {
     SDL_Rect *verts = (SDL_Rect *) SDL_AllocateRenderVertices(renderer, 2 * sizeof (SDL_Rect), 0, &cmd->data.draw.first);
 
-    if (!verts) {
+    if (verts == NULL) {
         return -1;
     }
 
@@ -284,7 +286,7 @@ SW_QueueCopyEx(SDL_Renderer * renderer, SDL_RenderCommand *cmd, SDL_Texture * te
 {
     CopyExData *verts = (CopyExData *) SDL_AllocateRenderVertices(renderer, sizeof (CopyExData), 0, &cmd->data.draw.first);
 
-    if (!verts) {
+    if (verts == NULL) {
         return -1;
     }
 
@@ -340,7 +342,7 @@ SW_RenderCopyEx(SDL_Renderer * renderer, SDL_Surface *surface, SDL_Texture * tex
     int blitRequired = SDL_FALSE;
     int isOpaque = SDL_FALSE;
 
-    if (!surface) {
+    if (surface == NULL) {
         return -1;
     }
 
@@ -559,7 +561,7 @@ SW_QueueGeometry(SDL_Renderer *renderer, SDL_RenderCommand *cmd, SDL_Texture *te
     int sz = texture ? sizeof (GeometryCopyData) : sizeof (GeometryFillData);
 
     verts = (void *) SDL_AllocateRenderVertices(renderer, count * sz, 0, &cmd->data.draw.first);
-    if (!verts) {
+    if (verts == NULL) {
         return -1;
     }
 
@@ -684,7 +686,7 @@ SW_RunCommandQueue(SDL_Renderer * renderer, SDL_RenderCommand *cmd, void *vertic
     SDL_Surface *surface = SW_ActivateRenderer(renderer);
     SW_DrawStateCache drawstate;
 
-    if (!surface) {
+    if (surface == NULL) {
         return -1;
     }
 
@@ -960,7 +962,7 @@ SW_RenderReadPixels(SDL_Renderer * renderer, const SDL_Rect * rect,
     Uint32 src_format;
     void *src_pixels;
 
-    if (!surface) {
+    if (surface == NULL) {
         return -1;
     }
 
@@ -988,7 +990,7 @@ SW_RenderPresent(SDL_Renderer * renderer)
 {
     SDL_Window *window = renderer->window;
 
-    if (!window) {
+    if (window == NULL) {
         return -1;
     }
     return SDL_UpdateWindowSurface(window);
@@ -1017,19 +1019,19 @@ SW_CreateRendererForSurface(SDL_Surface * surface)
     SDL_Renderer *renderer;
     SW_RenderData *data;
 
-    if (!surface) {
+    if (surface == NULL) {
         SDL_InvalidParamError("surface");
         return NULL;
     }
 
     renderer = (SDL_Renderer *) SDL_calloc(1, sizeof(*renderer));
-    if (!renderer) {
+    if (renderer == NULL) {
         SDL_OutOfMemory();
         return NULL;
     }
 
     data = (SW_RenderData *) SDL_calloc(1, sizeof(*data));
-    if (!data) {
+    if (data == NULL) {
         SW_DestroyRenderer(renderer);
         SDL_OutOfMemory();
         return NULL;
@@ -1075,7 +1077,7 @@ SW_CreateRenderer(SDL_Window * window, Uint32 flags)
 
     /* Set the vsync hint based on our flags, if it's not already set */
     hint = SDL_GetHint(SDL_HINT_RENDER_VSYNC);
-    if (!hint || !*hint) {
+    if (hint == NULL || !*hint) {
         no_hint_set = SDL_TRUE;
     } else {
         no_hint_set = SDL_FALSE;
@@ -1092,7 +1094,7 @@ SW_CreateRenderer(SDL_Window * window, Uint32 flags)
         SDL_SetHint(SDL_HINT_RENDER_VSYNC, "");
     }
 
-    if (!surface) {
+    if (surface == NULL) {
         return NULL;
     }
     return SW_CreateRendererForSurface(surface);
diff --git a/src/render/software/SDL_rotate.c b/src/render/software/SDL_rotate.c
index ade087265..c3d6ebde8 100644
--- a/src/render/software/SDL_rotate.c
+++ b/src/render/software/SDL_rotate.c
@@ -152,10 +152,13 @@ SDLgfx_rotozoomSurfaceSizeTrig(int width, int height, double angle, const SDL_FP
     {
         /* The trig code below gets the wrong size (due to FP inaccuracy?) when angle is a multiple of 90 degrees */
         int angle90 = (int)(angle/90);
-        if(angle90 == angle/90) { /* if the angle is a multiple of 90 degrees */
+        if (angle90 == angle/90) { /* if the angle is a multiple of 90 degrees */
             angle90 %= 4;
-            if(angle90 < 0) angle90 += 4; /* 0:0 deg, 1:90 deg, 2:180 deg, 3:270 deg */
-            if(angle90 & 1) {
+            if (angle90 < 0) {
+                angle90 += 4; /* 0:0 deg, 1:90 deg, 2:180 deg, 3:270 deg */
+            }
+
+            if (angle90 & 1) {
                 rect_dest->w  = height;
                 rect_dest->h = width;
                 *cangle = 0;
@@ -284,8 +287,12 @@ transformSurfaceRGBA(SDL_Surface * src, SDL_Surface * dst, int isin, int icos,
             for (x = 0; x < dst->w; x++) {
                 int dx = (sdx >> 16);
                 int dy = (sdy >> 16);
-                if (flipx) dx = sw - dx;
-                if (flipy) dy = sh - dy;
+                if (flipx) {
+                    dx = sw - dx;
+                }
+                if (flipy) {
+                    dy = sh - dy;
+                }
                 if ((dx > -1) && (dy > -1) && (dx < (src->w-1)) && (dy < (src->h-1))) {
                     int ex, ey;
                     int t1, t2;
@@ -341,8 +348,12 @@ transformSurfaceRGBA(SDL_Surface * src, SDL_Surface * dst, int isin, int icos,
                 int dx = (sdx >> 16);
                 int dy = (sdy >> 16);
                 if ((unsigned)dx < (unsigned)src->w && (unsigned)dy < (unsigned)src->h) {
-                    if(flipx) dx = sw - dx;
-                    if(flipy) dy = sh - dy;
+                    if (flipx) {
+                        dx = sw - dx;
+                    }
+                    if (flipy) {
+                        dy = sh - dy;
+                    }
                     *pc = *((tColorRGBA *)((Uint8 *)src->pixels + src->pitch * dy) + dx);
                 }
                 sdx += icos;
@@ -411,8 +422,12 @@ transformSurfaceY(SDL_Surface * src, SDL_Surface * dst, int isin, int icos, int
             int dx = (sdx >> 16);
             int dy = (sdy >> 16);
             if ((unsigned)dx < (unsigned)src->w && (unsigned)dy < (unsigned)src->h) {
-                if (flipx) dx = sw - dx;
-                if (flipy) dy = sh- dy;
+                if (flipx) {
+                    dx = sw - dx;
+                }
+                if (flipy) {
+                    dy = sh - dy;
+                }
                 *pc = *((tColorY *)src->pixels + src->pitch * dy + dx);
             }
             sdx += icos;
@@ -463,8 +478,9 @@ SDLgfx_rotateSurface(SDL_Surface * src, double angle, int smooth, int flipx, int
     double sangleinv, cangleinv;
 
     /* Sanity check */
-    if (src == NULL)
+    if (src == NULL) {
         return NULL;
+    }
 
     if (SDL_HasColorKey(src)) {
         if (SDL_GetColorKey(src, &colorkey) == 0) {
@@ -473,8 +489,9 @@ SDLgfx_rotateSurface(SDL_Surface * src, double angle, int smooth, int flipx, int
     }
     /* This function requires a 32-bit surface or 8-bit surface with a colorkey */
     is8bit = src->format->BitsPerPixel == 8 && colorKeyAvailable;
-    if (!(is8bit || (src->format->BitsPerPixel == 32 && src->format->Amask)))
+    if (!(is8bit || (src->format->BitsPerPixel == 32 && src->format->Amask))) {
         return NULL;
+    }
 
     /* Calculate target factors from sine/cosine and zoom */
     sangleinv = sangle*65536.0;
@@ -501,8 +518,9 @@ SDLgfx_rotateSurface(SDL_Surface * src, double angle, int smooth, int flipx, int
     }
 
     /* Check target */
-    if (rz_dst == NULL)
+    if (rz_dst == NULL) {
         return NULL;
+    }
 
     /* Adjust for guard rows */
     rz_dst->h = rect_dest->h;
@@ -542,14 +560,17 @@ SDLgfx_rotateSurface(SDL_Surface * src, double angle, int smooth, int flipx, int
     angle90 = (int)(angle/90);
     if (angle90 == angle/90) {
         angle90 %= 4;
-        if (angle90 < 0) angle90 += 4; /* 0:0 deg, 1:90 deg, 2:180 deg, 3:270 deg */
+        if (angle90 < 0) {
+            angle90 += 4; /* 0:0 deg, 1:90 deg, 2:180 deg, 3:270 deg */
+        }
+
     } else {
         angle90 = -1;
     }
 
     if (is8bit) {
         /* Call the 8-bit transformation routine to do the rotation */
-        if(angle90 >= 0) {
+        if (angle90 >= 0) {
             transformSurfaceY90(src, rz_dst, angle90, flipx, flipy);
         } else {
             transformSurfaceY(src, rz_dst, (int)sangleinv, (int)cangleinv,
diff --git a/src/render/software/SDL_triangle.c b/src/render/software/SDL_triangle.c
index f70c07933..38e2e2d0d 100644
--- a/src/render/software/SDL_triangle.c
+++ b/src/render/software/SDL_triangle.c
@@ -520,14 +520,26 @@ int SDL_SW_BlitTriangle(
         maxx = srcrect.x + srcrect.w;
         maxy = srcrect.y + srcrect.h;
         if (srcrect.w > 0) {
-            if (s0->x == maxx) s0->x--;
-            if (s1->x == maxx) s1->x--;
-            if (s2->x == maxx) s2->x--;
+            if (s0->x == maxx) {
+                s0->x--;
+            }
+            if (s1->x == maxx) {
+                s1->x--;
+            }
+            if (s2->x == maxx) {
+                s2->x--;
+            }
         }
         if (srcrect.h > 0) {
-            if (s0->y == maxy) s0->y--;
-            if (s1->y == maxy) s1->y--;
-            if (s2->y == maxy) s2->y--;
+            if (s0->y == maxy) {
+                s0->y--;
+            }
+            if (s1->y == maxy) {
+                s1->y--;
+            }
+            if (s2->y == maxy) {
+                s2->y--;
+            }
         }
     }
 
diff --git a/src/render/vitagxm/SDL_render_vita_gxm.c b/src/render/vitagxm/SDL_render_vita_gxm.c
index 1391b19a4..745617983 100644
--- a/src/render/vitagxm/SDL_render_vita_gxm.c
+++ b/src/render/vitagxm/SDL_render_vita_gxm.c
@@ -228,13 +228,13 @@ VITA_GXM_CreateRenderer(SDL_Window *window, Uint32 flags)
     VITA_GXM_RenderData *data;
 
     renderer = (SDL_Renderer *) SDL_calloc(1, sizeof(*renderer));
-    if (!renderer) {
+    if (renderer == NULL) {
         SDL_OutOfMemory();
         return NULL;
     }
 
     data = (VITA_GXM_RenderData *) SDL_calloc(1, sizeof(VITA_GXM_RenderData));
-    if (!data) {
+    if (data == NULL) {
         SDL_free(renderer);
         SDL_OutOfMemory();
         return NULL;
@@ -282,8 +282,7 @@ VITA_GXM_CreateRenderer(SDL_Window *window, Uint32 flags)
     sceSysmoduleLoadModule( SCE_SYSMODULE_RAZOR_CAPTURE );
 #endif
 
-    if (gxm_init(renderer) != 0)
-    {
+    if (gxm_init(renderer) != 0) {
         SDL_free(data);
         SDL_free(renderer);
         return NULL;
@@ -310,7 +309,7 @@ VITA_GXM_CreateTexture(SDL_Renderer *renderer, SDL_Texture *texture)
     VITA_GXM_RenderData *data = (VITA_GXM_RenderData *) renderer->driverdata;
     VITA_GXM_TextureData* vita_texture = (VITA_GXM_TextureData*) SDL_calloc(1, sizeof(VITA_GXM_TextureData));
 
-    if (!vita_texture) {
+    if (vita_texture == NULL) {
         return SDL_OutOfMemory();
     }
 
@@ -649,8 +648,7 @@ VITA_GXM_SetRenderTarget(SDL_Renderer *renderer, SDL_Texture *texture)
 static void
 VITA_GXM_SetBlendMode(VITA_GXM_RenderData *data, int blendMode)
 {
-    if (blendMode != data->currentBlendMode)
-    {
+    if (blendMode != data->currentBlendMode) {
         fragment_programs *in = &data->blendFragmentPrograms.blend_mode_blend;
 
         switch (blendMode)
@@ -711,8 +709,7 @@ VITA_GXM_QueueDrawPoints(SDL_Renderer * renderer, SDL_RenderCommand *cmd, const
     cmd->data.draw.first = (size_t)vertex;
     cmd->data.draw.count = count;
 
-    for (int i = 0; i < count; i++)
-    {
+    for (int i = 0; i < count; i++) {
         vertex[i].x = points[i].x;
         vertex[i].y = points[i].y;
         vertex[i].color = color;
@@ -735,8 +732,7 @@ VITA_GXM_QueueDrawLines(SDL_Renderer * renderer, SDL_RenderCommand *cmd, const S
     cmd->data.draw.first = (size_t)vertex;
     cmd->data.draw.count = (count-1) * 2;
 
-    for (int i = 0; i < count - 1; i++)
-    {
+    for (int i = 0; i < count - 1; i++) {
         vertex[i*2].x = points[i].x;
         vertex[i*2].y = points[i].y;
         vertex[i*2].color = color;
@@ -770,7 +766,7 @@ VITA_GXM_QueueGeometry(SDL_Renderer *renderer, SDL_RenderCommand *cmd, SDL_Textu
                 data,
                 count * sizeof(texture_vertex));
 
-        if (!vertices) {
+        if (vertices == NULL) {
             return -1;
         }
 
@@ -810,7 +806,7 @@ VITA_GXM_QueueGeometry(SDL_Renderer *renderer, SDL_RenderCommand *cmd, SDL_Textu
                 data,
                 count * sizeof(color_vertex));
 
-        if (!vertices) {
+        if (vertices == NULL) {
             return -1;
         }
 
@@ -1148,7 +1144,7 @@ VITA_GXM_RenderReadPixels(SDL_Renderer *renderer, const SDL_Rect *rect,
     }
 
     temp_pixels = SDL_malloc(buflen);
-    if (!temp_pixels) {
+    if (temp_pixels == NULL) {
         return SDL_OutOfMemory();
     }
 
@@ -1236,14 +1232,17 @@ VITA_GXM_DestroyTexture(SDL_Renderer *renderer, SDL_Texture *texture)
     VITA_GXM_RenderData *data = (VITA_GXM_RenderData *) renderer->driverdata;
     VITA_GXM_TextureData *vita_texture = (VITA_GXM_TextureData *) texture->driverdata;
 
-    if (data == NULL)
+    if (data == NULL) {
         return;
+    }
 
-    if(vita_texture == NULL)
+    if (vita_texture == NULL) {
         return;
+    }
 
-    if(vita_texture->tex == NULL)
+    if (vita_texture->tex == NULL) {
         return;
+    }
 
     sceGxmFinish(data->gxm_context);
 
@@ -1259,8 +1258,9 @@ VITA_GXM_DestroyRenderer(SDL_Renderer *renderer)
 {
     VITA_GXM_RenderData *data = (VITA_GXM_RenderData *) renderer->driverdata;
     if (data) {
-        if (!data->initialized)
+        if (!data->initialized) {
             return;
+        }
 
         gxm_finish(renderer);
 
diff --git a/src/render/vitagxm/SDL_render_vita_gxm_memory.c b/src/render/vitagxm/SDL_render_vita_gxm_memory.c
index 85d682ad7..dee8d600b 100644
--- a/src/render/vitagxm/SDL_render_vita_gxm_memory.c
+++ b/src/render/vitagxm/SDL_render_vita_gxm_memory.c
@@ -38,14 +38,17 @@ vita_mem_alloc(unsigned int type, unsigned int size, unsigned int alignment, uns
 
     *uid = sceKernelAllocMemBlock("gpu_mem", type, size, NULL);
 
-    if (*uid < 0)
+    if (*uid < 0) {
         return NULL;
+    }
 
-    if (sceKernelGetMemBlockBase(*uid, &mem) < 0)
+    if (sceKernelGetMemBlockBase(*uid, &mem) < 0) {
         return NULL;
+    }
 
-    if (sceGxmMapMemory(mem, size, attribs) < 0)
+    if (sceGxmMapMemory(mem, size, attribs) < 0) {
         return NULL;
+    }
 
     return mem;
 }
@@ -54,8 +57,9 @@ void
 vita_mem_free(SceUID uid)
 {
     void *mem = NULL;
-    if (sceKernelGetMemBlockBase(uid, &mem) < 0)
+    if (sceKernelGetMemBlockBase(uid, &mem) < 0) {
         return;
+    }
     sceGxmUnmapMemory(mem);
     sceKernelFreeMemBlock(uid);
 }
@@ -82,8 +86,7 @@ vita_gpu_mem_alloc(VITA_GXM_RenderData *data, unsigned int size)
         }
 
         ret = sceKernelGetMemBlockBase(data->texturePoolUID, &mem);
-        if ( ret < 0)
-        {
+        if ( ret < 0) {
             return NULL;
         }
         data->texturePool = sceClibMspaceCreate(mem, poolsize);
@@ -92,8 +95,7 @@ vita_gpu_mem_alloc(VITA_GXM_RenderData *data, unsigned int size)
             return NULL;
         }
         ret = sceGxmMapMemory(mem, poolsize, SCE_GXM_MEMORY_ATTRIB_READ | SCE_GXM_MEMORY_ATTRIB_WRITE);
-        if (ret < 0)
-        {
+        if (ret < 0) {
             return NULL;
         }
     }
@@ -103,8 +105,7 @@ vita_gpu_mem_alloc(VITA_GXM_RenderData *data, unsigned int size)
 void
 vita_gpu_mem_free(VITA_GXM_RenderData *data, void* ptr)
 {
-    if (data->texturePool != NULL)
-    {
+    if (data->texturePool != NULL) {
         sceClibMspaceFree(data->texturePool, ptr);
     }
 }
@@ -113,12 +114,12 @@ void
 vita_gpu_mem_destroy(VITA_GXM_RenderData *data)
 {
     void *mem = NULL;
-    if (data->texturePool != NULL)
-    {
+    if (data->texturePool != NULL) {
         sceClibMspaceDestroy(data->texturePool);
         data->texturePool = NULL;
-        if (sceKernelGetMemBlockBase(data->texturePoolUID, &mem) < 0)
+        if (sceKernelGetMemBlockBase(data->texturePoolUID, &mem) < 0) {
             return;
+        }
         sceGxmUnmapMemory(mem);
         sceKernelFreeMemBlock(data->texturePoolUID);
     }
@@ -132,10 +133,12 @@ vita_mem_vertex_usse_alloc(unsigned int size, SceUID *uid, unsigned int *usse_of
     size = ALIGN(size, 4096);
     *uid = sceKernelAllocMemBlock("vertex_usse", SCE_KERNEL_MEMBLOCK_TYPE_USER_RW_UNCACHE, size, NULL);
 
-    if (sceKernelGetMemBlockBase(*uid, &mem) < 0)
+    if (sceKernelGetMemBlockBase(*uid, &mem) < 0) {
         return NULL;
-    if (sceGxmMapVertexUsseMemory(mem, size, usse_offset) < 0)
+    }
+    if (sceGxmMapVertexUsseMemory(mem, size, usse_offset) < 0) {
         return NULL;
+    }
 
     return mem;
 }
@@ -144,8 +147,9 @@ void
 vita_mem_vertex_usse_free(SceUID uid)
 {
     void *mem = NULL;
-    if (sceKernelGetMemBlockBase(uid, &mem) < 0)
+    if (sceKernelGetMemBlockBase(uid, &mem) < 0) {
         return;
+    }
     sceGxmUnmapVertexUsseMemory(mem);
     sceKernelFreeMemBlock(uid);
 }
@@ -158,10 +162,12 @@ vita_mem_fragment_usse_alloc(unsigned int size, SceUID *uid, unsigned int *usse_
     size = ALIGN(size, 4096);
     *uid = sceKernelAllocMemBlock("fragment_usse", SCE_KERNEL_MEMBLOCK_TYPE_USER_RW_UNCACHE, size, NULL);
 
-    if (sceKernelGetMemBlockBase(*uid, &mem) < 0)
+    if (sceKernelGetMemBlockBase(*uid, &mem) < 0) {
         return NULL;
-    if (sceGxmMapFragmentUsseMemory(mem, size, usse_offset) < 0)
+    }
+    if (sceGxmMapFragmentUsseMemory(mem, size, usse_offset) < 0) {
         return NULL;
+    }
 
     return mem;
 }
@@ -170,8 +176,9 @@ void
 vita_mem_fragment_usse_free(SceUID uid)
 {
     void *mem = NULL;
-    if (sceKernelGetMemBlockBase(uid, &mem) < 0)
+    if (sceKernelGetMemBlockBase(uid, &mem) < 0) {
         return;
+    }
     sceGxmUnmapFragmentUsseMemory(mem);
     sceKernelFreeMemBlock(uid);
 }
diff --git a/src/render/vitagxm/SDL_render_vita_gxm_tools.c b/src/render/vitagxm/SDL_render_vita_gxm_tools.c
index 10deb556a..1151a5d82 100644
--- a/src/render/vitagxm/SDL_render_vita_gxm_tools.c
+++ b/src/render/vitagxm/SDL_render_vita_gxm_tools.c
@@ -260,7 +260,7 @@ set_stencil_mask(VITA_GXM_RenderData *data, float x, float y, float w, float h)
 void
 set_clip_rectangle(VITA_GXM_RenderData *data, int x_min, int y_min, int x_max, int y_max)
 {
-    if(data->drawing) {
+    if (data->drawing) {
         // clear the stencil buffer to 0
         sceGxmSetFrontStencilFunc(
             data->gxm_context,
@@ -750,8 +750,7 @@ gxm_init(SDL_Renderer *renderer)
         &data->linearIndicesUid
     );
 
-    for (i = 0; i <= UINT16_MAX; ++i)
-    {
+    for (i = 0; i <= UINT16_MAX; ++i) {
         data->linearIndices[i] = i;
     }
 
@@ -929,8 +928,7 @@ void gxm_finish(SDL_Renderer *renderer)
     // clean up display queue
     vita_mem_free(data->depthBufferUid);
 
-    for (size_t i = 0; i < VITA_GXM_BUFFERS; i++)
-    {
+    for (size_t i = 0; i < VITA_GXM_BUFFERS; i++) {
         // clear the buffer then deallocate
         SDL_memset(data->displayBufferData[i], 0, VITA_GXM_SCREEN_HEIGHT * VITA_GXM_SCREEN_STRIDE * 4);
         vita_mem_free(data->displayBufferUid[i]);
@@ -1050,8 +1048,9 @@ create_gxm_texture(VITA_GXM_RenderData *data, unsigned int w, unsigned int h, Sc
         tex_size += (((aligned_w + 1) / 2) * ((h + 1) / 2)) * 2;
     }
 
-    if (!texture)
+    if (texture == NULL) {
         return NULL;
+    }
 
     *return_w = w;
     *return_h = h;
@@ -1064,7 +1063,7 @@ create_gxm_texture(VITA_GXM_RenderData *data, unsigned int w, unsigned int h, Sc
     );
 
     /* Try SCE_KERNEL_MEMBLOCK_TYPE_USER_RW_UNCACHE in case we're out of VRAM */
-    if (!texture_data) {
+    if (texture_data == NULL) {
         SDL_LogWarn(SDL_LOG_CATEGORY_RENDER, "CDRAM texture allocation failed\n");
         texture_data = vita_mem_alloc(
             SCE_KERNEL_MEMBLOCK_TYPE_USER_RW_UNCACHE,
@@ -1078,7 +1077,7 @@ create_gxm_texture(VITA_GXM_RenderData *data, unsigned int w, unsigned int h, Sc
         texture->cdram = 1;
     }
 
-    if (!texture_data) {
+    if (texture_data == NULL) {
         SDL_free(texture);
         return NULL;
     }
@@ -1211,8 +1210,7 @@ void gxm_minimal_term_for_common_dialog(void)
 
 void gxm_init_for_common_dialog(void)
 {
-    for (int i = 0; i < VITA_GXM_BUFFERS; i += 1)
-    {
+    for (int i = 0; i < VITA_GXM_BUFFERS; i += 1) {
         buffer_for_common_dialog[i].displayData.wait_vblank = SDL_TRUE;
         buffer_for_common_dialog[i].displayData.address = vita_mem_alloc(
             SCE_KERNEL_MEMBLOCK_TYPE_USER_CDRAM_RW,
@@ -1260,8 +1258,7 @@ void gxm_swap_for_common_dialog(void)
 void gxm_term_for_common_dialog(void)
 {
     sceGxmDisplayQueueFinish();
-    for (int i = 0; i < VITA_GXM_BUFFERS; i += 1)
-    {
+    for (int i = 0; i < VITA_GXM_BUFFERS; i += 1) {
         vita_mem_free(buffer_for_common_dialog[i].uid);
         sceGxmSyncObjectDestroy(buffer_for_common_dialog[i].sync);
     }
diff --git a/src/sensor/SDL_sensor.c b/src/sensor/SDL_sensor.c
index 6db4c633f..6237498f2 100644
--- a/src/sensor/SDL_sensor.c
+++ b/src/sensor/SDL_sensor.c
@@ -79,7 +79,7 @@ SDL_SensorInit(void)
     int i, status;
 
     /* Create the sensor list lock */
-    if (!SDL_sensor_lock) {
+    if (SDL_sensor_lock == NULL) {
         SDL_sensor_lock = SDL_CreateMutex();
     }
 
diff --git a/src/sensor/android/SDL_androidsensor.c b/src/sensor/android/SDL_androidsensor.c
index 27fb04cdf..69c3f28fa 100644
--- a/src/sensor/android/SDL_androidsensor.c
+++ b/src/sensor/android/SDL_androidsensor.c
@@ -56,14 +56,14 @@ SDL_ANDROID_SensorInit(void)
     ASensorList sensors;
 
     SDL_sensor_manager = ASensorManager_getInstance();
-    if (!SDL_sensor_manager) {
+    if (SDL_sensor_manager == NULL) {
         return SDL_SetError("Couldn't create sensor manager");
     }
 
     SDL_sensor_looper = ALooper_forThread();
-    if (!SDL_sensor_looper) {
+    if (SDL_sensor_looper == NULL) {
         SDL_sensor_looper = ALooper_prepare(ALOOPER_PREPARE_ALLOW_NON_CALLBACKS);
-        if (!SDL_sensor_looper) {
+        if (SDL_sensor_looper == NULL) {
             return SDL_SetError("Couldn't create sensor event loop");
         }
     }
@@ -72,7 +72,7 @@ SDL_ANDROID_SensorInit(void)
     sensors_count = ASensorManager_getSensorList(SDL_sensor_manager, &sensors);
     if (sensors_count > 0) {
         SDL_sensors = (SDL_AndroidSensor *)SDL_calloc(sensors_count, sizeof(*SDL_sensors));
-        if (!SDL_sensors) {
+        if (SDL_sensors == NULL) {
             return SDL_OutOfMemory();
         }
 
diff --git a/src/sensor/vita/SDL_vitasensor.c b/src/sensor/vita/SDL_vitasensor.c
index 3123f1623..c1f28b4a7 100644
--- a/src/sensor/vita/SDL_vitasensor.c
+++ b/src/sensor/vita/SDL_vitasensor.c
@@ -55,7 +55,7 @@ SDL_VITA_SensorInit(void)
     SDL_sensors_count = 2;
 
     SDL_sensors = (SDL_VitaSensor *)SDL_calloc(SDL_sensors_count, sizeof(*SDL_sensors));
-    if (!SDL_sensors) {
+    if (SDL_sensors == NULL) {
         return SDL_OutOfMemory();
     }
 
@@ -145,15 +145,12 @@ SDL_VITA_SensorUpdate(SDL_Sensor *sensor)
     SDL_memset(motionState, 0, sizeof(motionState));
 
     err = sceMotionGetSensorState(motionState, SCE_MOTION_MAX_NUM_STATES);
-    if (err != 0)
-    {
+    if (err != 0) {
         return;
     }
 
-    for (int i = 0; i < SCE_MOTION_MAX_NUM_STATES; i++)
-    {
-        if (sensor->hwdata->counter < motionState[i].counter)
-        {
+    for (int i = 0; i < SCE_MOTION_MAX_NUM_STATES; i++) {
+        if (sensor->hwdata->counter < motionState[i].counter) {
             unsigned int timestamp = motionState[i].timestamp;
 
             sensor->hwdata->counter = motionState[i].counter;
diff --git a/src/sensor/windows/SDL_windowssensor.c b/src/sensor/windows/SDL_windowssensor.c
index b2edffce0..2a974b0df 100644
--- a/src/sensor/windows/SDL_windowssensor.c
+++ b/src/sensor/windows/SDL_windowssensor.c
@@ -67,7 +67,7 @@ static int DisconnectSensor(ISensor *sensor);
 
 static HRESULT STDMETHODCALLTYPE ISensorManagerEventsVtbl_QueryInterface(ISensorManagerEvents * This, REFIID riid, void **ppvObject)
 {
-    if (!ppvObject) {
+    if (ppvObject == NULL) {
         return E_INVALIDARG;
     }
 
@@ -107,7 +107,7 @@ static ISensorManagerEvents sensor_manager_events = {
 
 static HRESULT STDMETHODCALLTYPE ISensorEventsVtbl_QueryInterface(ISensorEvents * This, REFIID riid, void **ppvObject)
 {
-    if (!ppvObject) {
+    if (ppvObject == NULL) {
         return E_INVALIDARG;
     }
 
@@ -286,7 +286,7 @@ static int ConnectSensor(ISensor *sensor)
     if (bstr_name != NULL) {
         SysFreeString(bstr_name);
     }
-    if (!name) {
+    if (name == NULL) {
         return SDL_OutOfMemory();
     }
 
diff --git a/src/stdlib/SDL_crc16.c b/src/stdlib/SDL_crc16.c
index 0008b2e3e..c73dad653 100644
--- a/src/stdlib/SDL_crc16.c
+++ b/src/stdlib/SDL_crc16.c
@@ -48,7 +48,7 @@ Uint16 SDL_crc16(Uint16 crc, const void *data, size_t len)
 {
     /* As an optimization we can precalculate a 256 entry table for each byte */
     size_t i;
-    for(i = 0; i < len; ++i) {
+    for (i = 0; i < len; ++i) {
         crc = crc16_for_byte((Uint8)crc ^ ((const Uint8*)data)[i]) ^ crc >> 8;
     }
     return crc;
diff --git a/src/stdlib/SDL_crc32.c b/src/stdlib/SDL_crc32.c
index cd7229c96..be2144a7d 100644
--- a/src/stdlib/SDL_crc32.c
+++ b/src/stdlib/SDL_crc32.c
@@ -46,7 +46,7 @@ Uint32 SDL_crc32(Uint32 crc, const void *data, size_t len)
 {
     /* As an optimization we can precalculate a 256 entry table for each byte */
     size_t i;
-    for(i = 0; i < len; ++i) {
+    for (i = 0; i < len; ++i) {
         crc = crc32_for_byte((Uint8)crc ^ ((const Uint8*)data)[i]) ^ crc >> 8;
     }
     return crc;
diff --git a/src/stdlib/SDL_getenv.c b/src/stdlib/SDL_getenv.c
index b74974c34..737eb9bca 100644
--- a/src/stdlib/SDL_getenv.c
+++ b/src/stdlib/SDL_getenv.c
@@ -48,8 +48,8 @@ int
 SDL_setenv(const char *name, const char *value, int overwrite)
 {
     /* Input validation */
-    if (!name || *name == '\0' || SDL_strchr(name, '=') != NULL || !value) {
-        return (-1);
+    if (name == NULL || *name == '\0' || SDL_strchr(name, '=') != NULL || value == NULL) {
+        return -1;
     }
     
     return setenv(name, value, overwrite);
@@ -59,8 +59,8 @@ int
 SDL_setenv(const char *name, const char *value, int overwrite)
 {
     /* Input validation */
-    if (!name || *name == '\0' || SDL_strchr(name, '=') != NULL || !value) {
-        return (-1);
+    if (name == NULL || *name == '\0' || SDL_strchr(name, '=') != NULL || value == NULL) {
+        return -1;
     }
     
     if (!overwrite) {
@@ -82,8 +82,8 @@ SDL_setenv(const char *name, const char *value, int overwrite)
     char *new_variable;
 
     /* Input validation */
-    if (!name || *name == '\0' || SDL_strchr(name, '=') != NULL || !value) {
-        return (-1);
+    if (name == NULL || *name == '\0' || SDL_strchr(name, '=') != NULL || value == NULL) {
+        return -1;
     }
     
     if (getenv(name) != NULL) {
@@ -97,8 +97,8 @@ SDL_setenv(const char *name, const char *value, int overwrite)
     /* This leaks. Sorry. Get a better OS so we don't have to do this. */
     len = SDL_strlen(name) + SDL_strlen(value) + 2;
     new_variable = (char *) SDL_malloc(len);
-    if (!new_variable) {
-        return (-1);
+    if (new_variable == NULL) {
+        return -1;
     }
 
     SDL_snprintf(new_variable, len, "%s=%s", name, value);
@@ -115,8 +115,8 @@ SDL_setenv(const char *name, const char *value, int overwrite)
     char *new_variable;
 
     /* Input validation */
-    if (!name || *name == '\0' || SDL_strchr(name, '=') != NULL || !value) {
-        return (-1);
+    if (name == NULL || *name == '\0' || SDL_strchr(name, '=') != NULL || value == NULL) {
+        return -1;
     }
 
     /* See if it already exists */
@@ -127,8 +127,8 @@ SDL_setenv(const char *name, const char *value, int overwrite)
     /* Allocate memory for the variable */
     len = SDL_strlen(name) + SDL_strlen(value) + 2;
     new_variable = (char *) SDL_malloc(len);
-    if (!new_variable) {
-        return (-1);
+    if (new_variable == NULL) {
+        return -1;
     }
 
     SDL_snprintf(new_variable, len, "%s=%s", name, value);
@@ -166,7 +166,7 @@ SDL_setenv(const char *name, const char *value, int overwrite)
             SDL_free(new_variable);
         }
     }
-    return (added ? 0 : -1);
+    return added ? 0 : -1;
 }
 #endif
 
@@ -181,7 +181,7 @@ SDL_getenv(const char *name)
 #endif
 
     /* Input validation */
-    if (!name || *name == '\0') {
+    if (name == NULL || *name == '\0') {
         return NULL;
     }
 
@@ -194,7 +194,7 @@ SDL_getenv(const char *name)
     size_t bufferlen;
 
     /* Input validation */
-    if (!name || *name == '\0') {
+    if (name == NULL || *name == '\0') {
         return NULL;
     }
     
@@ -222,14 +222,14 @@ SDL_getenv(const char *name)
     char *value;
 
     /* Input validation */
-    if (!name || *name == '\0') {
+    if (name == NULL || *name == '\0') {
         return NULL;
     }
     
     value = (char *) 0;
     if (SDL_env) {
         len = SDL_strlen(name);
-        for (i = 0; SDL_env[i] && !value; ++i) {
+        for (i = 0; SDL_env[i] && value == NULL; ++i) {
             if ((SDL_strncmp(SDL_env[i], name, len) == 0) &&
                 (SDL_env[i][len] == '=')) {
                 value = &SDL_env[i][len + 1];
@@ -308,7 +308,7 @@ main(int argc, char *argv[])
     } else {
         printf("failed\n");
     }
-    return (0);
+    return 0;
 }
 #endif /* TEST_MAIN */
 
diff --git a/src/stdlib/SDL_iconv.c b/src/stdlib/SDL_iconv.c
index bee60d506..cb30ba705 100644
--- a/src/stdlib/SDL_iconv.c
+++ b/src/stdlib/SDL_iconv.c
@@ -170,16 +170,16 @@ getlocale(char *buffer, size_t bufsize)
     char *ptr;
 
     lang = SDL_getenv("LC_ALL");
-    if (!lang) {
+    if (lang == NULL) {
         lang = SDL_getenv("LC_CTYPE");
     }
-    if (!lang) {
+    if (lang == NULL) {
         lang = SDL_getenv("LC_MESSAGES");
     }
-    if (!lang) {
+    if (lang == NULL) {
         lang = SDL_getenv("LANG");
     }
-    if (!lang || !*lang || SDL_strcmp(lang, "C") == 0) {
+    if (lang == NULL || !*lang || SDL_strcmp(lang, "C") == 0) {
         lang = "ASCII";
     }
 
@@ -207,10 +207,10 @@ SDL_iconv_open(const char *tocode, const char *fromcode)
     char fromcode_buffer[64];
     char tocode_buffer[64];
 
-    if (!fromcode || !*fromcode) {
+    if (fromcode == NULL || !*fromcode) {
         fromcode = getlocale(fromcode_buffer, sizeof(fromcode_buffer));
     }
-    if (!tocode || !*tocode) {
+    if (tocode == NULL || !*tocode) {
         tocode = getlocale(tocode_buffer, sizeof(tocode_buffer));
     }
     for (i = 0; i < SDL_arraysize(encodings); ++i) {
@@ -250,11 +250,11 @@ SDL_iconv(SDL_iconv_t cd,
     Uint32 ch = 0;
     size_t total;
 
-    if (!inbuf || !*inbuf) {
+    if (inbuf == NULL || !*inbuf) {
         /* Reset the context */
         return 0;
     }
-    if (!outbuf || !*outbuf || !outbytesleft || !*outbytesleft) {
+    if (outbuf == NULL || !*outbuf || outbytesleft == NULL || !*outbytesleft) {
         return SDL_ICONV_E2BIG;
     }
     src = *inbuf;
@@ -820,10 +820,10 @@ SDL_iconv_string(const char *tocode, const char *fromcode, const char *inbuf,
     cd = SDL_iconv_open(tocode, fromcode);
     if (cd == (SDL_iconv_t) - 1) {
         /* See if we can recover here (fixes iconv on Solaris 11) */
-        if (!tocode || !*tocode) {
+        if (tocode == NULL || !*tocode) {
             tocode = "UTF-8";
         }
-        if (!fromcode || !*fromcode) {
+        if (fromcode == NULL || !*fromcode) {
             fromcode = "UTF-8";
         }
         cd = SDL_iconv_open(tocode, fromcode);
@@ -834,7 +834,7 @@ SDL_iconv_string(const char *tocode, const char *fromcode, const char *inbuf,
 
     stringsize = inbytesleft > 4 ? inbytesleft : 4;
     string = (char *) SDL_malloc(stringsize);
-    if (!string) {
+    if (string == NULL) {
         SDL_iconv_close(cd);
         return NULL;
     }
@@ -851,7 +851,7 @@ SDL_iconv_string(const char *tocode, const char *fromcode, const char *inbuf,
                 char *oldstring = string;
                 stringsize *= 2;
                 string = (char *) SDL_realloc(string, stringsize);
-                if (!string) {
+                if (string == NULL) {
                     SDL_free(oldstring);
                     SDL_iconv_close(cd);
                     return NULL;
diff --git a/src/stdlib/SDL_string.c b/src/stdlib/SDL_string.c
index ec632b7a6..1bfc13b4c 100644
--- a/src/stdlib/SDL_string.c
+++ b/src/stdlib/SDL_string.c
@@ -94,7 +94,7 @@ SDL_ScanLong(const char *text, int count, int radix, long *valuep)
             *valuep = value;
         }
     }
-    return (text - textstart);
+    return text - textstart;
 }
 #endif
 
@@ -134,7 +134,7 @@ SDL_ScanUnsignedLong(const char *text, int count, int radix, unsigned long *valu
     if (valuep && text > textstart) {
         *valuep = value;
     }
-    return (text - textstart);
+    return text - textstart;
 }
 #endif
 
@@ -166,7 +166,7 @@ SDL_ScanUintPtrT(const char *text, int radix, uintptr_t * valuep)
     if (valuep && text > textstart) {
         *valuep = value;
     }
-    return (text - textstart);
+    return text - textstart;
 }
 #endif
 
@@ -211,7 +211,7 @@ SDL_ScanLongLong(const char *text, int count, int radix, Sint64 * valuep)
             *valuep = value;
         }
     }
-    return (text - textstart);
+    return text - textstart;
 }
 #endif
 
@@ -251,7 +251,7 @@ SDL_ScanUnsignedLongLong(const char *text, int count, int radix, Uint64 * valuep
     if (valuep && text > textstart) {
         *valuep = value;
     }
-    return (text - textstart);
+    return text - textstart;
 }
 #endif
 
@@ -287,7 +287,7 @@ SDL_ScanFloat(const char *text, double *valuep)
             *valuep = value;
         }
     }
-    return (text - textstart);
+    return text - textstart;
 }
 #endif
 
@@ -336,7 +336,7 @@ SDL_memcmp(const void *s1, const void *s2, size_t len)
     char *s2p = (char *) s2;
     while (len--) {
         if (*s1p != *s2p) {
-            return (*s1p - *s2p);
+            return *s1p - *s2p;
         }
         ++s1p;
         ++s2p;
@@ -419,7 +419,7 @@ wchar_t *
 SDL_wcsstr(const wchar_t *haystack, const wchar_t *needle)
 {
 #if defined(HAVE_WCSSTR)
-    return SDL_const_cast(wchar_t*,wcsstr(haystack, needle));
+    return SDL_const_cast(wchar_t *, wcsstr(haystack, needle));
 #else
     size_t length = SDL_wcslen(needle);
     while (*haystack) {
@@ -439,8 +439,9 @@ SDL_wcscmp(const wchar_t *str1, const wchar_t *str2)
     return wcscmp(str1, str2);
 #else
     while (*str1 && *str2) {
-        if (*str1 != *str2)
+        if (*str1 != *str2) {
             break;
+        }
         ++str1;
         ++str2;
     }
@@ -455,8 +456,9 @@ SDL_wcsncmp(const wchar_t *str1, const wchar_t *str2, size_t maxlen)
     return wcsncmp(str1, str2, maxlen);
 #else
     while (*str1 && *str2 && maxlen) {
-        if (*str1 != *str2)
+        if (*str1 != *str2) {
             break;
+        }
         ++str1;
         ++str2;
         --maxlen;
@@ -464,7 +466,7 @@ SDL_wcsncmp(const wchar_t *str1, const wchar_t *str2, size_t maxlen)
     if (!maxlen) {
         return 0;
     }
-    return (int) (*str1 - *str2);
+    return (int)(*str1 - *str2);
 
 #endif /* HAVE_WCSNCMP */
 }
@@ -488,8 +490,9 @@ SDL_wcscasecmp(const wchar_t *str1, const wchar_t *str2)
             a = SDL_toupper((unsigned char) *str1);
             b = SDL_toupper((unsigned char) *str2);
         }
-        if (a != b)
+        if (a != b) {
             break;
+        }
         ++str1;
         ++str2;
     }
@@ -502,7 +505,7 @@ SDL_wcscasecmp(const wchar_t *str1, const wchar_t *str2)
         a = SDL_toupper((unsigned char) *str1);
         b = SDL_toupper((unsigned char) *str2);
     }
-    return (int) ((unsigned int) a - (unsigned int) b);
+    return (int)((unsigned int)a - (unsigned int)b);
 #endif /* HAVE__WCSICMP */
 }
 
@@ -525,8 +528,9 @@ SDL_wcsncasecmp(const wchar_t *str1, const wchar_t *str2, size_t maxlen)
             a = SDL_toupper((unsigned char) *str1);
             b = SDL_toupper((unsigned char) *str2);
         }
-        if (a != b)
+        if (a != b) {
             break;
+        }
         ++str1;
         ++str2;
         --maxlen;
@@ -543,7 +547,7 @@ SDL_wcsncasecmp(const wchar_t *str1, const wchar_t *str2, size_t maxlen)
             a = SDL_toupper((unsigned char) *str1);
             b = SDL_toupper((unsigned char) *str2);
         }
-        return (int) ((unsigned int) a - (unsigned int) b);
+        return (int)((unsigned int)a - (unsigned int)b);
     }
 #endif /* HAVE__WCSNICMP */
 }
@@ -581,8 +585,9 @@ SDL_utf8strlcpy(SDL_OUT_Z_CAP(dst_bytes) char *dst, const char *src, size_t dst_
                 c = (unsigned char)src[i];
                 trailing_bytes = UTF8_TrailingBytes(c);
                 if (trailing_bytes) {
-                    if (bytes - i != trailing_bytes + 1)
+                    if (bytes - i != trailing_bytes + 1) {
                         bytes = i;
+                    }
 
                     break;
                 }
@@ -708,18 +713,18 @@ char *
 SDL_strchr(const char *string, int c)
 {
 #ifdef HAVE_STRCHR
-    return SDL_const_cast(char*,strchr(string, c));
+    return SDL_const_cast(char *, strchr(string, c));
 #elif defined(HAVE_INDEX)
-    return SDL_const_cast(char*,index(string, c));
+    return SDL_const_cast(char *, index(string, c));
 #else
     while (*string) {
         if (*string == c) {
-            return (char *) string;
+            return (char *)string;
         }
         ++string;
     }
     if (c == '\0') {
-        return (char *) string;
+        return (char *)string;
     }
     return NULL;
 #endif /* HAVE_STRCHR */
@@ -729,14 +734,14 @@ char *
 SDL_strrchr(const char *string, int c)
 {
 #ifdef HAVE_STRRCHR
-    return SDL_const_cast(char*,strrchr(string, c));
+    return SDL_const_cast(char *, strrchr(string, c));
 #elif defined(HAVE_RINDEX)
-    return SDL_const_cast(char*,rindex(string, c));
+    return SDL_const_cast(char *, rindex(string, c));
 #else
     const char *bufp = string + SDL_strlen(string);
     while (bufp >= string) {
         if (*bufp == c) {
-            return (char *) bufp;
+            return (char *)bufp;
         }
         --bufp;
     }
@@ -748,12 +753,12 @@ char *
 SDL_strstr(const char *haystack, const char *needle)
 {
 #if defined(HAVE_STRSTR)
-    return SDL_const_cast(char*,strstr(haystack, needle));
+    return SDL_const_cast(char *, strstr(haystack, needle));
 #else
     size_t length = SDL_strlen(needle);
     while (*haystack) {
         if (SDL_strncmp(haystack, needle, length) == 0) {
-            return (char *) haystack;
+            return (char *)haystack;
         }
         ++haystack;
     }
@@ -765,12 +770,12 @@ char *
 SDL_strcasestr(const char *haystack, const char *needle)
 {
 #if defined(HAVE_STRCASESTR)
-    return SDL_const_cast(char*,strcasestr(haystack, needle));
+    return SDL_const_cast(char *, strcasestr(haystack, needle));
 #else
     size_t length = SDL_strlen(needle);
     while (*haystack) {
         if (SDL_strncasecmp(haystack, needle, length) == 0) {
-            return (char *) haystack;
+            return (char *)haystack;
         }
         ++haystack;
     }
@@ -1039,10 +1044,11 @@ SDL_strcmp(const char *str1, const char *str2)
 #else
     int result;
 
-    while(1) {
+    while (1) {
         result = (int)((unsigned char) *str1 - (unsigned char) *str2);
-        if (result != 0 || (*str1 == '\0'/* && *str2 == '\0'*/))
+        if (result != 0 || (*str1 == '\0'/* && *str2 == '\0'*/)) {
             break;
+        }
         ++str1;
         ++str2;
     }
@@ -1060,8 +1066,9 @@ SDL_strncmp(const char *str1, const char *str2, size_t maxlen)
 
     while (maxlen) {
         result = (int) (unsigned char) *str1 - (unsigned char) *str2;
-        if (result != 0 || *str1 == '\0'/* && *str2 == '\0'*/)
+        if (result != 0 || *str1 == '\0'/* && *str2 == '\0'*/) {
             break;
+        }
         ++str1;
         ++str2;
         --maxlen;
@@ -1087,8 +1094,9 @@ SDL_strcasecmp(const char *str1, const char *str2)
         a = SDL_toupper((unsigned char) *str1);
         b = SDL_toupper((unsigned char) *str2);
         result = a - b;
-        if (result != 0 || a == 0 /*&& b == 0*/)
+        if (result != 0 || a == 0 /*&& b == 0*/) {
             break;
+        }
         ++str1;
         ++str2;
     }
@@ -1110,14 +1118,16 @@ SDL_strncasecmp(const char *str1, const char *str2, size_t maxlen)
         a = SDL_tolower((unsigned char) *str1);
         b = SDL_tolower((unsigned char) *str2);
         result = a - b;
-        if (result != 0 || a == 0 /*&& b == 0*/)
+        if (result != 0 || a == 0 /*&& b == 0*/) {
             break;
+        }
         ++str1;
         ++str2;
         --maxlen;
     }
-    if (maxlen == 0)
+    if (maxlen == 0) {
         result = 0;
+    }
     return result;
 #endif /* HAVE_STRNCASECMP */
 }
@@ -1145,7 +1155,7 @@ SDL_vsscanf(const char *text, const char *fmt, va_list ap)
 {
     int retval = 0;
 
-    if (!text || !*text) {
+    if (text == NULL || !*text) {
         return -1;
     }
 
@@ -1456,10 +1466,16 @@ SDL_snprintf(SDL_OUT_Z_CAP(maxlen) char *text, size_t maxlen, SDL_PRINTF_FORMAT_
 int SDL_vsnprintf(SDL_OUT_Z_CAP(maxlen) char *text, size_t maxlen, const char *fmt, va_list ap)
 {
     int retval;
-    if (!fmt) fmt = "";
+    if (!fmt) {
+        fmt = "";
+    }
     retval = _vsnprintf(text, maxlen, fmt, ap);
-    if (maxlen > 0) text[maxlen-1] = '\0';
-    if (retval < 0) retval = (int) maxlen;
+    if (maxlen > 0) {
+        text[maxlen - 1] = '\0';
+    }
+    if (retval < 0) {
+        retval = (int)maxlen;
+    }
     return retval;
 }
 #elif defined(HAVE_VSNPRINTF)
@@ -1509,8 +1525,9 @@ SDL_PrintString(char *text, size_t maxlen, SDL_FormatInfo *info, const char *str
         size_t width = info->width - sz;
         size_t filllen;
 
-        if (info->precision >= 0 && (size_t)info->precision < sz)
+        if (info->precision >= 0 && (size_t)info->precision < sz) {
             width += sz - (size_t)info->precision;
+        }
 
         filllen = SDL_min(width, maxlen);
         SDL_memset(text, fill, filllen);
@@ -1546,8 +1563,9 @@ SDL_IntPrecisionAdjust(char *num, size_t maxlen, SDL_FormatInfo *info)
 {/* left-pad num with zeroes. */
     size_t sz, pad, have_sign;
 
-    if (!info)
+    if (info == NULL) {
         return;
+    }
 
     have_sign = 0;
     if (*num == '-' || *num == '+') {
@@ -1733,8 +1751,7 @@ SDL_vsnprintf(SDL_OUT_Z_CAP(maxlen) char *text, size_t maxlen, const char *fmt,
 
             if (*fmt >= '0' && *fmt <= '9') {
                 info.width = SDL_strtol(fmt, (char **)&fmt, 0);
-            }
-            else if (*fmt == '*') {
+            } else if (*fmt == '*') {
                 ++fmt;
                 info.width = va_arg(ap, int);
             }
@@ -1934,8 +1951,9 @@ SDL_vasprintf(char **strp, const char *fmt, va_list ap)
     *strp = NULL;
 
     p = (char *)SDL_malloc(size);
-    if (p == NULL)
+    if (p == NULL) {
         return -1;
+    }
 
     while (1) {
         /* Try to print in the allocated space */
@@ -1944,8 +1962,9 @@ SDL_vasprintf(char **strp, const char *fmt, va_list ap)
         va_end(aq);
 
         /* Check error code */
-        if (retval < 0)
+        if (retval < 0) {
             return retval;
+        }
 
         /* If that worked, return the string */
         if (retval < size) {
diff --git a/src/test/SDL_test_assert.c b/src/test/SDL_test_assert.c
index 148564ec1..7737ca2b0 100644
--- a/src/test/SDL_test_assert.c
+++ b/src/test/SDL_test_assert.c
@@ -74,13 +74,10 @@ int SDLTest_AssertCheck(int assertCondition, SDL_PRINTF_FORMAT_STRING const char
     va_end(list);
 
     /* Log pass or fail message */
-    if (assertCondition == ASSERT_FAIL)
-    {
+    if (assertCondition == ASSERT_FAIL) {
         SDLTest_AssertsFailed++;
         SDLTest_LogError(SDLTEST_ASSERT_CHECK_FORMAT, logMessage, "Failed");
-    }
-    else
-    {
+    } else {
         SDLTest_AssertsPassed++;
         SDLTest_Log(SDLTEST_ASSERT_CHECK_FORMAT, logMessage, "Passed");
     }
@@ -123,12 +120,9 @@ void SDLTest_ResetAssertSummary()
 void SDLTest_LogAssertSummary()
 {
     int totalAsserts = SDLTest_AssertsPassed + SDLTest_AssertsFailed;
-    if (SDLTest_AssertsFailed == 0)
-    {
+    if (SDLTest_AssertsFailed == 0) {
         SDLTest_Log(SDLTEST_ASSERT_SUMMARY_FORMAT, totalAsserts, SDLTest_AssertsPassed, SDLTest_AssertsFailed);
-    }
-    else
-    {
+    } else {
         SDLTest_LogError(SDLTEST_ASSERT_SUMMARY_FORMAT, totalAsserts, SDLTest_AssertsPassed, SDLTest_AssertsFailed);
     }
 }
diff --git a/src/test/SDL_test_common.c b/src/test/SDL_test_common.c
index 1dc97937a..1f6adfc5b 100644
--- a/src/test/SDL_test_common.c
+++ b/src/test/SDL_test_common.c
@@ -73,7 +73,7 @@ SDLTest_CommonCreateState(char **argv, Uint32 flags)
     }
 
     state = (SDLTest_CommonState *)SDL_calloc(1, sizeof(*state));
-    if (!state) {
+    if (state == NULL) {
         SDL_OutOfMemory();
         return NULL;
     }
@@ -116,6 +116,16 @@ SDLTest_CommonCreateState(char **argv, Uint32 flags)
     return state;
 }
 
+#define SEARCHARG(dim)              \
+    while (*dim && *dim != ',') {   \
+        ++dim;                      \
+    }                               \
+    if (!*dim) {                    \
+        return -1;                  \
+    }                               \
+    *dim++ = '\0';
+
+
 int
 SDLTest_CommonArg(SDLTest_CommonState * state, int index)
 {
@@ -309,20 +319,11 @@ SDLTest_CommonArg(SDLTest_CommonState * state, int index)
         }
         x = argv[index];
         y = argv[index];
-        #define SEARCHARG(dim) \
-            while (*dim && *dim != ',') { \
-                ++dim; \
-            } \
-            if (!*dim) { \
-                return -1; \
-            } \
-            *dim++ = '\0';
         SEARCHARG(y)
         w = y;
         SEARCHARG(w)
         h = w;
         SEARCHARG(h)
-        #undef SEARCHARG
         state->confine.x = SDL_atoi(x);
         state->confine.y = SDL_atoi(y);
         state->confine.w = SDL_atoi(w);
@@ -596,7 +597,7 @@ static const char *
 BuildCommonUsageString(char **pstr, const char **strlist, const int numitems, const char **strlist2, const int numitems2)
 {
     char *str = *pstr;
-    if (!str) {
+    if (str == NULL) {
         size_t len = SDL_strlen("[--trackmem]") + 2;
         int i;
         for (i = 0; i < numitems; i++) {
@@ -608,7 +609,7 @@ BuildCommonUsageString(char **pstr, const char **strlist, const int numitems, co
             }
         }
         str = (char *) SDL_calloc(1, len);
-        if (!str) {
+        if (str == NULL) {
             return "";  /* oh well. */
         }
         SDL_strlcat(str, "[--trackmem] ", len);
@@ -1009,7 +1010,7 @@ SDLTest_LoadIcon(const char *file)
     icon = SDL_LoadBMP(file);
     if (icon == NULL) {
         SDL_Log("Couldn't load %s: %s\n", file, SDL_GetError());
-        return (NULL);
+        return NULL;
     }
 
     if (icon->format->palette) {
@@ -1017,7 +1018,7 @@ SDLTest_LoadIcon(const char *file)
         SDL_SetColorKey(icon, 1, *((Uint8 *) icon->pixels));
     }
 
-    return (icon);
+    return icon;
 }
 
 static SDL_HitTestResult SDLCALL
@@ -1169,8 +1170,9 @@ SDLTest_CommonInit(SDLTest_CommonState * state)
                     SDL_Log("      Red Mask   = 0x%.8" SDL_PRIx32 "\n", Rmask);
                     SDL_Log("      Green Mask = 0x%.8" SDL_PRIx32 "\n", Gmask);
                     SDL_Log("      Blue Mask  = 0x%.8" SDL_PRIx32 "\n", Bmask);
-                    if (Amask)
+                    if (Amask) {
                         SDL_Log("      Alpha Mask = 0x%.8" SDL_PRIx32 "\n", Amask);
+                    }
                 }
 
                 /* Print available fullscreen video modes */
@@ -1193,9 +1195,9 @@ SDLTest_CommonInit(SDLTest_CommonState * state)
                                     Gmask);
                             SDL_Log("        Blue Mask  = 0x%.8" SDL_PRIx32 "\n",
                                     Bmask);
-                            if (Amask)
-                                SDL_Log("        Alpha Mask = 0x%.8" SDL_PRIx32 "\n",
-                                        Amask);
+                            if (Amask) {
+                                SDL_Log("        Alpha Mask = 0x%.8" SDL_PRIx32 "\n", Amask);
+                            }
                         }
                     }
                 }
@@ -1763,7 +1765,7 @@ SDLTest_ScreenShot(SDL_Renderer *renderer)
     SDL_Rect viewport;
     SDL_Surface *surface;
 
-    if (!renderer) {
+    if (renderer == NULL) {
         return;
     }
 
@@ -1775,7 +1777,7 @@ SDLTest_ScreenShot(SDL_Renderer *renderer)
                     0x000000FF, 0x0000FF00, 0x00FF0000,
 #endif
                     0x00000000);
-    if (!surface) {
+    if (surface == NULL) {
         SDL_Log("Couldn't create surface: %s\n", SDL_GetError());
         return;
     }
@@ -1800,7 +1802,7 @@ FullscreenTo(int index, int windowId)
     Uint32 flags;
     struct SDL_Rect rect = { 0, 0, 0, 0 };
     SDL_Window *window = SDL_GetWindowFromID(windowId);
-    if (!window) {
+    if (window == NULL) {
         return;
     }
 
@@ -1940,10 +1942,18 @@ SDLTest_CommonEvent(SDLTest_CommonState * state, SDL_Event * event, int *done)
                     int x, y;
                     SDL_GetWindowPosition(window, &x, &y);
 
-                    if (event->key.keysym.sym == SDLK_UP)    y -= delta;
-                    if (event->key.keysym.sym == SDLK_DOWN)  y += delta;
-                    if (event->key.keysym.sym == SDLK_LEFT)  x -= delta;
-                    if (event->key.keysym.sym == SDLK_RIGHT) x += delta;
+                    if (event->key.keysym.sym == SDLK_UP) {
+                        y -= delta;
+                    }
+                    if (event->key.keysym.sym == SDLK_DOWN) {
+                        y += delta;
+                    }
+                    if (event->key.keysym.sym == SDLK_LEFT) {
+                        x -= delta;
+                    }
+                    if (event->key.keysym.sym == SDLK_RIGHT) {
+                        x += delta;
+                    }
 
                     SDL_Log("Setting position to (%d, %d)\n", x, y);
                     SDL_SetWindowPosition(window, x, y);
diff --git a/src/test/SDL_test_font.c b/src/test/SDL_test_font.c
index 3bfcf4970..bbf0f2f40 100644
--- a/src/test/SDL_test_font.c
+++ b/src/test/SDL_test_font.c
@@ -3191,7 +3191,7 @@ int SDLTest_DrawCharacter(SDL_Renderer *renderer, int x, int y, Uint32 c)
             charWidth, charHeight, 32,
             0xFF000000, 0x00FF0000, 0x0000FF00, 0x000000FF);
         if (character == NULL) {
-            return (-1);
+            return -1;
         }
 
         charpos = SDLTest_FontData + ci * charSize;
@@ -3224,7 +3224,7 @@ int SDLTest_DrawCharacter(SDL_Renderer *renderer, int x, int y, Uint32 c)
          * Check pointer
          */
         if (cache->charTextureCache[ci] == NULL) {
-            return (-1);
+            return -1;
         }
     }
 
@@ -3241,7 +3241,7 @@ int SDLTest_DrawCharacter(SDL_Renderer *renderer, int x, int y, Uint32 c)
      */
     result |= SDL_RenderCopy(renderer, cache->charTextureCache[ci], &srect, &drect);
 
-    return (result);
+    return result;
 }
 
 /* Gets a unicode value from a UTF-8 encoded string
@@ -3352,14 +3352,14 @@ int SDLTest_DrawString(SDL_Renderer * renderer, int x, int y, const char *s)
         len -= advance;
     }
 
-    return (result);
+    return result;
 }
 
 SDLTest_TextWindow *SDLTest_TextWindowCreate(int x, int y, int w, int h)
 {
     SDLTest_TextWindow *textwin = (SDLTest_TextWindow *)SDL_malloc(sizeof(*textwin));
 
-    if ( !textwin ) {
+    if (textwin == NULL) {
         return NULL;
     }
 
@@ -3453,8 +3453,7 @@ void SDLTest_TextWindowClear(SDLTest_TextWindow *textwin)
 {
     int i;
 
-    for ( i = 0; i < textwin->numlines; ++i )
-    {
+    for ( i = 0; i < textwin->numlines; ++i ) {
         if ( textwin->lines[i] ) {
             SDL_free(textwin->lines[i]);
             textwin->lines[i] = NULL;
diff --git a/src/test/SDL_test_fuzzer.c b/src/test/SDL_test_fuzzer.c
index 98fb09df6..7eda8a075 100644
--- a/src/test/SDL_test_fuzzer.c
+++ b/src/test/SDL_test_fuzzer.c
@@ -167,11 +167,11 @@ SDLTest_RandomIntegerInRange(Sint32 pMin, Sint32 pMax)
     Sint64 temp;
     Sint64 number;
 
-    if(pMin > pMax) {
+    if (pMin > pMax) {
         temp = min;
         min = max;
         max = temp;
-    } else if(pMin == pMax) {
+    } else if (pMin == pMax) {
         return (Sint32)min;
     }
 
@@ -493,7 +493,7 @@ SDLTest_RandomAsciiStringWithMaximumLength(int maxLength)
 {
     int size;
 
-    if(maxLength < 1) {
+    if (maxLength < 1) {
                 SDL_InvalidParamError("maxLength");
         return NULL;
     }
@@ -510,7 +510,7 @@ SDLTest_RandomAsciiStringOfSize(int size)
     int counter;
 
 
-    if(size < 1) {
+    if (size < 1) {
                 SDL_InvalidParamError("size");
         return NULL;
     }
@@ -520,7 +520,7 @@ SDLTest_RandomAsciiStringOfSize(int size)
       return NULL;
         }
 
-    for(counter = 0; counter < size; ++counter) {
+    for (counter = 0; counter < size; ++counter) {
         string[counter] = (char)SDLTest_RandomIntegerInRange(32, 126);
     }
 
diff --git a/src/test/SDL_test_harness.c b/src/test/SDL_test_harness.c
index db3836b74..8057b6ae3 100644
--- a/src/test/SDL_test_harness.c
+++ b/src/test/SDL_test_harness.c
@@ -234,14 +234,12 @@ SDLTest_RunTest(SDLTest_TestSuiteReference *testSuite, const SDLTest_TestCaseRef
     int testResult = 0;
     int fuzzerCount;
 
-    if (testSuite==NULL || testCase==NULL || testSuite->name==NULL || testCase->name==NULL)
-    {
+    if (testSuite==NULL || testCase==NULL || testSuite->name==NULL || testCase->name==NULL) {
         SDLTest_LogError("Setup failure: testSuite or testCase references NULL");
         return TEST_RESULT_SETUP_FAILURE;
     }
 
-    if (!testCase->enabled && forceTestRun == SDL_FALSE)
-    {
+    if (!testCase->enabled && forceTestRun == SDL_FALSE) {
         SDLTest_Log(SDLTEST_FINAL_RESULT_FORMAT, "Test", testCase->name, "Skipped (Disabled)");
         return TEST_RESULT_SKIPPED;
     }
@@ -326,7 +324,7 @@ static void SDLTest_LogTestSuiteSummary(SDLTest_TestSuiteReference *testSuites)
 
     /* Loop over all suites */
     suiteCounter = 0;
-    while(&testSuites[suiteCounter]) {
+    while (&testSuites[suiteCounter]) {
         testSuite=&testSuites[suiteCounter];
         suiteCounter++;
         SDLTest_Log("Test Suite %i - %s\n", suiteCounter,
@@ -334,8 +332,7 @@ static void SDLTest_LogTestSuiteSummary(SDLTest_TestSuiteReference *testSuites)
 
         /* Loop over all test cases */
         testCounter = 0;
-        while(testSuite->testCases[testCounter])
-        {
+        while (testSuite->testCases[testCounter]) {
             testCase=(SDLTest_TestCaseReference *)testSuite->testCases[testCounter];
             testCounter++;
             SDLTest_Log("  Test Case %i - %s: %s", testCounter,
@@ -436,8 +433,7 @@ int SDLTest_RunSuites(SDLTest_TestSuiteReference *testSuites[], const char *user
         testSuite = testSuites[suiteCounter];
         suiteCounter++;
         testCounter = 0;
-        while (testSuite->testCases[testCounter])
-        {
+        while (testSuite->testCases[testCounter]) {
             testCounter++;
             totalNumberOfTests++;
         }
@@ -510,7 +506,7 @@ int SDLTest_RunSuites(SDLTest_TestSuiteReference *testSuites[], const char *user
 
     /* Loop over all suites */
     suiteCounter = 0;
-    while(testSuites[suiteCounter]) {
+    while (testSuites[suiteCounter]) {
         testSuite = testSuites[suiteCounter];
         currentSuiteName = (testSuite->name ? testSuite->name : SDLTEST_INVALID_NAME_FORMAT);
         suiteCounter++;
@@ -539,8 +535,7 @@ int SDLTest_RunSuites(SDLTest_TestSuiteReference *testSuites[], const char *user
 
             /* Loop over all test cases */
             testCounter = 0;
-            while(testSuite->testCases[testCounter])
-            {
+            while (testSuite->testCases[testCounter]) {
                 testCase = testSuite->testCases[testCounter];
                 currentTestName = (testCase->name ? testCase->name : SDLTEST_INVALID_NAME_FORMAT);
                 testCounter++;
@@ -575,8 +570,7 @@ int SDLTest_RunSuites(SDLTest_TestSuiteReference *testSuites[], const char *user
 
                     /* Loop over all iterations */
                     iterationCounter = 0;
-                    while(iterationCounter < testIterations)
-                    {
+                    while (iterationCounter < testIterations) {
                         iterationCounter++;
 
                         if (userExecKey != 0) {
@@ -603,7 +597,9 @@ int SDLTest_RunSuites(SDLTest_TestSuiteReference *testSuites[], const char *user
                     /* Take time - test end */
                     testEndSeconds = GetClock();
                     runtime = testEndSeconds - testStartSeconds;
-                    if (runtime < 0.0f) runtime = 0.0f;
+                    if (runtime < 0.0f) {
+                        runtime = 0.0f;
+                    }
 
                     if (testIterations > 1) {
                         /* Log test runtime */
@@ -638,20 +634,19 @@ int SDLTest_RunSuites(SDLTest_TestSuiteReference *testSuites[], const char *user
             /* Take time - suite end */
             suiteEndSeconds = GetClock();
             runtime = suiteEndSeconds - suiteStartSeconds;
-            if (runtime < 0.0f) runtime = 0.0f;
+            if (runtime < 0.0f) {
+                runtime = 0.0f;
+            }
 
             /* Log suite runtime */
             SDLTest_Log("Total Suite runtime: %.1f sec", runtime);
 
             /* Log summary and final Suite result */
             countSum = testPassedCount + testFailedCount + testSkippedCount;
-            if (testFailedCount == 0)
-            {
+            if (testFailedCount == 0) {
                 SDLTest_Log(SDLTEST_LOG_SUMMARY_FORMAT, "Suite", countSum, testPassedCount, testFailedCount, testSkippedCount);
                 SDLTest_Log(SDLTEST_FINAL_RESULT_FORMAT, "Suite", currentSuiteName, "Passed");
-            }
-            else
-            {
+            } else {
                 SDLTest_LogError(SDLTEST_LOG_SUMMARY_FORMAT, "Suite", countSum, testPassedCount, testFailedCount, testSkippedCount);
                 SDLTest_LogError(SDLTEST_FINAL_RESULT_FORMAT, "Suite", currentSuiteName, "Failed");
             }
@@ -662,21 +657,20 @@ int SDLTest_RunSuites(SDLTest_TestSuiteReference *testSuites[], const char *user
     /* Take time - run end */
     runEndSeconds = GetClock();
     runtime = runEndSeconds - runStartSeconds;
-    if (runtime < 0.0f) runtime = 0.0f;
+    if (runtime < 0.0f) {
+        runtime = 0.0f;
+    }
 
     /* Log total runtime */
     SDLTest_Log("Total Run runtime: %.1f sec", runtime);
 
     /* Log summary and final run result */
     countSum = totalTestPassedCount + totalTestFailedCount + totalTestSkippedCount;
-    if (totalTestFailedCount == 0)
-    {
+    if (totalTestFailedCount == 0) {
         runResult = 0;
         SDLTest_Log(SDLTEST_LOG_SUMMARY_FORMAT, "Run", countSum, totalTestPassedCount, totalTestFailedCount, totalTestSkippedCount);
         SDLTest_Log(SDLTEST_FINAL_RESULT_FORMAT, "Run /w seed", runSeed, "Passed");
-    }
-    else
-    {
+    } else {
         runResult = 1;
         SDLTest_LogError(SDLTEST_LOG_SUMMARY_FORMAT, "Run", countSum, totalTestPassedCount, totalTestFailedCount, totalTestSkippedCount);
         SDLTest_LogError(SDLTEST_FINAL_RESULT_FORMAT, "Run /w seed", runSeed, "Failed");
diff --git a/src/test/SDL_test_md5.c b/src/test/SDL_test_md5.c
index 662e2fa0c..06c188a15 100644
--- a/src/test/SDL_test_md5.c
+++ b/src/test/SDL_test_md5.c
@@ -109,7 +109,9 @@ static unsigned char MD5PADDING[64] = {
 
 void SDLTest_Md5Init(SDLTest_Md5Context * mdContext)
 {
-  if (mdContext==NULL) return;
+  if (mdContext == NULL) {
+    return;
+  }
 
   mdContext->i[0] = mdContext->i[1] = (MD5UINT4) 0;
 
@@ -135,8 +137,12 @@ void SDLTest_Md5Update(SDLTest_Md5Context * mdContext, unsigned char *inBuf,
   int       mdi;
   unsigned int i, ii;
 
-  if (mdContext == NULL) return;
-  if (inBuf == NULL || inLen < 1) return;
+  if (mdContext == NULL) {
+    return;
+  }
+  if (inBuf == NULL || inLen < 1) {
+    return;
+  }
 
   /*
    * compute number of bytes mod 64
@@ -146,8 +152,9 @@ void SDLTest_Md5Update(SDLTest_Md5Context * mdContext, unsigned char *inBuf,
   /*
    * update number of bits
    */
-  if ((mdContext->i[0] + ((MD5UINT4) inLen << 3)) < mdContext->i[0])
+  if ((mdContext->i[0] + ((MD5UINT4)inLen << 3)) < mdContext->i[0]) {
     mdContext->i[1]++;
+  }
   mdContext->i[0] += ((MD5UINT4) inLen << 3);
   mdContext->i[1] += ((MD5UINT4) inLen >> 29);
 
@@ -161,11 +168,9 @@ void SDLTest_Md5Update(SDLTest_Md5Context * mdContext, unsigned char *inBuf,
      * transform if necessary
      */
     if (mdi == 0x40) {
-      for (i = 0, ii = 0; i < 16; i++, ii += 4)
-    in[i] = (((MD5UINT4) mdContext->in[ii + 3]) << 24) |
-      (((MD5UINT4) mdContext->in[ii + 2]) << 16) |
-      (((MD5UINT4) mdContext->in[ii + 1]) << 8) |
-      ((MD5UINT4) mdContext->in[ii]);
+      for (i = 0, ii = 0; i < 16; i++, ii += 4) {
+    in[i] = (((MD5UINT4)mdContext->in[ii + 3]) << 24) | (((MD5UINT4)mdContext->in[ii + 2]) << 16) | (((MD5UINT4)mdContext->in[ii + 1]) << 8) | ((MD5UINT4)mdContext->in[ii]);
+      }
       SDLTest_Md5Transform(mdContext->buf, in);
       mdi = 0;
     }
@@ -184,7 +189,9 @@ void SDLTest_Md5Final(SDLTest_Md5Context * mdContext)
   unsigned int i, ii;
   unsigned int padLen;
 
-  if (mdContext == NULL) return;
+  if (mdContext == NULL) {
+    return;
+  }
 
   /*
    * save number of bits
@@ -206,11 +213,9 @@ void SDLTest_Md5Final(SDLTest_Md5Context * mdContext)
   /*
    * append length in bits and transform
    */
-  for (i = 0, ii = 0; i < 14; i++, ii += 4)
-    in[i] = (((MD5UINT4) mdContext->in[ii + 3]) << 24) |
-      (((MD5UINT4) mdContext->in[ii + 2]) << 16) |
-      (((MD5UINT4) mdContext->in[ii + 1]) << 8) |
-      ((MD5UINT4) mdContext->in[ii]);
+  for (i = 0, ii = 0; i < 14; i++, ii += 4) {
+    in[i] = (((MD5UINT4)mdContext->in[ii + 3]) << 24) | (((MD5UINT4)mdContext->in[ii + 2]) << 16) | (((MD5UINT4)mdContext->in[ii + 1]) << 8) | ((MD5UINT4)mdContext->in[ii]);
+  }
   SDLTest_Md5Transform(mdContext->buf, in);
 
   /*
diff --git a/src/test/SDL_test_memory.c b/src/test/SDL_test_memory.c
index 067b7a5b3..f01b509a4 100644
--- a/src/test/SDL_test_memory.c
+++ b/src/test/SDL_test_memory.c
@@ -84,7 +84,7 @@ static void SDL_TrackAllocation(void *mem, size_t size)
         return;
     }
     entry = (SDL_tracked_allocation *)SDL_malloc_orig(sizeof(*entry));
-    if (!entry) {
+    if (entry == NULL) {
         return;
     }
     entry->mem = mem;
@@ -171,7 +171,7 @@ static void * SDLCALL SDLTest_TrackedRealloc(void *ptr, size_t size)
 {
     void *mem;
 
-    SDL_assert(!ptr || SDL_IsAllocationTracked(ptr));
+    SDL_assert(ptr == NULL || SDL_IsAllocationTracked(ptr));
     mem = SDL_realloc_orig(ptr, size);
     if (mem && mem != ptr) {
         if (ptr) {
@@ -184,7 +184,7 @@ static void * SDLCALL SDLTest_TrackedRealloc(void *ptr, size_t size)
 
 static void SDLCALL SDLTest_TrackedFree(void *ptr)
 {
-    if (!ptr) {
+    if (ptr == NULL) {
         return;
     }
 
diff --git a/src/test/SDL_test_random.c b/src/test/SDL_test_random.c
index b2babf18c..d00f2dfec 100644
--- a/src/test/SDL_test_random.c
+++ b/src/test/SDL_test_random.c
@@ -40,7 +40,9 @@
 
 void SDLTest_RandomInit(SDLTest_RandomContext * rndContext, unsigned int xi, unsigned int ci)
 {
-  if (rndContext==NULL) return;
+  if (rndContext == NULL) {
+      return;
+  }
 
   /*
    * Choose a value for 'a' from this list
@@ -66,7 +68,9 @@ void SDLTest_RandomInitTime(SDLTest_RandomContext * rndContext)
 {
   int a, b;
 
-  if (rndContext==NULL) return;
+  if (rndContext == NULL) {
+    return;
+  }
 
   srand((unsigned int)time(NULL));
   a=rand();
@@ -81,7 +85,9 @@ unsigned int SDLTest_Random(SDLTest_RandomContext * rndContext)
 {
   unsigned int xh, xl;
 
-  if (rndContext==NULL) return -1;
+  if (rndContext == NULL) {
+    return -1;
+  }
 
   xh = rndContext->x >> 16;
   xl = rndContext->x & 65535;
@@ -89,9 +95,10 @@ unsigned int SDLTest_Random(SDLTest_RandomContext * rndContext)
   rndContext->c =
     xh * rndContext->ah + ((xh * rndContext->al) >> 16) +
     ((xl * rndContext->ah) >> 16);
-  if (xl * rndContext->al >= (~rndContext->c + 1))
+  if (xl * rndContext->al >= (~rndContext->c + 1)) {
     rndContext->c++;
-  return (rndContext->x);
+  }
+  return rndContext->x;
 }
 
 /* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/thread/SDL_thread.c b/src/thread/SDL_thread.c
index 4e51be68b..47abb59d1 100644
--- a/src/thread/SDL_thread.c
+++ b/src/thread/SDL_thread.c
@@ -42,7 +42,7 @@ SDL_TLSGet(SDL_TLSID id)
     SDL_TLSData *storage;
 
     storage = SDL_SYS_GetTLSData();
-    if (!storage || id == 0 || id > storage->limit) {
+    if (storage == NULL || id == 0 || id > storage->limit) {
         return NULL;
     }
     return storage->array[id-1].data;
@@ -58,13 +58,13 @@ SDL_TLSSet(SDL_TLSID id, const void *value, void (SDLCALL *destructor)(void *))
     }
 
     storage = SDL_SYS_GetTLSData();
-    if (!storage || (id > storage->limit)) {
+    if (storage == NULL || (id > storage->limit)) {
         unsigned int i, oldlimit, newlimit;
 
         oldlimit = storage ? storage->limit : 0;
         newlimit = (id + TLS_ALLOC_CHUNKSIZE);
         storage = (SDL_TLSData *)SDL_realloc(storage, sizeof(*storage)+(newlimit-1)*sizeof(storage->array[0]));
-        if (!storage) {
+        if (storage == NULL) {
             return SDL_OutOfMemory();
         }
         storage->limit = newlimit;
@@ -127,14 +127,14 @@ SDL_Generic_GetTLSData(void)
     SDL_TLSData *storage = NULL;
 
 #if !SDL_THREADS_DISABLED
-    if (!SDL_generic_TLS_mutex) {
+    if (SDL_generic_TLS_mutex == NULL) {
         static SDL_SpinLock tls_lock;
         SDL_AtomicLock(&tls_lock);
-        if (!SDL_generic_TLS_mutex) {
+        if (SDL_generic_TLS_mutex == NULL) {
             SDL_mutex *mutex = SDL_CreateMutex();
             SDL_MemoryBarrierRelease();
             SDL_generic_TLS_mutex = mutex;
-            if (!SDL_generic_TLS_mutex) {
+            if (SDL_generic_TLS_mutex == NULL) {
                 SDL_AtomicUnlock(&tls_lock);
                 return NULL;
             }
@@ -183,7 +183,7 @@ SDL_Generic_SetTLSData(SDL_TLSData *storage)
         }
         prev = entry;
     }
-    if (!entry) {
+    if (entry == NULL) {
         entry = (SDL_TLSEntry *)SDL_malloc(sizeof(*entry));
         if (entry) {
             entry->thread = thread;
@@ -194,7 +194,7 @@ SDL_Generic_SetTLSData(SDL_TLSData *storage)
     }
     SDL_UnlockMutex(SDL_generic_TLS_mutex);
 
-    if (!entry) {
+    if (entry == NULL) {
         return SDL_OutOfMemory();
     }
     return 0;
@@ -262,7 +262,7 @@ SDL_GetErrBuf(void)
     if (errbuf == ALLOCATION_IN_PROGRESS) {
         return SDL_GetStaticErrBuf();
     }
-    if (!errbuf) {
+    if (errbuf == NULL) {
         /* Get the original memory functions for this allocation because the lifetime
          * of the error buffer may span calls to SDL_SetMemoryFunctions() by the app
          */
@@ -273,7 +273,7 @@ SDL_GetErrBuf(void)
         /* Mark that we're in the middle of allocating our buffer */
         SDL_TLSSet(tls_errbuf, ALLOCATION_IN_PROGRESS, NULL);
         errbuf = (SDL_error *)realloc_func(NULL, sizeof(*errbuf));
-        if (!errbuf) {
+        if (errbuf == NULL) {
             SDL_TLSSet(tls_errbuf, NULL, NULL);
             return SDL_GetStaticErrBuf();
         }
@@ -474,7 +474,7 @@ SDL_WaitThread(SDL_Thread * thread, int *status)
 void
 SDL_DetachThread(SDL_Thread * thread)
 {
-    if (!thread) {
+    if (thread == NULL) {
         return;
     }
 
diff --git a/src/thread/generic/SDL_syscond.c b/src/thread/generic/SDL_syscond.c
index 59e8ce076..f3255f812 100644
--- a/src/thread/generic/SDL_syscond.c
+++ b/src/thread/generic/SDL_syscond.c
@@ -98,7 +98,7 @@ int
 SDL_CondSignal_generic(SDL_cond * _cond)
 {
     SDL_cond_generic *cond = (SDL_cond_generic *)_cond;
-    if (!cond) {
+    if (cond == NULL) {
         return SDL_InvalidParamError("cond");
     }
 
@@ -123,7 +123,7 @@ int
 SDL_CondBroadcast_generic(SDL_cond * _cond)
 {
     SDL_cond_generic *cond = (SDL_cond_generic *)_cond;
-    if (!cond) {
+    if (cond == NULL) {
         return SDL_InvalidParamError("cond");
     }
 
@@ -180,7 +180,7 @@ SDL_CondWaitTimeout_generic(SDL_cond * _cond, SDL_mutex * mutex, Uint32 ms)
     SDL_cond_generic *cond = (SDL_cond_generic *)_cond;
     int retval;
 
-    if (!cond) {
+    if (cond == NULL) {
         return SDL_InvalidParamError("cond");
     }
 
diff --git a/src/thread/generic/SDL_syssem.c b/src/thread/generic/SDL_syssem.c
index c21ff196a..797ede463 100644
--- a/src/thread/generic/SDL_syssem.c
+++ b/src/thread/generic/SDL_syssem.c
@@ -87,7 +87,7 @@ SDL_CreateSemaphore(Uint32 initial_value)
     SDL_sem *sem;
 
     sem = (SDL_sem *) SDL_malloc(sizeof(*sem));
-    if (!sem) {
+    if (sem == NULL) {
         SDL_OutOfMemory();
         return NULL;
     }
@@ -131,7 +131,7 @@ SDL_SemTryWait(SDL_sem * sem)
 {
     int retval;
 
-    if (!sem) {
+    if (sem == NULL) {
         return SDL_InvalidParamError("sem");
     }
 
@@ -151,7 +151,7 @@ SDL_SemWaitTimeout(SDL_sem * sem, Uint32 timeout)
 {
     int retval;
 
-    if (!sem) {
+    if (sem == NULL) {
         return SDL_InvalidParamError("sem");
     }
 
@@ -199,7 +199,7 @@ SDL_SemValue(SDL_sem * sem)
 int
 SDL_SemPost(SDL_sem * sem)
 {
-    if (!sem) {
+    if (sem == NULL) {
         return SDL_InvalidParamError("sem");
     }
 
diff --git a/src/thread/generic/SDL_systhread.c b/src/thread/generic/SDL_systhread.c
index e36bf4c1c..1f8f04223 100644
--- a/src/thread/generic/SDL_systhread.c
+++ b/src/thread/generic/SDL_systhread.c
@@ -47,13 +47,13 @@ SDL_SYS_SetupThread(const char *name)
 SDL_threadID
 SDL_ThreadID(void)
 {
-    return (0);
+    return 0;
 }
 
 int
 SDL_SYS_SetThreadPriority(SDL_ThreadPriority priority)
 {
-    return (0);
+    return 0;
 }
 
 void
diff --git a/src/thread/n3ds/SDL_syscond.c b/src/thread/n3ds/SDL_syscond.c
index 9c671f554..e825d6af0 100644
--- a/src/thread/n3ds/SDL_syscond.c
+++ b/src/thread/n3ds/SDL_syscond.c
@@ -57,8 +57,8 @@ SDL_DestroyCond(SDL_cond *cond)
 int
 SDL_CondSignal(SDL_cond *cond)
 {
-    if (!cond) {
-        return SDL_SetError("Passed a NULL condition variable");
+    if (cond == NULL) {
+        return SDL_InvalidParamError("cond");
     }
 
     CondVar_Signal(&cond->cond_variable);
@@ -69,8 +69,8 @@ SDL_CondSignal(SDL_cond *cond)
 int
 SDL_CondBroadcast(SDL_cond *cond)
 {
-    if (!cond) {
-        return SDL_SetError("Passed a NULL condition variable");
+    if (cond == NULL) {
+        return SDL_InvalidParamError("cond");
     }
 
     CondVar_Broadcast(&cond->cond_variable);
@@ -103,11 +103,11 @@ SDL_CondWaitTimeout(SDL_cond *cond, SDL_mutex *mutex, Uint32 ms)
 {
     Result res;
 
-    if (!cond) {
-        return SDL_SetError("Passed a NULL condition variable");
+    if (cond == NULL) {
+        return SDL_InvalidParamError("cond");
     }
-    if (!mutex) {
-        return SDL_SetError("Passed a NULL mutex");
+    if (mutex == NULL) {
+        return SDL_InvalidParamError("mutex");
     }
 
     res = 0;
diff --git a/src/thread/n3ds/SDL_syssem.c b/src/thread/n3ds/SDL_syssem.c
index 08fbb6f42..ee0b49fcd 100644
--- a/src/thread/n3ds/SDL_syssem.c
+++ b/src/thread/n3ds/SDL_syssem.c
@@ -44,7 +44,7 @@ SDL_CreateSemaphore(Uint32 initial_value)
     }
 
     sem = (SDL_sem *) SDL_malloc(sizeof(*sem));
-    if (!sem) {
+    if (sem == NULL) {
         SDL_OutOfMemory();
         return NULL;
     }
@@ -68,8 +68,8 @@ SDL_DestroySemaphore(SDL_sem *sem)
 int
 SDL_SemTryWait(SDL_sem *sem)
 {
-    if (!sem) {
-        return SDL_SetError("Passed a NULL semaphore");
+    if (sem == NULL) {
+        return SDL_InvalidParamError("sem");
     }
 
     return SDL_SemWaitTimeout(sem, 0);
@@ -80,8 +80,8 @@ SDL_SemWaitTimeout(SDL_sem *sem, Uint32 timeout)
 {
     int retval;
 
-    if (!sem) {
-        return SDL_SetError("Passed a NULL semaphore");
+    if (sem == NULL) {
+        return SDL_InvalidParamError("sem");
     }
 
     if (timeout == SDL_MUTEX_MAXWAIT) {
@@ -113,8 +113,8 @@ SDL_SemWait(SDL_sem *sem)
 Uint32
 SDL_SemValue(SDL_sem *sem)
 {
-    if (!sem) {
-        return SDL_SetError("Passed a NULL semaphore");
+    if (sem == NULL) {
+        return SDL_InvalidParamError("sem");
     }
     return sem->semaphore.current_count;
 }
@@ -122,8 +122,8 @@ SDL_SemValue(SDL_sem *sem)
 int
 SDL_SemPost(SDL_sem *sem)
 {
-    if (!sem) {
-        return SDL_SetError("Passed a NULL semaphore");
+    if (sem == NULL) {
+        return SDL_InvalidParamError("sem");
     }
     LightSemaphore_Release(&sem->semaphore, 1);
     return 0;
diff --git a/src/thread/ngage/SDL_sysmutex.cpp b/src/thread/ngage/SDL_sysmutex.cpp
index 6893fc628..e6f5bfbf6 100644
--- a/src/thread/ngage/SDL_sysmutex.cpp
+++ b/src/thread/ngage/SDL_sysmutex.cpp
@@ -36,7 +36,7 @@ extern TInt CreateUnique(TInt (*aFunc)(const TDesC& aName, TAny*, TAny*), TAny*,
 
 static TInt NewMutex(const TDesC& aName, TAny* aPtr1, TAny*)
 {
-    return ((RMutex*)aPtr1)->CreateGlobal(aName);
+    return ((RMutex *)aPtr1)->CreateGlobal(aName);
 }
 
 /* Create a mutex */
@@ -46,21 +46,19 @@ SDL_CreateMutex(void)
     RMutex rmutex;
 
     TInt status = CreateUnique(NewMutex, &rmutex, NULL);
-    if(status != KErrNone)
-    {
+    if (status != KErrNone) {
         SDL_SetError("Couldn't create mutex.");
     }
     SDL_mutex* mutex = new /*(ELeave)*/ SDL_mutex;
     mutex->handle = rmutex.Handle();
-    return(mutex);
+    return mutex;
 }
 
 /* Free the mutex */
 void
 SDL_DestroyMutex(SDL_mutex * mutex)
 {
-    if (mutex)
-    {
+    if (mutex) {
         RMutex rmutex;
         rmutex.SetHandle(mutex->handle);
         rmutex.Signal();
@@ -90,32 +88,30 @@ SDL_TryLockMutex(SDL_mutex * mutex)
 int
 SDL_LockMutex(SDL_mutex * mutex)
 {
-    if (mutex == NULL)
-    {
-        return SDL_SetError("Passed a NULL mutex.");
+    if (mutex == NULL) {
+        return SDL_InvalidParamError("mutex");
     }
 
     RMutex rmutex;
     rmutex.SetHandle(mutex->handle);
     rmutex.Wait();
 
-    return(0);
+    return 0;
 }
 
 /* Unlock the mutex */
 int
 SDL_UnlockMutex(SDL_mutex * mutex)
 {
-    if ( mutex == NULL )
-    {
-        return SDL_SetError("Passed a NULL mutex.");
+    if (mutex == NULL) {
+        return SDL_InvalidParamError("mutex");
     }
 
     RMutex rmutex;
     rmutex.SetHandle(mutex->handle);
     rmutex.Signal();
 
-    return(0);
+    return 0;
 }
 
 /* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/thread/ngage/SDL_syssem.cpp b/src/thread/ngage/SDL_syssem.cpp
index 622d6239a..be3b53d2f 100644
--- a/src/thread/ngage/SDL_syssem.cpp
+++ b/src/thread/ngage/SDL_syssem.cpp
@@ -60,18 +60,13 @@ static TBool RunThread(TAny* aInfo)
 static TInt
 NewThread(const TDesC& aName, TAny* aPtr1, TAny* aPtr2)
 {
-    return ((RThread*)(aPtr1))->Create
-        (aName,
-         RunThread,
-         KDefaultStackSize,
-         NULL,
-         aPtr2);
+    return ((RThread *)(aPtr1))->Create(aName, RunThread, KDefaultStackSize, NULL, aPtr2);
 }
 
 static TInt NewSema(const TDesC& aName, TAny* aPtr1, TAny* aPtr2)
 {
     TInt value = *((TInt*) aPtr2);
-    return ((RSemaphore*)aPtr1)->CreateGlobal(aName, value);
+    return ((RSemaphore *)aPtr1)->CreateGlobal(aName, value);
 }
 
 static void WaitAll(SDL_sem *sem)
@@ -79,8 +74,7 @@ static void WaitAll(SDL_sem *sem)
     RSemaphore sema;
     sema.SetHandle(sem->handle);
     sema.Wait();
-    while(sem->count < 0)
-    {
+    while(sem->count < 0) {
         sema.Wait();
     }
 }
@@ -90,21 +84,19 @@ SDL_CreateSemaphore(Uint32 initial_value)
 {
     RSemaphore s;
     TInt status = CreateUnique(NewSema, &s, &initial_value);
-    if(status != KErrNone)
-    {
+    if (status != KErrNone) {
         SDL_SetError("Couldn't create semaphore");
     }
     SDL_semaphore* sem = new /*(ELeave)*/ SDL_semaphore;
     sem->handle = s.Handle();
     sem->count = initial_value;
-    return(sem);
+    return sem;
 }
 
 void
 SDL_DestroySemaphore(SDL_sem * sem)
 {
-    if (sem)
-    {
+    if (sem) {
         RSemaphore sema;
         sema.SetHandle(sem->handle);
         sema.Signal(sema.Count());
@@ -117,13 +109,11 @@ SDL_DestroySemaphore(SDL_sem * sem)
 int
 SDL_SemWaitTimeout(SDL_sem * sem, Uint32 timeout)
 {
-    if (! sem)
-    {
-        return SDL_SetError("Passed a NULL sem");
+    if (sem == NULL) {
+        return SDL_InvalidParamError("sem");
     }
 
-    if (timeout == SDL_MUTEX_MAXWAIT)
-    {
+    if (timeout == SDL_MUTEX_MAXWAIT) {
         WaitAll(sem);
         return SDL_MUTEX_MAXWAIT;
     }
@@ -132,16 +122,14 @@ SDL_SemWaitTimeout(SDL_sem * sem, Uint32 timeout)
     TInfo*  info   = new (ELeave)TInfo(timeout, sem->handle);
     TInt    status = CreateUnique(NewThread, &thread, info);
 
-    if(status != KErrNone)
-    {
+    if (status != KErrNone) {
         return status;
     }
 
     thread.Resume();
     WaitAll(sem);
 
-    if(thread.ExitType() == EExitPending)
-    {
+    if (thread.ExitType() == EExitPending) {
         thread.Kill(SDL_MUTEX_TIMEOUT);
     }
 
@@ -152,8 +140,11 @@ SDL_SemWaitTimeout(SDL_sem * sem, Uint32 timeout)
 int
 SDL_SemTryWait(SDL_sem *sem)
 {
-    if(sem->count > 0)
-    {
+    if (sem == NULL) {
+        return SDL_InvalidParamError("sem");
+    }
+
+    if (sem->count > 0) {
         sem->count--;
     }
     return SDL_MUTEX_TIMEOUT;
@@ -168,9 +159,8 @@ SDL_SemWait(SDL_sem * sem)
 Uint32
 SDL_SemValue(SDL_sem * sem)
 {
-    if (! sem)
-    {
-        SDL_SetError("Passed a NULL sem.");
+    if (sem == NULL) {
+        SDL_InvalidParamError("sem");
         return 0;
     }
     return sem->count;
@@ -179,9 +169,8 @@ SDL_SemValue(SDL_sem * sem)
 int
 SDL_SemPost(SDL_sem * sem)
 {
-    if (! sem)
-    {
-        return SDL_SetError("Passed a NULL sem.");
+    if (sem == NULL) {
+        return SDL_InvalidParamError("sem");
     }
     sem->count++;
     RSemaphore sema;
diff --git a/src/thread/ngage/SDL_systhread.cpp b/src/thread/ngage/SDL_systhread.cpp
index f2c30f7b6..dcb870df3 100644
--- a/src/thread/ngage/SDL_systhread.cpp
+++ b/src/thread/ngage/SDL_systhread.cpp
@@ -40,18 +40,13 @@ static int
 RunThread(TAny* data)
 {
     SDL_RunThread((SDL_Thread*)data);
-    return(0);
+    return 0;
 }
 
 static TInt
 NewThread(const TDesC& aName, TAny* aPtr1, TAny* aPtr2)
 {
-    return ((RThread*)(aPtr1))->Create
-        (aName,
-         RunThread,
-         KDefaultStackSize,
-         NULL,
-         aPtr2);
+    return ((RThread *)(aPtr1))->Create(aName, RunThread, KDefaultStackSize, NULL, aPtr2);
 }
 
 int
@@ -75,17 +70,16 @@ SDL_SYS_CreateThread(SDL_Thread *thread)
     RThread rthread;
 
     TInt status = CreateUnique(NewThread, &rthread, thread);
-    if (status != KErrNone)
-    {
+    if (status != KErrNone) {
         delete(((RThread*)(thread->handle)));
         thread->handle = NULL;
         SDL_SetError("Not enough resources to create thread");
-        return(-1);
+        return -1;
     }
 
     rthread.Resume();
     thread->handle = rthread.Handle();
-    return(0);
+    return 0;
 }
 
 void
@@ -105,7 +99,7 @@ SDL_ThreadID(void)
 int
 SDL_SYS_SetThreadPriority(SDL_ThreadPriority priority)
 {
-    return (0);
+    return 0;
 }
 
 void
@@ -113,8 +107,7 @@ SDL_SYS_WaitThread(SDL_Thread * thread)
 {
     RThread t;
     t.Open(thread->threadid);
-    if(t.ExitReason() == EExitPending)
-    {
+    if (t.ExitReason() == EExitPending) {
         TRequestStatus status;
         t.Logon(status);
         User::WaitForRequest(status);
diff --git a/src/thread/ps2/SDL_syssem.c b/src/thread/ps2/SDL_syssem.c
index e6b0aee25..a4c7de806 100644
--- a/src/thread/ps2/SDL_syssem.c
+++ b/src/thread/ps2/SDL_syssem.c
@@ -105,8 +105,9 @@ int SDL_SemWaitTimeout(SDL_sem *sem, Uint32 timeout)
     ret = WaitSema(sem->semid);
     StopTimerAlarm(&alarm);
 
-    if (ret < 0)
+    if (ret < 0) {
         return SDL_MUTEX_TIMEDOUT;
+    }
     return 0; //Wait condition satisfied.
 }
 
diff --git a/src/thread/psp/SDL_syscond.c b/src/thread/psp/SDL_syscond.c
index 02307ed9c..32dcbd176 100644
--- a/src/thread/psp/SDL_syscond.c
+++ b/src/thread/psp/SDL_syscond.c
@@ -58,7 +58,7 @@ SDL_CreateCond(void)
     } else {
         SDL_OutOfMemory();
     }
-    return (cond);
+    return cond;
 }
 
 /* Destroy a condition variable */
@@ -83,7 +83,7 @@ SDL_DestroyCond(SDL_cond * cond)
 int
 SDL_CondSignal(SDL_cond * cond)
 {
-    if (!cond) {
+    if (cond == NULL) {
         return SDL_InvalidParamError("cond");
     }
 
@@ -107,7 +107,7 @@ SDL_CondSignal(SDL_cond * cond)
 int
 SDL_CondBroadcast(SDL_cond * cond)
 {
-    if (!cond) {
+    if (cond == NULL) {
         return SDL_InvalidParamError("cond");
     }
 
@@ -163,7 +163,7 @@ SDL_CondWaitTimeout(SDL_cond * cond, SDL_mutex * mutex, Uint32 ms)
 {
     int retval;
 
-    if (!cond) {
+    if (cond == NULL) {
         return SDL_InvalidParamError("cond");
     }
 
diff --git a/src/thread/pthread/SDL_syscond.c b/src/thread/pthread/SDL_syscond.c
index c84ec7ada..b7d764341 100644
--- a/src/thread/pthread/SDL_syscond.c
+++ b/src/thread/pthread/SDL_syscond.c
@@ -48,7 +48,7 @@ SDL_CreateCond(void)
             cond = NULL;
         }
     }
-    return (cond);
+    return cond;
 }
 
 /* Destroy a condition variable */
@@ -67,7 +67,7 @@ SDL_CondSignal(SDL_cond * cond)
 {
     int retval;
 
-    if (!cond) {
+    if (cond == NULL) {
         return SDL_InvalidParamError("cond");
     }
 
@@ -84,7 +84,7 @@ SDL_CondBroadcast(SDL_cond * cond)
 {
     int retval;
 
-    if (!cond) {
+    if (cond == NULL) {
         return SDL_InvalidParamError("cond");
     }
 
@@ -104,7 +104,7 @@ SDL_CondWaitTimeout(SDL_cond * cond, SDL_mutex * mutex, Uint32 ms)
 #endif
     struct timespec abstime;
 
-    if (!cond) {
+    if (cond == NULL) {
         return SDL_InvalidParamError("cond");
     }
 
@@ -147,7 +147,7 @@ SDL_CondWaitTimeout(SDL_cond * cond, SDL_mutex * mutex, Uint32 ms)
 int
 SDL_CondWait(SDL_cond * cond, SDL_mutex * mutex)
 {
-    if (!cond) {
+    if (cond == NULL) {
         return SDL_InvalidParamError("cond");
     } else if (pthread_cond_wait(&cond->cond, &mutex->id) != 0) {
         return SDL_SetError("pthread_cond_wait() failed");
diff --git a/src/thread/pthread/SDL_sysmutex.c b/src/thread/pthread/SDL_sysmutex.c
index c26982aed..09a00ced8 100644
--- a/src/thread/pthread/SDL_sysmutex.c
+++ b/src/thread/pthread/SDL_sysmutex.c
@@ -64,7 +64,7 @@ SDL_CreateMutex(void)
     } else {
         SDL_OutOfMemory();
     }
-    return (mutex);
+    return mutex;
 }
 
 void
diff --git a/src/thread/pthread/SDL_syssem.c b/src/thread/pthread/SDL_syssem.c
index 9a0c88822..8321807cc 100644
--- a/src/thread/pthread/SDL_syssem.c
+++ b/src/thread/pthread/SDL_syssem.c
@@ -72,7 +72,7 @@ SDL_SemTryWait(SDL_sem * sem)
 {
     int retval;
 
-    if (!sem) {
+    if (sem == NULL) {
         return SDL_InvalidParamError("sem");
     }
     retval = SDL_MUTEX_TIMEDOUT;
@@ -87,7 +87,7 @@ SDL_SemWait(SDL_sem * sem)
 {
     int retval;
 
-    if (!sem) {
+    if (sem == NULL) {
         return SDL_InvalidParamError("sem");
     }
 
@@ -114,7 +114,7 @@ SDL_SemWaitTimeout(SDL_sem * sem, Uint32 timeout)
     Uint32 end;
 #endif
 
-    if (!sem) {
+    if (sem == NULL) {
         return SDL_InvalidParamError("sem");
     }
 
@@ -194,7 +194,7 @@ SDL_SemPost(SDL_sem * sem)
 {
     int retval;
 
-    if (!sem) {
+    if (sem == NULL) {
         return SDL_InvalidParamError("sem");
     }
 
diff --git a/src/thread/pthread/SDL_systhread.c b/src/thread/pthread/SDL_systhread.c
index 3b3f40fa1..b873f3de5 100644
--- a/src/thread/pthread/SDL_systhread.c
+++ b/src/thread/pthread/SDL_systhread.c
@@ -187,7 +187,7 @@ SDL_SYS_SetupThread(const char *name)
 SDL_threadID
 SDL_ThreadID(void)
 {
-    return ((SDL_threadID) pthread_self());
+    return (SDL_threadID)pthread_self();
 }
 
 int
diff --git a/src/thread/stdcpp/SDL_syscond.cpp b/src/thread/stdcpp/SDL_syscond.cpp
index 90c38adba..95e82d074 100644
--- a/src/thread/stdcpp/SDL_syscond.cpp
+++ b/src/thread/stdcpp/SDL_syscond.cpp
@@ -69,7 +69,7 @@ extern "C"
 int
 SDL_CondSignal(SDL_cond * cond)
 {
-    if (!cond) {
+    if (cond == NULL) {
         return SDL_InvalidParamError("cond");
     }
 
@@ -82,7 +82,7 @@ extern "C"
 int
 SDL_CondBroadcast(SDL_cond * cond)
 {
-    if (!cond) {
+    if (cond == NULL) {
         return SDL_InvalidParamError("cond");
     }
 
@@ -132,7 +132,7 @@ SDL_CondWaitTimeout(SDL_cond * cond, SDL_mutex * mutex, Uint32 ms)
             cpp_lock.release();
             return 0;
         } else {
-            auto wait_result = cond->cpp_cond.wait_for(
+            auto wait_result = cond->cpp_cond.wait_for (
                 cpp_lock,
                 std::chrono::duration<Uint32, std::milli>(ms)
                 );
diff --git a/src/thread/stdcpp/SDL_systhread.cpp b/src/thread/stdcpp/SDL_systhread.cpp
index 3d818ac56..0d1756539 100644
--- a/src/thread/stdcpp/SDL_systhread.cpp
+++ b/src/thread/stdcpp/SDL_systhread.cpp
@@ -98,16 +98,13 @@ SDL_SYS_SetThreadPriority(SDL_ThreadPriority priority)
 
     if (priority == SDL_THREAD_PRIORITY_LOW) {
         value = THREAD_PRIORITY_LOWEST;
-    }
-    else if (priority == SDL_THREAD_PRIORITY_HIGH) {
+    } else if (priority == SDL_THREAD_PRIORITY_HIGH) {
         value = THREAD_PRIORITY_HIGHEST;
-    }
-    else if (priority == SDL_THREAD_PRIORITY_TIME_CRITICAL) {
+    } else if (priority == SDL_THREAD_PRIORITY_TIME_CRITICAL) {
         // FIXME: WinRT does not support TIME_CRITICAL! -flibit
         SDL_LogWarn(SDL_LOG_CATEGORY_SYSTEM, "TIME_CRITICAL unsupported, falling back to HIGHEST");
         value = THREAD_PRIORITY_HIGHEST;
-    }
-    else {
+    } else {
         value = THREAD_PRIORITY_NORMAL;
     }
     if (!SetThreadPriority(GetCurrentThread(), value)) {
diff --git a/src/thread/vita/SDL_syscond.c b/src/thread/vita/SDL_syscond.c
index c6e46c475..7a2dfe630 100644
--- a/src/thread/vita/SDL_syscond.c
+++ b/src/thread/vita/SDL_syscond.c
@@ -58,7 +58,7 @@ SDL_CreateCond(void)
     } else {
         SDL_OutOfMemory();
     }
-    return (cond);
+    return cond;
 }
 
 /* Destroy a condition variable */
@@ -83,7 +83,7 @@ SDL_DestroyCond(SDL_cond * cond)
 int
 SDL_CondSignal(SDL_cond * cond)
 {
-    if (!cond) {
+    if (cond == NULL) {
         return SDL_InvalidParamError("cond");
     }
 
@@ -107,7 +107,7 @@ SDL_CondSignal(SDL_cond * cond)
 int
 SDL_CondBroadcast(SDL_cond * cond)
 {
-    if (!cond) {
+    if (cond == NULL) {
         return SDL_InvalidParamError("cond");
     }
 
@@ -163,7 +163,7 @@ SDL_CondWaitTimeout(SDL_cond * cond, SDL_mutex * mutex, Uint32 ms)
 {
     int retval;
 
-    if (!cond) {
+    if (cond == NULL) {
         return SDL_InvalidParamError("cond");
     }
 
diff --git a/src/thread/windows/SDL_syscond_cv.c b/src/thread/windows/SDL_syscond_cv.c
index 9c0ceb3a8..99ff9cafc 100644
--- a/src/thread/windows/SDL_syscond_cv.c
+++ b/src/thread/windows/SDL_syscond_cv.c
@@ -88,7 +88,7 @@ SDL_CreateCond_cv(void)
 
     /* Relies on CONDITION_VARIABLE_INIT == 0. */
     cond = (SDL_cond_cv *) SDL_calloc(1, sizeof(*cond));
-    if (!cond) {
+    if (cond == NULL) {
         SDL_OutOfMemory();
     }
 
@@ -108,7 +108,7 @@ static int
 SDL_CondSignal_cv(SDL_cond * _cond)
 {
     SDL_cond_cv *cond = (SDL_cond_cv *)_cond;
-    if (!cond) {
+    if (cond == NULL) {
         return SDL_InvalidParamError("cond");
     }
 
@@ -121,7 +121,7 @@ static int
 SDL_CondBroadcast_cv(SDL_cond * _cond)
 {
     SDL_cond_cv *cond = (SDL_cond_cv *)_cond;
-    if (!cond) {
+    if (cond == NULL) {
         return SDL_InvalidParamError("cond");
     }
 
@@ -137,10 +137,10 @@ SDL_CondWaitTimeout_cv(SDL_cond * _cond, SDL_mutex * _mutex, Uint32 ms)
     DWORD timeout;
     int ret;
 
-    if (!cond) {
+    if (cond == NULL) {
         return SDL_InvalidParamError("cond");
     }
-    if (!_mutex) {
+    if (_mutex == NULL) {
         return SDL_InvalidParamError("mutex");
     }
 
@@ -234,7 +234,7 @@ SDL_CreateCond(void)
         if (SDL_mutex_impl_active.Type == SDL_MUTEX_INVALID) {
             /* The mutex implementation isn't decided yet, trigger it */
             SDL_mutex *mutex = SDL_CreateMutex();
-            if (!mutex) {
+            if (mutex == NULL) {
                 return NULL;
             }
             SDL_DestroyMutex(mutex);
diff --git a/src/thread/windows/SDL_sysmutex.c b/src/thread/windows/SDL_sysmutex.c
index 3974b3362..247738476 100644
--- a/src/thread/windows/SDL_sysmutex.c
+++ b/src/thread/windows/SDL_sysmutex.c
@@ -65,7 +65,7 @@ SDL_CreateMutex_srw(void)
 
     /* Relies on SRWLOCK_INIT == 0. */
     mutex = (SDL_mutex_srw *) SDL_calloc(1, sizeof(*mutex));
-    if (!mutex) {
+    if (mutex == NULL) {
         SDL_OutOfMemory();
     }
 
diff --git a/src/thread/windows/SDL_syssem.c b/src/thread/windows/SDL_syssem.c
index 629f2a9cc..e80d25653 100644
--- a/src/thread/windows/SDL_syssem.c
+++ b/src/thread/windows/SDL_syssem.c
@@ -121,7 +121,7 @@ SDL_SemTryWait_atom(SDL_sem * _sem)
     SDL_sem_atom *sem = (SDL_sem_atom *)_sem;
     LONG count;
 
-    if (!sem) {
+    if (sem == NULL) {
         return SDL_InvalidParamError("sem");
     }
 
@@ -143,7 +143,7 @@ SDL_SemWait_atom(SDL_sem * _sem)
     SDL_sem_atom *sem = (SDL_sem_atom *)_sem;
     LONG count;
 
-    if (!sem) {
+    if (sem == NULL) {
         return SDL_InvalidParamError("sem");
     }
 
@@ -175,7 +175,7 @@ SDL_SemWaitTimeout_atom(SDL_sem * _sem, Uint32 timeout)
         return SDL_SemWait_atom(_sem);
     }
 
-    if (!sem) {
+    if (sem == NULL) {
         return SDL_InvalidParamError("sem");
     }
 
@@ -218,7 +218,7 @@ SDL_SemValue_atom(SDL_sem * _sem)
 {
     SDL_sem_atom *sem = (SDL_sem_atom *)_sem;
 
-    if (!sem) {
+    if (sem == NULL) {
         SDL_InvalidParamError("sem");
         return 0;
     }
@@ -231,7 +231,7 @@ SDL_SemPost_atom(SDL_sem * _sem)
 {
     SDL_sem_atom *sem = (SDL_sem_atom *)_sem;
 
-    if (!sem) {
+    if (sem == NULL) {
         return SDL_InvalidParamError("sem");
     }
 
@@ -312,7 +312,7 @@ SDL_SemWaitTimeout_kern(SDL_sem * _sem, Uint32 timeout)
     int retval;
     DWORD dwMilliseconds;
 
-    if (!sem) {
+    if (sem == NULL) {
         return SDL_InvalidParamError("sem");
     }
 
@@ -353,7 +353,7 @@ static Uint32
 SDL_SemValue_kern(SDL_sem * _sem)
 {
     SDL_sem_kern *sem = (SDL_sem_kern *)_sem;
-    if (!sem) {
+    if (sem == NULL) {
         SDL_InvalidParamError("sem");
         return 0;
     }
@@ -364,7 +364,7 @@ static int
 SDL_SemPost_kern(SDL_sem * _sem)
 {
     SDL_sem_kern *sem = (SDL_sem_kern *)_sem;
-    if (!sem) {
+    if (sem == NULL) {
         return SDL_InvalidParamError("sem");
     }
     /* Increase the counter in the first place, because
@@ -421,7 +421,7 @@ SDL_CreateSemaphore(Uint32 initial_value)
                 pWaitOnAddress = (pfnWaitOnAddress) GetProcAddress(synch120, "WaitOnAddress");
                 pWakeByAddressSingle = (pfnWakeByAddressSingle) GetProcAddress(synch120, "WakeByAddressSingle");
 
-                if(pWaitOnAddress && pWakeByAddressSingle) {
+                if (pWaitOnAddress && pWakeByAddressSingle) {
                     impl = &SDL_sem_impl_atom;
                 }
             }
diff --git a/src/thread/windows/SDL_systhread.c b/src/thread/windows/SDL_systhread.c
index 8f44e473c..dbd6654c9 100644
--- a/src/thread/windows/SDL_systhread.c
+++ b/src/thread/windows/SDL_systhread.c
@@ -95,7 +95,7 @@ RunThreadViaCreateThread(LPVOID data)
 static unsigned __stdcall
 RunThreadViaBeginThreadEx(void *data)
 {
-  return (unsigned) RunThread(data);
+  return (unsigned)RunThread(data);
 }
 
 #ifdef SDL_PASSED_BEGINTHREAD_ENDTHREAD
@@ -206,7 +206,7 @@ SDL_SYS_SetupThread(const char *name)
 SDL_threadID
 SDL_ThreadID(void)
 {
-    return ((SDL_threadID) GetCurrentThreadId());
+    return (SDL_threadID)GetCurrentThreadId();
 }
 
 int
diff --git a/src/timer/SDL_timer.c b/src/timer/SDL_timer.c
index 6741e97cb..3a5828b42 100644
--- a/src/timer/SDL_timer.c
+++ b/src/timer/SDL_timer.c
@@ -174,7 +174,7 @@ SDL_TimerThread(void *_data)
                 current->scheduled = tick + interval;
                 SDL_AddTimerInternal(data, current);
             } else {
-                if (!freelist_head) {
+                if (freelist_head == NULL) {
                     freelist_head = current;
                 }
                 if (freelist_tail) {
@@ -302,7 +302,7 @@ SDL_AddTimer(Uint32 interval, SDL_TimerCallback callback, void *param)
         SDL_RemoveTimer(timer->timerID);
     } else {
         timer = (SDL_Timer *)SDL_malloc(sizeof(*timer));
-        if (!timer) {
+        if (timer == NULL) {
             SDL_OutOfMemory();
             return 0;
         }
@@ -315,7 +315,7 @@ SDL_AddTimer(Uint32 interval, SDL_TimerCallback callback, void *param)
     SDL_AtomicSet(&timer->canceled, 0);
 
     entry = (SDL_TimerMap *)SDL_malloc(sizeof(*entry));
-    if (!entry) {
+    if (entry == NULL) {
         SDL_free(timer);
         SDL_OutOfMemory();
         return 0;
@@ -432,7 +432,7 @@ SDL_AddTimer(Uint32 interval, SDL_TimerCallback callback, void *param)
     SDL_TimerMap *entry;
 
     entry = (SDL_TimerMap *)SDL_malloc(sizeof(*entry));
-    if (!entry) {
+    if (entry == NULL) {
         SDL_OutOfMemory();
         return 0;
     }
diff --git a/src/timer/ngage/SDL_systimer.cpp b/src/timer/ngage/SDL_systimer.cpp
index 543d8494d..bb56d2388 100644
--- a/src/timer/ngage/SDL_systimer.cpp
+++ b/src/timer/ngage/SDL_systimer.cpp
@@ -38,8 +38,7 @@ extern "C" {
 void
 SDL_TicksInit(void)
 {
-    if (ticks_started)
-    {
+    if (ticks_started) {
         return;
     }
     ticks_started = SDL_TRUE;
@@ -62,8 +61,7 @@ SDL_TicksQuit(void)
 Uint64
 SDL_GetTicks64(void)
 {
-    if (! ticks_started)
-    {
+    if (! ticks_started) {
         SDL_TicksInit();
     }
 
diff --git a/src/timer/psp/SDL_systimer.c b/src/timer/psp/SDL_systimer.c
index df6225fa3..0609958dd 100644
--- a/src/timer/psp/SDL_systimer.c
+++ b/src/timer/psp/SDL_systimer.c
@@ -79,8 +79,9 @@ SDL_GetPerformanceFrequency(void)
 void SDL_Delay(Uint32 ms)
 {
     const Uint32 max_delay = 0xffffffffUL / 1000;
-    if(ms > max_delay)
+    if (ms > max_delay) {
         ms = max_delay;
+    }
     sceKernelDelayThreadCB(ms * 1000);
 }
 
diff --git a/src/timer/unix/SDL_systimer.c b/src/timer/unix/SDL_systimer.c
index 406bd48c5..c7696c398 100644
--- a/src/timer/unix/SDL_systimer.c
+++ b/src/timer/unix/SDL_systimer.c
@@ -117,7 +117,7 @@ SDL_GetTicks64(void)
         return (Uint64)(((Sint64)(now.tv_sec - start_ts.tv_sec) * 1000) + ((now.tv_nsec - start_ts.tv_nsec) / 1000000));
 #elif defined(__APPLE__)
         const uint64_t now = mach_absolute_time();
-        return ((((now - start_mach) * mach_base_info.numer) / mach_base_info.denom) / 1000000);
+        return (((now - start_mach) * mach_base_info.numer) / mach_base_info.denom) / 1000000;
 #else
         SDL_assert(SDL_FALSE);
         return 0;
@@ -159,7 +159,7 @@ SDL_GetPerformanceCounter(void)
         ticks *= 1000000;
         ticks += now.tv_usec;
     }
-    return (ticks);
+    return ticks;
 }
 
 Uint64
diff --git a/src/timer/vita/SDL_systimer.c b/src/timer/vita/SDL_systimer.c
index db382378e..899d6bf6f 100644
--- a/src/timer/vita/SDL_systimer.c
+++ b/src/timer/vita/SDL_systimer.c
@@ -79,8 +79,9 @@ SDL_GetPerformanceFrequency(void)
 void SDL_Delay(Uint32 ms)
 {
     const Uint32 max_delay = 0xffffffffUL / 1000;
-    if(ms > max_delay)
+    if (ms > max_delay) {
         ms = max_delay;
+    }
     sceKernelDelayThreadCB(ms * 1000);
 }
 
diff --git a/src/video/SDL_RLEaccel.c b/src/video/SDL_RLEaccel.c
index b67b765e9..d9eaa4905 100644
--- a/src/video/SDL_RLEaccel.c
+++ b/src/video/SDL_RLEaccel.c
@@ -139,7 +139,7 @@
         Uint16 *src = (Uint16 *)(from);                 \
         Uint16 *dst = (Uint16 *)(to);                   \
         Uint32 ALPHA = alpha >> 3;                      \
-        for(i = 0; i < (int)(length); i++) {            \
+        for (i = 0; i < (int)(length); i++) {           \
             Uint32 s = *src++;                          \
             Uint32 d = *dst;                            \
             s = (s | s << 16) & 0x07e0f81f;             \
@@ -148,7 +148,7 @@
             d &= 0x07e0f81f;                            \
             *dst++ = (Uint16)(d | d >> 16);             \
         }                                               \
-    } while(0)
+    } while (0)
 
 #define ALPHA_BLIT16_555(to, from, length, bpp, alpha)  \
     do {                                                \
@@ -156,7 +156,7 @@
         Uint16 *src = (Uint16 *)(from);                 \
         Uint16 *dst = (Uint16 *)(to);                   \
         Uint32 ALPHA = alpha >> 3;                      \
-        for(i = 0; i < (int)(length); i++) {            \
+        for (i = 0; i < (int)(length); i++) {           \
             Uint32 s = *src++;                          \
             Uint32 d = *dst;                            \
             s = (s | s << 16) & 0x03e07c1f;             \
@@ -165,7 +165,7 @@
             d &= 0x03e07c1f;                            \
             *dst++ = (Uint16)(d | d >> 16);             \
         }                                               \
-    } while(0)
+    } while (0)
 
 /*
  * The general slow catch-all function, for remaining depths and formats
@@ -225,7 +225,7 @@
             src += bpp;                                         \
             dst += bpp;                                         \
         }                                                       \
-    } while(0)
+    } while (0)
 
 /*
  * Special case: 50% alpha (alpha=128)
@@ -240,13 +240,13 @@
         int i;                                                  \
         Uint32 *src = (Uint32 *)(from);                         \
         Uint32 *dst = (Uint32 *)(to);                           \
-        for(i = 0; i < (int)(length); i++) {                    \
+        for (i = 0; i < (int)(length); i++) {                   \
             Uint32 s = *src++;                                  \
             Uint32 d = *dst;                                    \
             *dst++ = (((s & 0x00fefefe) + (d & 0x00fefefe)) >> 1) \
                  + (s & d & 0x00010101);                        \
         }                                                       \
-    } while(0)
+    } while (0)
 
 /*
  * For 16bpp, we can actually blend two pixels in parallel, if we take
@@ -260,7 +260,7 @@
         Uint32 d = *dst;                                        \
         *dst++ = (Uint16)((((s & mask) + (d & mask)) >> 1) +    \
                           (s & d & (~mask & 0xffff)));          \
-    } while(0)
+    } while (0)
 
 /* basic 16bpp blender. mask is the pixels to keep when adding. */
 #define ALPHA_BLIT16_50(to, from, length, bpp, alpha, mask)     \
@@ -290,7 +290,7 @@
             if (n)                                              \
                 BLEND16_50(dst, src, mask); /* last odd pixel */ \
         }                                                       \
-    } while(0)
+    } while (0)
 
 #define ALPHA_BLIT16_565_50(to, from, length, bpp, alpha)       \
     ALPHA_BLIT16_50(to, from, length, bpp, alpha, 0xf7deU)
@@ -324,8 +324,9 @@
                         } else {                                \
                             blitter(2, Uint8, ALPHA_BLIT16_565); \
                         }                                       \
-                    } else                                      \
+                    } else {                                     \
                         goto general16;                         \
+                    }                                           \
                     break;                                      \
                                                                 \
                 case 0x7fff:                                    \
@@ -338,8 +339,9 @@
                             blitter(2, Uint8, ALPHA_BLIT16_555); \
                         }                                       \
                         break;                                  \
-                    } else                                      \
+                    } else {                                    \
                         goto general16;                         \
+                    }                                           \
                     break;                                      \
                                                                 \
                 default:                                        \
@@ -361,12 +363,13 @@
                     } else {                                    \
                         blitter(4, Uint16, ALPHA_BLIT32_888);   \
                     }                                           \
-                } else                                          \
+                } else {                                        \
                     blitter(4, Uint16, ALPHA_BLIT_ANY);         \
+                }                                               \
                 break;                                          \
             }                                                   \
         }                                                       \
-    } while(0)
+    } while (0)
 
 /*
  * Set a pixel value using the given format, except that the alpha value is
@@ -384,12 +387,6 @@
  * This takes care of the case when the surface is clipped on the left and/or
  * right. Top clipping has already been taken care of.
  */
-static void
-RLEClipBlit(int w, Uint8 * srcbuf, SDL_Surface * surf_dst,
-            Uint8 * dstbuf, SDL_Rect * srcrect, unsigned alpha)
-{
-    SDL_PixelFormat *fmt = surf_dst->format;
-
 #define RLECLIPBLIT(bpp, Type, do_blit)                         \
     do {                                                        \
         int linecount = srcrect->h;                             \
@@ -423,24 +420,31 @@ RLEClipBlit(int w, Uint8 * srcbuf, SDL_Surface * surf_dst,
     nocopy ## bpp ## do_blit:                                   \
                 srcbuf += run * bpp;                            \
                 ofs += run;                                     \
-            } else if (!ofs)                                    \
+            } else if (!ofs) {                                  \
                 break;                                          \
+            }                                                   \
                                                                 \
             if (ofs == w) {                                     \
                 ofs = 0;                                        \
                 dstbuf += surf_dst->pitch;                      \
-                if (!--linecount)                               \
+                if (!--linecount) {                             \
                     break;                                      \
+                }                                               \
             }                                                   \
         }                                                       \
-    } while(0)
+    } while (0)
 
-    CHOOSE_BLIT(RLECLIPBLIT, alpha, fmt);
 
-#undef RLECLIPBLIT
+static void
+RLEClipBlit(int w, Uint8 * srcbuf, SDL_Surface * surf_dst,
+            Uint8 * dstbuf, SDL_Rect * srcrect, unsigned alpha)
+{
+    SDL_PixelFormat *fmt = surf_dst->format;
 
+    CHOOSE_BLIT(RLECLIPBLIT, alpha, fmt);
 }
 
+#undef RLECLIPBLIT
 
 /* blit a colorkeyed RLE surface */
 static int SDLCALL
@@ -456,7 +460,7 @@ SDL_RLEBlit(SDL_Surface * surf_src, SDL_Rect * srcrect,
     /* Lock the destination if necessary */
     if (SDL_MUSTLOCK(surf_dst)) {
         if (SDL_LockSurface(surf_dst) < 0) {
-            return (-1);
+            return -1;
         }
     }
 
@@ -474,19 +478,19 @@ SDL_RLEBlit(SDL_Surface * surf_src, SDL_Rect * srcrect,
         if (vskip) {
 
 #define RLESKIP(bpp, Type)          \
-        for(;;) {           \
+        for (;;) {           \
             int run;            \
             ofs += *(Type *)srcbuf; \
             run = ((Type *)srcbuf)[1];  \
             srcbuf += sizeof(Type) * 2; \
-            if(run) {           \
+            if (run) {           \
             srcbuf += run * bpp;    \
             ofs += run;     \
-            } else if(!ofs)     \
+            } else if (!ofs)     \
             goto done;      \
-            if(ofs == w) {      \
+            if (ofs == w) {      \
             ofs = 0;        \
-            if(!--vskip)        \
+            if (!--vskip)        \
                 break;      \
             }               \
         }
@@ -522,25 +526,25 @@ SDL_RLEBlit(SDL_Surface * surf_src, SDL_Rect * srcrect,
         do {                                  \
         int linecount = srcrect->h;                   \
         int ofs = 0;                              \
-        for(;;) {                             \
+        for (;;) {                             \
             unsigned run;                         \
             ofs += *(Type *)srcbuf;                   \
             run = ((Type *)srcbuf)[1];                    \
             srcbuf += 2 * sizeof(Type);                   \
-            if(run) {                             \
+            if (run) {                             \
             do_blit(dstbuf + ofs * bpp, srcbuf, run, bpp, alpha); \
             srcbuf += run * bpp;                      \
             ofs += run;                       \
-            } else if(!ofs)                       \
+            } else if (!ofs)                       \
             break;                            \
-            if(ofs == w) {                        \
+            if (ofs == w) {                        \
             ofs = 0;                          \
             dstbuf += surf_dst->pitch;                     \
-            if(!--linecount)                      \
+            if (!--linecount)                      \
                 break;                        \
             }                                 \
         }                                 \
-        } while(0)
+        } while (0)
 
         CHOOSE_BLIT(RLEBLIT, alpha, fmt);
 
@@ -552,7 +556,7 @@ SDL_RLEBlit(SDL_Surface * surf_src, SDL_Rect * srcrect,
     if (SDL_MUSTLOCK(surf_dst)) {
         SDL_UnlockSurface(surf_dst);
     }
-    return (0);
+    return 0;
 }
 
 #undef OPAQUE_BLIT
@@ -578,7 +582,7 @@ SDL_RLEBlit(SDL_Surface * surf_src, SDL_Rect * srcrect,
     d &= 0xff00;                        \
     d = (d + ((s - d) * alpha >> 8)) & 0xff00;      \
     dst = d1 | d | 0xff000000;              \
-    } while(0)
+    } while (0)
 
 /*
  * For 16bpp pixels, we have stored the 5 most significant alpha bits in
@@ -594,7 +598,7 @@ SDL_RLEBlit(SDL_Surface * surf_src, SDL_Rect * srcrect,
     d += (s - d) * alpha >> 5;      \
     d &= 0x07e0f81f;            \
     dst = (Uint16)(d | d >> 16);            \
-    } while(0)
+    } while (0)
 
 #define BLIT_TRANSL_555(src, dst)       \
     do {                    \
@@ -606,7 +610,7 @@ SDL_RLEBlit(SDL_Surface * surf_src, SDL_Rect * srcrect,
     d += (s - d) * alpha >> 5;      \
     d &= 0x03e07c1f;            \
     dst = (Uint16)(d | d >> 16);            \
-    } while(0)
+    } while (0)
 
 /* used to save the destination format in the encoding. Designed to be
    macro-compatible with SDL_PixelFormat but without the unneeded fields */
@@ -653,27 +657,27 @@ RLEAlphaClipBlit(int w, Uint8 * srcbuf, SDL_Surface * surf_dst,
         ofs += ((Ctype *)srcbuf)[0];                  \
         run = ((Ctype *)srcbuf)[1];               \
         srcbuf += 2 * sizeof(Ctype);                  \
-        if(run) {                         \
+        if (run) {                         \
             /* clip to left and right borders */          \
             int cofs = ofs;                   \
             int crun = run;                   \
-            if(left - cofs > 0) {                 \
+            if (left - cofs > 0) {                 \
             crun -= left - cofs;                  \
             cofs = left;                      \
             }                             \
-            if(crun > right - cofs)               \
+            if (crun > right - cofs)               \
             crun = right - cofs;                  \
-            if(crun > 0)                      \
+            if (crun > 0)                      \
             PIXEL_COPY(dstbuf + cofs * sizeof(Ptype),     \
                    srcbuf + (cofs - ofs) * sizeof(Ptype), \
                    (unsigned)crun, sizeof(Ptype));    \
             srcbuf += run * sizeof(Ptype);            \
             ofs += run;                       \
-        } else if(!ofs)                       \
+        } else if (!ofs)                       \
             return;                       \
-        } while(ofs < w);                         \
+        } while (ofs < w);                         \
         /* skip padding if necessary */               \
-        if(sizeof(Ptype) == 2)                    \
+        if (sizeof(Ptype) == 2)                    \
         srcbuf += (uintptr_t)srcbuf & 2;              \
         /* blit translucent pixels on the same line */        \
         ofs = 0;                              \
@@ -682,30 +686,30 @@ RLEAlphaClipBlit(int w, Uint8 * srcbuf, SDL_Surface * surf_dst,
         ofs += ((Uint16 *)srcbuf)[0];                 \
         run = ((Uint16 *)srcbuf)[1];                  \
         srcbuf += 4;                          \
-        if(run) {                         \
+        if (run) {                         \
             /* clip to left and right borders */          \
             int cofs = ofs;                   \
             int crun = run;                   \
-            if(left - cofs > 0) {                 \
+            if (left - cofs > 0) {                 \
             crun -= left - cofs;                  \
             cofs = left;                      \
             }                             \
-            if(crun > right - cofs)               \
+            if (crun > right - cofs)               \
             crun = right - cofs;                  \
-            if(crun > 0) {                    \
+            if (crun > 0) {                    \
             Ptype *dst = (Ptype *)dstbuf + cofs;          \
             Uint32 *src = (Uint32 *)srcbuf + (cofs - ofs);    \
             int i;                        \
-            for(i = 0; i < crun; i++)             \
+            for (i = 0; i < crun; i++)             \
                 do_blend(src[i], dst[i]);             \
             }                             \
             srcbuf += run * 4;                    \
             ofs += run;                       \
         }                             \
-        } while(ofs < w);                         \
+        } while (ofs < w);                         \
         dstbuf += surf_dst->pitch;                     \
-    } while(--linecount);                         \
-    } while(0)
+    } while (--linecount);                         \
+    } while (0)
 
     switch (df->BytesPerPixel) {
     case 2:
@@ -819,16 +823,16 @@ SDL_RLEAlphaBlit(SDL_Surface * surf_src, SDL_Rect * srcrect,
             ofs += ((Ctype *)srcbuf)[0];             \
             run = ((Ctype *)srcbuf)[1];              \
             srcbuf += 2 * sizeof(Ctype);             \
-            if(run) {                        \
+            if (run) {                        \
             PIXEL_COPY(dstbuf + ofs * sizeof(Ptype), srcbuf, \
                    run, sizeof(Ptype));          \
             srcbuf += run * sizeof(Ptype);           \
             ofs += run;                  \
-            } else if(!ofs)                  \
+            } else if (!ofs)                  \
             goto done;                   \
-        } while(ofs < w);                    \
+        } while (ofs < w);                    \
         /* skip padding if necessary */              \
-        if(sizeof(Ptype) == 2)                   \
+        if (sizeof(Ptype) == 2)                   \
             srcbuf += (uintptr_t)srcbuf & 2;             \
         /* blit translucent pixels on the same line */       \
         ofs = 0;                         \
@@ -837,10 +841,10 @@ SDL_RLEAlphaBlit(SDL_Surface * surf_src, SDL_Rect * srcrect,
             ofs += ((Uint16 *)srcbuf)[0];            \
             run = ((Uint16 *)srcbuf)[1];             \
             srcbuf += 4;                     \
-            if(run) {                        \
+            if (run) {                        \
             Ptype *dst = (Ptype *)dstbuf + ofs;      \
             unsigned i;                  \
-            for(i = 0; i < run; i++) {           \
+            for (i = 0; i < run; i++) {           \
                 Uint32 src = *(Uint32 *)srcbuf;      \
                 do_blend(src, *dst);             \
                 srcbuf += 4;                 \
@@ -848,10 +852,10 @@ SDL_RLEAlphaBlit(SDL_Surface * surf_src, SDL_Rect * srcrect,
             }                        \
             ofs += run;                  \
             }                            \
-        } while(ofs < w);                    \
+        } while (ofs < w);                    \
         dstbuf += surf_dst->pitch;                    \
-        } while(--linecount);                    \
-    } while(0)
+        } while (--linecount);                    \
+    } while (0)
 
         switch (df->BytesPerPixel) {
         case 2:
@@ -1036,11 +1040,13 @@ RLEAlphaSurface(SDL_Surface * surface)
                         SDL_PixelFormat *, SDL_PixelFormat *);
 
     dest = surface->map->dst;
-    if (!dest)
+    if (dest == NULL) {
         return -1;
+    }
     df = dest->format;
-    if (surface->format->BitsPerPixel != 32)
-        return -1;              /* only 32bpp source supported */
+    if (surface->format->BitsPerPixel != 32) {
+        return -1; /* only 32bpp source supported */
+    }
 
     /* find out whether the destination is one we support,
        and determine the max size of the encoded result */
@@ -1090,7 +1096,7 @@ RLEAlphaSurface(SDL_Surface * surface)
 
     maxsize += sizeof(RLEDestFormat);
     rlebuf = (Uint8 *) SDL_malloc(maxsize);
-    if (!rlebuf) {
+    if (rlebuf == NULL) {
         return SDL_OutOfMemory();
     }
     {
@@ -1122,7 +1128,7 @@ RLEAlphaSurface(SDL_Surface * surface)
 
         /* opaque counts are 8 or 16 bits, depending on target depth */
 #define ADD_OPAQUE_COUNTS(n, m)         \
-    if(df->BytesPerPixel == 4) {        \
+    if (df->BytesPerPixel == 4) {        \
         ((Uint16 *)dst)[0] = n;     \
         ((Uint16 *)dst)[1] = m;     \
         dst += 4;               \
@@ -1150,8 +1156,9 @@ RLEAlphaSurface(SDL_Surface * surface)
                 while (x < w && ISOPAQUE(src[x], sf))
                     x++;
                 skip = runstart - skipstart;
-                if (skip == w)
+                if (skip == w) {
                     blankline = 1;
+                }
                 run = x - runstart;
                 while (skip > max_opaque_run) {
                     ADD_OPAQUE_COUNTS(max_opaque_run, 0);
@@ -1203,8 +1210,9 @@ RLEAlphaSurface(SDL_Surface * surface)
                     runstart += len;
                     run -= len;
                 }
-                if (!blankline)
+                if (!blankline) {
                     lastline = dst;
+                }
             } while (x < w);
 
             src += surface->pitch >> 2;
@@ -1230,8 +1238,9 @@ RLEAlphaSurface(SDL_Surface * surface)
     /* reallocate the buffer to release unused memory */
     {
         Uint8 *p = SDL_realloc(rlebuf, dst - rlebuf);
-        if (!p)
+        if (p == NULL) {
             p = rlebuf;
+        }
         surface->map->data = p;
     }
 
@@ -1247,7 +1256,7 @@ getpix_8(const Uint8 * srcbuf)
 static Uint32
 getpix_16(const Uint8 * srcbuf)
 {
-    return *(const Uint16 *) srcbuf;
+    return *(const Uint16 *)srcbuf;
 }
 
 static Uint32
@@ -1263,7 +1272,7 @@ getpix_24(const Uint8 * srcbuf)
 static Uint32
 getpix_32(const Uint8 * srcbuf)
 {
-    return *(const Uint32 *) srcbuf;
+    return *(const Uint32 *)srcbuf;
 }
 
 typedef Uint32(*getpix_func) (const Uint8 *);
@@ -1325,7 +1334,7 @@ RLEColorkeySurface(SDL_Surface * surface)
     h = surface->h;
 
 #define ADD_COUNTS(n, m)            \
-    if(bpp == 4) {              \
+    if (bpp == 4) {              \
         ((Uint16 *)dst)[0] = n;     \
         ((Uint16 *)dst)[1] = m;     \
         dst += 4;               \
@@ -1350,8 +1359,9 @@ RLEColorkeySurface(SDL_Surface * surface)
             while (x < w && (getpix(srcbuf + x * bpp) & rgbmask) != ckey)
                 x++;
             skip = runstart - skipstart;
-            if (skip == w)
+            if (skip == w) {
                 blankline = 1;
+            }
             run = x - runstart;
 
             /* encode segment */
@@ -1373,8 +1383,9 @@ RLEColorkeySurface(SDL_Surface * surface)
                 runstart += len;
                 run -= len;
             }
-            if (!blankline)
+            if (!blankline) {
                 lastline = dst;
+            }
         } while (x < w);
 
         srcbuf += surface->pitch;
@@ -1399,8 +1410,9 @@ RLEColorkeySurface(SDL_Surface * surface)
     {
         /* If SDL_realloc returns NULL, the original block is left intact */
         Uint8 *p = SDL_realloc(rlebuf, dst - rlebuf);
-        if (!p)
+        if (p == NULL) {
             p = rlebuf;
+        }
         surface->map->data = p;
     }
 
@@ -1466,7 +1478,7 @@ SDL_RLESurface(SDL_Surface * surface)
     /* The surface is now accelerated */
     surface->flags |= SDL_RLEACCEL;
 
-    return (0);
+    return 0;
 }
 
 /*
@@ -1498,7 +1510,7 @@ UnRLEAlpha(SDL_Surface * surface)
 
     surface->pixels = SDL_SIMDAlloc(surface->h * surface->pitch);
     if (!surface->pixels) {
-        return (SDL_FALSE);
+        return SDL_FALSE;
     }
     surface->flags |= SDL_SIMD_ALIGNED;
     /* fill background with transparent pixels */
@@ -1529,8 +1541,9 @@ UnRLEAlpha(SDL_Surface * surface)
         } while (ofs < w);
 
         /* skip padding if needed */
-        if (bpp == 2)
-            srcbuf += (uintptr_t) srcbuf & 2;
+        if (bpp == 2) {
+            srcbuf += (uintptr_t)srcbuf & 2;
+        }
 
         /* copy translucent pixels */
         ofs = 0;
@@ -1548,7 +1561,7 @@ UnRLEAlpha(SDL_Surface * surface)
     }
 
 end_function:
-    return (SDL_TRUE);
+    return SDL_TRUE;
 }
 
 void
diff --git a/src/video/SDL_blit.c b/src/video/SDL_blit.c
index fa6492f51..70a66caef 100644
--- a/src/video/SDL_blit.c
+++ b/src/video/SDL_blit.c
@@ -96,7 +96,7 @@ SDL_SoftBlit(SDL_Surface * src, SDL_Rect * srcrect,
         SDL_UnlockSurface(src);
     }
     /* Blit is done! */
-    return (okay ? 0 : -1);
+    return okay ? 0 : -1;
 }
 
 #if SDL_HAVE_BLIT_AUTO
diff --git a/src/video/SDL_blit_A.c b/src/video/SDL_blit_A.c
index 56ba024c9..1a181ab17 100644
--- a/src/video/SDL_blit_A.c
+++ b/src/video/SDL_blit_A.c
@@ -1190,8 +1190,8 @@ BlitARGBto565PixelAlpha(SDL_BlitInfo * info)
            compositioning used (>>8 instead of /255) doesn't handle
            it correctly. Also special-case alpha=0 for speed?
            Benchmark this! */
-        if(alpha) {   
-          if(alpha == (SDL_ALPHA_OPAQUE >> 3)) {
+        if (alpha) {   
+          if (alpha == (SDL_ALPHA_OPAQUE >> 3)) {
             *dstp = (Uint16)((s >> 8 & 0xf800) + (s >> 5 & 0x7e0) + (s >> 3  & 0x1f));
           } else {
             Uint32 d = *dstp;
@@ -1237,8 +1237,8 @@ BlitARGBto555PixelAlpha(SDL_BlitInfo * info)
            compositioning used (>>8 instead of /255) doesn't handle
            it correctly. Also special-case alpha=0 for speed?
            Benchmark this! */
-        if(alpha) {   
-          if(alpha == (SDL_ALPHA_OPAQUE >> 3)) {
+        if (alpha) {   
+          if (alpha == (SDL_ALPHA_OPAQUE >> 3)) {
             *dstp = (Uint16)((s >> 9 & 0x7c00) + (s >> 6 & 0x3e0) + (s >> 3  & 0x1f));
           } else {
             Uint32 d = *dstp;
@@ -1327,7 +1327,7 @@ BlitNtoNSurfaceAlphaKey(SDL_BlitInfo * info)
         DUFFS_LOOP4(
         {
         RETRIEVE_RGB_PIXEL(src, srcbpp, Pixel);
-        if(sA && Pixel != ckey) {
+        if (sA && Pixel != ckey) {
             RGB_FROM_PIXEL(Pixel, srcfmt, sR, sG, sB);
             DISEMBLE_RGBA(dst, dstbpp, dstfmt, Pixel, dR, dG, dB, dA);
             ALPHA_BLEND_RGBA(sR, sG, sB, sA, dR, dG, dB, dA);
@@ -1370,7 +1370,7 @@ BlitNtoNPixelAlpha(SDL_BlitInfo * info)
         DUFFS_LOOP4(
         {
         DISEMBLE_RGBA(src, srcbpp, srcfmt, Pixel, sR, sG, sB, sA);
-        if(sA) {
+        if (sA) {
             DISEMBLE_RGBA(dst, dstbpp, dstfmt, Pixel, dR, dG, dB, dA);
             ALPHA_BLEND_RGBA(sR, sG, sB, sA, dR, dG, dB, dA);
             ASSEMBLE_RGBA(dst, dstbpp, dstfmt, dR, dG, dB, dA);
@@ -1412,12 +1412,14 @@ SDL_CalculateBlitA(SDL_Surface * surface)
                     || (sf->Bmask == 0xff && df->Bmask == 0x1f)))
                 {
 #if SDL_ARM_NEON_BLITTERS
-                    if (SDL_HasNEON())
+                    if (SDL_HasNEON()) {
                         return BlitARGBto565PixelAlphaARMNEON;
+                    }
 #endif
 #if SDL_ARM_SIMD_BLITTERS
-                    if (SDL_HasARMSIMD())
+                    if (SDL_HasARMSIMD()) {
                         return BlitARGBto565PixelAlphaARMSIMD;
+                    }
 #endif
                 }
 #endif
@@ -1425,10 +1427,11 @@ SDL_CalculateBlitA(SDL_Surface * surface)
                     && sf->Gmask == 0xff00
                     && ((sf->Rmask == 0xff && df->Rmask == 0x1f)
                         || (sf->Bmask == 0xff && df->Bmask == 0x1f))) {
-                if (df->Gmask == 0x7e0)
+                if (df->Gmask == 0x7e0) {
                     return BlitARGBto565PixelAlpha;
-                else if (df->Gmask == 0x3e0)
+                } else if (df->Gmask == 0x3e0) {
                     return BlitARGBto555PixelAlpha;
+                }
             }
             return BlitNtoNPixelAlpha;
 
@@ -1442,23 +1445,27 @@ SDL_CalculateBlitA(SDL_Surface * surface)
                     && sf->Bshift % 8 == 0
                     && sf->Ashift % 8 == 0 && sf->Aloss == 0) {
 #ifdef __3dNOW__
-                    if (SDL_Has3DNow())
+                    if (SDL_Has3DNow()) {
                         return BlitRGBtoRGBPixelAlphaMMX3DNOW;
+                    }
 #endif
 #ifdef __MMX__
-                    if (SDL_HasMMX())
+                    if (SDL_HasMMX()) {
                         return BlitRGBtoRGBPixelAlphaMMX;
+                    }
 #endif
                 }
 #endif /* __MMX__ || __3dNOW__ */
                 if (sf->Amask == 0xff000000) {
 #if SDL_ARM_NEON_BLITTERS
-                    if (SDL_HasNEON())
+                    if (SDL_HasNEON()) {
                         return BlitRGBtoRGBPixelAlphaARMNEON;
+                    }
 #endif
 #if SDL_ARM_SIMD_BLITTERS
-                    if (SDL_HasARMSIMD())
+                    if (SDL_HasARMSIMD()) {
                         return BlitRGBtoRGBPixelAlphaARMSIMD;
+                    }
 #endif
                     return BlitRGBtoRGBPixelAlpha;
                 }
@@ -1514,10 +1521,9 @@ SDL_CalculateBlitA(SDL_Surface * surface)
                     && sf->Gmask == df->Gmask
                     && sf->Bmask == df->Bmask && sf->BytesPerPixel == 4) {
 #ifdef __MMX__
-                    if (sf->Rshift % 8 == 0
-                        && sf->Gshift % 8 == 0
-                        && sf->Bshift % 8 == 0 && SDL_HasMMX())
+                    if (sf->Rshift % 8 == 0 && sf->Gshift % 8 == 0 && sf->Bshift % 8 == 0 && SDL_HasMMX()) {
                         return BlitRGBtoRGBSurfaceAlphaMMX;
+                    }
 #endif
                     if ((sf->Rmask | sf->Gmask | sf->Bmask) == 0xffffff) {
                         return BlitRGBtoRGBSurfaceAlpha;
diff --git a/src/video/SDL_blit_N.c b/src/video/SDL_blit_N.c
index 3efa917d6..458b2840b 100644
--- a/src/video/SDL_blit_N.c
+++ b/src/video/SDL_blit_N.c
@@ -63,8 +63,9 @@ GetL3CacheSize(void)
 
 
     int err = sysctlbyname(key, &result, &typeSize, NULL, 0);
-    if (0 != err)
+    if (0 != err) {
         return 0;
+    }
 
     return result;
 }
@@ -762,7 +763,7 @@ ConvertAltivec32to32_noprefetch(SDL_BlitInfo * info)
         while ((UNALIGNED_PTR(dst)) && (width)) {
             bits = *(src++);
             RGBA_FROM_8888(bits, srcfmt, r, g, b, a);
-            if(!srcfmt->Amask)
+            if (!srcfmt->Amask)
               a = info->a;
             *(dst++) = MAKE8888(dstfmt, r, g, b, a);
             width--;
@@ -795,7 +796,7 @@ ConvertAltivec32to32_noprefetch(SDL_BlitInfo * info)
         while (extrawidth) {
             bits = *(src++);    /* max 7 pixels, don't bother with prefetch. */
             RGBA_FROM_8888(bits, srcfmt, r, g, b, a);
-            if(!srcfmt->Amask)
+            if (!srcfmt->Amask)
               a = info->a;
             *(dst++) = MAKE8888(dstfmt, r, g, b, a);
             extrawidth--;
@@ -853,7 +854,7 @@ ConvertAltivec32to32_prefetch(SDL_BlitInfo * info)
                       DST_CHAN_DEST);
             bits = *(src++);
             RGBA_FROM_8888(bits, srcfmt, r, g, b, a);
-            if(!srcfmt->Amask)
+            if (!srcfmt->Amask)
               a = info->a;
             *(dst++) = MAKE8888(dstfmt, r, g, b, a);
             width--;
@@ -890,7 +891,7 @@ ConvertAltivec32to32_prefetch(SDL_BlitInfo * info)
         while (extrawidth) {
             bits = *(src++);    /* max 7 pixels, don't bother with prefetch. */
             RGBA_FROM_8888(bits, srcfmt, r, g, b, a);
-            if(!srcfmt->Amask)
+            if (!srcfmt->Amask)
               a = info->a;
             *(dst++) = MAKE8888(dstfmt, r, g, b, a);
             extrawidth--;
@@ -2307,10 +2308,18 @@ get_permutation(SDL_PixelFormat *srcfmt, SDL_PixelFormat *dstfmt,
 #if SDL_BYTEORDER == SDL_LIL_ENDIAN
 #else
     if (srcbpp == 3 && dstbpp == 4) {
-        if (p0 != 1) p0--;
-        if (p1 != 1) p1--;
-        if (p2 != 1) p2--;
-        if (p3 != 1) p3--;
+        if (p0 != 1) {
+            p0--;
+        }
+        if (p1 != 1) {
+            p1--;
+        }
+        if (p2 != 1) {
+            p2--;
+        }
+        if (p3 != 1) {
+            p3--;
+        }
     } else if (srcbpp == 4 && dstbpp == 3) {
         p0 = p1;
         p1 = p2;
@@ -3377,7 +3386,7 @@ SDL_CalculateBlitN(SDL_Surface * surface)
 
     /* We don't support destinations less than 8-bits */
     if (dstfmt->BitsPerPixel < 8) {
-        return (NULL);
+        return NULL;
     }
 
     switch (surface->map->info.flags & ~SDL_COPY_RLE_MASK) {
@@ -3400,8 +3409,9 @@ SDL_CalculateBlitN(SDL_Surface * surface)
         } else {
             /* Now the meat, choose the blitter we want */
             Uint32 a_need = NO_ALPHA;
-            if (dstfmt->Amask)
+            if (dstfmt->Amask) {
                 a_need = srcfmt->Amask ? COPY_ALPHA : SET_ALPHA;
+            }
             table = normal_blit[srcfmt->BytesPerPixel - 1];
             for (which = 0; table[which].dstbpp; ++which) {
                 if (MASKOK(srcfmt->Rmask, table[which].srcR) &&
@@ -3413,8 +3423,9 @@ SDL_CalculateBlitN(SDL_Surface * surface)
                     dstfmt->BytesPerPixel == table[which].dstbpp &&
                     (a_need & table[which].alpha) == a_need &&
                     ((table[which].blit_features & GetBlitFeatures()) ==
-                     table[which].blit_features))
+                     table[which].blit_features)) {
                     break;
+                }
             }
             blitfun = table[which].blitfunc;
 
@@ -3444,7 +3455,7 @@ SDL_CalculateBlitN(SDL_Surface * surface)
                 }
             }
         }
-        return (blitfun);
+        return blitfun;
 
     case SDL_COPY_COLORKEY:
         /* colorkey blit: Here we don't have too many options, mostly
diff --git a/src/video/SDL_blit_auto.c b/src/video/SDL_blit_auto.c
index f15a43622..ed121e18c 100644
--- a/src/video/SDL_blit_auto.c
+++ b/src/video/SDL_blit_auto.c
@@ -82,9 +82,15 @@ static void SDL_Blit_RGB888_RGB888_Blend(SDL_BlitInfo *info)
                 dstB = srcB;
                 break;
             case SDL_COPY_ADD:
-                dstR = srcR + dstR; if (dstR > 255) dstR = 255;
-                dstG = srcG + dstG; if (dstG > 255) dstG = 255;
-                dstB = srcB + dstB; if (dstB > 255) dstB = 255;
+                dstR = srcR + dstR; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = srcG + dstG; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = srcB + dstB; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             case SDL_COPY_MOD:
                 dstR = (srcR * dstR) / 255;
@@ -143,9 +149,15 @@ static void SDL_Blit_RGB888_RGB888_Blend_Scale(SDL_BlitInfo *info)
                 dstB = srcB;
                 break;
             case SDL_COPY_ADD:
-                dstR = srcR + dstR; if (dstR > 255) dstR = 255;
-                dstG = srcG + dstG; if (dstG > 255) dstG = 255;
-                dstB = srcB + dstB; if (dstB > 255) dstB = 255;
+                dstR = srcR + dstR; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = srcG + dstG; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = srcB + dstB; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             case SDL_COPY_MOD:
                 dstR = (srcR * dstR) / 255;
@@ -284,9 +296,15 @@ static void SDL_Blit_RGB888_RGB888_Modulate_Blend(SDL_BlitInfo *info)
                 dstB = srcB + ((255 - srcA) * dstB) / 255;
                 break;
             case SDL_COPY_ADD:
-                dstR = srcR + dstR; if (dstR > 255) dstR = 255;
-                dstG = srcG + dstG; if (dstG > 255) dstG = 255;
-                dstB = srcB + dstB; if (dstB > 255) dstB = 255;
+                dstR = srcR + dstR; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = srcG + dstG; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = srcB + dstB; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             case SDL_COPY_MOD:
                 dstR = (srcR * dstR) / 255;
@@ -294,9 +312,15 @@ static void SDL_Blit_RGB888_RGB888_Modulate_Blend(SDL_BlitInfo *info)
                 dstB = (srcB * dstB) / 255;
                 break;
             case SDL_COPY_MUL:
-                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) dstR = 255;
-                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) dstG = 255;
-                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) dstB = 255;
+                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             }
             dstpixel = (dstR << 16) | (dstG << 8) | dstB;
@@ -363,9 +387,15 @@ static void SDL_Blit_RGB888_RGB888_Modulate_Blend_Scale(SDL_BlitInfo *info)
                 dstB = srcB + ((255 - srcA) * dstB) / 255;
                 break;
             case SDL_COPY_ADD:
-                dstR = srcR + dstR; if (dstR > 255) dstR = 255;
-                dstG = srcG + dstG; if (dstG > 255) dstG = 255;
-                dstB = srcB + dstB; if (dstB > 255) dstB = 255;
+                dstR = srcR + dstR; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = srcG + dstG; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = srcB + dstB; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             case SDL_COPY_MOD:
                 dstR = (srcR * dstR) / 255;
@@ -373,9 +403,15 @@ static void SDL_Blit_RGB888_RGB888_Modulate_Blend_Scale(SDL_BlitInfo *info)
                 dstB = (srcB * dstB) / 255;
                 break;
             case SDL_COPY_MUL:
-                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) dstR = 255;
-                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) dstG = 255;
-                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) dstB = 255;
+                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             }
             dstpixel = (dstR << 16) | (dstG << 8) | dstB;
@@ -446,9 +482,15 @@ static void SDL_Blit_RGB888_BGR888_Blend(SDL_BlitInfo *info)
                 dstB = srcB;
                 break;
             case SDL_COPY_ADD:
-                dstR = srcR + dstR; if (dstR > 255) dstR = 255;
-                dstG = srcG + dstG; if (dstG > 255) dstG = 255;
-                dstB = srcB + dstB; if (dstB > 255) dstB = 255;
+                dstR = srcR + dstR; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = srcG + dstG; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = srcB + dstB; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             case SDL_COPY_MOD:
                 dstR = (srcR * dstR) / 255;
@@ -507,9 +549,15 @@ static void SDL_Blit_RGB888_BGR888_Blend_Scale(SDL_BlitInfo *info)
                 dstB = srcB;
                 break;
             case SDL_COPY_ADD:
-                dstR = srcR + dstR; if (dstR > 255) dstR = 255;
-                dstG = srcG + dstG; if (dstG > 255) dstG = 255;
-                dstB = srcB + dstB; if (dstB > 255) dstB = 255;
+                dstR = srcR + dstR; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = srcG + dstG; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = srcB + dstB; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             case SDL_COPY_MOD:
                 dstR = (srcR * dstR) / 255;
@@ -648,9 +696,15 @@ static void SDL_Blit_RGB888_BGR888_Modulate_Blend(SDL_BlitInfo *info)
                 dstB = srcB + ((255 - srcA) * dstB) / 255;
                 break;
             case SDL_COPY_ADD:
-                dstR = srcR + dstR; if (dstR > 255) dstR = 255;
-                dstG = srcG + dstG; if (dstG > 255) dstG = 255;
-                dstB = srcB + dstB; if (dstB > 255) dstB = 255;
+                dstR = srcR + dstR; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = srcG + dstG; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = srcB + dstB; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             case SDL_COPY_MOD:
                 dstR = (srcR * dstR) / 255;
@@ -658,9 +712,15 @@ static void SDL_Blit_RGB888_BGR888_Modulate_Blend(SDL_BlitInfo *info)
                 dstB = (srcB * dstB) / 255;
                 break;
             case SDL_COPY_MUL:
-                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) dstR = 255;
-                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) dstG = 255;
-                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) dstB = 255;
+                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             }
             dstpixel = (dstB << 16) | (dstG << 8) | dstR;
@@ -727,9 +787,15 @@ static void SDL_Blit_RGB888_BGR888_Modulate_Blend_Scale(SDL_BlitInfo *info)
                 dstB = srcB + ((255 - srcA) * dstB) / 255;
                 break;
             case SDL_COPY_ADD:
-                dstR = srcR + dstR; if (dstR > 255) dstR = 255;
-                dstG = srcG + dstG; if (dstG > 255) dstG = 255;
-                dstB = srcB + dstB; if (dstB > 255) dstB = 255;
+                dstR = srcR + dstR; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = srcG + dstG; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = srcB + dstB; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             case SDL_COPY_MOD:
                 dstR = (srcR * dstR) / 255;
@@ -737,9 +803,15 @@ static void SDL_Blit_RGB888_BGR888_Modulate_Blend_Scale(SDL_BlitInfo *info)
                 dstB = (srcB * dstB) / 255;
                 break;
             case SDL_COPY_MUL:
-                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) dstR = 255;
-                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) dstG = 255;
-                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) dstB = 255;
+                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             }
             dstpixel = (dstB << 16) | (dstG << 8) | dstR;
@@ -810,9 +882,15 @@ static void SDL_Blit_RGB888_ARGB8888_Blend(SDL_BlitInfo *info)
                 dstA = 0xFF;
                 break;
             case SDL_COPY_ADD:
-                dstR = srcR + dstR; if (dstR > 255) dstR = 255;
-                dstG = srcG + dstG; if (dstG > 255) dstG = 255;
-                dstB = srcB + dstB; if (dstB > 255) dstB = 255;
+                dstR = srcR + dstR; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = srcG + dstG; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = srcB + dstB; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             case SDL_COPY_MOD:
                 dstR = (srcR * dstR) / 255;
@@ -873,9 +951,15 @@ static void SDL_Blit_RGB888_ARGB8888_Blend_Scale(SDL_BlitInfo *info)
                 dstA = 0xFF;
                 break;
             case SDL_COPY_ADD:
-                dstR = srcR + dstR; if (dstR > 255) dstR = 255;
-                dstG = srcG + dstG; if (dstG > 255) dstG = 255;
-                dstB = srcB + dstB; if (dstB > 255) dstB = 255;
+                dstR = srcR + dstR; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = srcG + dstG; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = srcB + dstB; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             case SDL_COPY_MOD:
                 dstR = (srcR * dstR) / 255;
@@ -1020,9 +1104,15 @@ static void SDL_Blit_RGB888_ARGB8888_Modulate_Blend(SDL_BlitInfo *info)
                 dstA = srcA + ((255 - srcA) * dstA) / 255;
                 break;
             case SDL_COPY_ADD:
-                dstR = srcR + dstR; if (dstR > 255) dstR = 255;
-                dstG = srcG + dstG; if (dstG > 255) dstG = 255;
-                dstB = srcB + dstB; if (dstB > 255) dstB = 255;
+                dstR = srcR + dstR; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = srcG + dstG; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = srcB + dstB; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             case SDL_COPY_MOD:
                 dstR = (srcR * dstR) / 255;
@@ -1030,10 +1120,18 @@ static void SDL_Blit_RGB888_ARGB8888_Modulate_Blend(SDL_BlitInfo *info)
                 dstB = (srcB * dstB) / 255;
                 break;
             case SDL_COPY_MUL:
-                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) dstR = 255;
-                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) dstG = 255;
-                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) dstB = 255;
-                dstA = ((srcA * dstA) + (dstA * (255 - srcA))) / 255; if (dstA > 255) dstA = 255;
+                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) {
+                    dstB = 255;
+                }
+                dstA = ((srcA * dstA) + (dstA * (255 - srcA))) / 255; if (dstA > 255) {
+                    dstA = 255;
+                }
                 break;
             }
             dstpixel = (dstA << 24) | (dstR << 16) | (dstG << 8) | dstB;
@@ -1101,9 +1199,15 @@ static void SDL_Blit_RGB888_ARGB8888_Modulate_Blend_Scale(SDL_BlitInfo *info)
                 dstA = srcA + ((255 - srcA) * dstA) / 255;
                 break;
             case SDL_COPY_ADD:
-                dstR = srcR + dstR; if (dstR > 255) dstR = 255;
-                dstG = srcG + dstG; if (dstG > 255) dstG = 255;
-                dstB = srcB + dstB; if (dstB > 255) dstB = 255;
+                dstR = srcR + dstR; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = srcG + dstG; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = srcB + dstB; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             case SDL_COPY_MOD:
                 dstR = (srcR * dstR) / 255;
@@ -1111,10 +1215,18 @@ static void SDL_Blit_RGB888_ARGB8888_Modulate_Blend_Scale(SDL_BlitInfo *info)
                 dstB = (srcB * dstB) / 255;
                 break;
             case SDL_COPY_MUL:
-                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) dstR = 255;
-                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) dstG = 255;
-                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) dstB = 255;
-                dstA = ((srcA * dstA) + (dstA * (255 - srcA))) / 255; if (dstA > 255) dstA = 255;
+                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) {
+                    dstB = 255;
+                }
+                dstA = ((srcA * dstA) + (dstA * (255 - srcA))) / 255; if (dstA > 255) {
+                    dstA = 255;
+                }
                 break;
             }
             dstpixel = (dstA << 24) | (dstR << 16) | (dstG << 8) | dstB;
@@ -1185,9 +1297,15 @@ static void SDL_Blit_BGR888_RGB888_Blend(SDL_BlitInfo *info)
                 dstB = srcB;
                 break;
             case SDL_COPY_ADD:
-                dstR = srcR + dstR; if (dstR > 255) dstR = 255;
-                dstG = srcG + dstG; if (dstG > 255) dstG = 255;
-                dstB = srcB + dstB; if (dstB > 255) dstB = 255;
+                dstR = srcR + dstR; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = srcG + dstG; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = srcB + dstB; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             case SDL_COPY_MOD:
                 dstR = (srcR * dstR) / 255;
@@ -1246,9 +1364,15 @@ static void SDL_Blit_BGR888_RGB888_Blend_Scale(SDL_BlitInfo *info)
                 dstB = srcB;
                 break;
             case SDL_COPY_ADD:
-                dstR = srcR + dstR; if (dstR > 255) dstR = 255;
-                dstG = srcG + dstG; if (dstG > 255) dstG = 255;
-                dstB = srcB + dstB; if (dstB > 255) dstB = 255;
+                dstR = srcR + dstR; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = srcG + dstG; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = srcB + dstB; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             case SDL_COPY_MOD:
                 dstR = (srcR * dstR) / 255;
@@ -1387,9 +1511,15 @@ static void SDL_Blit_BGR888_RGB888_Modulate_Blend(SDL_BlitInfo *info)
                 dstB = srcB + ((255 - srcA) * dstB) / 255;
                 break;
             case SDL_COPY_ADD:
-                dstR = srcR + dstR; if (dstR > 255) dstR = 255;
-                dstG = srcG + dstG; if (dstG > 255) dstG = 255;
-                dstB = srcB + dstB; if (dstB > 255) dstB = 255;
+                dstR = srcR + dstR; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = srcG + dstG; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = srcB + dstB; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             case SDL_COPY_MOD:
                 dstR = (srcR * dstR) / 255;
@@ -1397,9 +1527,15 @@ static void SDL_Blit_BGR888_RGB888_Modulate_Blend(SDL_BlitInfo *info)
                 dstB = (srcB * dstB) / 255;
                 break;
             case SDL_COPY_MUL:
-                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) dstR = 255;
-                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) dstG = 255;
-                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) dstB = 255;
+                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             }
             dstpixel = (dstR << 16) | (dstG << 8) | dstB;
@@ -1466,9 +1602,15 @@ static void SDL_Blit_BGR888_RGB888_Modulate_Blend_Scale(SDL_BlitInfo *info)
                 dstB = srcB + ((255 - srcA) * dstB) / 255;
                 break;
             case SDL_COPY_ADD:
-                dstR = srcR + dstR; if (dstR > 255) dstR = 255;
-                dstG = srcG + dstG; if (dstG > 255) dstG = 255;
-                dstB = srcB + dstB; if (dstB > 255) dstB = 255;
+                dstR = srcR + dstR; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = srcG + dstG; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = srcB + dstB; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             case SDL_COPY_MOD:
                 dstR = (srcR * dstR) / 255;
@@ -1476,9 +1618,15 @@ static void SDL_Blit_BGR888_RGB888_Modulate_Blend_Scale(SDL_BlitInfo *info)
                 dstB = (srcB * dstB) / 255;
                 break;
             case SDL_COPY_MUL:
-                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) dstR = 255;
-                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) dstG = 255;
-                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) dstB = 255;
+                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             }
             dstpixel = (dstR << 16) | (dstG << 8) | dstB;
@@ -1544,9 +1692,15 @@ static void SDL_Blit_BGR888_BGR888_Blend(SDL_BlitInfo *info)
                 dstB = srcB;
                 break;
             case SDL_COPY_ADD:
-                dstR = srcR + dstR; if (dstR > 255) dstR = 255;
-                dstG = srcG + dstG; if (dstG > 255) dstG = 255;
-                dstB = srcB + dstB; if (dstB > 255) dstB = 255;
+                dstR = srcR + dstR; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = srcG + dstG; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = srcB + dstB; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             case SDL_COPY_MOD:
                 dstR = (srcR * dstR) / 255;
@@ -1605,9 +1759,15 @@ static void SDL_Blit_BGR888_BGR888_Blend_Scale(SDL_BlitInfo *info)
                 dstB = srcB;
                 break;
             case SDL_COPY_ADD:
-                dstR = srcR + dstR; if (dstR > 255) dstR = 255;
-                dstG = srcG + dstG; if (dstG > 255) dstG = 255;
-                dstB = srcB + dstB; if (dstB > 255) dstB = 255;
+                dstR = srcR + dstR; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = srcG + dstG; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = srcB + dstB; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             case SDL_COPY_MOD:
                 dstR = (srcR * dstR) / 255;
@@ -1746,9 +1906,15 @@ static void SDL_Blit_BGR888_BGR888_Modulate_Blend(SDL_BlitInfo *info)
                 dstB = srcB + ((255 - srcA) * dstB) / 255;
                 break;
             case SDL_COPY_ADD:
-                dstR = srcR + dstR; if (dstR > 255) dstR = 255;
-                dstG = srcG + dstG; if (dstG > 255) dstG = 255;
-                dstB = srcB + dstB; if (dstB > 255) dstB = 255;
+                dstR = srcR + dstR; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = srcG + dstG; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = srcB + dstB; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             case SDL_COPY_MOD:
                 dstR = (srcR * dstR) / 255;
@@ -1756,9 +1922,15 @@ static void SDL_Blit_BGR888_BGR888_Modulate_Blend(SDL_BlitInfo *info)
                 dstB = (srcB * dstB) / 255;
                 break;
             case SDL_COPY_MUL:
-                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) dstR = 255;
-                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) dstG = 255;
-                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) dstB = 255;
+                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             }
             dstpixel = (dstB << 16) | (dstG << 8) | dstR;
@@ -1825,9 +1997,15 @@ static void SDL_Blit_BGR888_BGR888_Modulate_Blend_Scale(SDL_BlitInfo *info)
                 dstB = srcB + ((255 - srcA) * dstB) / 255;
                 break;
             case SDL_COPY_ADD:
-                dstR = srcR + dstR; if (dstR > 255) dstR = 255;
-                dstG = srcG + dstG; if (dstG > 255) dstG = 255;
-                dstB = srcB + dstB; if (dstB > 255) dstB = 255;
+                dstR = srcR + dstR; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = srcG + dstG; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = srcB + dstB; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             case SDL_COPY_MOD:
                 dstR = (srcR * dstR) / 255;
@@ -1835,9 +2013,15 @@ static void SDL_Blit_BGR888_BGR888_Modulate_Blend_Scale(SDL_BlitInfo *info)
                 dstB = (srcB * dstB) / 255;
                 break;
             case SDL_COPY_MUL:
-                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) dstR = 255;
-                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) dstG = 255;
-                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) dstB = 255;
+                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             }
             dstpixel = (dstB << 16) | (dstG << 8) | dstR;
@@ -1910,9 +2094,15 @@ static void SDL_Blit_BGR888_ARGB8888_Blend(SDL_BlitInfo *info)
                 dstA = 0xFF;
                 break;
             case SDL_COPY_ADD:
-                dstR = srcR + dstR; if (dstR > 255) dstR = 255;
-                dstG = srcG + dstG; if (dstG > 255) dstG = 255;
-                dstB = srcB + dstB; if (dstB > 255) dstB = 255;
+                dstR = srcR + dstR; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = srcG + dstG; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = srcB + dstB; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             case SDL_COPY_MOD:
                 dstR = (srcR * dstR) / 255;
@@ -1973,9 +2163,15 @@ static void SDL_Blit_BGR888_ARGB8888_Blend_Scale(SDL_BlitInfo *info)
                 dstA = 0xFF;
                 break;
             case SDL_COPY_ADD:
-                dstR = srcR + dstR; if (dstR > 255) dstR = 255;
-                dstG = srcG + dstG; if (dstG > 255) dstG = 255;
-                dstB = srcB + dstB; if (dstB > 255) dstB = 255;
+                dstR = srcR + dstR; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = srcG + dstG; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = srcB + dstB; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             case SDL_COPY_MOD:
                 dstR = (srcR * dstR) / 255;
@@ -2120,9 +2316,15 @@ static void SDL_Blit_BGR888_ARGB8888_Modulate_Blend(SDL_BlitInfo *info)
                 dstA = srcA + ((255 - srcA) * dstA) / 255;
                 break;
             case SDL_COPY_ADD:
-                dstR = srcR + dstR; if (dstR > 255) dstR = 255;
-                dstG = srcG + dstG; if (dstG > 255) dstG = 255;
-                dstB = srcB + dstB; if (dstB > 255) dstB = 255;
+                dstR = srcR + dstR; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = srcG + dstG; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = srcB + dstB; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             case SDL_COPY_MOD:
                 dstR = (srcR * dstR) / 255;
@@ -2130,10 +2332,18 @@ static void SDL_Blit_BGR888_ARGB8888_Modulate_Blend(SDL_BlitInfo *info)
                 dstB = (srcB * dstB) / 255;
                 break;
             case SDL_COPY_MUL:
-                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) dstR = 255;
-                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) dstG = 255;
-                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) dstB = 255;
-                dstA = ((srcA * dstA) + (dstA * (255 - srcA))) / 255; if (dstA > 255) dstA = 255;
+                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) {
+                    dstB = 255;
+                }
+                dstA = ((srcA * dstA) + (dstA * (255 - srcA))) / 255; if (dstA > 255) {
+                    dstA = 255;
+                }
                 break;
             }
             dstpixel = (dstA << 24) | (dstR << 16) | (dstG << 8) | dstB;
@@ -2201,9 +2411,15 @@ static void SDL_Blit_BGR888_ARGB8888_Modulate_Blend_Scale(SDL_BlitInfo *info)
                 dstA = srcA + ((255 - srcA) * dstA) / 255;
                 break;
             case SDL_COPY_ADD:
-                dstR = srcR + dstR; if (dstR > 255) dstR = 255;
-                dstG = srcG + dstG; if (dstG > 255) dstG = 255;
-                dstB = srcB + dstB; if (dstB > 255) dstB = 255;
+                dstR = srcR + dstR; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = srcG + dstG; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = srcB + dstB; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             case SDL_COPY_MOD:
                 dstR = (srcR * dstR) / 255;
@@ -2211,10 +2427,18 @@ static void SDL_Blit_BGR888_ARGB8888_Modulate_Blend_Scale(SDL_BlitInfo *info)
                 dstB = (srcB * dstB) / 255;
                 break;
             case SDL_COPY_MUL:
-                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) dstR = 255;
-                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) dstG = 255;
-                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) dstB = 255;
-                dstA = ((srcA * dstA) + (dstA * (255 - srcA))) / 255; if (dstA > 255) dstA = 255;
+                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) {
+                    dstB = 255;
+                }
+                dstA = ((srcA * dstA) + (dstA * (255 - srcA))) / 255; if (dstA > 255) {
+                    dstA = 255;
+                }
                 break;
             }
             dstpixel = (dstA << 24) | (dstR << 16) | (dstG << 8) | dstB;
@@ -2291,9 +2515,15 @@ static void SDL_Blit_ARGB8888_RGB888_Blend(SDL_BlitInfo *info)
                 dstB = srcB + ((255 - srcA) * dstB) / 255;
                 break;
             case SDL_COPY_ADD:
-                dstR = srcR + dstR; if (dstR > 255) dstR = 255;
-                dstG = srcG + dstG; if (dstG > 255) dstG = 255;
-                dstB = srcB + dstB; if (dstB > 255) dstB = 255;
+                dstR = srcR + dstR; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = srcG + dstG; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = srcB + dstB; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             case SDL_COPY_MOD:
                 dstR = (srcR * dstR) / 255;
@@ -2301,9 +2531,15 @@ static void SDL_Blit_ARGB8888_RGB888_Blend(SDL_BlitInfo *info)
                 dstB = (srcB * dstB) / 255;
                 break;
             case SDL_COPY_MUL:
-                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) dstR = 255;
-                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) dstG = 255;
-                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) dstB = 255;
+                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             }
             dstpixel = (dstR << 16) | (dstG << 8) | dstB;
@@ -2360,9 +2596,15 @@ static void SDL_Blit_ARGB8888_RGB888_Blend_Scale(SDL_BlitInfo *info)
                 dstB = srcB + ((255 - srcA) * dstB) / 255;
                 break;
             case SDL_COPY_ADD:
-                dstR = srcR + dstR; if (dstR > 255) dstR = 255;
-                dstG = srcG + dstG; if (dstG > 255) dstG = 255;
-                dstB = srcB + dstB; if (dstB > 255) dstB = 255;
+                dstR = srcR + dstR; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = srcG + dstG; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = srcB + dstB; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             case SDL_COPY_MOD:
                 dstR = (srcR * dstR) / 255;
@@ -2370,9 +2612,15 @@ static void SDL_Blit_ARGB8888_RGB888_Blend_Scale(SDL_BlitInfo *info)
                 dstB = (srcB * dstB) / 255;
                 break;
             case SDL_COPY_MUL:
-                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) dstR = 255;
-                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) dstG = 255;
-                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) dstB = 255;
+                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             }
             dstpixel = (dstR << 16) | (dstG << 8) | dstB;
@@ -2503,9 +2751,15 @@ static void SDL_Blit_ARGB8888_RGB888_Modulate_Blend(SDL_BlitInfo *info)
                 dstB = srcB + ((255 - srcA) * dstB) / 255;
                 break;
             case SDL_COPY_ADD:
-                dstR = srcR + dstR; if (dstR > 255) dstR = 255;
-                dstG = srcG + dstG; if (dstG > 255) dstG = 255;
-                dstB = srcB + dstB; if (dstB > 255) dstB = 255;
+                dstR = srcR + dstR; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = srcG + dstG; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = srcB + dstB; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             case SDL_COPY_MOD:
                 dstR = (srcR * dstR) / 255;
@@ -2513,9 +2767,15 @@ static void SDL_Blit_ARGB8888_RGB888_Modulate_Blend(SDL_BlitInfo *info)
                 dstB = (srcB * dstB) / 255;
                 break;
             case SDL_COPY_MUL:
-                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) dstR = 255;
-                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) dstG = 255;
-                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) dstB = 255;
+                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             }
             dstpixel = (dstR << 16) | (dstG << 8) | dstB;
@@ -2584,9 +2844,15 @@ static void SDL_Blit_ARGB8888_RGB888_Modulate_Blend_Scale(SDL_BlitInfo *info)
                 dstB = srcB + ((255 - srcA) * dstB) / 255;
                 break;
             case SDL_COPY_ADD:
-                dstR = srcR + dstR; if (dstR > 255) dstR = 255;
-                dstG = srcG + dstG; if (dstG > 255) dstG = 255;
-                dstB = srcB + dstB; if (dstB > 255) dstB = 255;
+                dstR = srcR + dstR; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = srcG + dstG; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = srcB + dstB; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             case SDL_COPY_MOD:
                 dstR = (srcR * dstR) / 255;
@@ -2594,9 +2860,15 @@ static void SDL_Blit_ARGB8888_RGB888_Modulate_Blend_Scale(SDL_BlitInfo *info)
                 dstB = (srcB * dstB) / 255;
                 break;
             case SDL_COPY_MUL:
-                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) dstR = 255;
-                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) dstG = 255;
-                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) dstB = 255;
+                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             }
             dstpixel = (dstR << 16) | (dstG << 8) | dstB;
@@ -2675,9 +2947,15 @@ static void SDL_Blit_ARGB8888_BGR888_Blend(SDL_BlitInfo *info)
                 dstB = srcB + ((255 - srcA) * dstB) / 255;
                 break;
             case SDL_COPY_ADD:
-                dstR = srcR + dstR; if (dstR > 255) dstR = 255;
-                dstG = srcG + dstG; if (dstG > 255) dstG = 255;
-                dstB = srcB + dstB; if (dstB > 255) dstB = 255;
+                dstR = srcR + dstR; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = srcG + dstG; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = srcB + dstB; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             case SDL_COPY_MOD:
                 dstR = (srcR * dstR) / 255;
@@ -2685,9 +2963,15 @@ static void SDL_Blit_ARGB8888_BGR888_Blend(SDL_BlitInfo *info)
                 dstB = (srcB * dstB) / 255;
                 break;
             case SDL_COPY_MUL:
-                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) dstR = 255;
-                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) dstG = 255;
-                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) dstB = 255;
+                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             }
             dstpixel = (dstB << 16) | (dstG << 8) | dstR;
@@ -2744,9 +3028,15 @@ static void SDL_Blit_ARGB8888_BGR888_Blend_Scale(SDL_BlitInfo *info)
                 dstB = srcB + ((255 - srcA) * dstB) / 255;
                 break;
             case SDL_COPY_ADD:
-                dstR = srcR + dstR; if (dstR > 255) dstR = 255;
-                dstG = srcG + dstG; if (dstG > 255) dstG = 255;
-                dstB = srcB + dstB; if (dstB > 255) dstB = 255;
+                dstR = srcR + dstR; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = srcG + dstG; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = srcB + dstB; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             case SDL_COPY_MOD:
                 dstR = (srcR * dstR) / 255;
@@ -2754,9 +3044,15 @@ static void SDL_Blit_ARGB8888_BGR888_Blend_Scale(SDL_BlitInfo *info)
                 dstB = (srcB * dstB) / 255;
                 break;
             case SDL_COPY_MUL:
-                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) dstR = 255;
-                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) dstG = 255;
-                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) dstB = 255;
+                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             }
             dstpixel = (dstB << 16) | (dstG << 8) | dstR;
@@ -2887,9 +3183,15 @@ static void SDL_Blit_ARGB8888_BGR888_Modulate_Blend(SDL_BlitInfo *info)
                 dstB = srcB + ((255 - srcA) * dstB) / 255;
                 break;
             case SDL_COPY_ADD:
-                dstR = srcR + dstR; if (dstR > 255) dstR = 255;
-                dstG = srcG + dstG; if (dstG > 255) dstG = 255;
-                dstB = srcB + dstB; if (dstB > 255) dstB = 255;
+                dstR = srcR + dstR; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = srcG + dstG; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = srcB + dstB; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             case SDL_COPY_MOD:
                 dstR = (srcR * dstR) / 255;
@@ -2897,9 +3199,15 @@ static void SDL_Blit_ARGB8888_BGR888_Modulate_Blend(SDL_BlitInfo *info)
                 dstB = (srcB * dstB) / 255;
                 break;
             case SDL_COPY_MUL:
-                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) dstR = 255;
-                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) dstG = 255;
-                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) dstB = 255;
+                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             }
             dstpixel = (dstB << 16) | (dstG << 8) | dstR;
@@ -2968,9 +3276,15 @@ static void SDL_Blit_ARGB8888_BGR888_Modulate_Blend_Scale(SDL_BlitInfo *info)
                 dstB = srcB + ((255 - srcA) * dstB) / 255;
                 break;
             case SDL_COPY_ADD:
-                dstR = srcR + dstR; if (dstR > 255) dstR = 255;
-                dstG = srcG + dstG; if (dstG > 255) dstG = 255;
-                dstB = srcB + dstB; if (dstB > 255) dstB = 255;
+                dstR = srcR + dstR; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = srcG + dstG; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = srcB + dstB; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             case SDL_COPY_MOD:
                 dstR = (srcR * dstR) / 255;
@@ -2978,9 +3292,15 @@ static void SDL_Blit_ARGB8888_BGR888_Modulate_Blend_Scale(SDL_BlitInfo *info)
                 dstB = (srcB * dstB) / 255;
                 break;
             case SDL_COPY_MUL:
-                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) dstR = 255;
-                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) dstG = 255;
-                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) dstB = 255;
+                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             }
             dstpixel = (dstB << 16) | (dstG << 8) | dstR;
@@ -3055,9 +3375,15 @@ static void SDL_Blit_ARGB8888_ARGB8888_Blend(SDL_BlitInfo *info)
                 dstA = srcA + ((255 - srcA) * dstA) / 255;
                 break;
             case SDL_COPY_ADD:
-                dstR = srcR + dstR; if (dstR > 255) dstR = 255;
-                dstG = srcG + dstG; if (dstG > 255) dstG = 255;
-                dstB = srcB + dstB; if (dstB > 255) dstB = 255;
+                dstR = srcR + dstR; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = srcG + dstG; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = srcB + dstB; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             case SDL_COPY_MOD:
                 dstR = (srcR * dstR) / 255;
@@ -3065,10 +3391,18 @@ static void SDL_Blit_ARGB8888_ARGB8888_Blend(SDL_BlitInfo *info)
                 dstB = (srcB * dstB) / 255;
                 break;
             case SDL_COPY_MUL:
-                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) dstR = 255;
-                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) dstG = 255;
-                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) dstB = 255;
-                dstA = ((srcA * dstA) + (dstA * (255 - srcA))) / 255; if (dstA > 255) dstA = 255;
+                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) {
+                    dstB = 255;
+                }
+                dstA = ((srcA * dstA) + (dstA * (255 - srcA))) / 255; if (dstA > 255) {
+                    dstA = 255;
+                }
                 break;
             }
             dstpixel = (dstA << 24) | (dstR << 16) | (dstG << 8) | dstB;
@@ -3126,9 +3460,15 @@ static void SDL_Blit_ARGB8888_ARGB8888_Blend_Scale(SDL_BlitInfo *info)
                 dstA = srcA + ((255 - srcA) * dstA) / 255;
                 break;
             case SDL_COPY_ADD:
-                dstR = srcR + dstR; if (dstR > 255) dstR = 255;
-                dstG = srcG + dstG; if (dstG > 255) dstG = 255;
-                dstB = srcB + dstB; if (dstB > 255) dstB = 255;
+                dstR = srcR + dstR; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = srcG + dstG; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = srcB + dstB; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             case SDL_COPY_MOD:
                 dstR = (srcR * dstR) / 255;
@@ -3136,10 +3476,18 @@ static void SDL_Blit_ARGB8888_ARGB8888_Blend_Scale(SDL_BlitInfo *info)
                 dstB = (srcB * dstB) / 255;
                 break;
             case SDL_COPY_MUL:
-                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) dstR = 255;
-                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) dstG = 255;
-                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) dstB = 255;
-                dstA = ((srcA * dstA) + (dstA * (255 - srcA))) / 255; if (dstA > 255) dstA = 255;
+                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) {
+                    dstB = 255;
+                }
+                dstA = ((srcA * dstA) + (dstA * (255 - srcA))) / 255; if (dstA > 255) {
+                    dstA = 255;
+                }
                 break;
             }
             dstpixel = (dstA << 24) | (dstR << 16) | (dstG << 8) | dstB;
@@ -3279,9 +3627,15 @@ static void SDL_Blit_ARGB8888_ARGB8888_Modulate_Blend(SDL_BlitInfo *info)
                 dstA = srcA + ((255 - srcA) * dstA) / 255;
                 break;
             case SDL_COPY_ADD:
-                dstR = srcR + dstR; if (dstR > 255) dstR = 255;
-                dstG = srcG + dstG; if (dstG > 255) dstG = 255;
-                dstB = srcB + dstB; if (dstB > 255) dstB = 255;
+                dstR = srcR + dstR; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = srcG + dstG; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = srcB + dstB; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             case SDL_COPY_MOD:
                 dstR = (srcR * dstR) / 255;
@@ -3289,10 +3643,18 @@ static void SDL_Blit_ARGB8888_ARGB8888_Modulate_Blend(SDL_BlitInfo *info)
                 dstB = (srcB * dstB) / 255;
                 break;
             case SDL_COPY_MUL:
-                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) dstR = 255;
-                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) dstG = 255;
-                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) dstB = 255;
-                dstA = ((srcA * dstA) + (dstA * (255 - srcA))) / 255; if (dstA > 255) dstA = 255;
+                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) {
+                    dstB = 255;
+                }
+                dstA = ((srcA * dstA) + (dstA * (255 - srcA))) / 255; if (dstA > 255) {
+                    dstA = 255;
+                }
                 break;
             }
             dstpixel = (dstA << 24) | (dstR << 16) | (dstG << 8) | dstB;
@@ -3362,9 +3724,15 @@ static void SDL_Blit_ARGB8888_ARGB8888_Modulate_Blend_Scale(SDL_BlitInfo *info)
                 dstA = srcA + ((255 - srcA) * dstA) / 255;
                 break;
             case SDL_COPY_ADD:
-                dstR = srcR + dstR; if (dstR > 255) dstR = 255;
-                dstG = srcG + dstG; if (dstG > 255) dstG = 255;
-                dstB = srcB + dstB; if (dstB > 255) dstB = 255;
+                dstR = srcR + dstR; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = srcG + dstG; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = srcB + dstB; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             case SDL_COPY_MOD:
                 dstR = (srcR * dstR) / 255;
@@ -3372,10 +3740,18 @@ static void SDL_Blit_ARGB8888_ARGB8888_Modulate_Blend_Scale(SDL_BlitInfo *info)
                 dstB = (srcB * dstB) / 255;
                 break;
             case SDL_COPY_MUL:
-                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) dstR = 255;
-                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) dstG = 255;
-                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) dstB = 255;
-                dstA = ((srcA * dstA) + (dstA * (255 - srcA))) / 255; if (dstA > 255) dstA = 255;
+                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) {
+                    dstB = 255;
+                }
+                dstA = ((srcA * dstA) + (dstA * (255 - srcA))) / 255; if (dstA > 255) {
+                    dstA = 255;
+                }
                 break;
             }
             dstpixel = (dstA << 24) | (dstR << 16) | (dstG << 8) | dstB;
@@ -3452,9 +3828,15 @@ static void SDL_Blit_RGBA8888_RGB888_Blend(SDL_BlitInfo *info)
                 dstB = srcB + ((255 - srcA) * dstB) / 255;
                 break;
             case SDL_COPY_ADD:
-                dstR = srcR + dstR; if (dstR > 255) dstR = 255;
-                dstG = srcG + dstG; if (dstG > 255) dstG = 255;
-                dstB = srcB + dstB; if (dstB > 255) dstB = 255;
+                dstR = srcR + dstR; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = srcG + dstG; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = srcB + dstB; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             case SDL_COPY_MOD:
                 dstR = (srcR * dstR) / 255;
@@ -3462,9 +3844,15 @@ static void SDL_Blit_RGBA8888_RGB888_Blend(SDL_BlitInfo *info)
                 dstB = (srcB * dstB) / 255;
                 break;
             case SDL_COPY_MUL:
-                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) dstR = 255;
-                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) dstG = 255;
-                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) dstB = 255;
+                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             }
             dstpixel = (dstR << 16) | (dstG << 8) | dstB;
@@ -3521,9 +3909,15 @@ static void SDL_Blit_RGBA8888_RGB888_Blend_Scale(SDL_BlitInfo *info)
                 dstB = srcB + ((255 - srcA) * dstB) / 255;
                 break;
             case SDL_COPY_ADD:
-                dstR = srcR + dstR; if (dstR > 255) dstR = 255;
-                dstG = srcG + dstG; if (dstG > 255) dstG = 255;
-                dstB = srcB + dstB; if (dstB > 255) dstB = 255;
+                dstR = srcR + dstR; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = srcG + dstG; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = srcB + dstB; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             case SDL_COPY_MOD:
                 dstR = (srcR * dstR) / 255;
@@ -3531,9 +3925,15 @@ static void SDL_Blit_RGBA8888_RGB888_Blend_Scale(SDL_BlitInfo *info)
                 dstB = (srcB * dstB) / 255;
                 break;
             case SDL_COPY_MUL:
-                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) dstR = 255;
-                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) dstG = 255;
-                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) dstB = 255;
+                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             }
             dstpixel = (dstR << 16) | (dstG << 8) | dstB;
@@ -3664,9 +4064,15 @@ static void SDL_Blit_RGBA8888_RGB888_Modulate_Blend(SDL_BlitInfo *info)
                 dstB = srcB + ((255 - srcA) * dstB) / 255;
                 break;
             case SDL_COPY_ADD:
-                dstR = srcR + dstR; if (dstR > 255) dstR = 255;
-                dstG = srcG + dstG; if (dstG > 255) dstG = 255;
-                dstB = srcB + dstB; if (dstB > 255) dstB = 255;
+                dstR = srcR + dstR; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = srcG + dstG; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = srcB + dstB; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             case SDL_COPY_MOD:
                 dstR = (srcR * dstR) / 255;
@@ -3674,9 +4080,15 @@ static void SDL_Blit_RGBA8888_RGB888_Modulate_Blend(SDL_BlitInfo *info)
                 dstB = (srcB * dstB) / 255;
                 break;
             case SDL_COPY_MUL:
-                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) dstR = 255;
-                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) dstG = 255;
-                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) dstB = 255;
+                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             }
             dstpixel = (dstR << 16) | (dstG << 8) | dstB;
@@ -3745,9 +4157,15 @@ static void SDL_Blit_RGBA8888_RGB888_Modulate_Blend_Scale(SDL_BlitInfo *info)
                 dstB = srcB + ((255 - srcA) * dstB) / 255;
                 break;
             case SDL_COPY_ADD:
-                dstR = srcR + dstR; if (dstR > 255) dstR = 255;
-                dstG = srcG + dstG; if (dstG > 255) dstG = 255;
-                dstB = srcB + dstB; if (dstB > 255) dstB = 255;
+                dstR = srcR + dstR; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = srcG + dstG; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = srcB + dstB; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             case SDL_COPY_MOD:
                 dstR = (srcR * dstR) / 255;
@@ -3755,9 +4173,15 @@ static void SDL_Blit_RGBA8888_RGB888_Modulate_Blend_Scale(SDL_BlitInfo *info)
                 dstB = (srcB * dstB) / 255;
                 break;
             case SDL_COPY_MUL:
-                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) dstR = 255;
-                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) dstG = 255;
-                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) dstB = 255;
+                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             }
             dstpixel = (dstR << 16) | (dstG << 8) | dstB;
@@ -3836,9 +4260,15 @@ static void SDL_Blit_RGBA8888_BGR888_Blend(SDL_BlitInfo *info)
                 dstB = srcB + ((255 - srcA) * dstB) / 255;
                 break;
             case SDL_COPY_ADD:
-                dstR = srcR + dstR; if (dstR > 255) dstR = 255;
-                dstG = srcG + dstG; if (dstG > 255) dstG = 255;
-                dstB = srcB + dstB; if (dstB > 255) dstB = 255;
+                dstR = srcR + dstR; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = srcG + dstG; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = srcB + dstB; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             case SDL_COPY_MOD:
                 dstR = (srcR * dstR) / 255;
@@ -3846,9 +4276,15 @@ static void SDL_Blit_RGBA8888_BGR888_Blend(SDL_BlitInfo *info)
                 dstB = (srcB * dstB) / 255;
                 break;
             case SDL_COPY_MUL:
-                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) dstR = 255;
-                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) dstG = 255;
-                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) dstB = 255;
+                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             }
             dstpixel = (dstB << 16) | (dstG << 8) | dstR;
@@ -3905,9 +4341,15 @@ static void SDL_Blit_RGBA8888_BGR888_Blend_Scale(SDL_BlitInfo *info)
                 dstB = srcB + ((255 - srcA) * dstB) / 255;
                 break;
             case SDL_COPY_ADD:
-                dstR = srcR + dstR; if (dstR > 255) dstR = 255;
-                dstG = srcG + dstG; if (dstG > 255) dstG = 255;
-                dstB = srcB + dstB; if (dstB > 255) dstB = 255;
+                dstR = srcR + dstR; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = srcG + dstG; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = srcB + dstB; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             case SDL_COPY_MOD:
                 dstR = (srcR * dstR) / 255;
@@ -3915,9 +4357,15 @@ static void SDL_Blit_RGBA8888_BGR888_Blend_Scale(SDL_BlitInfo *info)
                 dstB = (srcB * dstB) / 255;
                 break;
             case SDL_COPY_MUL:
-                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) dstR = 255;
-                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) dstG = 255;
-                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) dstB = 255;
+                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             }
             dstpixel = (dstB << 16) | (dstG << 8) | dstR;
@@ -4048,9 +4496,15 @@ static void SDL_Blit_RGBA8888_BGR888_Modulate_Blend(SDL_BlitInfo *info)
                 dstB = srcB + ((255 - srcA) * dstB) / 255;
                 break;
             case SDL_COPY_ADD:
-                dstR = srcR + dstR; if (dstR > 255) dstR = 255;
-                dstG = srcG + dstG; if (dstG > 255) dstG = 255;
-                dstB = srcB + dstB; if (dstB > 255) dstB = 255;
+                dstR = srcR + dstR; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = srcG + dstG; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = srcB + dstB; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             case SDL_COPY_MOD:
                 dstR = (srcR * dstR) / 255;
@@ -4058,9 +4512,15 @@ static void SDL_Blit_RGBA8888_BGR888_Modulate_Blend(SDL_BlitInfo *info)
                 dstB = (srcB * dstB) / 255;
                 break;
             case SDL_COPY_MUL:
-                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) dstR = 255;
-                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) dstG = 255;
-                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) dstB = 255;
+                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             }
             dstpixel = (dstB << 16) | (dstG << 8) | dstR;
@@ -4129,9 +4589,15 @@ static void SDL_Blit_RGBA8888_BGR888_Modulate_Blend_Scale(SDL_BlitInfo *info)
                 dstB = srcB + ((255 - srcA) * dstB) / 255;
                 break;
             case SDL_COPY_ADD:
-                dstR = srcR + dstR; if (dstR > 255) dstR = 255;
-                dstG = srcG + dstG; if (dstG > 255) dstG = 255;
-                dstB = srcB + dstB; if (dstB > 255) dstB = 255;
+                dstR = srcR + dstR; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = srcG + dstG; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = srcB + dstB; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             case SDL_COPY_MOD:
                 dstR = (srcR * dstR) / 255;
@@ -4139,9 +4605,15 @@ static void SDL_Blit_RGBA8888_BGR888_Modulate_Blend_Scale(SDL_BlitInfo *info)
                 dstB = (srcB * dstB) / 255;
                 break;
             case SDL_COPY_MUL:
-                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) dstR = 255;
-                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) dstG = 255;
-                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) dstB = 255;
+                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             }
             dstpixel = (dstB << 16) | (dstG << 8) | dstR;
@@ -4219,9 +4691,15 @@ static void SDL_Blit_RGBA8888_ARGB8888_Blend(SDL_BlitInfo *info)
                 dstA = srcA + ((255 - srcA) * dstA) / 255;
                 break;
             case SDL_COPY_ADD:
-                dstR = srcR + dstR; if (dstR > 255) dstR = 255;
-                dstG = srcG + dstG; if (dstG > 255) dstG = 255;
-                dstB = srcB + dstB; if (dstB > 255) dstB = 255;
+                dstR = srcR + dstR; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = srcG + dstG; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = srcB + dstB; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             case SDL_COPY_MOD:
                 dstR = (srcR * dstR) / 255;
@@ -4229,10 +4707,18 @@ static void SDL_Blit_RGBA8888_ARGB8888_Blend(SDL_BlitInfo *info)
                 dstB = (srcB * dstB) / 255;
                 break;
             case SDL_COPY_MUL:
-                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) dstR = 255;
-                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) dstG = 255;
-                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) dstB = 255;
-                dstA = ((srcA * dstA) + (dstA * (255 - srcA))) / 255; if (dstA > 255) dstA = 255;
+                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) {
+                    dstB = 255;
+                }
+                dstA = ((srcA * dstA) + (dstA * (255 - srcA))) / 255; if (dstA > 255) {
+                    dstA = 255;
+                }
                 break;
             }
             dstpixel = (dstA << 24) | (dstR << 16) | (dstG << 8) | dstB;
@@ -4290,9 +4776,15 @@ static void SDL_Blit_RGBA8888_ARGB8888_Blend_Scale(SDL_BlitInfo *info)
                 dstA = srcA + ((255 - srcA) * dstA) / 255;
                 break;
             case SDL_COPY_ADD:
-                dstR = srcR + dstR; if (dstR > 255) dstR = 255;
-                dstG = srcG + dstG; if (dstG > 255) dstG = 255;
-                dstB = srcB + dstB; if (dstB > 255) dstB = 255;
+                dstR = srcR + dstR; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = srcG + dstG; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = srcB + dstB; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             case SDL_COPY_MOD:
                 dstR = (srcR * dstR) / 255;
@@ -4300,10 +4792,18 @@ static void SDL_Blit_RGBA8888_ARGB8888_Blend_Scale(SDL_BlitInfo *info)
                 dstB = (srcB * dstB) / 255;
                 break;
             case SDL_COPY_MUL:
-                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) dstR = 255;
-                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) dstG = 255;
-                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) dstB = 255;
-                dstA = ((srcA * dstA) + (dstA * (255 - srcA))) / 255; if (dstA > 255) dstA = 255;
+                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) {
+                    dstB = 255;
+                }
+                dstA = ((srcA * dstA) + (dstA * (255 - srcA))) / 255; if (dstA > 255) {
+                    dstA = 255;
+                }
                 break;
             }
             dstpixel = (dstA << 24) | (dstR << 16) | (dstG << 8) | dstB;
@@ -4443,9 +4943,15 @@ static void SDL_Blit_RGBA8888_ARGB8888_Modulate_Blend(SDL_BlitInfo *info)
                 dstA = srcA + ((255 - srcA) * dstA) / 255;
                 break;
             case SDL_COPY_ADD:
-                dstR = srcR + dstR; if (dstR > 255) dstR = 255;
-                dstG = srcG + dstG; if (dstG > 255) dstG = 255;
-                dstB = srcB + dstB; if (dstB > 255) dstB = 255;
+                dstR = srcR + dstR; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = srcG + dstG; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = srcB + dstB; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             case SDL_COPY_MOD:
                 dstR = (srcR * dstR) / 255;
@@ -4453,10 +4959,18 @@ static void SDL_Blit_RGBA8888_ARGB8888_Modulate_Blend(SDL_BlitInfo *info)
                 dstB = (srcB * dstB) / 255;
                 break;
             case SDL_COPY_MUL:
-                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) dstR = 255;
-                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) dstG = 255;
-                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) dstB = 255;
-                dstA = ((srcA * dstA) + (dstA * (255 - srcA))) / 255; if (dstA > 255) dstA = 255;
+                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) {
+                    dstB = 255;
+                }
+                dstA = ((srcA * dstA) + (dstA * (255 - srcA))) / 255; if (dstA > 255) {
+                    dstA = 255;
+                }
                 break;
             }
             dstpixel = (dstA << 24) | (dstR << 16) | (dstG << 8) | dstB;
@@ -4526,9 +5040,15 @@ static void SDL_Blit_RGBA8888_ARGB8888_Modulate_Blend_Scale(SDL_BlitInfo *info)
                 dstA = srcA + ((255 - srcA) * dstA) / 255;
                 break;
             case SDL_COPY_ADD:
-                dstR = srcR + dstR; if (dstR > 255) dstR = 255;
-                dstG = srcG + dstG; if (dstG > 255) dstG = 255;
-                dstB = srcB + dstB; if (dstB > 255) dstB = 255;
+                dstR = srcR + dstR; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = srcG + dstG; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = srcB + dstB; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             case SDL_COPY_MOD:
                 dstR = (srcR * dstR) / 255;
@@ -4536,10 +5056,18 @@ static void SDL_Blit_RGBA8888_ARGB8888_Modulate_Blend_Scale(SDL_BlitInfo *info)
                 dstB = (srcB * dstB) / 255;
                 break;
             case SDL_COPY_MUL:
-                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) dstR = 255;
-                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) dstG = 255;
-                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) dstB = 255;
-                dstA = ((srcA * dstA) + (dstA * (255 - srcA))) / 255; if (dstA > 255) dstA = 255;
+                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) {
+                    dstB = 255;
+                }
+                dstA = ((srcA * dstA) + (dstA * (255 - srcA))) / 255; if (dstA > 255) {
+                    dstA = 255;
+                }
                 break;
             }
             dstpixel = (dstA << 24) | (dstR << 16) | (dstG << 8) | dstB;
@@ -4618,9 +5146,15 @@ static void SDL_Blit_ABGR8888_RGB888_Blend(SDL_BlitInfo *info)
                 dstB = srcB + ((255 - srcA) * dstB) / 255;
                 break;
             case SDL_COPY_ADD:
-                dstR = srcR + dstR; if (dstR > 255) dstR = 255;
-                dstG = srcG + dstG; if (dstG > 255) dstG = 255;
-                dstB = srcB + dstB; if (dstB > 255) dstB = 255;
+                dstR = srcR + dstR; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = srcG + dstG; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = srcB + dstB; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             case SDL_COPY_MOD:
                 dstR = (srcR * dstR) / 255;
@@ -4628,9 +5162,15 @@ static void SDL_Blit_ABGR8888_RGB888_Blend(SDL_BlitInfo *info)
                 dstB = (srcB * dstB) / 255;
                 break;
             case SDL_COPY_MUL:
-                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) dstR = 255;
-                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) dstG = 255;
-                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) dstB = 255;
+                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             }
             dstpixel = (dstR << 16) | (dstG << 8) | dstB;
@@ -4687,9 +5227,15 @@ static void SDL_Blit_ABGR8888_RGB888_Blend_Scale(SDL_BlitInfo *info)
                 dstB = srcB + ((255 - srcA) * dstB) / 255;
                 break;
             case SDL_COPY_ADD:
-                dstR = srcR + dstR; if (dstR > 255) dstR = 255;
-                dstG = srcG + dstG; if (dstG > 255) dstG = 255;
-                dstB = srcB + dstB; if (dstB > 255) dstB = 255;
+                dstR = srcR + dstR; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = srcG + dstG; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = srcB + dstB; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             case SDL_COPY_MOD:
                 dstR = (srcR * dstR) / 255;
@@ -4697,9 +5243,15 @@ static void SDL_Blit_ABGR8888_RGB888_Blend_Scale(SDL_BlitInfo *info)
                 dstB = (srcB * dstB) / 255;
                 break;
             case SDL_COPY_MUL:
-                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) dstR = 255;
-                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) dstG = 255;
-                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) dstB = 255;
+                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             }
             dstpixel = (dstR << 16) | (dstG << 8) | dstB;
@@ -4830,9 +5382,15 @@ static void SDL_Blit_ABGR8888_RGB888_Modulate_Blend(SDL_BlitInfo *info)
                 dstB = srcB + ((255 - srcA) * dstB) / 255;
                 break;
             case SDL_COPY_ADD:
-                dstR = srcR + dstR; if (dstR > 255) dstR = 255;
-                dstG = srcG + dstG; if (dstG > 255) dstG = 255;
-                dstB = srcB + dstB; if (dstB > 255) dstB = 255;
+                dstR = srcR + dstR; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = srcG + dstG; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = srcB + dstB; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             case SDL_COPY_MOD:
                 dstR = (srcR * dstR) / 255;
@@ -4840,9 +5398,15 @@ static void SDL_Blit_ABGR8888_RGB888_Modulate_Blend(SDL_BlitInfo *info)
                 dstB = (srcB * dstB) / 255;
                 break;
             case SDL_COPY_MUL:
-                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) dstR = 255;
-                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) dstG = 255;
-                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) dstB = 255;
+                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             }
             dstpixel = (dstR << 16) | (dstG << 8) | dstB;
@@ -4911,9 +5475,15 @@ static void SDL_Blit_ABGR8888_RGB888_Modulate_Blend_Scale(SDL_BlitInfo *info)
                 dstB = srcB + ((255 - srcA) * dstB) / 255;
                 break;
             case SDL_COPY_ADD:
-                dstR = srcR + dstR; if (dstR > 255) dstR = 255;
-                dstG = srcG + dstG; if (dstG > 255) dstG = 255;
-                dstB = srcB + dstB; if (dstB > 255) dstB = 255;
+                dstR = srcR + dstR; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = srcG + dstG; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = srcB + dstB; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             case SDL_COPY_MOD:
                 dstR = (srcR * dstR) / 255;
@@ -4921,9 +5491,15 @@ static void SDL_Blit_ABGR8888_RGB888_Modulate_Blend_Scale(SDL_BlitInfo *info)
                 dstB = (srcB * dstB) / 255;
                 break;
             case SDL_COPY_MUL:
-                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) dstR = 255;
-                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) dstG = 255;
-                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) dstB = 255;
+                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             }
             dstpixel = (dstR << 16) | (dstG << 8) | dstB;
@@ -5000,9 +5576,15 @@ static void SDL_Blit_ABGR8888_BGR888_Blend(SDL_BlitInfo *info)
                 dstB = srcB + ((255 - srcA) * dstB) / 255;
                 break;
             case SDL_COPY_ADD:
-                dstR = srcR + dstR; if (dstR > 255) dstR = 255;
-                dstG = srcG + dstG; if (dstG > 255) dstG = 255;
-                dstB = srcB + dstB; if (dstB > 255) dstB = 255;
+                dstR = srcR + dstR; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = srcG + dstG; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = srcB + dstB; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             case SDL_COPY_MOD:
                 dstR = (srcR * dstR) / 255;
@@ -5010,9 +5592,15 @@ static void SDL_Blit_ABGR8888_BGR888_Blend(SDL_BlitInfo *info)
                 dstB = (srcB * dstB) / 255;
                 break;
             case SDL_COPY_MUL:
-                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) dstR = 255;
-                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) dstG = 255;
-                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) dstB = 255;
+                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             }
             dstpixel = (dstB << 16) | (dstG << 8) | dstR;
@@ -5069,9 +5657,15 @@ static void SDL_Blit_ABGR8888_BGR888_Blend_Scale(SDL_BlitInfo *info)
                 dstB = srcB + ((255 - srcA) * dstB) / 255;
                 break;
             case SDL_COPY_ADD:
-                dstR = srcR + dstR; if (dstR > 255) dstR = 255;
-                dstG = srcG + dstG; if (dstG > 255) dstG = 255;
-                dstB = srcB + dstB; if (dstB > 255) dstB = 255;
+                dstR = srcR + dstR; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = srcG + dstG; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = srcB + dstB; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             case SDL_COPY_MOD:
                 dstR = (srcR * dstR) / 255;
@@ -5079,9 +5673,15 @@ static void SDL_Blit_ABGR8888_BGR888_Blend_Scale(SDL_BlitInfo *info)
                 dstB = (srcB * dstB) / 255;
                 break;
             case SDL_COPY_MUL:
-                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) dstR = 255;
-                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) dstG = 255;
-                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) dstB = 255;
+                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             }
             dstpixel = (dstB << 16) | (dstG << 8) | dstR;
@@ -5212,9 +5812,15 @@ static void SDL_Blit_ABGR8888_BGR888_Modulate_Blend(SDL_BlitInfo *info)
                 dstB = srcB + ((255 - srcA) * dstB) / 255;
                 break;
             case SDL_COPY_ADD:
-                dstR = srcR + dstR; if (dstR > 255) dstR = 255;
-                dstG = srcG + dstG; if (dstG > 255) dstG = 255;
-                dstB = srcB + dstB; if (dstB > 255) dstB = 255;
+                dstR = srcR + dstR; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = srcG + dstG; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = srcB + dstB; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             case SDL_COPY_MOD:
                 dstR = (srcR * dstR) / 255;
@@ -5222,9 +5828,15 @@ static void SDL_Blit_ABGR8888_BGR888_Modulate_Blend(SDL_BlitInfo *info)
                 dstB = (srcB * dstB) / 255;
                 break;
             case SDL_COPY_MUL:
-                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) dstR = 255;
-                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) dstG = 255;
-                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) dstB = 255;
+                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             }
             dstpixel = (dstB << 16) | (dstG << 8) | dstR;
@@ -5293,9 +5905,15 @@ static void SDL_Blit_ABGR8888_BGR888_Modulate_Blend_Scale(SDL_BlitInfo *info)
                 dstB = srcB + ((255 - srcA) * dstB) / 255;
                 break;
             case SDL_COPY_ADD:
-                dstR = srcR + dstR; if (dstR > 255) dstR = 255;
-                dstG = srcG + dstG; if (dstG > 255) dstG = 255;
-                dstB = srcB + dstB; if (dstB > 255) dstB = 255;
+                dstR = srcR + dstR; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = srcG + dstG; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = srcB + dstB; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             case SDL_COPY_MOD:
                 dstR = (srcR * dstR) / 255;
@@ -5303,9 +5921,15 @@ static void SDL_Blit_ABGR8888_BGR888_Modulate_Blend_Scale(SDL_BlitInfo *info)
                 dstB = (srcB * dstB) / 255;
                 break;
             case SDL_COPY_MUL:
-                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) dstR = 255;
-                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) dstG = 255;
-                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) dstB = 255;
+                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             }
             dstpixel = (dstB << 16) | (dstG << 8) | dstR;
@@ -5385,9 +6009,15 @@ static void SDL_Blit_ABGR8888_ARGB8888_Blend(SDL_BlitInfo *info)
                 dstA = srcA + ((255 - srcA) * dstA) / 255;
                 break;
             case SDL_COPY_ADD:
-                dstR = srcR + dstR; if (dstR > 255) dstR = 255;
-                dstG = srcG + dstG; if (dstG > 255) dstG = 255;
-                dstB = srcB + dstB; if (dstB > 255) dstB = 255;
+                dstR = srcR + dstR; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = srcG + dstG; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = srcB + dstB; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             case SDL_COPY_MOD:
                 dstR = (srcR * dstR) / 255;
@@ -5395,10 +6025,18 @@ static void SDL_Blit_ABGR8888_ARGB8888_Blend(SDL_BlitInfo *info)
                 dstB = (srcB * dstB) / 255;
                 break;
             case SDL_COPY_MUL:
-                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) dstR = 255;
-                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) dstG = 255;
-                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) dstB = 255;
-                dstA = ((srcA * dstA) + (dstA * (255 - srcA))) / 255; if (dstA > 255) dstA = 255;
+                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) {
+                    dstB = 255;
+                }
+                dstA = ((srcA * dstA) + (dstA * (255 - srcA))) / 255; if (dstA > 255) {
+                    dstA = 255;
+                }
                 break;
             }
             dstpixel = (dstA << 24) | (dstR << 16) | (dstG << 8) | dstB;
@@ -5456,9 +6094,15 @@ static void SDL_Blit_ABGR8888_ARGB8888_Blend_Scale(SDL_BlitInfo *info)
                 dstA = srcA + ((255 - srcA) * dstA) / 255;
                 break;
             case SDL_COPY_ADD:
-                dstR = srcR + dstR; if (dstR > 255) dstR = 255;
-                dstG = srcG + dstG; if (dstG > 255) dstG = 255;
-                dstB = srcB + dstB; if (dstB > 255) dstB = 255;
+                dstR = srcR + dstR; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = srcG + dstG; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = srcB + dstB; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             case SDL_COPY_MOD:
                 dstR = (srcR * dstR) / 255;
@@ -5466,10 +6110,18 @@ static void SDL_Blit_ABGR8888_ARGB8888_Blend_Scale(SDL_BlitInfo *info)
                 dstB = (srcB * dstB) / 255;
                 break;
             case SDL_COPY_MUL:
-                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) dstR = 255;
-                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) dstG = 255;
-                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) dstB = 255;
-                dstA = ((srcA * dstA) + (dstA * (255 - srcA))) / 255; if (dstA > 255) dstA = 255;
+                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) {
+                    dstB = 255;
+                }
+                dstA = ((srcA * dstA) + (dstA * (255 - srcA))) / 255; if (dstA > 255) {
+                    dstA = 255;
+                }
                 break;
             }
             dstpixel = (dstA << 24) | (dstR << 16) | (dstG << 8) | dstB;
@@ -5609,9 +6261,15 @@ static void SDL_Blit_ABGR8888_ARGB8888_Modulate_Blend(SDL_BlitInfo *info)
                 dstA = srcA + ((255 - srcA) * dstA) / 255;
                 break;
             case SDL_COPY_ADD:
-                dstR = srcR + dstR; if (dstR > 255) dstR = 255;
-                dstG = srcG + dstG; if (dstG > 255) dstG = 255;
-                dstB = srcB + dstB; if (dstB > 255) dstB = 255;
+                dstR = srcR + dstR; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = srcG + dstG; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = srcB + dstB; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             case SDL_COPY_MOD:
                 dstR = (srcR * dstR) / 255;
@@ -5619,10 +6277,18 @@ static void SDL_Blit_ABGR8888_ARGB8888_Modulate_Blend(SDL_BlitInfo *info)
                 dstB = (srcB * dstB) / 255;
                 break;
             case SDL_COPY_MUL:
-                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) dstR = 255;
-                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) dstG = 255;
-                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) dstB = 255;
-                dstA = ((srcA * dstA) + (dstA * (255 - srcA))) / 255; if (dstA > 255) dstA = 255;
+                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) {
+                    dstB = 255;
+                }
+                dstA = ((srcA * dstA) + (dstA * (255 - srcA))) / 255; if (dstA > 255) {
+                    dstA = 255;
+                }
                 break;
             }
             dstpixel = (dstA << 24) | (dstR << 16) | (dstG << 8) | dstB;
@@ -5692,9 +6358,15 @@ static void SDL_Blit_ABGR8888_ARGB8888_Modulate_Blend_Scale(SDL_BlitInfo *info)
                 dstA = srcA + ((255 - srcA) * dstA) / 255;
                 break;
             case SDL_COPY_ADD:
-                dstR = srcR + dstR; if (dstR > 255) dstR = 255;
-                dstG = srcG + dstG; if (dstG > 255) dstG = 255;
-                dstB = srcB + dstB; if (dstB > 255) dstB = 255;
+                dstR = srcR + dstR; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = srcG + dstG; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = srcB + dstB; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             case SDL_COPY_MOD:
                 dstR = (srcR * dstR) / 255;
@@ -5702,10 +6374,18 @@ static void SDL_Blit_ABGR8888_ARGB8888_Modulate_Blend_Scale(SDL_BlitInfo *info)
                 dstB = (srcB * dstB) / 255;
                 break;
             case SDL_COPY_MUL:
-                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) dstR = 255;
-                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) dstG = 255;
-                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) dstB = 255;
-                dstA = ((srcA * dstA) + (dstA * (255 - srcA))) / 255; if (dstA > 255) dstA = 255;
+                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) {
+                    dstB = 255;
+                }
+                dstA = ((srcA * dstA) + (dstA * (255 - srcA))) / 255; if (dstA > 255) {
+                    dstA = 255;
+                }
                 break;
             }
             dstpixel = (dstA << 24) | (dstR << 16) | (dstG << 8) | dstB;
@@ -5784,9 +6464,15 @@ static void SDL_Blit_BGRA8888_RGB888_Blend(SDL_BlitInfo *info)
                 dstB = srcB + ((255 - srcA) * dstB) / 255;
                 break;
             case SDL_COPY_ADD:
-                dstR = srcR + dstR; if (dstR > 255) dstR = 255;
-                dstG = srcG + dstG; if (dstG > 255) dstG = 255;
-                dstB = srcB + dstB; if (dstB > 255) dstB = 255;
+                dstR = srcR + dstR; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = srcG + dstG; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = srcB + dstB; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             case SDL_COPY_MOD:
                 dstR = (srcR * dstR) / 255;
@@ -5794,9 +6480,15 @@ static void SDL_Blit_BGRA8888_RGB888_Blend(SDL_BlitInfo *info)
                 dstB = (srcB * dstB) / 255;
                 break;
             case SDL_COPY_MUL:
-                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) dstR = 255;
-                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) dstG = 255;
-                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) dstB = 255;
+                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             }
             dstpixel = (dstR << 16) | (dstG << 8) | dstB;
@@ -5853,9 +6545,15 @@ static void SDL_Blit_BGRA8888_RGB888_Blend_Scale(SDL_BlitInfo *info)
                 dstB = srcB + ((255 - srcA) * dstB) / 255;
                 break;
             case SDL_COPY_ADD:
-                dstR = srcR + dstR; if (dstR > 255) dstR = 255;
-                dstG = srcG + dstG; if (dstG > 255) dstG = 255;
-                dstB = srcB + dstB; if (dstB > 255) dstB = 255;
+                dstR = srcR + dstR; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = srcG + dstG; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = srcB + dstB; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             case SDL_COPY_MOD:
                 dstR = (srcR * dstR) / 255;
@@ -5863,9 +6561,15 @@ static void SDL_Blit_BGRA8888_RGB888_Blend_Scale(SDL_BlitInfo *info)
                 dstB = (srcB * dstB) / 255;
                 break;
             case SDL_COPY_MUL:
-                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) dstR = 255;
-                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) dstG = 255;
-                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) dstB = 255;
+                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             }
             dstpixel = (dstR << 16) | (dstG << 8) | dstB;
@@ -5996,9 +6700,15 @@ static void SDL_Blit_BGRA8888_RGB888_Modulate_Blend(SDL_BlitInfo *info)
                 dstB = srcB + ((255 - srcA) * dstB) / 255;
                 break;
             case SDL_COPY_ADD:
-                dstR = srcR + dstR; if (dstR > 255) dstR = 255;
-                dstG = srcG + dstG; if (dstG > 255) dstG = 255;
-                dstB = srcB + dstB; if (dstB > 255) dstB = 255;
+                dstR = srcR + dstR; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = srcG + dstG; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = srcB + dstB; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             case SDL_COPY_MOD:
                 dstR = (srcR * dstR) / 255;
@@ -6006,9 +6716,15 @@ static void SDL_Blit_BGRA8888_RGB888_Modulate_Blend(SDL_BlitInfo *info)
                 dstB = (srcB * dstB) / 255;
                 break;
             case SDL_COPY_MUL:
-                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) dstR = 255;
-                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) dstG = 255;
-                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) dstB = 255;
+                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             }
             dstpixel = (dstR << 16) | (dstG << 8) | dstB;
@@ -6077,9 +6793,15 @@ static void SDL_Blit_BGRA8888_RGB888_Modulate_Blend_Scale(SDL_BlitInfo *info)
                 dstB = srcB + ((255 - srcA) * dstB) / 255;
                 break;
             case SDL_COPY_ADD:
-                dstR = srcR + dstR; if (dstR > 255) dstR = 255;
-                dstG = srcG + dstG; if (dstG > 255) dstG = 255;
-                dstB = srcB + dstB; if (dstB > 255) dstB = 255;
+                dstR = srcR + dstR; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = srcG + dstG; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = srcB + dstB; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             case SDL_COPY_MOD:
                 dstR = (srcR * dstR) / 255;
@@ -6087,9 +6809,15 @@ static void SDL_Blit_BGRA8888_RGB888_Modulate_Blend_Scale(SDL_BlitInfo *info)
                 dstB = (srcB * dstB) / 255;
                 break;
             case SDL_COPY_MUL:
-                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) dstR = 255;
-                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) dstG = 255;
-                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) dstB = 255;
+                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             }
             dstpixel = (dstR << 16) | (dstG << 8) | dstB;
@@ -6166,9 +6894,15 @@ static void SDL_Blit_BGRA8888_BGR888_Blend(SDL_BlitInfo *info)
                 dstB = srcB + ((255 - srcA) * dstB) / 255;
                 break;
             case SDL_COPY_ADD:
-                dstR = srcR + dstR; if (dstR > 255) dstR = 255;
-                dstG = srcG + dstG; if (dstG > 255) dstG = 255;
-                dstB = srcB + dstB; if (dstB > 255) dstB = 255;
+                dstR = srcR + dstR; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = srcG + dstG; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = srcB + dstB; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             case SDL_COPY_MOD:
                 dstR = (srcR * dstR) / 255;
@@ -6176,9 +6910,15 @@ static void SDL_Blit_BGRA8888_BGR888_Blend(SDL_BlitInfo *info)
                 dstB = (srcB * dstB) / 255;
                 break;
             case SDL_COPY_MUL:
-                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) dstR = 255;
-                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) dstG = 255;
-                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) dstB = 255;
+                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             }
             dstpixel = (dstB << 16) | (dstG << 8) | dstR;
@@ -6235,9 +6975,15 @@ static void SDL_Blit_BGRA8888_BGR888_Blend_Scale(SDL_BlitInfo *info)
                 dstB = srcB + ((255 - srcA) * dstB) / 255;
                 break;
             case SDL_COPY_ADD:
-                dstR = srcR + dstR; if (dstR > 255) dstR = 255;
-                dstG = srcG + dstG; if (dstG > 255) dstG = 255;
-                dstB = srcB + dstB; if (dstB > 255) dstB = 255;
+                dstR = srcR + dstR; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = srcG + dstG; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = srcB + dstB; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             case SDL_COPY_MOD:
                 dstR = (srcR * dstR) / 255;
@@ -6245,9 +6991,15 @@ static void SDL_Blit_BGRA8888_BGR888_Blend_Scale(SDL_BlitInfo *info)
                 dstB = (srcB * dstB) / 255;
                 break;
             case SDL_COPY_MUL:
-                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) dstR = 255;
-                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) dstG = 255;
-                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) dstB = 255;
+                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             }
             dstpixel = (dstB << 16) | (dstG << 8) | dstR;
@@ -6378,9 +7130,15 @@ static void SDL_Blit_BGRA8888_BGR888_Modulate_Blend(SDL_BlitInfo *info)
                 dstB = srcB + ((255 - srcA) * dstB) / 255;
                 break;
             case SDL_COPY_ADD:
-                dstR = srcR + dstR; if (dstR > 255) dstR = 255;
-                dstG = srcG + dstG; if (dstG > 255) dstG = 255;
-                dstB = srcB + dstB; if (dstB > 255) dstB = 255;
+                dstR = srcR + dstR; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = srcG + dstG; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = srcB + dstB; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             case SDL_COPY_MOD:
                 dstR = (srcR * dstR) / 255;
@@ -6388,9 +7146,15 @@ static void SDL_Blit_BGRA8888_BGR888_Modulate_Blend(SDL_BlitInfo *info)
                 dstB = (srcB * dstB) / 255;
                 break;
             case SDL_COPY_MUL:
-                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) dstR = 255;
-                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) dstG = 255;
-                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) dstB = 255;
+                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             }
             dstpixel = (dstB << 16) | (dstG << 8) | dstR;
@@ -6459,9 +7223,15 @@ static void SDL_Blit_BGRA8888_BGR888_Modulate_Blend_Scale(SDL_BlitInfo *info)
                 dstB = srcB + ((255 - srcA) * dstB) / 255;
                 break;
             case SDL_COPY_ADD:
-                dstR = srcR + dstR; if (dstR > 255) dstR = 255;
-                dstG = srcG + dstG; if (dstG > 255) dstG = 255;
-                dstB = srcB + dstB; if (dstB > 255) dstB = 255;
+                dstR = srcR + dstR; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = srcG + dstG; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = srcB + dstB; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             case SDL_COPY_MOD:
                 dstR = (srcR * dstR) / 255;
@@ -6469,9 +7239,15 @@ static void SDL_Blit_BGRA8888_BGR888_Modulate_Blend_Scale(SDL_BlitInfo *info)
                 dstB = (srcB * dstB) / 255;
                 break;
             case SDL_COPY_MUL:
-                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) dstR = 255;
-                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) dstG = 255;
-                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) dstB = 255;
+                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             }
             dstpixel = (dstB << 16) | (dstG << 8) | dstR;
@@ -6551,9 +7327,15 @@ static void SDL_Blit_BGRA8888_ARGB8888_Blend(SDL_BlitInfo *info)
                 dstA = srcA + ((255 - srcA) * dstA) / 255;
                 break;
             case SDL_COPY_ADD:
-                dstR = srcR + dstR; if (dstR > 255) dstR = 255;
-                dstG = srcG + dstG; if (dstG > 255) dstG = 255;
-                dstB = srcB + dstB; if (dstB > 255) dstB = 255;
+                dstR = srcR + dstR; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = srcG + dstG; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = srcB + dstB; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             case SDL_COPY_MOD:
                 dstR = (srcR * dstR) / 255;
@@ -6561,10 +7343,18 @@ static void SDL_Blit_BGRA8888_ARGB8888_Blend(SDL_BlitInfo *info)
                 dstB = (srcB * dstB) / 255;
                 break;
             case SDL_COPY_MUL:
-                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) dstR = 255;
-                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) dstG = 255;
-                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) dstB = 255;
-                dstA = ((srcA * dstA) + (dstA * (255 - srcA))) / 255; if (dstA > 255) dstA = 255;
+                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) {
+                    dstB = 255;
+                }
+                dstA = ((srcA * dstA) + (dstA * (255 - srcA))) / 255; if (dstA > 255) {
+                    dstA = 255;
+                }
                 break;
             }
             dstpixel = (dstA << 24) | (dstR << 16) | (dstG << 8) | dstB;
@@ -6622,9 +7412,15 @@ static void SDL_Blit_BGRA8888_ARGB8888_Blend_Scale(SDL_BlitInfo *info)
                 dstA = srcA + ((255 - srcA) * dstA) / 255;
                 break;
             case SDL_COPY_ADD:
-                dstR = srcR + dstR; if (dstR > 255) dstR = 255;
-                dstG = srcG + dstG; if (dstG > 255) dstG = 255;
-                dstB = srcB + dstB; if (dstB > 255) dstB = 255;
+                dstR = srcR + dstR; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = srcG + dstG; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = srcB + dstB; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             case SDL_COPY_MOD:
                 dstR = (srcR * dstR) / 255;
@@ -6632,10 +7428,18 @@ static void SDL_Blit_BGRA8888_ARGB8888_Blend_Scale(SDL_BlitInfo *info)
                 dstB = (srcB * dstB) / 255;
                 break;
             case SDL_COPY_MUL:
-                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) dstR = 255;
-                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) dstG = 255;
-                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) dstB = 255;
-                dstA = ((srcA * dstA) + (dstA * (255 - srcA))) / 255; if (dstA > 255) dstA = 255;
+                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) {
+                    dstB = 255;
+                }
+                dstA = ((srcA * dstA) + (dstA * (255 - srcA))) / 255; if (dstA > 255) {
+                    dstA = 255;
+                }
                 break;
             }
             dstpixel = (dstA << 24) | (dstR << 16) | (dstG << 8) | dstB;
@@ -6775,9 +7579,15 @@ static void SDL_Blit_BGRA8888_ARGB8888_Modulate_Blend(SDL_BlitInfo *info)
                 dstA = srcA + ((255 - srcA) * dstA) / 255;
                 break;
             case SDL_COPY_ADD:
-                dstR = srcR + dstR; if (dstR > 255) dstR = 255;
-                dstG = srcG + dstG; if (dstG > 255) dstG = 255;
-                dstB = srcB + dstB; if (dstB > 255) dstB = 255;
+                dstR = srcR + dstR; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = srcG + dstG; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = srcB + dstB; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             case SDL_COPY_MOD:
                 dstR = (srcR * dstR) / 255;
@@ -6785,10 +7595,18 @@ static void SDL_Blit_BGRA8888_ARGB8888_Modulate_Blend(SDL_BlitInfo *info)
                 dstB = (srcB * dstB) / 255;
                 break;
             case SDL_COPY_MUL:
-                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) dstR = 255;
-                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) dstG = 255;
-                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) dstB = 255;
-                dstA = ((srcA * dstA) + (dstA * (255 - srcA))) / 255; if (dstA > 255) dstA = 255;
+                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) {
+                    dstB = 255;
+                }
+                dstA = ((srcA * dstA) + (dstA * (255 - srcA))) / 255; if (dstA > 255) {
+                    dstA = 255;
+                }
                 break;
             }
             dstpixel = (dstA << 24) | (dstR << 16) | (dstG << 8) | dstB;
@@ -6858,9 +7676,15 @@ static void SDL_Blit_BGRA8888_ARGB8888_Modulate_Blend_Scale(SDL_BlitInfo *info)
                 dstA = srcA + ((255 - srcA) * dstA) / 255;
                 break;
             case SDL_COPY_ADD:
-                dstR = srcR + dstR; if (dstR > 255) dstR = 255;
-                dstG = srcG + dstG; if (dstG > 255) dstG = 255;
-                dstB = srcB + dstB; if (dstB > 255) dstB = 255;
+                dstR = srcR + dstR; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = srcG + dstG; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = srcB + dstB; if (dstB > 255) {
+                    dstB = 255;
+                }
                 break;
             case SDL_COPY_MOD:
                 dstR = (srcR * dstR) / 255;
@@ -6868,10 +7692,18 @@ static void SDL_Blit_BGRA8888_ARGB8888_Modulate_Blend_Scale(SDL_BlitInfo *info)
                 dstB = (srcB * dstB) / 255;
                 break;
             case SDL_COPY_MUL:
-                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) dstR = 255;
-                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) dstG = 255;
-                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) dstB = 255;
-                dstA = ((srcA * dstA) + (dstA * (255 - srcA))) / 255; if (dstA > 255) dstA = 255;
+                dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255; if (dstR > 255) {
+                    dstR = 255;
+                }
+                dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255; if (dstG > 255) {
+                    dstG = 255;
+                }
+                dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255; if (dstB > 255) {
+                    dstB = 255;
+                }
+                dstA = ((srcA * dstA) + (dstA * (255 - srcA))) / 255; if (dstA > 255) {
+                    dstA = 255;
+                }
                 break;
             }
             dstpixel = (dstA << 24) | (dstR << 16) | (dstG << 8) | dstB;
diff --git a/src/video/SDL_blit_copy.c b/src/video/SDL_blit_copy.c
index 0223d9a16..91e2de982 100644
--- a/src/video/SDL_blit_copy.c
+++ b/src/video/SDL_blit_copy.c
@@ -47,8 +47,9 @@ SDL_memcpySSE(Uint8 * dst, const Uint8 * src, int len)
         dst += 64;
     }
 
-    if (len & 63)
+    if (len & 63) {
         SDL_memcpy(dst, src, len & 63);
+    }
 }
 #endif /* __SSE__ */
 
@@ -65,7 +66,7 @@ SDL_memcpyMMX(Uint8 * dst, const Uint8 * src, int len)
     __m64* d64 = (__m64*)dst;
     __m64* s64 = (__m64*)src;
 
-    for(i= len / 64; i--;) {
+    for (i= len / 64; i--;) {
         d64[0] = s64[0];
         d64[1] = s64[1];
         d64[2] = s64[2];
@@ -79,8 +80,7 @@ SDL_memcpyMMX(Uint8 * dst, const Uint8 * src, int len)
         s64 += 8;
     }
 
-    if (remain)
-    {
+    if (remain) {
         const int skip = len - remain;
         SDL_memcpy(dst + skip, src + skip, remain);
     }
diff --git a/src/video/SDL_blit_slow.c b/src/video/SDL_blit_slow.c
index ed9c692b1..ebcb825e5 100644
--- a/src/video/SDL_blit_slow.c
+++ b/src/video/SDL_blit_slow.c
@@ -148,14 +148,17 @@ SDL_Blit_Slow(SDL_BlitInfo * info)
                 break;
             case SDL_COPY_ADD:
                 dstR = srcR + dstR;
-                if (dstR > 255)
+                if (dstR > 255) {
                     dstR = 255;
+                }
                 dstG = srcG + dstG;
-                if (dstG > 255)
+                if (dstG > 255) {
                     dstG = 255;
+                }
                 dstB = srcB + dstB;
-                if (dstB > 255)
+                if (dstB > 255) {
                     dstB = 255;
+                }
                 break;
             case SDL_COPY_MOD:
                 dstR = (srcR * dstR) / 255;
@@ -164,17 +167,21 @@ SDL_Blit_Slow(SDL_BlitInfo * info)
                 break;
             case SDL_COPY_MUL:
                 dstR = ((srcR * dstR) + (dstR * (255 - srcA))) / 255;
-                if (dstR > 255)
+                if (dstR > 255) {
                     dstR = 255;
+                }
                 dstG = ((srcG * dstG) + (dstG * (255 - srcA))) / 255;
-                if (dstG > 255)
+                if (dstG > 255) {
                     dstG = 255;
+                }
                 dstB = ((srcB * dstB) + (dstB * (255 - srcA))) / 255;
-                if (dstB > 255)
+                if (dstB > 255) {
                     dstB = 255;
+                }
                 dstA = ((srcA * dstA) + (dstA * (255 - srcA))) / 255;
-                if (dstA > 255)
+                if (dstA > 255) {
                     dstA = 255;
+                }
                 break;
             }
             if (FORMAT_HAS_ALPHA(dstfmt_val)) {
diff --git a/src/video/SDL_bmp.c b/src/video/SDL_bmp.c
index 369b925a6..884580d87 100644
--- a/src/video/SDL_bmp.c
+++ b/src/video/SDL_bmp.c
@@ -67,17 +67,21 @@ static SDL_bool readRlePixels(SDL_Surface * surface, SDL_RWops * src, int isRle8
     Uint8 ch;
     Uint8 needsPad;
 
-#define COPY_PIXEL(x)   spot = &bits[ofs++]; if(spot >= start && spot < end) *spot = (x)
+#define COPY_PIXEL(x)   spot = &bits[ofs++]; if (spot >= start && spot < end) *spot = (x)
 
     for (;;) {
-        if (!SDL_RWread(src, &ch, 1, 1)) return SDL_TRUE;
+        if (!SDL_RWread(src, &ch, 1, 1)) {
+            return SDL_TRUE;
+        }
         /*
         | encoded mode starts with a run length, and then a byte
         | with two colour indexes to alternate between for the run
         */
         if (ch) {
             Uint8 pixel;
-            if (!SDL_RWread(src, &pixel, 1, 1)) return SDL_TRUE;
+            if (!SDL_RWread(src, &pixel, 1, 1)) {
+                return SDL_TRUE;
+            }
             if (isRle8) {                   /* 256-color bitmap, compressed */
                 do {
                     COPY_PIXEL(pixel);
@@ -87,9 +91,13 @@ static SDL_bool readRlePixels(SDL_Surface * surface, SDL_RWops * src, int isRle8
                 Uint8 pixel1 = pixel & 0x0F;
                 for (;;) {
                     COPY_PIXEL(pixel0); /* even count, high nibble */
-                    if (!--ch) break;
+                    if (!--ch) {
+                    break;
+                    }
                     COPY_PIXEL(pixel1); /* odd count, low nibble */
-                    if (!--ch) break;
+                    if (!--ch) {
+                    break;
+                    }
                 }
             }
         } else {
@@ -98,7 +106,9 @@ static SDL_bool readRlePixels(SDL_Surface * surface, SDL_RWops * src, int isRle8
             | a cursor move, or some absolute data.
             | zero tag may be absolute mode or an escape
             */
-            if (!SDL_RWread(src, &ch, 1, 1)) return SDL_TRUE;
+            if (!SDL_RWread(src, &ch, 1, 1)) {
+                return SDL_TRUE;
+            }
             switch (ch) {
             case 0:                         /* end of line */
                 ofs = 0;
@@ -107,9 +117,13 @@ static SDL_bool readRlePixels(SDL_Surface * surface, SDL_RWops * src, int isRle8
             case 1:                         /* end of bitmap */
                 return SDL_FALSE;           /* success! */
             case 2:                         /* delta */
-                if (!SDL_RWread(src, &ch, 1, 1)) return SDL_TRUE;
+                if (!SDL_RWread(src, &ch, 1, 1)) {
+                    return SDL_TRUE;
+                }
                 ofs += ch;
-                if (!SDL_RWread(src, &ch, 1, 1)) return SDL_TRUE;
+                if (!SDL_RWread(src, &ch, 1, 1)) {
+                    return SDL_TRUE;
+                }
                 bits -= (ch * pitch);
                 break;
             default:                        /* no compression */
@@ -117,22 +131,32 @@ static SDL_bool readRlePixels(SDL_Surface * surface, SDL_RWops * src, int isRle8
                     needsPad = (ch & 1);
                     do {
                         Uint8 pixel;
-                        if (!SDL_RWread(src, &pixel, 1, 1)) return SDL_TRUE;
+                        if (!SDL_RWread(src, &pixel, 1, 1)) {
+                            return SDL_TRUE;
+                        }
                         COPY_PIXEL(pixel);
                     } while (--ch);
                 } else {
                     needsPad = (((ch+1)>>1) & 1); /* (ch+1)>>1: bytes size */
                     for (;;) {
                         Uint8 pixel;
-                        if (!SDL_RWread(src, &pixel, 1, 1)) return SDL_TRUE;
+                        if (!SDL_RWread(src, &pixel, 1, 1)) {
+                            return SDL_TRUE;
+                        }
                         COPY_PIXEL(pixel >> 4);
-                        if (!--ch) break;
+                        if (!--ch) {
+                            break;
+                        }
                         COPY_PIXEL(pixel & 0x0F);
-                        if (!--ch) break;
+                        if (!--ch) {
+                            break;
+                        }
                     }
                 }
                 /* pad at even boundary */
-                if (needsPad && !SDL_RWread(src, &ch, 1, 1)) return SDL_TRUE;
+                if (needsPad && !SDL_RWread(src, &ch, 1, 1)) {
+                    return SDL_TRUE;
+                }
                 break;
             }
         }
@@ -463,7 +487,9 @@ SDL_LoadBMP_RW(SDL_RWops * src, int freesrc)
     }
     if ((biCompression == BI_RLE4) || (biCompression == BI_RLE8)) {
         was_error = readRlePixels(surface, src, biCompression == BI_RLE8);
-        if (was_error) SDL_Error(SDL_EFREAD);
+        if (was_error) {
+            SDL_Error(SDL_EFREAD);
+        }
         goto done;
     }
     top = (Uint8 *)surface->pixels;
@@ -538,15 +564,17 @@ SDL_LoadBMP_RW(SDL_RWops * src, int freesrc)
             case 15:
             case 16:{
                     Uint16 *pix = (Uint16 *) bits;
-                    for (i = 0; i < surface->w; i++)
+                    for (i = 0; i < surface->w; i++) {
                         pix[i] = SDL_Swap16(pix[i]);
+                    }
                     break;
                 }
 
             case 32:{
                     Uint32 *pix = (Uint32 *) bits;
-                    for (i = 0; i < surface->w; i++)
+                    for (i = 0; i < surface->w; i++) {
                         pix[i] = SDL_Swap32(pix[i]);
+                    }
                     break;
                 }
             }
@@ -580,7 +608,7 @@ SDL_LoadBMP_RW(SDL_RWops * src, int freesrc)
     if (freesrc && src) {
         SDL_RWclose(src);
     }
-    return (surface);
+    return surface;
 }
 
 int
@@ -665,7 +693,7 @@ SDL_SaveBMP_RW(SDL_Surface * saveme, SDL_RWops * dst, int freedst)
                 SDL_InitFormat(&format, SDL_PIXELFORMAT_BGR24);
             }
             surface = SDL_ConvertSurface(saveme, &format, 0);
-            if (!surface) {
+            if (surface == NULL) {
                 SDL_SetError("Couldn't convert image to %d bpp",
                              format.BitsPerPixel);
             }
@@ -820,7 +848,7 @@ SDL_SaveBMP_RW(SDL_Surface * saveme, SDL_RWops * dst, int freedst)
     if (freedst && dst) {
         SDL_RWclose(dst);
     }
-    return ((SDL_strcmp(SDL_GetError(), "") == 0) ? 0 : -1);
+    return (SDL_strcmp(SDL_GetError(), "") == 0) ? 0 : -1;
 }
 
 /* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/video/SDL_clipboard.c b/src/video/SDL_clipboard.c
index b5ea5ed53..f1ce89293 100644
--- a/src/video/SDL_clipboard.c
+++ b/src/video/SDL_clipboard.c
@@ -29,11 +29,11 @@ SDL_SetClipboardText(const char *text)
 {
     SDL_VideoDevice *_this = SDL_GetVideoDevice();
 
-    if (!_this) {
+    if (_this == NULL) {
         return SDL_SetError("Video subsystem must be initialized to set clipboard text");
     }
 
-    if (!text) {
+    if (text == NULL) {
         text = "";
     }
     if (_this->SetClipboardText) {
@@ -50,11 +50,11 @@ SDL_SetPrimarySelectionText(const char *text)
 {
     SDL_VideoDevice *_this = SDL_GetVideoDevice();
 
-    if (!_this) {
+    if (_this == NULL) {
         return SDL_SetError("Video subsystem must be initialized to set primary selection text");
     }
 
-    if (!text) {
+    if (text == NULL) {
         text = "";
     }
     if (_this->SetPrimarySelectionText) {
@@ -71,7 +71,7 @@ SDL_GetClipboardText(void)
 {
     SDL_VideoDevice *_this = SDL_GetVideoDevice();
 
-    if (!_this) {
+    if (_this == NULL) {
         SDL_SetError("Video subsystem must be initialized to get clipboard text");
         return SDL_strdup("");
     }
@@ -80,7 +80,7 @@ SDL_GetClipboardText(void)
         return _this->GetClipboardText(_this);
     } else {
         const char *text = _this->clipboard_text;
-        if (!text) {
+        if (text == NULL) {
             text = "";
         }
         return SDL_strdup(text);
@@ -92,7 +92,7 @@ SDL_GetPrimarySelectionText(void)
 {
     SDL_VideoDevice *_this = SDL_GetVideoDevice();
 
-    if (!_this) {
+    if (_this == NULL) {
         SDL_SetError("Video subsystem must be initialized to get primary selection text");
         return SDL_strdup("");
     }
@@ -101,7 +101,7 @@ SDL_GetPrimarySelectionText(void)
         return _this->GetPrimarySelectionText(_this);
     } else {
         const char *text = _this->primary_selection_text;
-        if (!text) {
+        if (text == NULL) {
             text = "";
         }
         return SDL_strdup(text);
@@ -113,7 +113,7 @@ SDL_HasClipboardText(void)
 {
     SDL_VideoDevice *_this = SDL_GetVideoDevice();
 
-    if (!_this) {
+    if (_this == NULL) {
         SDL_SetError("Video subsystem must be initialized to check clipboard text");
         return SDL_FALSE;
     }
@@ -134,7 +134,7 @@ SDL_HasPrimarySelectionText(void)
 {
     SDL_VideoDevice *_this = SDL_GetVideoDevice();
 
-    if (!_this) {
+    if (_this == NULL) {
         SDL_SetError("Video subsystem must be initialized to check primary selection text");
         return SDL_FALSE;
     }
diff --git a/src/video/SDL_egl.c b/src/video/SDL_egl.c
index 41ae6ec01..d6385e0ce 100644
--- a/src/video/SDL_egl.c
+++ b/src/video/SDL_egl.c
@@ -250,19 +250,19 @@ SDL_EGL_GetProcAddress(_THIS, const char *proc)
         const SDL_bool is_egl_15_or_later = eglver >= ((((Uint32) 1) << 16) | 5);
 
         /* EGL 1.5 can use eglGetProcAddress() for any symbol. 1.4 and earlier can't use it for core entry points. */
-        if (!retval && is_egl_15_or_later && _this->egl_data->eglGetProcAddress) {
+        if (retval == NULL && is_egl_15_or_later && _this->egl_data->eglGetProcAddress) {
             retval = _this->egl_data->eglGetProcAddress(proc);
         }
 
         #if !defined(__EMSCRIPTEN__) && !defined(SDL_VIDEO_DRIVER_VITA)  /* LoadFunction isn't needed on Emscripten and will call dlsym(), causing other problems. */
         /* Try SDL_LoadFunction() first for EGL <= 1.4, or as a fallback for >= 1.5. */
-        if (!retval) {
+        if (retval == NULL) {
             retval = SDL_LoadFunction(_this->egl_data->opengl_dll_handle, proc);
         }
         #endif
 
         /* Try eglGetProcAddress if we're on <= 1.4 and still searching... */
-        if (!retval && !is_egl_15_or_later && _this->egl_data->eglGetProcAddress) {
+        if (retval == NULL && !is_egl_15_or_later && _this->egl_data->eglGetProcAddress) {
             retval = _this->egl_data->eglGetProcAddress(proc);
         }
     }
@@ -611,8 +611,7 @@ SDL_EGL_InitializeOffscreen(_THIS, int device)
         if (_this->egl_data->eglInitialize(_this->egl_data->egl_display, NULL, NULL) != EGL_TRUE) {
             return SDL_SetError("Could not initialize EGL");
         }
-    }
-    else {
+    } else {
         int i;
         SDL_bool found = SDL_FALSE;
         EGLDisplay attempted_egl_display;
@@ -818,8 +817,7 @@ SDL_EGL_PrivateChooseConfig(_THIS, SDL_bool set_config_caveat_none)
     }
 
     /* first ensure that a found config has a matching format, or the function will fall through. */
-    if (_this->egl_data->egl_required_visual_id)
-    {
+    if (_this->egl_data->egl_required_visual_id) {
         for (i = 0; i < found_configs; i++ ) {
             EGLint format;
             _this->egl_data->eglGetConfigAttrib(_this->egl_data->egl_display,
diff --git a/src/video/SDL_fillrect.c b/src/video/SDL_fillrect.c
index 222d69e22..748b61a19 100644
--- a/src/video/SDL_fillrect.c
+++ b/src/video/SDL_fillrect.c
@@ -237,12 +237,12 @@ SDL_FillRect4(Uint8 * pixels, int pitch, Uint32 color, int w, int h)
 int
 SDL_FillRect(SDL_Surface * dst, const SDL_Rect * rect, Uint32 color)
 {
-    if (!dst) {
+    if (dst == NULL) {
         return SDL_InvalidParamError("SDL_FillRect(): dst");
     }
 
     /* If 'rect' == NULL, then fill the whole surface */
-    if (!rect) {
+    if (rect == NULL) {
         rect = &dst->clip_rect;
         /* Don't attempt to fill if the surface's clip_rect is empty */
         if (SDL_RectEmpty(rect)) {
@@ -305,7 +305,7 @@ SDL_FillRects(SDL_Surface * dst, const SDL_Rect * rects, int count,
     void (*fill_function)(Uint8 * pixels, int pitch, Uint32 color, int w, int h) = NULL;
     int i;
 
-    if (!dst) {
+    if (dst == NULL) {
         return SDL_InvalidParamError("SDL_FillRects(): dst");
     }
 
@@ -319,7 +319,7 @@ SDL_FillRects(SDL_Surface * dst, const SDL_Rect * rects, int count,
         return SDL_SetError("SDL_FillRects(): You must lock the surface");
     }
 
-    if (!rects) {
+    if (rects == NULL) {
         return SDL_InvalidParamError("SDL_FillRects(): rects");
     }
 
diff --git a/src/video/SDL_pixels.c b/src/video/SDL_pixels.c
index 654453278..e4dc0cc8b 100644
--- a/src/video/SDL_pixels.c
+++ b/src/video/SDL_pixels.c
@@ -83,11 +83,12 @@ Uint8* SDL_expand_byte[9] = {
 
 /* Helper functions */
 
+#define CASE(X) case X: return #X;
 const char*
 SDL_GetPixelFormatName(Uint32 format)
 {
     switch (format) {
-#define CASE(X) case X: return #X;
+
     CASE(SDL_PIXELFORMAT_INDEX1LSB)
     CASE(SDL_PIXELFORMAT_INDEX1MSB)
     CASE(SDL_PIXELFORMAT_INDEX4LSB)
@@ -127,11 +128,12 @@ SDL_GetPixelFormatName(Uint32 format)
     CASE(SDL_PIXELFORMAT_NV12)
     CASE(SDL_PIXELFORMAT_NV21)
     CASE(SDL_PIXELFORMAT_EXTERNAL_OES)
-#undef CASE
+
     default:
         return "SDL_PIXELFORMAT_UNKNOWN";
     }
 }
+#undef CASE
 
 SDL_bool
 SDL_PixelFormatEnumToMasks(Uint32 format, int *bpp, Uint32 * Rmask,
@@ -565,8 +567,9 @@ SDL_InitFormat(SDL_PixelFormat * format, Uint32 pixel_format)
     format->Rshift = 0;
     format->Rloss = 8;
     if (Rmask) {
-        for (mask = Rmask; !(mask & 0x01); mask >>= 1)
+        for (mask = Rmask; !(mask & 0x01); mask >>= 1) {
             ++format->Rshift;
+        }
         for (; (mask & 0x01); mask >>= 1)
             --format->Rloss;
     }
@@ -575,8 +578,9 @@ SDL_InitFormat(SDL_PixelFormat * format, Uint32 pixel_format)
     format->Gshift = 0;
     format->Gloss = 8;
     if (Gmask) {
-        for (mask = Gmask; !(mask & 0x01); mask >>= 1)
+        for (mask = Gmask; !(mask & 0x01); mask >>= 1) {
             ++format->Gshift;
+        }
         for (; (mask & 0x01); mask >>= 1)
             --format->Gloss;
     }
@@ -585,8 +589,9 @@ SDL_InitFormat(SDL_PixelFormat * format, Uint32 pixel_format)
     format->Bshift = 0;
     format->Bloss = 8;
     if (Bmask) {
-        for (mask = Bmask; !(mask & 0x01); mask >>= 1)
+        for (mask = Bmask; !(mask & 0x01); mask >>= 1) {
             ++format->Bshift;
+        }
         for (; (mask & 0x01); mask >>= 1)
             --format->Bloss;
     }
@@ -595,8 +600,9 @@ SDL_InitFormat(SDL_PixelFormat * format, Uint32 pixel_format)
     format->Ashift = 0;
     format->Aloss = 8;
     if (Amask) {
-        for (mask = Amask; !(mask & 0x01); mask >>= 1)
+        for (mask = Amask; !(mask & 0x01); mask >>= 1) {
             ++format->Ashift;
+        }
         for (; (mask & 0x01); mask >>= 1)
             --format->Aloss;
     }
@@ -613,7 +619,7 @@ SDL_FreeFormat(SDL_PixelFormat *format)
 {
     SDL_PixelFormat *prev;
 
-    if (!format) {
+    if (format == NULL) {
         SDL_InvalidParamError("format");
         return;
     }
@@ -657,7 +663,7 @@ SDL_AllocPalette(int ncolors)
     }
 
     palette = (SDL_Palette *) SDL_malloc(sizeof(*palette));
-    if (!palette) {
+    if (palette == NULL) {
         SDL_OutOfMemory();
         return NULL;
     }
@@ -679,7 +685,7 @@ SDL_AllocPalette(int ncolors)
 int
 SDL_SetPixelFormatPalette(SDL_PixelFormat * format, SDL_Palette *palette)
 {
-    if (!format) {
+    if (format == NULL) {
         return SDL_InvalidParamError("SDL_SetPixelFormatPalette(): format");
     }
 
@@ -711,7 +717,7 @@ SDL_SetPaletteColors(SDL_Palette * palette, const SDL_Color * colors,
     int status = 0;
 
     /* Verify the parameters */
-    if (!palette) {
+    if (palette == NULL) {
         return -1;
     }
     if (ncolors > (palette->ncolors - firstcolor)) {
@@ -734,7 +740,7 @@ SDL_SetPaletteColors(SDL_Palette * palette, const SDL_Color * colors,
 void
 SDL_FreePalette(SDL_Palette * palette)
 {
-    if (!palette) {
+    if (palette == NULL) {
         SDL_InvalidParamError("palette");
         return;
     }
@@ -752,8 +758,9 @@ void
 SDL_DitherColors(SDL_Color * colors, int bpp)
 {
     int i;
-    if (bpp != 8)
-        return;                 /* only 8bpp supported right now */
+    if (bpp != 8) {
+        return; /* only 8bpp supported right now */
+    }
 
     for (i = 0; i < 256; i++) {
         int r, g, b;
@@ -801,7 +808,7 @@ SDL_FindColor(SDL_Palette * pal, Uint8 r, Uint8 g, Uint8 b, Uint8 a)
             smallest = distance;
         }
     }
-    return (pixel);
+    return pixel;
 }
 
 /* Tell whether palette is opaque, and if it has an alpha_channel */
@@ -857,9 +864,7 @@ Uint32
 SDL_MapRGB(const SDL_PixelFormat * format, Uint8 r, Uint8 g, Uint8 b)
 {
     if (format->palette == NULL) {
-        return (r >> format->Rloss) << format->Rshift
-            | (g >> format->Gloss) << format->Gshift
-            | (b >> format->Bloss) << format->Bshift | format->Amask;
+        return (r >> format->Rloss) << format->Rshift | (g >> format->Gloss) << format->Gshift | (b >> format->Bloss) << format->Bshift | format->Amask;
     } else {
         return SDL_FindColor(format->palette, r, g, b, SDL_ALPHA_OPAQUE);
     }
@@ -871,10 +876,7 @@ SDL_MapRGBA(const SDL_PixelFormat * format, Uint8 r, Uint8 g, Uint8 b,
             Uint8 a)
 {
     if (format->palette == NULL) {
-        return (r >> format->Rloss) << format->Rshift
-            | (g >> format->Gloss) << format->Gshift
-            | (b >> format->Bloss) << format->Bshift
-            | ((Uint32)(a >> format->Aloss) << format->Ashift & format->Amask);
+        return (r >> format->Rloss) << format->Rshift | (g >> format->Gloss) << format->Gshift | (b >> format->Bloss) << format->Bshift | ((Uint32)(a >> format->Aloss) << format->Ashift & format->Amask);
     } else {
         return SDL_FindColor(format->palette, r, g, b, a);
     }
@@ -945,7 +947,7 @@ Map1to1(SDL_Palette * src, SDL_Palette * dst, int *identical)
                  (src->colors, dst->colors,
                   src->ncolors * sizeof(SDL_Color)) == 0)) {
                 *identical = 1;
-                return (NULL);
+                return NULL;
             }
         }
         *identical = 0;
@@ -953,14 +955,14 @@ Map1to1(SDL_Palette * src, SDL_Palette * dst, int *identical)
     map = (Uint8 *) SDL_calloc(256, sizeof(Uint8));
     if (map == NULL) {
         SDL_OutOfMemory();
-        return (NULL);
+        return NULL;
     }
     for (i = 0; i < src->ncolors; ++i) {
         map[i] = SDL_FindColor(dst,
                                src->colors[i].r, src->colors[i].g,
                                src->colors[i].b, src->colors[i].a);
     }
-    return (map);
+    return map;
 }
 
 /* Map from Palette to BitField */
@@ -977,7 +979,7 @@ Map1toN(SDL_PixelFormat * src, Uint8 Rmod, Uint8 Gmod, Uint8 Bmod, Uint8 Amod,
     map = (Uint8 *) SDL_calloc(256, bpp);
     if (map == NULL) {
         SDL_OutOfMemory();
-        return (NULL);
+        return NULL;
     }
 
     /* We memory copy to the pixel map so the endianness is preserved */
@@ -988,7 +990,7 @@ Map1toN(SDL_PixelFormat * src, Uint8 Rmod, Uint8 Gmod, Uint8 Bmod, Uint8 Amod,
         Uint8 A = (Uint8) ((pal->colors[i].a * Amod) / 255);
         ASSEMBLE_RGBA(&map[i * bpp], dst->BytesPerPixel, dst, (Uint32)R, (Uint32)G, (Uint32)B, (Uint32)A);
     }
-    return (map);
+    return map;
 }
 
 /* Map from BitField to Dithered-Palette to Palette */
@@ -1003,7 +1005,7 @@ MapNto1(SDL_PixelFormat * src, SDL_PixelFormat * dst, int *identical)
     dithered.ncolors = 256;
     SDL_DitherColors(colors, 8);
     dithered.colors = colors;
-    return (Map1to1(&dithered, pal, identical));
+    return Map1to1(&dithered, pal, identical);
 }
 
 SDL_BlitMap *
@@ -1015,7 +1017,7 @@ SDL_AllocBlitMap(void)
     map = (SDL_BlitMap *) SDL_calloc(1, sizeof(*map));
     if (map == NULL) {
         SDL_OutOfMemory();
-        return (NULL);
+        return NULL;
     }
     map->info.r = 0xFF;
     map->info.g = 0xFF;
@@ -1023,7 +1025,7 @@ SDL_AllocBlitMap(void)
     map->info.a = 0xFF;
 
     /* It's ready to go */
-    return (map);
+    return map;
 }
 
 
@@ -1045,7 +1047,7 @@ SDL_InvalidateAllBlitMap(SDL_Surface *surface)
 void
 SDL_InvalidateMap(SDL_BlitMap * map)
 {
-    if (!map) {
+    if (map == NULL) {
         return;
     }
     if (map->dst) {
@@ -1086,18 +1088,19 @@ SDL_MapSurface(SDL_Surface * src, SDL_Surface * dst)
                 Map1to1(srcfmt->palette, dstfmt->palette, &map->identity);
             if (!map->identity) {
                 if (map->info.table == NULL) {
-                    return (-1);
+                    return -1;
                 }
             }
-            if (srcfmt->BitsPerPixel != dstfmt->BitsPerPixel)
+            if (srcfmt->BitsPerPixel != dstfmt->BitsPerPixel) {
                 map->identity = 0;
+            }
         } else {
             /* Palette --> BitField */
             map->info.table =
                 Map1toN(srcfmt, src->map->info.r, src->map->info.g,
                         src->map->info.b, src->map->info.a, dstfmt);
             if (map->info.table == NULL) {
-                return (-1);
+                return -1;
             }
         }
     } else {
@@ -1106,7 +1109,7 @@ SDL_MapSurface(SDL_Surface * src, SDL_Surface * dst)
             map->info.table = MapNto1(srcfmt, dstfmt, &map->identity);
             if (!map->identity) {
                 if (map->info.table == NULL) {
-                    return (-1);
+                    return -1;
                 }
             }
             map->identity = 0;  /* Don't optimize to copy */
@@ -1138,7 +1141,7 @@ SDL_MapSurface(SDL_Surface * src, SDL_Surface * dst)
     }
 
     /* Choose your blitters wisely */
-    return (SDL_CalculateBlit(src));
+    return SDL_CalculateBlit(src);
 }
 
 void
diff --git a/src/video/SDL_rect.c b/src/video/SDL_rect.c
index dfa939032..26eb3cef4 100644
--- a/src/video/SDL_rect.c
+++ b/src/video/SDL_rect.c
@@ -39,10 +39,10 @@ SDL_GetSpanEnclosingRect(int width, int height,
     } else if (height < 1) {
         SDL_InvalidParamError("height");
         return SDL_FALSE;
-    } else if (!rects) {
+    } else if (rects == NULL) {
         SDL_InvalidParamError("rects");
         return SDL_FALSE;
-    } else if (!span) {
+    } else if (span == NULL) {
         SDL_InvalidParamError("span");
         return SDL_FALSE;
     } else if (numrects < 1) {
diff --git a/src/video/SDL_rect_impl.h b/src/video/SDL_rect_impl.h
index 26a54484a..0e2513c35 100644
--- a/src/video/SDL_rect_impl.h
+++ b/src/video/SDL_rect_impl.h
@@ -26,10 +26,10 @@ SDL_HASINTERSECTION(const RECTTYPE * A, const RECTTYPE * B)
 {
     SCALARTYPE Amin, Amax, Bmin, Bmax;
 
-    if (!A) {
+    if (A == NULL) {
         SDL_InvalidParamError("A");
         return SDL_FALSE;
-    } else if (!B) {
+    } else if (B == NULL) {
         SDL_InvalidParamError("B");
         return SDL_FALSE;
     } else if (SDL_RECTEMPTY(A) || SDL_RECTEMPTY(B)) {
@@ -72,13 +72,13 @@ SDL_INTERSECTRECT(const RECTTYPE * A, const RECTTYPE * B, RECTTYPE * result)
 {
     SCALARTYPE Amin, Amax, Bmin, Bmax;
 
-    if (!A) {
+    if (A == NULL) {
         SDL_InvalidParamError("A");
         return SDL_FALSE;
-    } else if (!B) {
+    } else if (B == NULL) {
         SDL_InvalidParamError("B");
         return SDL_FALSE;
-    } else if (!result) {
+    } else if (result == NULL) {
         SDL_InvalidParamError("result");
         return SDL_FALSE;
     } else if (SDL_RECTEMPTY(A) || SDL_RECTEMPTY(B)) {  /* Special cases for empty rects */
@@ -123,13 +123,13 @@ SDL_UNIONRECT(const RECTTYPE * A, const RECTTYPE * B, RECTTYPE * result)
 {
     SCALARTYPE Amin, Amax, Bmin, Bmax;
 
-    if (!A) {
+    if (A == NULL) {
         SDL_InvalidParamError("A");
         return;
-    } else if (!B) {
+    } else if (B == NULL) {
         SDL_InvalidParamError("B");
         return;
-    } else if (!result) {
+    } else if (result == NULL) {
         SDL_InvalidParamError("result");
         return;
     } else if (SDL_RECTEMPTY(A)) {  /* Special cases for empty Rects */
@@ -183,7 +183,7 @@ SDL_bool SDL_ENCLOSEPOINTS(const POINTTYPE * points, int count, const RECTTYPE *
     SCALARTYPE x, y;
     int i;
 
-    if (!points) {
+    if (points == NULL) {
         SDL_InvalidParamError("points");
         return SDL_FALSE;
     } else if (count < 1) {
@@ -305,19 +305,19 @@ SDL_INTERSECTRECTANDLINE(const RECTTYPE * rect, SCALARTYPE *X1, SCALARTYPE *Y1,
     SCALARTYPE recty2;
     int outcode1, outcode2;
 
-    if (!rect) {
+    if (rect == NULL) {
         SDL_InvalidParamError("rect");
         return SDL_FALSE;
-    } else if (!X1) {
+    } else if (X1 == NULL) {
         SDL_InvalidParamError("X1");
         return SDL_FALSE;
-    } else if (!Y1) {
+    } else if (Y1 == NULL) {
         SDL_InvalidParamError("Y1");
         return SDL_FALSE;
-    } else if (!X2) {
+    } else if (X2 == NULL) {
         SDL_InvalidParamError("X2");
         return SDL_FALSE;
-    } else if (!Y2) {
+    } else if (Y2 == NULL) {
         SDL_InvalidParamError("Y2");
         return SDL_FALSE;
     } else if (SDL_RECTEMPTY(rect)) {
diff --git a/src/video/SDL_shape.c b/src/video/SDL_shape.c
index 6c95164f2..f45dc25a1 100644
--- a/src/video/SDL_shape.c
+++ b/src/video/SDL_shape.c
@@ -33,33 +33,31 @@ SDL_CreateShapedWindow(const char *title,unsigned int x,unsigned int y,unsigned
 {
     SDL_Window *result = NULL;
     result = SDL_CreateWindow(title,-1000,-1000,w,h,(flags | SDL_WINDOW_BORDERLESS) & (~SDL_WINDOW_FULLSCREEN) & (~SDL_WINDOW_RESIZABLE) /* & (~SDL_WINDOW_SHOWN) */);
-    if(result != NULL) {
+    if (result != NULL) {
         if (SDL_GetVideoDevice()->shape_driver.CreateShaper == NULL) {
             SDL_DestroyWindow(result);
             return NULL;
         }
         result->shaper = SDL_GetVideoDevice()->shape_driver.CreateShaper(result);
-        if(result->shaper != NULL) {
+        if (result->shaper != NULL) {
             result->shaper->userx = x;
             result->shaper->usery = y;
             result->shaper->mode.mode = ShapeModeDefault;
             result->shaper->mode.parameters.binarizationCutoff = 1;
             result->shaper->hasshape = SDL_FALSE;
             return result;
-        }
-        else {
+        } else {
             SDL_DestroyWindow(result);
             return NULL;
         }
-    }
-    else
+    } else
         return NULL;
 }
 
 SDL_bool
 SDL_IsShapedWindow(const SDL_Window *window)
 {
-    if(window == NULL)
+    if (window == NULL)
         return SDL_FALSE;
     else
         return (SDL_bool)(window->shaper != NULL);
@@ -78,14 +76,15 @@ SDL_CalculateShapeBitmap(SDL_WindowShapeMode mode,SDL_Surface *shape,Uint8* bitm
     Uint8 *bitmap_scanline;
     SDL_Color key;
 
-    if(SDL_MUSTLOCK(shape))
+    if (SDL_MUSTLOCK(shape)) {
         SDL_LockSurface(shape);
+    }
 
     SDL_memset(bitmap, 0, shape->h * bytes_per_scanline);
 
-    for(y = 0;y<shape->h;y++) {
+    for (y = 0;y<shape->h;y++) {
         bitmap_scanline = bitmap + y * bytes_per_scanline;
-        for(x=0;x<shape->w;x++) {
+        for (x=0;x<shape->w;x++) {
             alpha = 0;
             pixel_value = 0;
             pixel = (Uint8 *)(shape->pixels) + (y*shape->pitch) + (x*shape->format->BytesPerPixel);
@@ -123,8 +122,9 @@ SDL_CalculateShapeBitmap(SDL_WindowShapeMode mode,SDL_Surface *shape,Uint8* bitm
         }
     }
 
-    if(SDL_MUSTLOCK(shape))
+    if (SDL_MUSTLOCK(shape)) {
         SDL_UnlockSurface(shape);
+    }
 }
 
 static SDL_ShapeTree*
@@ -139,8 +139,8 @@ RecursivelyCalculateShapeTree(SDL_WindowShapeMode mode,SDL_Surface* mask,SDL_Rec
     SDL_ShapeTree* result = (SDL_ShapeTree*)SDL_malloc(sizeof(SDL_ShapeTree));
     SDL_Rect next = {0,0,0,0};
 
-    for(y=dimensions.y;y<dimensions.y + dimensions.h;y++) {
-        for(x=dimensions.x;x<dimensions.x + dimensions.w;x++) {
+    for (y=dimensions.y;y<dimensions.y + dimensions.h;y++) {
+        for (x=dimensions.x;x<dimensions.x + dimensions.w;x++) {
             pixel_value = 0;
             pixel = (Uint8 *)(mask->pixels) + (y*mask->pitch) + (x*mask->format->BytesPerPixel);
             switch(mask->format->BytesPerPixel) {
@@ -173,9 +173,10 @@ RecursivelyCalculateShapeTree(SDL_WindowShapeMode mode,SDL_Surface* mask,SDL_Rec
                     pixel_opaque = ((key.r != r || key.g != g || key.b != b) ? SDL_TRUE : SDL_FALSE);
                     break;
             }
-            if(last_opaque == -1)
+            if (last_opaque == -1) {
                 last_opaque = pixel_opaque;
-            if(last_opaque != pixel_opaque) {
+            }
+            if (last_opaque != pixel_opaque) {
                 const int halfwidth = dimensions.w / 2;
                 const int halfheight = dimensions.h / 2;
 
@@ -224,11 +225,13 @@ SDL_CalculateShapeTree(SDL_WindowShapeMode mode,SDL_Surface* shape)
     dimensions.w = shape->w;
     dimensions.h = shape->h;
 
-    if(SDL_MUSTLOCK(shape))
+    if (SDL_MUSTLOCK(shape)) {
         SDL_LockSurface(shape);
+    }
     result = RecursivelyCalculateShapeTree(mode,shape,dimensions);
-    if(SDL_MUSTLOCK(shape))
+    if (SDL_MUSTLOCK(shape)) {
         SDL_UnlockSurface(shape);
+    }
     return result;
 }
 
@@ -236,20 +239,19 @@ void
 SDL_TraverseShapeTree(SDL_ShapeTree *tree,SDL_TraversalFunction function,void* closure)
 {
     SDL_assert(tree != NULL);
-    if(tree->kind == QuadShape) {
+    if (tree->kind == QuadShape) {
         SDL_TraverseShapeTree((SDL_ShapeTree *)tree->data.children.upleft,function,closure);
         SDL_TraverseShapeTree((SDL_ShapeTree *)tree->data.children.upright,function,closure);
         SDL_TraverseShapeTree((SDL_ShapeTree *)tree->data.children.downleft,function,closure);
         SDL_TraverseShapeTree((SDL_ShapeTree *)tree->data.children.downright,function,closure);
-    }
-    else
+    } else
         function(tree,closure);
 }
 
 void
 SDL_FreeShapeTree(SDL_ShapeTree** shape_tree)
 {
-    if((*shape_tree)->kind == QuadShape) {
+    if ((*shape_tree)->kind == QuadShape) {
         SDL_FreeShapeTree((SDL_ShapeTree **)(char*)&(*shape_tree)->data.children.upleft);
         SDL_FreeShapeTree((SDL_ShapeTree **)(char*)&(*shape_tree)->data.children.upright);
         SDL_FreeShapeTree((SDL_ShapeTree **)(char*)&(*shape_tree)->data.children.downleft);
@@ -318,29 +320,28 @@ SDL_SetWindowShape(SDL_Window *window,SDL_Surface *shape,SDL_WindowShapeMode *sh
 static SDL_bool
 SDL_WindowHasAShape(SDL_Window *window)
 {
-    if (window == NULL || !SDL_IsShapedWindow(window))
+    if (window == NULL || !SDL_IsShapedWindow(window)) {
         return SDL_FALSE;
+    }
     return window->shaper->hasshape;
 }
 
 int
 SDL_GetShapedWindowMode(SDL_Window *window,SDL_WindowShapeMode *shape_mode)
 {
-    if(window != NULL && SDL_IsShapedWindow(window)) {
-        if(shape_mode == NULL) {
-            if(SDL_WindowHasAShape(window))
+    if (window != NULL && SDL_IsShapedWindow(window)) {
+        if (shape_mode == NULL) {
+            if (SDL_WindowHasAShape(window))
                 /* The window given has a shape. */
                 return 0;
             else
                 /* The window given is shapeable but lacks a shape. */
                 return SDL_WINDOW_LACKS_SHAPE;
-        }
-        else {
+        } else {
             *shape_mode = window->shaper->mode;
             return 0;
         }
-    }
-    else
+    } else
         /* The window given is not a valid shapeable window. */
         return SDL_NONSHAPEABLE_WINDOW;
 }
diff --git a/src/video/SDL_surface.c b/src/video/SDL_surface.c
index 5930e4055..129debeae 100644
--- a/src/video/SDL_surface.c
+++ b/src/video/SDL_surface.c
@@ -121,7 +121,7 @@ SDL_CreateRGBSurfaceWithFormat(Uint32 flags, int width, int height, int depth,
     if (SDL_ISPIXELFORMAT_INDEXED(surface->format->format)) {
         SDL_Palette *palette =
             SDL_AllocPalette((1 << surface->format->BitsPerPixel));
-        if (!palette) {
+        if (palette == NULL) {
             SDL_FreeSurface(surface);
             return NULL;
         }
@@ -292,7 +292,7 @@ SDL_CreateRGBSurfaceWithFormatFrom(void *pixels,
 int
 SDL_SetSurfacePalette(SDL_Surface * surface, SDL_Palette * palette)
 {
-    if (!surface) {
+    if (surface == NULL) {
         return SDL_InvalidParamError("SDL_SetSurfacePalette(): surface");
     }
     if (SDL_SetPixelFormatPalette(surface->format, palette) < 0) {
@@ -308,7 +308,7 @@ SDL_SetSurfaceRLE(SDL_Surface * surface, int flag)
 {
     int flags;
 
-    if (!surface) {
+    if (surface == NULL) {
         return -1;
     }
 
@@ -327,7 +327,7 @@ SDL_SetSurfaceRLE(SDL_Surface * surface, int flag)
 SDL_bool
 SDL_HasSurfaceRLE(SDL_Surface * surface)
 {
-    if (!surface) {
+    if (surface == NULL) {
         return SDL_FALSE;
     }
 
@@ -343,7 +343,7 @@ SDL_SetColorKey(SDL_Surface * surface, int flag, Uint32 key)
 {
     int flags;
 
-    if (!surface) {
+    if (surface == NULL) {
         return SDL_InvalidParamError("surface");
     }
 
@@ -372,7 +372,7 @@ SDL_SetColorKey(SDL_Surface * surface, int flag, Uint32 key)
 SDL_bool
 SDL_HasColorKey(SDL_Surface * surface)
 {
-    if (!surface) {
+    if (surface == NULL) {
         return SDL_FALSE;
     }
 
@@ -386,7 +386,7 @@ SDL_HasColorKey(SDL_Surface * surface)
 int
 SDL_GetColorKey(SDL_Surface * surface, Uint32 * key)
 {
-    if (!surface) {
+    if (surface == NULL) {
         return SDL_InvalidParamError("surface");
     }
 
@@ -407,7 +407,7 @@ SDL_ConvertColorkeyToAlpha(SDL_Surface * surface, SDL_bool ignore_alpha)
 {
     int x, y, bpp;
 
-    if (!surface) {
+    if (surface == NULL) {
         return;
     }
 
@@ -497,7 +497,7 @@ SDL_SetSurfaceColorMod(SDL_Surface * surface, Uint8 r, Uint8 g, Uint8 b)
 {
     int flags;
 
-    if (!surface) {
+    if (surface == NULL) {
         return -1;
     }
 
@@ -521,7 +521,7 @@ SDL_SetSurfaceColorMod(SDL_Surface * surface, Uint8 r, Uint8 g, Uint8 b)
 int
 SDL_GetSurfaceColorMod(SDL_Surface * surface, Uint8 * r, Uint8 * g, Uint8 * b)
 {
-    if (!surface) {
+    if (surface == NULL) {
         return -1;
     }
 
@@ -542,7 +542,7 @@ SDL_SetSurfaceAlphaMod(SDL_Surface * surface, Uint8 alpha)
 {
     int flags;
 
-    if (!surface) {
+    if (surface == NULL) {
         return -1;
     }
 
@@ -563,7 +563,7 @@ SDL_SetSurfaceAlphaMod(SDL_Surface * surface, Uint8 alpha)
 int
 SDL_GetSurfaceAlphaMod(SDL_Surface * surface, Uint8 * alpha)
 {
-    if (!surface) {
+    if (surface == NULL) {
         return -1;
     }
 
@@ -578,7 +578,7 @@ SDL_SetSurfaceBlendMode(SDL_Surface * surface, SDL_BlendMode blendMode)
 {
     int flags, status;
 
-    if (!surface) {
+    if (surface == NULL) {
         return -1;
     }
 
@@ -616,11 +616,11 @@ SDL_SetSurfaceBlendMode(SDL_Surface * surface, SDL_BlendMode blendMode)
 int
 SDL_GetSurfaceBlendMode(SDL_Surface * surface, SDL_BlendMode *blendMode)
 {
-    if (!surface) {
+    if (surface == NULL) {
         return -1;
     }
 
-    if (!blendMode) {
+    if (blendMode == NULL) {
         return 0;
     }
 
@@ -651,7 +651,7 @@ SDL_SetClipRect(SDL_Surface * surface, const SDL_Rect * rect)
     SDL_Rect full_rect;
 
     /* Don't do anything if there's no surface to act on */
-    if (!surface) {
+    if (surface == NULL) {
         return SDL_FALSE;
     }
 
@@ -662,7 +662,7 @@ SDL_SetClipRect(SDL_Surface * surface, const SDL_Rect * rect)
     full_rect.h = surface->h;
 
     /* Set the clipping rectangle */
-    if (!rect) {
+    if (rect == NULL) {
         surface->clip_rect = full_rect;
         return SDL_TRUE;
     }
@@ -699,7 +699,7 @@ SDL_LowerBlit(SDL_Surface * src, SDL_Rect * srcrect,
         (src->format->palette &&
          src->map->src_palette_version != src->format->palette->version)) {
         if (SDL_MapSurface(src, dst) < 0) {
-            return (-1);
+            return -1;
         }
         /* just here for debugging */
 /*         printf */
@@ -707,7 +707,7 @@ SDL_LowerBlit(SDL_Surface * src, SDL_Rect * srcrect,
 /*              src, dst->flags, src->map->info.flags, dst, dst->flags, */
 /*              dst->map->info.flags, src->map->blit); */
     }
-    return (src->map->blit(src, srcrect, dst, dstrect));
+    return src->map->blit(src, srcrect, dst, dstrect);
 }
 
 
@@ -719,7 +719,7 @@ SDL_UpperBlit(SDL_Surface * src, const SDL_Rect * srcrect,
     int srcx, srcy, w, h;
 
     /* Make sure the surfaces aren't locked */
-    if (!src || !dst) {
+    if (src == NULL || dst == NULL) {
         return SDL_InvalidParamError("SDL_UpperBlit(): src/dst");
     }
     if (src->locked || dst->locked) {
@@ -746,8 +746,9 @@ SDL_UpperBlit(SDL_Surface * src, const SDL_Rect * srcrect,
             srcx = 0;
         }
         maxw = src->w - srcx;
-        if (maxw < w)
+        if (maxw < w) {
             w = maxw;
+        }
 
         srcy = srcrect->y;
         h = srcrect->h;
@@ -757,8 +758,9 @@ SDL_UpperBlit(SDL_Surface * src, const SDL_Rect * srcrect,
             srcy = 0;
         }
         maxh = src->h - srcy;
-        if (maxh < h)
+        if (maxh < h) {
             h = maxh;
+        }
 
     } else {
         srcx = srcy = 0;
@@ -778,8 +780,9 @@ SDL_UpperBlit(SDL_Surface * src, const SDL_Rect * srcrect,
             srcx += dx;
         }
         dx = dstrect->x + w - clip->x - clip->w;
-        if (dx > 0)
+        if (dx > 0) {
             w -= dx;
+        }
 
         dy = clip->y - dstrect->y;
         if (dy > 0) {
@@ -788,8 +791,9 @@ SDL_UpperBlit(SDL_Surface * src, const SDL_Rect * srcrect,
             srcy += dy;
         }
         dy = dstrect->y + h - clip->y - clip->h;
-        if (dy > 0)
+        if (dy > 0) {
             h -= dy;
+        }
     }
 
     /* Switch back to a fast blit if we were previously stretching */
@@ -830,14 +834,14 @@ SDL_PrivateUpperBlitScaled(SDL_Surface * src, const SDL_Rect * srcrect,
     int dst_w, dst_h;
 
     /* Make sure the surfaces aren't locked */
-    if (!src || !dst) {
+    if (src == NULL || dst == NULL) {
         return SDL_InvalidParamError("SDL_UpperBlitScaled(): src/dst");
     }
     if (src->locked || dst->locked) {
         return SDL_SetError("Surfaces must not be locked during blit");
     }
 
-    if (NULL == srcrect) {
+    if (srcrect == NULL) {
         src_w = src->w;
         src_h = src->h;
     } else {
@@ -845,7 +849,7 @@ SDL_PrivateUpperBlitScaled(SDL_Surface * src, const SDL_Rect * srcrect,
         src_h = srcrect->h;
     }
 
-    if (NULL == dstrect) {
+    if (dstrect == NULL) {
         dst_w = dst->w;
         dst_h = dst->h;
     } else {
@@ -861,7 +865,7 @@ SDL_PrivateUpperBlitScaled(SDL_Surface * src, const SDL_Rect * srcrect,
     scaling_w = (double)dst_w / src_w;
     scaling_h = (double)dst_h / src_h;
 
-    if (NULL == dstrect) {
+    if (dstrect == NULL) {
         dst_x0 = 0;
         dst_y0 = 0;
         dst_x1 = dst_w;
@@ -873,7 +877,7 @@ SDL_PrivateUpperBlitScaled(SDL_Surface * src, const SDL_Rect * srcrect,
         dst_y1 = dst_y0 + dst_h;
     }
 
-    if (NULL == srcrect) {
+    if (srcrect == NULL) {
         src_x0 = 0;
         src_y0 = 0;
         src_x1 = src_w;
@@ -1012,9 +1016,9 @@ SDL_PrivateLowerBlitScaled(SDL_Surface * src, SDL_Rect * srcrect,
         if ( !(src->map->info.flags & complex_copy_flags) &&
                 src->format->format == dst->format->format &&
                 !SDL_ISPIXELFORMAT_INDEXED(src->format->format) ) {
-            return SDL_SoftStretch( src, srcrect, dst, dstrect );
+            return SDL_SoftStretch(src, srcrect, dst, dstrect);
         } else {
-            return SDL_LowerBlit( src, srcrect, dst, dstrect );
+            return SDL_LowerBlit(src, srcrect, dst, dstrect);
         }
     } else {
         if ( !(src->map->info.flags & complex_copy_flags) &&
@@ -1118,7 +1122,7 @@ SDL_LockSurface(SDL_Surface * surface)
     ++surface->locked;
 
     /* Ready to go.. */
-    return (0);
+    return 0;
 }
 
 /*
@@ -1168,11 +1172,11 @@ SDL_ConvertSurface(SDL_Surface * surface, const SDL_PixelFormat * format,
     Uint8 *palette_saved_alpha = NULL;
     int palette_saved_alpha_ncolors = 0;
 
-    if (!surface) {
+    if (surface == NULL) {
         SDL_InvalidParamError("surface");
         return NULL;
     }
-    if (!format) {
+    if (format == NULL) {
         SDL_InvalidParamError("format");
         return NULL;
     }
@@ -1181,14 +1185,13 @@ SDL_ConvertSurface(SDL_Surface * surface, const SDL_PixelFormat * format,
     if (format->palette != NULL) {
         int i;
         for (i = 0; i < format->palette->ncolors; ++i) {
-            if ((format->palette->colors[i].r != 0xFF) ||
-                (format->palette->colors[i].g != 0xFF) ||
-                (format->palette->colors[i].b != 0xFF))
+            if ((format->palette->colors[i].r != 0xFF) || (format->palette->colors[i].g != 0xFF) || (format->palette->colors[i].b != 0xFF)) {
                 break;
+            }
         }
         if (i == format->palette->ncolors) {
             SDL_SetError("Empty destination palette");
-            return (NULL);
+            return NULL;
         }
     }
 
@@ -1198,7 +1201,7 @@ SDL_ConvertSurface(SDL_Surface * surface, const SDL_PixelFormat * format,
                                    format->Gmask, format->Bmask,
                                    format->Amask);
     if (convert == NULL) {
-        return (NULL);
+        return NULL;
     }
 
     /* Copy the palette if any */
@@ -1384,7 +1387,7 @@ SDL_ConvertSurface(SDL_Surface * surface, const SDL_PixelFormat * format,
     }
 
     /* We're ready to go! */
-    return (convert);
+    return convert;
 }
 
 SDL_Surface *
@@ -1455,13 +1458,13 @@ int SDL_ConvertPixels(int width, int height,
     void *nonconst_src = (void *) src;
     int ret;
 
-    if (!src) {
+    if (src == NULL) {
         return SDL_InvalidParamError("src");
     }
     if (!src_pitch) {
         return SDL_InvalidParamError("src_pitch");
     }
-    if (!dst) {
+    if (dst == NULL) {
         return SDL_InvalidParamError("dst");
     }
     if (!dst_pitch) {
@@ -1537,13 +1540,13 @@ int SDL_PremultiplyAlpha(int width, int height,
     Uint32 dstpixel;
     Uint32 dstR, dstG, dstB, dstA;
 
-    if (!src) {
+    if (src == NULL) {
         return SDL_InvalidParamError("src");
     }
     if (!src_pitch) {
         return SDL_InvalidParamError("src_pitch");
     }
-    if (!dst) {
+    if (dst == NULL) {
         return SDL_InvalidParamError("dst");
     }
     if (!dst_pitch) {
diff --git a/src/video/SDL_video.c b/src/video/SDL_video.c
index 0804c9cfb..636cff947 100644
--- a/src/video/SDL_video.c
+++ b/src/video/SDL_video.c
@@ -225,7 +225,7 @@ SDL_CreateWindowTexture(SDL_VideoDevice *_this, SDL_Window * window, Uint32 * fo
     SDL_WindowTextureData *data = SDL_GetWindowData(window, SDL_WINDOWTEXTUREDATA);
     int i;
 
-    if (!data) {
+    if (data == NULL) {
         SDL_Renderer *renderer = NULL;
         const char *hint = SDL_GetHint(SDL_HINT_FRAMEBUFFER_ACCELERATION);
         const SDL_bool specific_accelerated_renderer = (
@@ -244,7 +244,7 @@ SDL_CreateWindowTexture(SDL_VideoDevice *_this, SDL_Window * window, Uint32 * fo
                     break;
                 }
             }
-            if (!renderer || (SDL_GetRendererInfo(renderer, &info) == -1)) {
+            if (renderer == NULL || (SDL_GetRendererInfo(renderer, &info) == -1)) {
                 if (renderer) { SDL_DestroyRenderer(renderer); }
                 return SDL_SetError("Requested renderer for " SDL_HINT_FRAMEBUFFER_ACCELERATION " is not available");
             }
@@ -263,7 +263,7 @@ SDL_CreateWindowTexture(SDL_VideoDevice *_this, SDL_Window * window, Uint32 * fo
                     }
                 }
             }
-            if (!renderer) {
+            if (renderer == NULL) {
                 return SDL_SetError("No hardware accelerated renderers available");
             }
         }
@@ -272,7 +272,7 @@ SDL_CreateWindowTexture(SDL_VideoDevice *_this, SDL_Window * window, Uint32 * fo
 
         /* Create the data after we successfully create the renderer (bug #1116) */
         data = (SDL_WindowTextureData *)SDL_calloc(1, sizeof(*data));
-        if (!data) {
+        if (data == NULL) {
             SDL_DestroyRenderer(renderer);
             return SDL_OutOfMemory();
         }
@@ -345,7 +345,7 @@ SDL_UpdateWindowTexture(SDL_VideoDevice *unused, SDL_Window * window, const SDL_
     void *src;
 
     data = SDL_GetWindowData(window, SDL_WINDOWTEXTUREDATA);
-    if (!data || !data->texture) {
+    if (data == NULL || !data->texture) {
         return SDL_SetError("No window texture data");
     }
 
@@ -373,7 +373,7 @@ SDL_DestroyWindowTexture(SDL_VideoDevice *unused, SDL_Window * window)
     SDL_WindowTextureData *data;
 
     data = SDL_SetWindowData(window, SDL_WINDOWTEXTUREDATA, NULL);
-    if (!data) {
+    if (data == NULL) {
         return;
     }
     if (data->texture) {
@@ -475,7 +475,7 @@ SDL_VideoInit(const char *driver_name)
     }
     if (driver_name != NULL && *driver_name != 0) {
         const char *driver_attempt = driver_name;
-        while(driver_attempt != NULL && *driver_attempt != 0 && video == NULL) {
+        while (driver_attempt != NULL && *driver_attempt != 0 && video == NULL) {
             const char* driver_attempt_end = SDL_strchr(driver_attempt, ',');
             size_t driver_attempt_len = (driver_attempt_end != NULL) ? (driver_attempt_end - driver_attempt)
                                                                      : SDL_strlen(driver_attempt);
@@ -579,7 +579,7 @@ pre_driver_error:
 const char *
 SDL_GetCurrentVideoDriver()
 {
-    if (!_this) {
+    if (_this == NULL) {
         SDL_UninitializedVideo();
         return NULL;
     }
@@ -663,7 +663,7 @@ SDL_DelVideoDisplay(int index)
 int
 SDL_GetNumVideoDisplays(void)
 {
-    if (!_this) {
+    if (_this == NULL) {
         SDL_UninitializedVideo();
         return 0;
     }
@@ -714,7 +714,7 @@ SDL_GetDisplayBounds(int displayIndex, SDL_Rect * rect)
 
     CHECK_DISPLAY_INDEX(displayIndex, -1);
 
-    if (!rect) {
+    if (rect == NULL) {
         return SDL_InvalidParamError("rect");
     }
 
@@ -753,7 +753,7 @@ SDL_GetDisplayUsableBounds(int displayIndex, SDL_Rect * rect)
 
     CHECK_DISPLAY_INDEX(displayIndex, -1);
 
-    if (!rect) {
+    if (rect == NULL) {
         return SDL_InvalidParamError("rect");
     }
 
@@ -824,7 +824,7 @@ SDL_AddDisplayMode(SDL_VideoDisplay * display, const SDL_DisplayMode * mode)
         modes =
             SDL_realloc(modes,
                         (display->max_display_modes + 32) * sizeof(*modes));
-        if (!modes) {
+        if (modes == NULL) {
             return SDL_FALSE;
         }
         display->display_modes = modes;
@@ -899,8 +899,7 @@ SDL_GetDisplayMode(int displayIndex, int index, SDL_DisplayMode * mode)
 
     display = &_this->displays[displayIndex];
     if (index < 0 || index >= SDL_GetNumDisplayModesForDisplay(display)) {
-        return SDL_SetError("index must be in the range of 0 - %d",
-                            SDL_GetNumDisplayModesForDisplay(display) - 1);
+        return SDL_SetError("index must be in the range of 0 - %d", SDL_GetNumDisplayModesForDisplay(display) - 1);
     }
     if (mode) {
         *mode = display->display_modes[index];
@@ -946,7 +945,7 @@ SDL_GetClosestDisplayModeForDisplay(SDL_VideoDisplay * display,
     int i;
     SDL_DisplayMode *current, *match;
 
-    if (!mode || !closest) {
+    if (mode == NULL || closest == NULL) {
         SDL_InvalidParamError("mode/closest");
         return NULL;
     }
@@ -983,7 +982,7 @@ SDL_GetClosestDisplayModeForDisplay(SDL_VideoDisplay * display,
                modes may still follow. */
             continue;
         }
-        if (!match || current->w < match->w || current->h < match->h) {
+        if (match == NULL || current->w < match->w || current->h < match->h) {
             match = current;
             continue;
         }
@@ -1087,8 +1086,7 @@ SDL_SetDisplayModeForDisplay(SDL_VideoDisplay * display, const SDL_DisplayMode *
 
         /* Get a good video mode, the closest one possible */
         if (!SDL_GetClosestDisplayModeForDisplay(display, &display_mode, &display_mode)) {
-            return SDL_SetError("No video mode large enough for %dx%d",
-                                display_mode.w, display_mode.h);
+            return SDL_SetError("No video mode large enough for %dx%d", display_mode.w, display_mode.h);
         }
     } else {
         display_mode = display->desktop_mode;
@@ -1294,7 +1292,7 @@ SDL_GetWindowDisplayMode(SDL_Window * window, SDL_DisplayMode * mode)
 
     CHECK_WINDOW_MAGIC(window, -1);
 
-    if (!mode) {
+    if (mode == NULL) {
         return SDL_InvalidParamError("mode");
     }
 
@@ -1377,8 +1375,9 @@ SDL_UpdateFullscreenMode(SDL_Window * window, SDL_bool fullscreen)
        do nothing, or else we may trigger an ugly double-transition
      */
     if (SDL_strcmp(_this->name, "cocoa") == 0) {  /* don't do this for X11, etc */
-        if (window->is_destroying && (window->last_fullscreen_flags & FULLSCREEN_MASK) == SDL_WINDOW_FULLSCREEN_DESKTOP)
+        if (window->is_destroying && (window->last_fullscreen_flags & FULLSCREEN_MASK) == SDL_WINDOW_FULLSCREEN_DESKTOP) {
             return 0;
+        }
     
         /* If we're switching between a fullscreen Space and "normal" fullscreen, we need to get back to normal first. */
         if (fullscreen && ((window->last_fullscreen_flags & FULLSCREEN_MASK) == SDL_WINDOW_FULLSCREEN_DESKTOP) && ((window->flags & FULLSCREEN_MASK) == SDL_WINDOW_FULLSCREEN)) {
@@ -1597,9 +1596,8 @@ SDL_FinishWindowCreation(SDL_Window *window, Uint32 flags)
 static int
 SDL_ContextNotSupported(const char *name)
 {
-    return SDL_SetError("%s support is either not configured in SDL "
-                 "or not available in current SDL video driver "
-                 "(%s) or platform", name, _this->name);
+    return SDL_SetError("%s support is either not configured in SDL " "or not available in current SDL video driver " "(%s) or platform", name,
+                        _this->name);
 }
 
 static int
@@ -1614,7 +1612,7 @@ SDL_CreateWindow(const char *title, int x, int y, int w, int h, Uint32 flags)
     SDL_Window *window;
     Uint32 type_flags, graphics_flags;
 
-    if (!_this) {
+    if (_this == NULL) {
         /* Initialize the video system if needed */
         if (SDL_Init(SDL_INIT_VIDEO) < 0) {
             return NULL;
@@ -1691,7 +1689,7 @@ SDL_CreateWindow(const char *title, int x, int y, int w, int h, Uint32 flags)
     }
 
     window = (SDL_Window *)SDL_calloc(1, sizeof(*window));
-    if (!window) {
+    if (window == NULL) {
         SDL_OutOfMemory();
         return NULL;
     }
@@ -1807,7 +1805,7 @@ SDL_CreateWindowFrom(const void *data)
     SDL_Window *window;
     Uint32 flags = SDL_WINDOW_FOREIGN;
 
-    if (!_this) {
+    if (_this == NULL) {
         SDL_UninitializedVideo();
         return NULL;
     }
@@ -1843,7 +1841,7 @@ SDL_CreateWindowFrom(const void *data)
     }
 
     window = (SDL_Window *)SDL_calloc(1, sizeof(*window));
-    if (!window) {
+    if (window == NULL) {
         SDL_OutOfMemory();
         return NULL;
     }
@@ -2014,7 +2012,7 @@ SDL_RecreateWindow(SDL_Window * window, Uint32 flags)
 SDL_bool
 SDL_HasWindows(void)
 {
-    return (_this && _this->windows != NULL);
+    return _this && _this->windows != NULL;
 }
 
 Uint32
@@ -2030,7 +2028,7 @@ SDL_GetWindowFromID(Uint32 id)
 {
     SDL_Window *window;
 
-    if (!_this) {
+    if (_this == NULL) {
         return NULL;
     }
     for (window = _this->windows; window; window = window->next) {
@@ -2079,7 +2077,7 @@ SDL_SetWindowIcon(SDL_Window * window, SDL_Surface * icon)
 {
     CHECK_WINDOW_MAGIC(window,);
 
-    if (!icon) {
+    if (icon == NULL) {
         return;
     }
 
@@ -2372,10 +2370,10 @@ SDL_GetWindowBordersSize(SDL_Window * window, int *top, int *left, int *bottom,
 {
     int dummy = 0;
 
-    if (!top) { top = &dummy; }
-    if (!left) { left = &dummy; }
-    if (!right) { right = &dummy; }
-    if (!bottom) { bottom = &dummy; }
+    if (top == NULL) { top = &dummy; }
+    if (left == NULL) { left = &dummy; }
+    if (right == NULL) { right = &dummy; }
+    if (bottom == NULL) { bottom = &dummy; }
 
     /* Always initialize, so applications don't have to care */
     *top = *left = *bottom = *right = 0;
@@ -3027,23 +3025,21 @@ SDL_SetWindowMouseGrab(SDL_Window * window, SDL_bool grabbed)
 SDL_bool
 SDL_GetWindowGrab(SDL_Window * window)
 {
-    return (SDL_GetWindowKeyboardGrab(window) || SDL_GetWindowMouseGrab(window));
+    return SDL_GetWindowKeyboardGrab(window) || SDL_GetWindowMouseGrab(window);
 }
 
 SDL_bool
 SDL_GetWindowKeyboardGrab(SDL_Window * window)
 {
     CHECK_WINDOW_MAGIC(window, SDL_FALSE);
-    return window == _this->grabbed_window &&
-           ((_this->grabbed_window->flags & SDL_WINDOW_KEYBOARD_GRABBED) != 0);
+    return window == _this->grabbed_window && ((_this->grabbed_window->flags & SDL_WINDOW_KEYBOARD_GRABBED) != 0);
 }
 
 SDL_bool
 SDL_GetWindowMouseGrab(SDL_Window * window)
 {
     CHECK_WINDOW_MAGIC(window, SDL_FALSE);
-    return window == _this->grabbed_window &&
-           ((_this->grabbed_window->flags & SDL_WINDOW_MOUSE_GRABBED) != 0);
+    return window == _this->grabbed_window && ((_this->grabbed_window->flags & SDL_WINDOW_MOUSE_GRABBED) != 0);
 }
 
 SDL_Window *
@@ -3221,7 +3217,7 @@ ShouldMinimizeOnFocusLoss(SDL_Window * window)
 
     /* Real fullscreen windows should minimize on focus loss so the desktop video mode is restored */
     hint = SDL_GetHint(SDL_HINT_VIDEO_MINIMIZE_ON_FOCUS_LOSS);
-    if (!hint || !*hint || SDL_strcasecmp(hint, "auto") == 0) {
+    if (hint == NULL || !*hint || SDL_strcasecmp(hint, "auto") == 0) {
         if ((window->flags & SDL_WINDOW_FULLSCREEN_DESKTOP) == SDL_WINDOW_FULLSCREEN_DESKTOP ||
             DisableDisplayModeSwitching(_this) == SDL_TRUE) {
             return SDL_FALSE;
@@ -3253,7 +3249,7 @@ SDL_GetFocusWindow(void)
 {
     SDL_Window *window;
 
-    if (!_this) {
+    if (_this == NULL) {
         return NULL;
     }
     for (window = _this->windows; window; window = window->next) {
@@ -3350,7 +3346,7 @@ SDL_DestroyWindow(SDL_Window * window)
 SDL_bool
 SDL_IsScreenSaverEnabled()
 {
-    if (!_this) {
+    if (_this == NULL) {
         return SDL_TRUE;
     }
     return _this->suspend_screensaver ? SDL_FALSE : SDL_TRUE;
@@ -3359,7 +3355,7 @@ SDL_IsScreenSaverEnabled()
 void
 SDL_EnableScreenSaver()
 {
-    if (!_this) {
+    if (_this == NULL) {
         return;
     }
     if (!_this->suspend_screensaver) {
@@ -3374,7 +3370,7 @@ SDL_EnableScreenSaver()
 void
 SDL_DisableScreenSaver()
 {
-    if (!_this) {
+    if (_this == NULL) {
         return;
     }
     if (_this->suspend_screensaver) {
@@ -3391,7 +3387,7 @@ SDL_VideoQuit(void)
 {
     int i;
 
-    if (!_this) {
+    if (_this == NULL) {
         return;
     }
 
@@ -3436,7 +3432,7 @@ SDL_GL_LoadLibrary(const char *path)
 {
     int retval;
 
-    if (!_this) {
+    if (_this == NULL) {
         return SDL_UninitializedVideo();
     }
     if (_this->gl_config.driver_loaded) {
@@ -3457,7 +3453,7 @@ SDL_GL_LoadLibrary(const char *path)
             _this->GL_UnloadLibrary(_this);
         }
     }
-    return (retval);
+    return retval;
 }
 
 void *
@@ -3465,7 +3461,7 @@ SDL_GL_GetProcAddress(const char *proc)
 {
     void *func;
 
-    if (!_this) {
+    if (_this == NULL) {
         SDL_UninitializedVideo();
         return NULL;
     }
@@ -3485,7 +3481,7 @@ SDL_GL_GetProcAddress(const char *proc)
 void
 SDL_GL_UnloadLibrary(void)
 {
-    if (!_this) {
+    if (_this == NULL) {
         SDL_UninitializedVideo();
         return;
     }
@@ -3503,7 +3499,7 @@ SDL_GL_UnloadLibrary(void)
 static SDL_INLINE SDL_bool
 isAtLeastGL3(const char *verstr)
 {
-    return (verstr && (SDL_atoi(verstr) >= 3));
+    return verstr && (SDL_atoi(verstr) >= 3);
 }
 #endif
 
@@ -3530,7 +3526,7 @@ SDL_GL_ExtensionSupported(const char *extension)
     /* Lookup the available extensions */
 
     glGetStringFunc = SDL_GL_GetProcAddress("glGetString");
-    if (!glGetStringFunc) {
+    if (glGetStringFunc == NULL) {
         return SDL_FALSE;
     }
 
@@ -3542,7 +3538,7 @@ SDL_GL_ExtensionSupported(const char *extension)
 
         glGetStringiFunc = SDL_GL_GetProcAddress("glGetStringi");
         glGetIntegervFunc = SDL_GL_GetProcAddress("glGetIntegerv");
-        if ((!glGetStringiFunc) || (!glGetIntegervFunc)) {
+        if ((glGetStringiFunc == NULL) || (glGetIntegervFunc == NULL)) {
             return SDL_FALSE;
         }
 
@@ -3563,7 +3559,7 @@ SDL_GL_ExtensionSupported(const char *extension)
     /* Try the old way with glGetString(GL_EXTENSIONS) ... */
 
     extensions = (const char *) glGetStringFunc(GL_EXTENSIONS);
-    if (!extensions) {
+    if (extensions == NULL) {
         return SDL_FALSE;
     }
     /*
@@ -3575,13 +3571,16 @@ SDL_GL_ExtensionSupported(const char *extension)
 
     for (;;) {
         where = SDL_strstr(start, extension);
-        if (!where)
+        if (where == NULL) {
             break;
+        }
 
         terminator = where + SDL_strlen(extension);
-        if (where == extensions || *(where - 1) == ' ')
-            if (*terminator == ' ' || *terminator == '\0')
+        if (where == extensions || *(where - 1) == ' ') {
+            if (*terminator == ' ' || *terminator == '\0') {
                 return SDL_TRUE;
+            }
+        }
 
         start = terminator;
     }
@@ -3625,7 +3624,7 @@ SDL_GL_DeduceMaxSupportedESProfile(int* major, int* minor)
 void
 SDL_GL_ResetAttributes()
 {
-    if (!_this) {
+    if (_this == NULL) {
         return;
     }
 
@@ -3683,7 +3682,7 @@ SDL_GL_SetAttribute(SDL_GLattr attr, int value)
 #if SDL_VIDEO_OPENGL || SDL_VIDEO_OPENGL_ES || SDL_VIDEO_OPENGL_ES2
     int retval;
 
-    if (!_this) {
+    if (_this == NULL) {
         return SDL_UninitializedVideo();
     }
     retval = 0;
@@ -3822,14 +3821,14 @@ SDL_GL_GetAttribute(SDL_GLattr attr, int *value)
     GLenum attachmentattrib = 0;
 #endif
 
-    if (!value) {
+    if (value == NULL) {
         return SDL_InvalidParamError("value");
     }
 
     /* Clear value in any case */
     *value = 0;
 
-    if (!_this) {
+    if (_this == NULL) {
         return SDL_UninitializedVideo();
     }
 
@@ -3969,8 +3968,7 @@ SDL_GL_GetAttribute(SDL_GLattr attr, int *value)
         {
             if (_this->gl_config.profile_mask == SDL_GL_CONTEXT_PROFILE_ES) {
                 *value = 1;
-            }
-            else {
+            } else {
                 *value = 0;
             }
             return 0;
@@ -4006,7 +4004,7 @@ SDL_GL_GetAttribute(SDL_GLattr attr, int *value)
 
 #if SDL_VIDEO_OPENGL
     glGetStringFunc = SDL_GL_GetProcAddress("glGetString");
-    if (!glGetStringFunc) {
+    if (glGetStringFunc == NULL) {
         return -1;
     }
 
@@ -4044,7 +4042,7 @@ SDL_GL_GetAttribute(SDL_GLattr attr, int *value)
     }
 
     glGetErrorFunc = SDL_GL_GetProcAddress("glGetError");
-    if (!glGetErrorFunc) {
+    if (glGetErrorFunc == NULL) {
         return -1;
     }
 
@@ -4093,7 +4091,7 @@ SDL_GL_MakeCurrent(SDL_Window * window, SDL_GLContext ctx)
 {
     int retval;
 
-    if (!_this) {
+    if (_this == NULL) {
         return SDL_UninitializedVideo();
     }
 
@@ -4128,7 +4126,7 @@ SDL_GL_MakeCurrent(SDL_Window * window, SDL_GLContext ctx)
 SDL_Window *
 SDL_GL_GetCurrentWindow(void)
 {
-    if (!_this) {
+    if (_this == NULL) {
         SDL_UninitializedVideo();
         return NULL;
     }
@@ -4138,7 +4136,7 @@ SDL_GL_GetCurrentWindow(void)
 SDL_GLContext
 SDL_GL_GetCurrentContext(void)
 {
-    if (!_this) {
+    if (_this == NULL) {
         SDL_UninitializedVideo();
         return NULL;
     }
@@ -4159,7 +4157,7 @@ void SDL_GL_GetDrawableSize(SDL_Window * window, int *w, int *h)
 int
 SDL_GL_SetSwapInterval(int interval)
 {
-    if (!_this) {
+    if (_this == NULL) {
         return SDL_UninitializedVideo();
     } else if (SDL_GL_GetCurrentContext() == NULL) {
         return SDL_SetError("No OpenGL context has been made current");
@@ -4173,7 +4171,7 @@ SDL_GL_SetSwapInterval(int interval)
 int
 SDL_GL_GetSwapInterval(void)
 {
-    if (!_this) {
+    if (_this == NULL) {
         return 0;
     } else if (SDL_GL_GetCurrentContext() == NULL) {
         return 0;
@@ -4209,7 +4207,7 @@ SDL_GL_SwapWindow(SDL_Window * window)
 void
 SDL_GL_DeleteContext(SDL_GLContext context)
 {
-    if (!_this || !context) {
+    if (_this == NULL || !context) {
         return;
     }
 
@@ -4379,7 +4377,7 @@ SDL_IsTextInputShown(void)
 SDL_bool
 SDL_IsTextInputActive(void)
 {
-    return (SDL_GetEventState(SDL_TEXTINPUT) == SDL_ENABLE);
+    return SDL_GetEventState(SDL_TEXTINPUT) == SDL_ENABLE;
 }
 
 void
@@ -4498,7 +4496,7 @@ SDL_ShowMessageBox(const SDL_MessageBoxData *messageboxdata, int *buttonid)
     SDL_Window *current_window;
     SDL_MessageBoxData mbdata;
 
-    if (!messageboxdata) {
+    if (messageboxdata == NULL) {
         return SDL_InvalidParamError("messageboxdata");
     } else if (messageboxdata->numbuttons < 0) {
         return SDL_SetError("Invalid number of buttons");
@@ -4513,13 +4511,17 @@ SDL_ShowMessageBox(const SDL_MessageBoxData *messageboxdata, int *buttonid)
     show_cursor_prev = SDL_ShowCursor(1);
     SDL_ResetKeyboard();
 
-    if (!buttonid) {
+    if (buttonid == NULL) {
         buttonid = &dummybutton;
     }
 
     SDL_memcpy(&mbdata, messageboxdata, sizeof(*messageboxdata));
-    if (!mbdata.title) mbdata.title = "";
-    if (!mbdata.message) mbdata.message = "";
+    if (!mbdata.title) {
+        mbdata.title = "";
+    }
+    if (!mbdata.message) {
+        mbdata.message = "";
+    }
     messageboxdata = &mbdata;
 
     SDL_ClearError();
@@ -4633,8 +4635,12 @@ SDL_ShowSimpleMessageBox(Uint32 flags, const char *title, const char *message, S
     /* Web browsers don't (currently) have an API for a custom message box
        that can block, but for the most common case (SDL_ShowSimpleMessageBox),
        we can use the standard Javascript alert() function. */
-    if (!title) title = "";
-    if (!message) message = "";
+    if (title == NULL) {
+        title = "";
+    }
+    if (message == NULL) {
+        message = "";
+    }
     EM_ASM_({
         alert(UTF8ToString($0) + "\n\n" + UTF8ToString($1));
     }, title, message);
@@ -4691,8 +4697,7 @@ SDL_ComputeDiagonalDPI(int hpix, int vpix, float hinches, float vinches)
         return 0.0f;
     }
 
-    return (float)(SDL_sqrt((double)hpix * (double)hpix + (double)vpix * (double)vpix) /
-                   SDL_sqrt((double)den2));
+    return (float)(SDL_sqrt((double)hpix * (double)hpix + (double)vpix * (double)vpix) / SDL_sqrt((double)den2));
 }
 
 /*
@@ -4748,7 +4753,7 @@ void SDL_OnApplicationDidBecomeActive(void)
 int SDL_Vulkan_LoadLibrary(const char *path)
 {
     int retval;
-    if (!_this) {
+    if (_this == NULL) {
         SDL_UninitializedVideo();
         return -1;
     }
@@ -4771,7 +4776,7 @@ int SDL_Vulkan_LoadLibrary(const char *path)
 
 void *SDL_Vulkan_GetVkGetInstanceProcAddr(void)
 {
-    if (!_this) {
+    if (_this == NULL) {
         SDL_UninitializedVideo();
         return NULL;
     }
@@ -4784,7 +4789,7 @@ void *SDL_Vulkan_GetVkGetInstanceProcAddr(void)
 
 void SDL_Vulkan_UnloadLibrary(void)
 {
-    if (!_this) {
+    if (_this == NULL) {
         SDL_UninitializedVideo();
         return;
     }
@@ -4803,14 +4808,13 @@ SDL_bool SDL_Vulkan_GetInstanceExtensions(SDL_Window *window, unsigned *count, c
     if (window) {
         CHECK_WINDOW_MAGIC(window, SDL_FALSE);
 
-        if (!(window->flags & SDL_WINDOW_VULKAN))
-        {
+        if (!(window->flags & SDL_WINDOW_VULKAN)) {
             SDL_SetError(NOT_A_VULKAN_WINDOW);
             return SDL_FALSE;
         }
     }
 
-    if (!count) {
+    if (count == NULL) {
         SDL_InvalidParamError("count");
         return SDL_FALSE;
     }
@@ -4834,7 +4838,7 @@ SDL_bool SDL_Vulkan_CreateSurface(SDL_Window *window,
         return SDL_FALSE;
     }
 
-    if (!surface) {
+    if (surface == NULL) {
         SDL_InvalidParamError("surface");
         return SDL_FALSE;
     }
diff --git a/src/video/SDL_vulkan_utils.c b/src/video/SDL_vulkan_utils.c
index 33761a591..c7176e3dc 100644
--- a/src/video/SDL_vulkan_utils.c
+++ b/src/video/SDL_vulkan_utils.c
@@ -149,7 +149,7 @@ VkExtensionProperties *SDL_Vulkan_CreateInstanceExtensionsList(
         retval = SDL_calloc(count, sizeof(VkExtensionProperties));
     }
 
-    if (!retval) {
+    if (retval == NULL) {
         SDL_OutOfMemory();
         return NULL;
     }
@@ -249,7 +249,7 @@ SDL_bool SDL_Vulkan_Display_CreateSurface(void *vkGetInstanceProcAddr_,
     }
 
     physicalDevices = SDL_malloc(sizeof(VkPhysicalDevice) * physicalDeviceCount);
-    if (!physicalDevices) {
+    if (physicalDevices == NULL) {
         SDL_OutOfMemory();
         goto error;
     }
@@ -292,7 +292,7 @@ SDL_bool SDL_Vulkan_Display_CreateSurface(void *vkGetInstanceProcAddr_,
         }
 
         displayProperties = SDL_malloc(sizeof(VkDisplayPropertiesKHR) * displayPropertiesCount);
-        if (!displayProperties) {
+        if (displayProperties == NULL) {
             SDL_OutOfMemory();
             goto error;
         }
@@ -314,15 +314,14 @@ SDL_bool SDL_Vulkan_Display_CreateSurface(void *vkGetInstanceProcAddr_,
 
         /* Get display mode properties for the chosen display */
         result = vkGetDisplayModePropertiesKHR(physicalDevice, display, &displayModePropertiesCount, NULL);
-        if (result != VK_SUCCESS || displayModePropertiesCount == 0)
-        {
+        if (result != VK_SUCCESS || displayModePropertiesCount == 0) {
             SDL_SetError("Error enumerating display modes");
             goto error;
         }
         SDL_LogDebug(SDL_LOG_CATEGORY_VIDEO, "vulkandisplay: Number of display modes: %u", displayModePropertiesCount);
 
         displayModeProperties = SDL_malloc(sizeof(VkDisplayModePropertiesKHR) * displayModePropertiesCount);
-        if (!displayModeProperties) {
+        if (displayModeProperties == NULL) {
             SDL_OutOfMemory();
             goto error;
         }
@@ -369,7 +368,7 @@ SDL_bool SDL_Vulkan_Display_CreateSurface(void *vkGetInstanceProcAddr_,
         SDL_LogDebug(SDL_LOG_CATEGORY_VIDEO, "vulkandisplay: Number of display planes: %u", displayPlanePropertiesCount);
 
         displayPlaneProperties = SDL_malloc(sizeof(VkDisplayPlanePropertiesKHR) * displayPlanePropertiesCount);
-        if (!displayPlaneProperties) {
+        if (displayPlaneProperties == NULL) {
             SDL_OutOfMemory();
             goto error;
         }
@@ -400,7 +399,7 @@ SDL_bool SDL_Vulkan_Display_CreateSurface(void *vkGetInstanceProcAddr_,
             SDL_LogDebug(SDL_LOG_CATEGORY_VIDEO, "vulkandisplay: Number of supported displays for plane %u: %u", i, planeSupportedDisplaysCount);
 
             planeSupportedDisplays = SDL_malloc(sizeof(VkDisplayKHR) * planeSupportedDisplaysCount);
-            if (!planeSupportedDisplays) {
+            if (planeSupportedDisplays == NULL) {
                 SDL_free(displayPlaneProperties);
                 SDL_OutOfMemory();
                 goto error;
@@ -414,8 +413,7 @@ SDL_bool SDL_Vulkan_Display_CreateSurface(void *vkGetInstanceProcAddr_,
                 goto error;
             }
 
-            for (j = 0; j < planeSupportedDisplaysCount && planeSupportedDisplays[j] != display; ++j)
-            {
+            for (j = 0; j < planeSupportedDisplaysCount && planeSupportedDisplays[j] != display; ++j) {
             }
 
             SDL_free(planeSupportedDisplays);
diff --git a/src/video/SDL_yuv.c b/src/video/SDL_yuv.c
index 38cf9e733..be3ee0c57 100644
--- a/src/video/SDL_yuv.c
+++ b/src/video/SDL_yuv.c
@@ -78,17 +78,12 @@ static int GetYUVConversionType(int width, int height, YCbCrType *yuv_type)
 
 static SDL_bool IsPlanar2x2Format(Uint32 format)
 {
-    return (format == SDL_PIXELFORMAT_YV12 ||
-            format == SDL_PIXELFORMAT_IYUV ||
-            format == SDL_PIXELFORMAT_NV12 ||
-            format == SDL_PIXELFORMAT_NV21);
+    return format == SDL_PIXELFORMAT_YV12 || format == SDL_PIXELFORMAT_IYUV || format == SDL_PIXELFORMAT_NV12 || format == SDL_PIXELFORMAT_NV21;
 }
 
 static SDL_bool IsPacked4Format(Uint32 format)
 {
-    return (format == SDL_PIXELFORMAT_YUY2 ||
-            format == SDL_PIXELFORMAT_UYVY ||
-            format == SDL_PIXELFORMAT_YVYU);
+    return format == SDL_PIXELFORMAT_YUY2 || format == SDL_PIXELFORMAT_UYVY || format == SDL_PIXELFORMAT_YVYU;
 }
 
 static int GetYUVPlanes(int width, int height, Uint32 format, const void *yuv, int yuv_pitch,
@@ -629,8 +624,7 @@ SDL_ConvertPixels_ARGB8888_to_YUV(int width, int height, const void *src, int sr
             next_row = (const Uint8*)src;
             next_row += src_pitch;
 
-            if (dst_format == SDL_PIXELFORMAT_YV12 || dst_format == SDL_PIXELFORMAT_IYUV)
-            {
+            if (dst_format == SDL_PIXELFORMAT_YV12 || dst_format == SDL_PIXELFORMAT_IYUV) {
                 /* Write UV planes, not interleaved */
                 uv_skip = (uv_stride - (width + 1)/2);
                 for (j = 0; j < height_half; j++) {
@@ -663,9 +657,7 @@ SDL_ConvertPixels_ARGB8888_to_YUV(int width, int height, const void *src, int sr
                     plane_u += uv_skip;
                     plane_v += uv_skip;
                 }
-            }
-            else if (dst_format == SDL_PIXELFORMAT_NV12)
-            {
+            } else if (dst_format == SDL_PIXELFORMAT_NV12) {
                 uv_skip = (uv_stride - ((width + 1)/2)*2);
                 for (j = 0; j < height_half; j++) {
                     for (i = 0; i < width_half; i++) {
@@ -694,9 +686,7 @@ SDL_ConvertPixels_ARGB8888_to_YUV(int width, int height, const void *src, int sr
                         *plane_interleaved_uv++ = MAKE_V(r, g, b);
                     }
                 }
-            } 
-            else /* dst_format == SDL_PIXELFORMAT_NV21 */
-            {
+            } else /* dst_format == SDL_PIXELFORMAT_NV21 */ {
                 uv_skip = (uv_stride - ((width + 1)/2)*2);
                 for (j = 0; j < height_half; j++) {
                     for (i = 0; i < width_half; i++) {
@@ -744,8 +734,7 @@ SDL_ConvertPixels_ARGB8888_to_YUV(int width, int height, const void *src, int sr
             plane_skip = (dst_pitch - row_size);
 
             /* Write YUV plane, packed */
-            if (dst_format == SDL_PIXELFORMAT_YUY2) 
-            {
+            if (dst_format == SDL_PIXELFORMAT_YUY2) {
                 for (j = 0; j < height; j++) {
                     for (i = 0; i < width_half; i++) {
                         READ_TWO_RGB_PIXELS;
@@ -766,9 +755,7 @@ SDL_ConvertPixels_ARGB8888_to_YUV(int width, int height, const void *src, int sr
                     plane += plane_skip;
                     curr_row += src_pitch;
                 }
-            } 
-            else if (dst_format == SDL_PIXELFORMAT_UYVY)
-            {
+            } else if (dst_format == SDL_PIXELFORMAT_UYVY) {
                 for (j = 0; j < height; j++) {
                     for (i = 0; i < width_half; i++) {
                         READ_TWO_RGB_PIXELS;
@@ -789,9 +776,7 @@ SDL_ConvertPixels_ARGB8888_to_YUV(int width, int height, const void *src, int sr
                     plane += plane_skip;
                     curr_row += src_pitch;
                 }
-            }
-            else if (dst_format == SDL_PIXELFORMAT_YVYU)
-            {
+            } else if (dst_format == SDL_PIXELFORMAT_YVYU) {
                 for (j = 0; j < height; j++) {
                     for (i = 0; i < width_half; i++) {
                         READ_TWO_RGB_PIXELS;
@@ -962,7 +947,7 @@ SDL_ConvertPixels_SwapUVPlanes(int width, int height, const void *src, int src_p
 
         /* Allocate a temporary row for the swap */
         tmp = (Uint8 *)SDL_malloc(UVwidth);
-        if (!tmp) {
+        if (tmp == NULL) {
             return SDL_OutOfMemory();
         }
         for (y = 0; y < UVheight; ++y) {
@@ -1023,7 +1008,7 @@ SDL_ConvertPixels_PackUVPlanes_to_NV(int width, int height, const void *src, int
     if (src == dst) {
         /* Need to make a copy of the buffer so we don't clobber it while converting */
         tmp = (Uint8 *)SDL_malloc(2*UVheight*srcUVPitch);
-        if (!tmp) {
+        if (tmp == NULL) {
             return SDL_OutOfMemory();
         }
         SDL_memcpy(tmp, src, 2*UVheight*srcUVPitch);
@@ -1097,7 +1082,7 @@ SDL_ConvertPixels_SplitNV_to_UVPlanes(int width, int height, const void *src, in
     if (src == dst) {
         /* Need to make a copy of the buffer so we don't clobber it while converting */
         tmp = (Uint8 *)SDL_malloc(UVheight*srcUVPitch);
-        if (!tmp) {
+        if (tmp == NULL) {
             return SDL_OutOfMemory();
         }
         SDL_memcpy(tmp, src, UVheight*srcUVPitch);
@@ -1269,7 +1254,8 @@ SDL_ConvertPixels_Planar2x2_to_Planar2x2(int width, int height,
     default:
         break;
     }
-    return SDL_SetError("SDL_ConvertPixels_Planar2x2_to_Planar2x2: Unsupported YUV conversion: %s -> %s", SDL_GetPixelFormatName(src_format), SDL_GetPixelFormatName(dst_format));
+    return SDL_SetError("SDL_ConvertPixels_Planar2x2_to_Planar2x2: Unsupported YUV conversion: %s -> %s", SDL_GetPixelFormatName(src_format),
+                        SDL_GetPixelFormatName(dst_format));
 }
 
 #ifdef __SSE2__
@@ -1582,7 +1568,8 @@ SDL_ConvertPixels_Packed4_to_Packed4(int width, int height,
     default:
         break;
     }
-    return SDL_SetError("SDL_ConvertPixels_Packed4_to_Packed4: Unsupported YUV conversion: %s -> %s", SDL_GetPixelFormatName(src_format), SDL_GetPixelFormatName(dst_format));
+    return SDL_SetError("SDL_ConvertPixels_Packed4_to_Packed4: Unsupported YUV conversion: %s -> %s", SDL_GetPixelFormatName(src_format),
+                        SDL_GetPixelFormatName(dst_format));
 }
 
 static int
@@ -1885,7 +1872,8 @@ SDL_ConvertPixels_YUV_to_YUV(int width, int height,
     } else if (IsPacked4Format(src_format) && IsPlanar2x2Format(dst_format)) {
         return SDL_ConvertPixels_Packed4_to_Planar2x2(width, height, src_format, src, src_pitch, dst_format, dst, dst_pitch);
     } else {
-        return SDL_SetError("SDL_ConvertPixels_YUV_to_YUV: Unsupported YUV conversion: %s -> %s", SDL_GetPixelFormatName(src_format), SDL_GetPixelFormatName(dst_format));
+        return SDL_SetError("SDL_ConvertPixels_YUV_to_YUV: Unsupported YUV conversion: %s -> %s", SDL_GetPixelFormatName(src_format),
+                            SDL_GetPixelFormatName(dst_format));
     }
 #else
     return SDL_SetError("SDL not built with YUV support");
diff --git a/src/video/android/SDL_androidkeyboard.c b/src/video/android/SDL_androidkeyboard.c
index 3a05eb445..07f9672c4 100644
--- a/src/video/android/SDL_androidkeyboard.c
+++ b/src/video/android/SDL_androidkeyboard.c
@@ -369,7 +369,7 @@ Android_SetTextInputRect(_THIS, const SDL_Rect *rect)
 {
     SDL_VideoData *videodata = (SDL_VideoData *)_this->driverdata;
 
-    if (!rect) {
+    if (rect == NULL) {
         SDL_InvalidParamError("rect");
         return;
     }
diff --git a/src/video/android/SDL_androidmouse.c b/src/video/android/SDL_androidmouse.c
index 38953fa07..139a7348c 100644
--- a/src/video/android/SDL_androidmouse.c
+++ b/src/video/android/SDL_androidmouse.c
@@ -92,7 +92,7 @@ Android_CreateCursor(SDL_Surface * surface, int hot_x, int hot_y)
     SDL_Surface *converted;
 
     converted = SDL_ConvertSurfaceFormat(surface, SDL_PIXELFORMAT_ARGB8888, 0);
-    if (!converted) {
+    if (converted == NULL) {
         return NULL;
     }
     custom_cursor = Android_JNI_CreateCustomCursor(converted, hot_x, hot_y);
@@ -124,7 +124,7 @@ Android_FreeCursor(SDL_Cursor * cursor)
 static SDL_Cursor *
 Android_CreateEmptyCursor()
 {
-    if (!empty_cursor) {
+    if (empty_cursor == NULL) {
         SDL_Surface *empty_surface = SDL_CreateRGBSurfaceWithFormat(0, 1, 1, 32, SDL_PIXELFORMAT_ARGB8888);
         if (empty_surface) {
             SDL_memset(empty_surface->pixels, 0, empty_surface->h * empty_surface->pitch);
@@ -147,7 +147,7 @@ Android_DestroyEmptyCursor()
 static int
 Android_ShowCursor(SDL_Cursor *cursor)
 {
-    if (!cursor) {
+    if (cursor == NULL) {
         cursor = Android_CreateEmptyCursor();
     }
     if (cursor) {
@@ -229,7 +229,7 @@ Android_OnMouse(SDL_Window *window, int state, int action, float x, float y, SDL
     int changes;
     Uint8 button;
 
-    if (!window) {
+    if (window == NULL) {
         return;
     }
 
diff --git a/src/video/android/SDL_androidtouch.c b/src/video/android/SDL_androidtouch.c
index 24d985b0e..02c50356d 100644
--- a/src/video/android/SDL_androidtouch.c
+++ b/src/video/android/SDL_androidtouch.c
@@ -54,7 +54,7 @@ void Android_OnTouch(SDL_Window *window, int touch_device_id_in, int pointer_fin
     SDL_TouchID touchDeviceId = 0;
     SDL_FingerID fingerId = 0;
 
-    if (!window) {
+    if (window == NULL) {
         return;
     }
 
diff --git a/src/video/android/SDL_androidvideo.c b/src/video/android/SDL_androidvideo.c
index 3ed828fde..62354fe41 100644
--- a/src/video/android/SDL_androidvideo.c
+++ b/src/video/android/SDL_androidvideo.c
@@ -92,13 +92,13 @@ Android_CreateDevice(void)
 
     /* Initialize all variables that we clean on shutdown */
     device = (SDL_VideoDevice *) SDL_calloc(1, sizeof(SDL_VideoDevice));
-    if (!device) {
+    if (device == NULL) {
         SDL_OutOfMemory();
         return NULL;
     }
 
     data = (SDL_VideoData *) SDL_calloc(1, sizeof(SDL_VideoData));
-    if (!data) {
+    if (data == NULL) {
         SDL_OutOfMemory();
         SDL_free(device);
         return NULL;
@@ -283,8 +283,7 @@ void Android_SendResize(SDL_Window *window)
       which can happen after VideoInit().
     */
     SDL_VideoDevice *device = SDL_GetVideoDevice();
-    if (device && device->num_displays > 0)
-    {
+    if (device && device->num_displays > 0) {
         SDL_VideoDisplay *display          = &device->displays[0];
         display->desktop_mode.format       = Android_ScreenFormat;
         display->desktop_mode.w            = Android_DeviceWidth;
diff --git a/src/video/android/SDL_androidvulkan.c b/src/video/android/SDL_androidvulkan.c
index 058165f57..09c44b1f5 100644
--- a/src/video/android/SDL_androidvulkan.c
+++ b/src/video/android/SDL_androidvulkan.c
@@ -42,51 +42,56 @@ int Android_Vulkan_LoadLibrary(_THIS, const char *path)
     SDL_bool hasSurfaceExtension = SDL_FALSE;
     SDL_bool hasAndroidSurfaceExtension = SDL_FALSE;
     PFN_vkGetInstanceProcAddr vkGetInstanceProcAddr = NULL;
-    if(_this->vulkan_config.loader_handle)
+    if (_this->vulkan_config.loader_handle) {
         return SDL_SetError("Vulkan already loaded");
+    }
 
     /* Load the Vulkan loader library */
-    if(!path)
+    if (path == NULL) {
         path = SDL_getenv("SDL_VULKAN_LIBRARY");
-    if(!path)
+    }
+    if (path == NULL) {
         path = "libvulkan.so";
+    }
     _this->vulkan_config.loader_handle = SDL_LoadObject(path);
-    if(!_this->vulkan_config.loader_handle)
+    if (!_this->vulkan_config.loader_handle) {
         return -1;
+    }
     SDL_strlcpy(_this->vulkan_config.loader_path, path,
                 SDL_arraysize(_this->vulkan_config.loader_path));
     vkGetInstanceProcAddr = (PFN_vkGetInstanceProcAddr)SDL_LoadFunction(
         _this->vulkan_config.loader_handle, "vkGetInstanceProcAddr");
-    if(!vkGetInstanceProcAddr)
+    if (!vkGetInstanceProcAddr) {
         goto fail;
+    }
     _this->vulkan_config.vkGetInstanceProcAddr = (void *)vkGetInstanceProcAddr;
     _this->vulkan_config.vkEnumerateInstanceExtensionProperties =
         (void *)((PFN_vkGetInstanceProcAddr)_this->vulkan_config.vkGetInstanceProcAddr)(
             VK_NULL_HANDLE, "vkEnumerateInstanceExtensionProperties");
-    if(!_this->vulkan_config.vkEnumerateInstanceExtensionProperties)
+    if (!_this->vulkan_config.vkEnumerateInstanceExtensionProperties) {
         goto fail;
+    }
     extensions = SDL_Vulkan_CreateInstanceExtensionsList(
         (PFN_vkEnumerateInstanceExtensionProperties)
             _this->vulkan_config.vkEnumerateInstanceExtensionProperties,
         &extensionCount);
-    if(!extensions)
+    if (extensions == NULL) {
         goto fail;
-    for(i = 0; i < extensionCount; i++)
+    }
+    for (i = 0; i < extensionCount; i++)
     {
-        if(SDL_strcmp(VK_KHR_SURFACE_EXTENSION_NAME, extensions[i].extensionName) == 0)
+        if (SDL_strcmp(VK_KHR_SURFACE_EXTENSION_NAME, extensions[i].extensionName) == 0) {
             hasSurfaceExtension = SDL_TRUE;
-        else if(SDL_strcmp(VK_KHR_ANDROID_SURFACE_EXTENSION_NAME, extensions[i].extensionName) == 0)
+        } else if (SDL_strcmp(VK_KHR_ANDROID_SURFACE_EXTENSION_NAME, extensions[i].extensionName) == 0) {
             hasAndroidSurfaceExtension = SDL_TRUE;
+        }
     }
     SDL_free(extensions);
-    if(!hasSurfaceExtension)
-    {
+    if (!hasSurfaceExtension) {
         SDL_SetError("Installed Vulkan doesn't implement the "
                      VK_KHR_SURFACE_EXTENSION_NAME " extension");
         goto fail;
-    }
-    else if(!hasAndroidSurfaceExtension)
-    {
+    } else if (!hasAndroidSurfaceExtension) {
         SDL_SetError("Installed Vulkan doesn't implement the "
                      VK_KHR_ANDROID_SURFACE_EXTENSION_NAME "extension");
         goto fail;
@@ -101,8 +106,7 @@ fail:
 
 void Android_Vulkan_UnloadLibrary(_THIS)
 {
-    if(_this->vulkan_config.loader_handle)
-    {
+    if (_this->vulkan_config.loader_handle) {
         SDL_UnloadObject(_this->vulkan_config.loader_handle);
         _this->vulkan_config.loader_handle = NULL;
     }
@@ -116,8 +120,7 @@ SDL_bool Android_Vulkan_GetInstanceExtensions(_THIS,
     static const char *const extensionsForAndroid[] = {
         VK_KHR_SURFACE_EXTENSION_NAME, VK_KHR_ANDROID_SURFACE_EXTENSION_NAME
     };
-    if(!_this->vulkan_config.loader_handle)
-    {
+    if (!_this->vulkan_config.loader_handle) {
         SDL_SetError("Vulkan is not loaded");
         return SDL_FALSE;
     }
@@ -141,14 +144,12 @@ SDL_bool Android_Vulkan_CreateSurface(_THIS,
     VkAndroidSurfaceCreateInfoKHR createInfo;
     VkResult result;
 
-    if(!_this->vulkan_config.loader_handle)
-    {
+    if (!_this->vulkan_config.loader_handle) {
         SDL_SetError("Vulkan is not loaded");
         return SDL_FALSE;
     }
 
-    if(!vkCreateAndroidSurfaceKHR)
-    {
+    if (!vkCreateAndroidSurfaceKHR) {
         SDL_SetError(VK_KHR_ANDROID_SURFACE_EXTENSION_NAME
                      " extension is not enabled in the Vulkan instance.");
         return SDL_FALSE;
@@ -160,8 +161,7 @@ SDL_bool Android_Vulkan_CreateSurface(_THIS,
     createInfo.window = windowData->native_window;
     result = vkCreateAndroidSurfaceKHR(instance, &createInfo,
                                        NULL, surface);
-    if(result != VK_SUCCESS)
-    {
+    if (result != VK_SUCCESS) {
         SDL_SetError("vkCreateAndroidSurfaceKHR failed: %s",
                      SDL_Vulkan_GetResultString(result));
         return SDL_FALSE;
diff --git a/src/video/android/SDL_androidwindow.c b/src/video/android/SDL_androidwindow.c
index 21bedca7d..b94c38dff 100644
--- a/src/video/android/SDL_androidwindow.c
+++ b/src/video/android/SDL_androidwindow.c
@@ -66,7 +66,7 @@ Android_CreateWindow(_THIS, SDL_Window * window)
     SDL_SetKeyboardFocus(window);
 
     data = (SDL_WindowData *) SDL_calloc(1, sizeof(*data));
-    if (!data) {
+    if (data == NULL) {
         retval = SDL_OutOfMemory();
         goto endfunction;
     }
@@ -135,7 +135,7 @@ Android_SetWindowFullscreen(_THIS, SDL_Window *window, SDL_VideoDisplay *display
         }
 
         data = (SDL_WindowData *)window->driverdata;
-        if (!data || !data->native_window) {
+        if (data == NULL || !data->native_window) {
             if (data && !data->native_window) {
                 SDL_SetError("Missing native window");
             }
diff --git a/src/video/dummy/SDL_nullframebuffer.c b/src/video/dummy/SDL_nullframebuffer.c
index dd7cbbd16..16b5db8de 100644
--- a/src/video/dummy/SDL_nullframebuffer.c
+++ b/src/video/dummy/SDL_nullframebuffer.c
@@ -40,7 +40,7 @@ int SDL_DUMMY_CreateWindowFramebuffer(_THIS, SDL_Window * window, Uint32 * forma
     /* Create a new one */
     SDL_GetWindowSize(window, &w, &h);
     surface = SDL_CreateRGBSurfaceWithFormat(0, w, h, 0, surface_format);
-    if (!surface) {
+    if (surface == NULL) {
         return -1;
     }
 
@@ -58,7 +58,7 @@ int SDL_DUMMY_UpdateWindowFramebuffer(_THIS, SDL_Window * window, const SDL_Rect
     SDL_Surface *surface;
 
     surface = (SDL_Surface *) SDL_GetWindowData(window, DUMMY_SURFACE);
-    if (!surface) {
+    if (surface == NULL) {
         return SDL_SetError("Couldn't find dummy surface for window");
     }
 
diff --git a/src/video/dummy/SDL_nullvideo.c b/src/video/dummy/SDL_nullvideo.c
index df6c769cf..e9417350f 100644
--- a/src/video/dummy/SDL_nullvideo.c
+++ b/src/video/dummy/SDL_nullvideo.c
@@ -93,14 +93,14 @@ DUMMY_CreateDevice(void)
     SDL_VideoDevice *device;
 
     if (!DUMMY_Available()) {
-        return (0);
+        return 0;
     }
 
     /* Initialize all variables that we clean on shutdown */
     device = (SDL_VideoDevice *) SDL_calloc(1, sizeof(SDL_VideoDevice));
-    if (!device) {
+    if (device == NULL) {
         SDL_OutOfMemory();
-        return (0);
+        return 0;
     }
     device->is_dummy = SDL_TRUE;
 
diff --git a/src/video/emscripten/SDL_emscriptenevents.c b/src/video/emscripten/SDL_emscriptenevents.c
index deb12b47a..cba2ae5b0 100644
--- a/src/video/emscripten/SDL_emscriptenevents.c
+++ b/src/video/emscripten/SDL_emscriptenevents.c
@@ -773,8 +773,9 @@ Emscripten_HandleTouch(int eventType, const EmscriptenTouchEvent *touchEvent, vo
         SDL_FingerID id;
         float x, y;
 
-        if (!touchEvent->touches[i].isChanged)
+        if (!touchEvent->touches[i].isChanged) {
             continue;
+        }
 
         id = touchEvent->touches[i].identifier;
         x = touchEvent->touches[i].targetX / client_w;
@@ -858,14 +859,11 @@ Emscripten_HandleFullscreenChange(int eventType, const EmscriptenFullscreenChang
     SDL_WindowData *window_data = userData;
     SDL_VideoDisplay *display;
 
-    if(fullscreenChangeEvent->isFullscreen)
-    {
+    if (fullscreenChangeEvent->isFullscreen) {
         window_data->window->flags |= window_data->requested_fullscreen_mode;
 
         window_data->requested_fullscreen_mode = 0;
-    }
-    else
-    {
+    } else {
         window_data->window->flags &= ~FULLSCREEN_MASK;
 
         /* reset fullscreen window if the browser left fullscreen */
@@ -893,15 +891,13 @@ Emscripten_HandleResize(int eventType, const EmscriptenUiEvent *uiEvent, void *u
         }
     }
 
-    if(!(window_data->window->flags & FULLSCREEN_MASK))
-    {
+    if (!(window_data->window->flags & FULLSCREEN_MASK)) {
         /* this will only work if the canvas size is set through css */
-        if(window_data->window->flags & SDL_WINDOW_RESIZABLE)
-        {
+        if (window_data->window->flags & SDL_WINDOW_RESIZABLE) {
             double w = window_data->window->w;
             double h = window_data->window->h;
 
-            if(window_data->external_size) {
+            if (window_data->external_size) {
                 emscripten_get_element_css_size(window_data->canvas_id, &w, &h);
             }
 
@@ -931,8 +927,7 @@ Emscripten_HandleCanvasResize(int eventType, const void *reserved, void *userDat
     /*this is used during fullscreen changes*/
     SDL_WindowData *window_data = userData;
 
-    if(window_data->fullscreen_resize)
-    {
+    if (window_data->fullscreen_resize) {
         double css_w, css_h;
         emscripten_get_element_css_size(window_data->canvas_id, &css_w, &css_h);
         SDL_SendWindowEvent(window_data->window, SDL_WINDOWEVENT_RESIZED, css_w, css_h);
@@ -987,7 +982,9 @@ Emscripten_RegisterEventHandlers(SDL_WindowData *data)
 
     /* Keyboard events are awkward */
     keyElement = SDL_GetHint(SDL_HINT_EMSCRIPTEN_KEYBOARD_ELEMENT);
-    if (!keyElement) keyElement = EMSCRIPTEN_EVENT_TARGET_WINDOW;
+    if (keyElement == NULL) {
+        keyElement = EMSCRIPTEN_EVENT_TARGET_WINDOW;
+    }
 
     emscripten_set_keydown_callback(keyElement, data, 0, Emscripten_HandleKey);
     emscripten_set_keyup_callback(keyElement, data, 0, Emscripten_HandleKey);
@@ -1029,7 +1026,7 @@ Emscripten_UnregisterEventHandlers(SDL_WindowData *data)
     emscripten_set_pointerlockchange_callback(EMSCRIPTEN_EVENT_TARGET_DOCUMENT, NULL, 0, NULL);
 
     target = SDL_GetHint(SDL_HINT_EMSCRIPTEN_KEYBOARD_ELEMENT);
-    if (!target) {
+    if (target == NULL) {
         target = EMSCRIPTEN_EVENT_TARGET_WINDOW;
     }
 
diff --git a/src/video/emscripten/SDL_emscriptenframebuffer.c b/src/video/emscripten/SDL_emscriptenframebuffer.c
index 03fea04ef..cb07a38f5 100644
--- a/src/video/emscripten/SDL_emscriptenframebuffer.c
+++ b/src/video/emscripten/SDL_emscriptenframebuffer.c
@@ -47,7 +47,7 @@ int Emscripten_CreateWindowFramebuffer(_THIS, SDL_Window * window, Uint32 * form
     SDL_GetWindowSize(window, &w, &h);
 
     surface = SDL_CreateRGBSurface(0, w, h, bpp, Rmask, Gmask, Bmask, Amask);
-    if (!surface) {
+    if (surface == NULL) {
         return -1;
     }
 
@@ -65,7 +65,7 @@ int Emscripten_UpdateWindowFramebuffer(_THIS, SDL_Window * window, const SDL_Rec
 
     SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
     surface = data->surface;
-    if (!surface) {
+    if (surface == NULL) {
         return SDL_SetError("Couldn't find framebuffer surface for window");
     }
 
diff --git a/src/video/emscripten/SDL_emscriptenmouse.c b/src/video/emscripten/SDL_emscriptenmouse.c
index 38e394ac1..b172b9998 100644
--- a/src/video/emscripten/SDL_emscriptenmouse.c
+++ b/src/video/emscripten/SDL_emscriptenmouse.c
@@ -40,7 +40,7 @@ Emscripten_CreateCursorFromString(const char* cursor_str, SDL_bool is_custom)
     cursor = SDL_calloc(1, sizeof(SDL_Cursor));
     if (cursor) {
         curdata = (Emscripten_CursorData *) SDL_calloc(1, sizeof(*curdata));
-        if (!curdata) {
+        if (curdata == NULL) {
             SDL_OutOfMemory();
             SDL_free(cursor);
             return NULL;
@@ -49,8 +49,7 @@ Emscripten_CreateCursorFromString(const char* cursor_str, SDL_bool is_custom)
         curdata->system_cursor = cursor_str;
         curdata->is_custom = is_custom;
         cursor->driverdata = curdata;
-    }
-    else {
+    } else {
         SDL_OutOfMemory();
     }
 
@@ -72,7 +71,7 @@ Emscripten_CreateCursor(SDL_Surface* surface, int hot_x, int hot_y)
 
     conv_surf = SDL_ConvertSurfaceFormat(surface, SDL_PIXELFORMAT_ABGR8888, 0);
 
-    if (!conv_surf) {
+    if (conv_surf == NULL) {
         return NULL;
     }
 
@@ -204,18 +203,17 @@ Emscripten_ShowCursor(SDL_Cursor* cursor)
 {
     Emscripten_CursorData *curdata;
     if (SDL_GetMouseFocus() != NULL) {
-        if(cursor && cursor->driverdata) {
+        if (cursor && cursor->driverdata) {
             curdata = (Emscripten_CursorData *) cursor->driverdata;
 
-            if(curdata->system_cursor) {
+            if (curdata->system_cursor) {
                 MAIN_THREAD_EM_ASM({
                     if (Module['canvas']) {
                         Module['canvas'].style['cursor'] = UTF8ToString($0);
                     }
                 }, curdata->system_cursor);
             }
-        }
-        else {
+        } else {
             MAIN_THREAD_EM_ASM(
                 if (Module['canvas']) {
                     Module['canvas'].style['cursor'] = 'none';
@@ -239,7 +237,7 @@ Emscripten_SetRelativeMouseMode(SDL_bool enabled)
     SDL_WindowData *window_data;
 
     /* TODO: pointer lock isn't actually enabled yet */
-    if(enabled) {
+    if (enabled) {
         window = SDL_GetMouseFocus();
         if (window == NULL) {
             return -1;
@@ -247,11 +245,11 @@ Emscripten_SetRelativeMouseMode(SDL_bool enabled)
 
         window_data = (SDL_WindowData *) window->driverdata;
 
-        if(emscripten_request_pointerlock(window_data->canvas_id, 1) >= EMSCRIPTEN_RESULT_SUCCESS) {
+        if (emscripten_request_pointerlock(window_data->canvas_id, 1) >= EMSCRIPTEN_RESULT_SUCCESS) {
             return 0;
         }
     } else {
-        if(emscripten_exit_pointerlock() >= EMSCRIPTEN_RESULT_SUCCESS) {
+        if (emscripten_exit_pointerlock() >= EMSCRIPTEN_RESULT_SUCCESS) {
             return 0;
         }
     }
diff --git a/src/video/emscripten/SDL_emscriptenvideo.c b/src/video/emscripten/SDL_emscriptenvideo.c
index 550031d3f..04c4fac6b 100644
--- a/src/video/emscripten/SDL_emscriptenvideo.c
+++ b/src/video/emscripten/SDL_emscriptenvideo.c
@@ -69,9 +69,9 @@ Emscripten_CreateDevice(void)
 
     /* Initialize all variables that we clean on shutdown */
     device = (SDL_VideoDevice *) SDL_calloc(1, sizeof(SDL_VideoDevice));
-    if (!device) {
+    if (device == NULL) {
         SDL_OutOfMemory();
-        return (0);
+        return 0;
     }
 
     /* Firefox sends blur event which would otherwise prevent full screen
@@ -325,7 +325,7 @@ Emscripten_DestroyWindow(_THIS, SDL_Window * window)
 {
     SDL_WindowData *data;
 
-    if(window->driverdata) {
+    if (window->driverdata) {
         data = (SDL_WindowData *) window->driverdata;
 
         Emscripten_UnregisterEventHandlers(data);
@@ -349,19 +349,19 @@ static void
 Emscripten_SetWindowFullscreen(_THIS, SDL_Window * window, SDL_VideoDisplay * display, SDL_bool fullscreen)
 {
     SDL_WindowData *data;
-    if(window->driverdata) {
+    if (window->driverdata) {
         data = (SDL_WindowData *) window->driverdata;
 
-        if(fullscreen) {
+        if (fullscreen) {
             EmscriptenFullscreenStrategy strategy;
             SDL_bool is_desktop_fullscreen = (window->flags & SDL_WINDOW_FULLSCREEN_DESKTOP) == SDL_WINDOW_FULLSCREEN_DESKTOP;
             int res;
 
             strategy.scaleMode = is_desktop_fullscreen ? EMSCRIPTEN_FULLSCREEN_SCALE_STRETCH : EMSCRIPTEN_FULLSCREEN_SCALE_ASPECT;
 
-            if(!is_desktop_fullscreen) {
+            if (!is_desktop_fullscreen) {
                 strategy.canvasResolutionScaleMode = EMSCRIPTEN_FULLSCREEN_CANVAS_SCALE_NONE;
-            } else if(window->flags & SDL_WINDOW_ALLOW_HIGHDPI) {
+            } else if (window->flags & SDL_WINDOW_ALLOW_HIGHDPI) {
                 strategy.canvasResolutionScaleMode = EMSCRIPTEN_FULLSCREEN_CANVAS_SCALE_HIDEF;
             } else {
                 strategy.canvasResolutionScaleMode = EMSCRIPTEN_FULLSCREEN_CANVAS_SCALE_STDDEF;
@@ -376,12 +376,11 @@ Emscripten_SetWindowFullscreen(_THIS, SDL_Window * window, SDL_VideoDisplay * di
             data->fullscreen_resize = is_desktop_fullscreen;
 
             res = emscripten_request_fullscreen_strategy(data->canvas_id, 1, &strategy);
-            if(res != EMSCRIPTEN_RESULT_SUCCESS && res != EMSCRIPTEN_RESULT_DEFERRED) {
+            if (res != EMSCRIPTEN_RESULT_SUCCESS && res != EMSCRIPTEN_RESULT_DEFERRED) {
                 /* unset flags, fullscreen failed */
                 window->flags &= ~(SDL_WINDOW_FULLSCREEN_DESKTOP | SDL_WINDOW_FULLSCREEN);
             }
-        }
-        else
+        } else
             emscripten_exit_fullscreen();
     }
 }
diff --git a/src/video/haiku/SDL_bclipboard.cc b/src/video/haiku/SDL_bclipboard.cc
index 37cec38d3..c03286988 100644
--- a/src/video/haiku/SDL_bclipboard.cc
+++ b/src/video/haiku/SDL_bclipboard.cc
@@ -37,12 +37,12 @@ extern "C" {
 
 int HAIKU_SetClipboardText(_THIS, const char *text) {
     BMessage *clip = NULL;
-    if(be_clipboard->Lock()) {
+    if (be_clipboard->Lock()) {
         be_clipboard->Clear();
-        if((clip = be_clipboard->Data())) {
+        if ((clip = be_clipboard->Data())) {
             /* Presumably the string of characters is ascii-format */
             ssize_t asciiLength = 0;
-            for(; text[asciiLength] != 0; ++asciiLength) {}
+            for (; text[asciiLength] != 0; ++asciiLength) {}
             clip->AddData("text/plain", B_MIME_TYPE, text, asciiLength);
             be_clipboard->Commit();
         }
@@ -56,8 +56,8 @@ char *HAIKU_GetClipboardText(_THIS) {
     const char *text = NULL;    
     ssize_t length;
     char *result;
-    if(be_clipboard->Lock()) {
-        if((clip = be_clipboard->Data())) {
+    if (be_clipboard->Lock()) {
+        if ((clip = be_clipboard->Data())) {
             /* Presumably the string of characters is ascii-format */
             clip->FindData("text/plain", B_MIME_TYPE, (const void**)&text,
                 &length);
@@ -65,7 +65,7 @@ char *HAIKU_GetClipboardText(_THIS) {
         be_clipboard->Unlock();
     } 
     
-    if (!text) {
+    if (text == NULL) {
         result = SDL_strdup("");
     } else {
         /* Copy the data and pass on to SDL */
diff --git a/src/video/haiku/SDL_bframebuffer.cc b/src/video/haiku/SDL_bframebuffer.cc
index f303177cb..361f620cd 100644
--- a/src/video/haiku/SDL_bframebuffer.cc
+++ b/src/video/haiku/SDL_bframebuffer.cc
@@ -36,11 +36,11 @@ extern "C" {
 #endif
 
 static SDL_INLINE SDL_BWin *_ToBeWin(SDL_Window *window) {
-    return ((SDL_BWin*)(window->driverdata));
+    return (SDL_BWin *)(window->driverdata);
 }
 
 static SDL_INLINE SDL_BApp *_GetBeApp() {
-    return ((SDL_BApp*)be_app);
+    return (SDL_BApp *)be_app;
 }
 
 int HAIKU_CreateWindowFramebuffer(_THIS, SDL_Window * window,
@@ -48,7 +48,7 @@ int HAIKU_CreateWindowFramebuffer(_THIS, SDL_Window * window,
                                        void ** pixels, int *pitch) {
     SDL_BWin *bwin = _ToBeWin(window);
     BScreen bscreen;
-    if(!bscreen.IsValid()) {
+    if (!bscreen.IsValid()) {
         return -1;
     }
 
@@ -65,14 +65,14 @@ int HAIKU_CreateWindowFramebuffer(_THIS, SDL_Window * window,
     /* Create the new bitmap object */
     BBitmap *bitmap = bwin->GetBitmap();
 
-    if(bitmap) {
+    if (bitmap) {
         delete bitmap;
     }
     bitmap = new BBitmap(bwin->Bounds(), (color_space)bmode.space,
             false,    /* Views not accepted */
             true);    /* Contiguous memory required */
 
-    if(bitmap->InitCheck() != B_OK) {
+    if (bitmap->InitCheck() != B_OK) {
         delete bitmap;
         return SDL_SetError("Could not initialize back buffer!");
     }
@@ -94,8 +94,9 @@ int HAIKU_CreateWindowFramebuffer(_THIS, SDL_Window * window,
 
 int HAIKU_UpdateWindowFramebuffer(_THIS, SDL_Window * window,
                                       const SDL_Rect * rects, int numrects) {
-    if(!window)
+    if (window == NULL) {
         return 0;
+    }
 
     SDL_BWin *bwin = _ToBeWin(window);
 
diff --git a/src/video/haiku/SDL_bkeyboard.cc b/src/video/haiku/SDL_bkeyboard.cc
index a4aea4d48..bdede08f3 100644
--- a/src/video/haiku/SDL_bkeyboard.cc
+++ b/src/video/haiku/SDL_bkeyboard.cc
@@ -42,11 +42,11 @@ static SDL_Scancode keymap[KEYMAP_SIZE];
 static int8 keystate[KEYMAP_SIZE];
 
 void HAIKU_InitOSKeymap(void) {
-        for( uint i = 0; i < SDL_TABLESIZE(keymap); ++i ) {
+        for ( uint i = 0; i < SDL_TABLESIZE(keymap); ++i ) {
             keymap[i] = SDL_SCANCODE_UNKNOWN;
         }
 
-        for( uint i = 0; i < KEYMAP_SIZE; ++i ) {
+        for ( uint i = 0; i < KEYMAP_SIZE; ++i ) {
             keystate[i] = SDL_RELEASED;
         }
 
@@ -160,7 +160,7 @@ void HAIKU_InitOSKeymap(void) {
 }
 
 SDL_Scancode HAIKU_GetScancodeFromBeKey(int32 bkey) {
-    if(bkey > 0 && bkey < (int32)SDL_TABLESIZE(keymap)) {
+    if (bkey > 0 && bkey < (int32)SDL_TABLESIZE(keymap)) {
         return keymap[bkey];
     } else {
         return SDL_SCANCODE_UNKNOWN;
@@ -168,7 +168,7 @@ SDL_Scancode HAIKU_GetScancodeFromBeKey(int32 bkey) {
 }
 
 int8 HAIKU_GetKeyState(int32 bkey) {
-    if(bkey > 0 && bkey < KEYMAP_SIZE) {
+    if (bkey > 0 && bkey < KEYMAP_SIZE) {
         return keystate[bkey];
     } else {
         return SDL_RELEASED;
@@ -176,7 +176,7 @@ int8 HAIKU_GetKeyState(int32 bkey) {
 }
 
 void HAIKU_SetKeyState(int32 bkey, int8 state) {
-    if(bkey > 0 && bkey < KEYMAP_SIZE) {
+    if (bkey > 0 && bkey < KEYMAP_SIZE) {
         keystate[bkey] = state;
     }
 }
diff --git a/src/video/haiku/SDL_bmessagebox.cc b/src/video/haiku/SDL_bmessagebox.cc
index d777ed834..7ff5acb02 100644
--- a/src/video/haiku/SDL_bmessagebox.cc
+++ b/src/video/haiku/SDL_bmessagebox.cc
@@ -131,25 +131,20 @@ class HAIKU_SDL_MessageBox : public BAlert
 	void
 	ParseSdlMessageBoxData(const SDL_MessageBoxData *aMessageBoxData)
 	{
-		if (aMessageBoxData == NULL)
-		{
+		if (aMessageBoxData == NULL) {
 			SetTitle(HAIKU_SDL_DefTitle);
 			SetMessageText(HAIKU_SDL_DefMessage);
 			AddButton(HAIKU_SDL_DefButton);
 			return;
 		}
 
-		if (aMessageBoxData->numbuttons <= 0)
-		{
+		if (aMessageBoxData->numbuttons <= 0) {
 			AddButton(HAIKU_SDL_DefButton);
-		}
-		else
-		{
+		} else {
 			AddSdlButtons(aMessageBoxData->buttons, aMessageBoxData->numbuttons);
 		}
 
-		if (aMessageBoxData->colorScheme != NULL)
-		{
+		if (aMessageBoxData->colorScheme != NULL) {
 			fCustomColorScheme = true;
 			ApplyAndParseColorScheme(aMessageBoxData->colorScheme);
 		}
@@ -179,11 +174,9 @@ class HAIKU_SDL_MessageBox : public BAlert
 	                const SDL_MessageBoxColor *aTextColor,
 	                const SDL_MessageBoxColor *aSelectedColor)
 	{
-		if (fCustomColorScheme)
-		{
+		if (fCustomColorScheme) {
 			int32 countButtons = CountButtons();
-			for (int i = 0; i < countButtons; ++i)
-			{
+			for (int i = 0; i < countButtons; ++i) {
 				ButtonAt(i)->SetViewColor(ConvertColorType(aBorderColor));
 				ButtonAt(i)->SetLowColor(ConvertColorType(aBackgroundColor));
 
@@ -218,15 +211,12 @@ class HAIKU_SDL_MessageBox : public BAlert
 		BString message = aMessage;
 		int32 length = message.CountChars();
 
-		for (int i = 0, c = 0; i < length; ++i)
-		{
+		for (int i = 0, c = 0; i < length; ++i) {
 			c++;
-			if (*(message.CharAt(i)) == '\n')
-			{
+			if (*(message.CharAt(i)) == '\n') {
 				c = 0;
 			}
-			if (c > final)
-			{
+			if (c > final) {
 				final = c;
 			}
 		}
@@ -238,20 +228,17 @@ class HAIKU_SDL_MessageBox : public BAlert
 	SetMessageText(const char *aMessage)
 	{
 		fThereIsLongLine = CheckLongLines(aMessage);
-		if (fThereIsLongLine)
-		{
+		if (fThereIsLongLine) {
 			fMessageBoxTextView->SetWordWrap(true);
 		}
 
 		rgb_color textColor = ui_color(B_PANEL_TEXT_COLOR);
-		if (fCustomColorScheme)
-		{
+		if (fCustomColorScheme) {
 			textColor = fTextColor;
 		}
 
 		/*
-		if (fNoTitledWindow)
-		{
+		if (fNoTitledWindow) {
 			fMessageBoxTextView->SetFontAndColor(be_bold_font);
 			fMessageBoxTextView->Insert(fTitle);
 			fMessageBoxTextView->Insert("\n\n");
@@ -269,16 +256,14 @@ class HAIKU_SDL_MessageBox : public BAlert
 	void
 	AddSdlButtons(const SDL_MessageBoxButtonData *aButtons, int aNumButtons)
 	{
-		for (int i = 0; i < aNumButtons; ++i)
-		{
+		for (int i = 0; i < aNumButtons; ++i) {
 			fButtons.push_back(&aButtons[i]);
 		}
 
 		std::sort(fButtons.begin(), fButtons.end(), &HAIKU_SDL_MessageBox::SortButtonsPredicate);
 
 		size_t countButtons = fButtons.size();
-		for (size_t i = 0; i < countButtons; ++i)
-		{
+		for (size_t i = 0; i < countButtons; ++i) {
 			switch (fButtons[i]->flags)
 			{
 				case SDL_MESSAGEBOX_BUTTON_ESCAPEKEY_DEFAULT:
@@ -342,12 +327,9 @@ protected:
 	virtual void
 	FrameResized(float aNewWidth, float aNewHeight)
 	{
-		if (fComputedMessageBoxWidth > aNewWidth)
-		{
+		if (fComputedMessageBoxWidth > aNewWidth) {
 			ResizeTo(fComputedMessageBoxWidth, aNewHeight);
-		}
-		else
-		{
+		} else {
 			BAlert::FrameResized(aNewWidth, aNewHeight);
 		}
 	}
@@ -375,38 +357,32 @@ HAIKU_ShowMessageBox(const SDL_MessageBoxData *messageboxdata, int *buttonid)
 	// "You need a valid BApplication object before interacting with the app_server."
 	// "2 BApplication objects were created. Only one is allowed."
 	BApplication *application = NULL;
-	if (be_app == NULL)
-	{
+	if (be_app == NULL) {
 		application = new(std::nothrow) BApplication(signature);
-		if (application == NULL)
-		{
+		if (application == NULL) {
 			return SDL_SetError("Cannot create the BApplication object. Lack of memory?");
 		}
 	}
 
 	HAIKU_SDL_MessageBox *SDL_MessageBox = new(std::nothrow) HAIKU_SDL_MessageBox(messageboxdata);
-	if (SDL_MessageBox == NULL)
-	{
+	if (SDL_MessageBox == NULL) {
 		return SDL_SetError("Cannot create the HAIKU_SDL_MessageBox (BAlert inheritor) object. Lack of memory?");
 	}
 	const int closeButton = SDL_MessageBox->GetCloseButtonId();
 	int pushedButton = SDL_MessageBox->Go();
 
 	// The close button is equivalent to pressing Escape.
-	if (closeButton != G_CLOSE_BUTTON_ID && pushedButton == G_CLOSE_BUTTON_ID)
-	{
+	if (closeButton != G_CLOSE_BUTTON_ID && pushedButton == G_CLOSE_BUTTON_ID) {
 		pushedButton = closeButton;
 	}
 
 	// It's deleted by itself after the "Go()" method was executed.
 	/*
-	if (messageBox != NULL)
-	{
+	if (messageBox != NULL) {
 		delete messageBox;
 	}
 	*/
-	if (application != NULL)
-	{
+	if (application != NULL) {
 		delete application;
 	}
 
diff --git a/src/video/haiku/SDL_bmodes.cc b/src/video/haiku/SDL_bmodes.cc
index 5e51647ca..8fc6bfdac 100644
--- a/src/video/haiku/SDL_bmodes.cc
+++ b/src/video/haiku/SDL_bmodes.cc
@@ -49,18 +49,18 @@ struct SDL_DisplayModeData {
 #endif
 
 static SDL_INLINE SDL_BWin *_ToBeWin(SDL_Window *window) {
-    return ((SDL_BWin*)(window->driverdata));
+    return (SDL_BWin *)(window->driverdata);
 }
 
 static SDL_INLINE SDL_BApp *_GetBeApp() {
-    return ((SDL_BApp*)be_app);
+    return (SDL_BApp *)be_app;
 }
 
 static SDL_INLINE display_mode * _ExtractBMode(SDL_DisplayMode *mode) {
 #if WRAP_BMODE
-    return ((SDL_DisplayModeData*)mode->driverdata)->bmode;
+    return ((SDL_DisplayModeData *)mode->driverdata)->bmode;
 #else
-    return (display_mode*)(mode->driverdata);
+    return (display_mode *)(mode->driverdata);
 #endif
 }
 
@@ -80,24 +80,24 @@ void _SpoutModeData(display_mode *bmode) {
     printf("\tw,h = (%i,%i)\n", bmode->virtual_width, bmode->virtual_height);
     printf("\th,v = (%i,%i)\n", bmode->h_display_start, 
             bmode->v_display_start);
-    if(bmode->flags) {
+    if (bmode->flags) {
         printf("\tFlags:\n");
-        if(bmode->flags & B_SCROLL) {
+        if (bmode->flags & B_SCROLL) {
             printf("\t\tB_SCROLL\n");
         }
-        if(bmode->flags & B_8_BIT_DAC) {
+        if (bmode->flags & B_8_BIT_DAC) {
             printf("\t\tB_8_BIT_DAC\n");
         }
-        if(bmode->flags & B_HARDWARE_CURSOR) {
+        if (bmode->flags & B_HARDWARE_CURSOR) {
             printf("\t\tB_HARDWARE_CURSOR\n");
         }
-        if(bmode->flags & B_PARALLEL_ACCESS) {
+        if (bmode->flags & B_PARALLEL_ACCESS) {
             printf("\t\tB_PARALLEL_ACCESS\n");
         }
-        if(bmode->flags & B_DPMS) {
+        if (bmode->flags & B_DPMS) {
             printf("\t\tB_DPMS\n");
         }
-        if(bmode->flags & B_IO_FB_NA) {
+        if (bmode->flags & B_IO_FB_NA) {
             printf("\t\tB_IO_FB_NA\n");
         }
     }
@@ -109,21 +109,21 @@ void _SpoutModeData(display_mode *bmode) {
     printf("\t\tv - display: %i sync start: %i sync end: %i total: %i\n",
         bmode->timing.v_display, bmode->timing.v_sync_start,
         bmode->timing.v_sync_end, bmode->timing.v_total);
-    if(bmode->timing.flags) {
+    if (bmode->timing.flags) {
         printf("\t\tFlags:\n");
-        if(bmode->timing.flags & B_BLANK_PEDESTAL) {
+        if (bmode->timing.flags & B_BLANK_PEDESTAL) {
             printf("\t\t\tB_BLANK_PEDESTAL\n");
         }
-        if(bmode->timing.flags & B_TIMING_INTERLACED) {
+        if (bmode->timing.flags & B_TIMING_INTERLACED) {
             printf("\t\t\tB_TIMING_INTERLACED\n");
         }
-        if(bmode->timing.flags & B_POSITIVE_HSYNC) {
+        if (bmode->timing.flags & B_POSITIVE_HSYNC) {
             printf("\t\t\tB_POSITIVE_HSYNC\n");
         }
-        if(bmode->timing.flags & B_POSITIVE_VSYNC) {
+        if (bmode->timing.flags & B_POSITIVE_VSYNC) {
             printf("\t\t\tB_POSITIVE_VSYNC\n");
         }
-        if(bmode->timing.flags & B_SYNC_ON_GREEN) {
+        if (bmode->timing.flags & B_SYNC_ON_GREEN) {
             printf("\t\t\tB_SYNC_ON_GREEN\n");
         }
     }
@@ -247,7 +247,7 @@ void HAIKU_GetDisplayModes(_THIS, SDL_VideoDisplay *display) {
     bscreen.GetModeList(&bmodes, &count);
     bscreen.GetMode(&this_bmode);
     
-    for(i = 0; i < count; ++i) {
+    for (i = 0; i < count; ++i) {
         // FIXME: Apparently there are errors with colorspace changes
         if (bmodes[i].space == this_bmode.space) {
             _BDisplayModeToSdlDisplayMode(&bmodes[i], &mode);
@@ -258,10 +258,10 @@ void HAIKU_GetDisplayModes(_THIS, SDL_VideoDisplay *display) {
 }
 
 
-int HAIKU_SetDisplayMode(_THIS, SDL_VideoDisplay *display, SDL_DisplayMode *mode){
+int HAIKU_SetDisplayMode(_THIS, SDL_VideoDisplay *display, SDL_DisplayMode *mode) {
     /* Get the current screen */
     BScreen bscreen;
-    if(!bscreen.IsValid()) {
+    if (!bscreen.IsValid()) {
         printf(__FILE__": %d - ERROR: BAD SCREEN\n", __LINE__);
     }
 
@@ -273,8 +273,8 @@ int HAIKU_SetDisplayMode(_THIS, SDL_VideoDisplay *display, SDL_DisplayMode *mode
     uint32 c = 0, i;
     display_mode *bmode_list;
     bscreen.GetModeList(&bmode_list, &c);
-    for(i = 0; i < c; ++i) {
-        if(    bmode_list[i].space == bmode->space &&
+    for (i = 0; i < c; ++i) {
+        if (    bmode_list[i].space == bmode->space &&
             bmode_list[i].virtual_width == bmode->virtual_width &&
             bmode_list[i].virtual_height == bmode->virtual_height ) {
                 bmode = &bmode_list[i];
@@ -282,7 +282,7 @@ int HAIKU_SetDisplayMode(_THIS, SDL_VideoDisplay *display, SDL_DisplayMode *mode
         }
     }
 
-    if(bscreen.SetMode(bmode) != B_OK) {
+    if (bscreen.SetMode(bmode) != B_OK) {
         return SDL_SetError("Bad video mode");
     }
     
diff --git a/src/video/haiku/SDL_bopengl.cc b/src/video/haiku/SDL_bopengl.cc
index 72bdb77f4..76751a647 100644
--- a/src/video/haiku/SDL_bopengl.cc
+++ b/src/video/haiku/SDL_bopengl.cc
@@ -36,11 +36,11 @@ extern "C" {
 
 
 static SDL_INLINE SDL_BWin *_ToBeWin(SDL_Window *window) {
-    return ((SDL_BWin*)(window->driverdata));
+    return (SDL_BWin *)(window->driverdata);
 }
 
 static SDL_INLINE SDL_BApp *_GetBeApp() {
-    return ((SDL_BApp*)be_app);
+    return (SDL_BApp *)be_app;
 }
 
 /* Passing a NULL path means load pointers from the application */
@@ -51,7 +51,7 @@ int HAIKU_GL_LoadLibrary(_THIS, const char *path)
             int32 cookie = 0;
     while (get_next_image_info(0, &cookie, &info) == B_OK) {
         void *location = NULL;
-        if( get_image_symbol(info.id, "glBegin", B_SYMBOL_TYPE_ANY,
+        if ( get_image_symbol(info.id, "glBegin", B_SYMBOL_TYPE_ANY,
                 &location) == B_OK) {
 
             _this->gl_config.dll_handle = (void *) (addr_t) info.id;
@@ -175,9 +175,9 @@ void HAIKU_GL_UnloadLibrary(_THIS) {
    currently in use. */
 void HAIKU_GL_RebootContexts(_THIS) {
     SDL_Window *window = _this->windows;
-    while(window) {
+    while (window) {
         SDL_BWin *bwin = _ToBeWin(window);
-        if(bwin->GetGLView()) {
+        if (bwin->GetGLView()) {
             bwin->LockLooper();
             bwin->RemoveGLView();
             bwin->CreateGLView(bwin->GetGLType());
diff --git a/src/video/haiku/SDL_bvideo.cc b/src/video/haiku/SDL_bvideo.cc
index e409f3c6f..337175d73 100644
--- a/src/video/haiku/SDL_bvideo.cc
+++ b/src/video/haiku/SDL_bvideo.cc
@@ -41,7 +41,7 @@ extern "C" {
 #include "SDL_bevents.h"
 
 static SDL_INLINE SDL_BWin *_ToBeWin(SDL_Window *window) {
-    return ((SDL_BWin*)(window->driverdata));
+    return (SDL_BWin *)(window->driverdata);
 }
 
 /* FIXME: Undefined functions */
@@ -198,7 +198,7 @@ HAIKU_CreateCursor(SDL_Surface * surface, int hot_x, int hot_y)
     SDL_Surface *converted;
 
     converted = SDL_ConvertSurfaceFormat(surface, SDL_PIXELFORMAT_ARGB8888, 0);
-    if (!converted) {
+    if (converted == NULL) {
         return NULL;
     }
 
@@ -220,8 +220,9 @@ static int HAIKU_ShowCursor(SDL_Cursor *cursor)
 {
 	SDL_Mouse *mouse = SDL_GetMouse();
 
-	if (!mouse)
+	if (mouse == NULL) {
 		return 0;
+	}
 
 	if (cursor) {
 		BCursor *hCursor = (BCursor*)cursor->driverdata;
@@ -239,7 +240,7 @@ static int
 HAIKU_SetRelativeMouseMode(SDL_bool enabled)
 {
     SDL_Window *window = SDL_GetMouseFocus();
-    if (!window) {
+    if (window == NULL) {
       return 0;
     }
 
@@ -259,8 +260,9 @@ HAIKU_SetRelativeMouseMode(SDL_bool enabled)
 static void HAIKU_MouseInit(_THIS)
 {
 	SDL_Mouse *mouse = SDL_GetMouse();
-	if (!mouse)
+	if (mouse == NULL) {
 		return;
+	}
 	mouse->CreateCursor = HAIKU_CreateCursor;
 	mouse->CreateSystemCursor = HAIKU_CreateSystemCursor;
 	mouse->ShowCursor = HAIKU_ShowCursor;
@@ -292,7 +294,7 @@ int HAIKU_VideoInit(_THIS)
 #endif
 
     /* We're done! */
-    return (0);
+    return 0;
 }
 
 void HAIKU_VideoQuit(_THIS)
@@ -309,7 +311,7 @@ int HAIKU_OpenURL(const char *url)
 {
     BUrl burl(url);
     const status_t rc = burl.OpenWithPreferredApplication(false);
-    return (rc == B_NO_ERROR) ? 0 : SDL_SetError("URL open failed (err=%d)", (int) rc);
+    return (rc == B_NO_ERROR) ? 0 : SDL_SetError("URL open failed (err=%d)", (int)rc);
 }
 
 #ifdef __cplusplus
diff --git a/src/video/haiku/SDL_bwindow.cc b/src/video/haiku/SDL_bwindow.cc
index 24625337d..39da73a6c 100644
--- a/src/video/haiku/SDL_bwindow.cc
+++ b/src/video/haiku/SDL_bwindow.cc
@@ -34,11 +34,11 @@ extern "C" {
 #endif
 
 static SDL_INLINE SDL_BWin *_ToBeWin(SDL_Window *window) {
-    return ((SDL_BWin*)(window->driverdata));
+    return (SDL_BWin *)(window->driverdata);
 }
 
 static SDL_INLINE SDL_BApp *_GetBeApp() {
-    return ((SDL_BApp*)be_app);
+    return (SDL_BApp *)be_app;
 }
 
 static int _InitWindow(_THIS, SDL_Window *window) {
@@ -52,23 +52,24 @@ static int _InitWindow(_THIS, SDL_Window *window) {
         window->y + window->h - 1
     );
     
-    if(window->flags & SDL_WINDOW_FULLSCREEN) {
+    if (window->flags & SDL_WINDOW_FULLSCREEN) {
         /* TODO: Add support for this flag */
         printf(__FILE__": %d!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n",__LINE__);
     }
-    if(window->flags & SDL_WINDOW_OPENGL) {
+    if (window->flags & SDL_WINDOW_OPENGL) {
         /* TODO: Add support for this flag */
     }
-    if(!(window->flags & SDL_WINDOW_RESIZABLE)) {
+    if (!(window->flags & SDL_WINDOW_RESIZABLE)) {
         flags |= B_NOT_RESIZABLE | B_NOT_ZOOMABLE;
     }
-    if(window->flags & SDL_WINDOW_BORDERLESS) {
+    if (window->flags & SDL_WINDOW_BORDERLESS) {
         look = B_NO_BORDER_WINDOW_LOOK;
     }
 
     SDL_BWin *bwin = new(std::nothrow) SDL_BWin(bounds, look, flags);
-    if(bwin == NULL)
+    if (bwin == NULL) {
         return -1;
+    }
 
     window->driverdata = bwin;
     int32 winID = _GetBeApp()->GetID(window);
@@ -90,8 +91,9 @@ int HAIKU_CreateWindow(_THIS, SDL_Window *window) {
 int HAIKU_CreateWindowFrom(_THIS, SDL_Window * window, const void *data) {
 
     SDL_BWin *otherBWin = (SDL_BWin*)data;
-    if(!otherBWin->LockLooper())
+    if (!otherBWin->LockLooper()) {
         return -1;
+    }
     
     /* Create the new window and initialize its members */
     window->x = (int)otherBWin->Frame().left;
@@ -100,7 +102,7 @@ int HAIKU_CreateWindowFrom(_THIS, SDL_Window * window, const void *data) {
     window->h = (int)otherBWin->Frame().Height();
     
     /* Set SDL flags */
-    if(!(otherBWin->Flags() & B_NOT_RESIZABLE)) {
+    if (!(otherBWin->Flags() & B_NOT_RESIZABLE)) {
         window->flags |= SDL_WINDOW_RESIZABLE;
     }
     
@@ -205,7 +207,7 @@ int HAIKU_GetWindowGammaRamp(_THIS, SDL_Window * window, Uint16 * ramp) {
 }
 
 
-void HAIKU_SetWindowMinimumSize(_THIS, SDL_Window * window){
+void HAIKU_SetWindowMinimumSize(_THIS, SDL_Window * window) {
     BMessage msg(BWIN_MINIMUM_SIZE_WINDOW);
     msg.AddInt32("window-w", window->w -1);
     msg.AddInt32("window-h", window->h -1);
diff --git a/src/video/kmsdrm/SDL_kmsdrmdyn.c b/src/video/kmsdrm/SDL_kmsdrmdyn.c
index bf3ff2e3e..de8c2e4fd 100644
--- a/src/video/kmsdrm/SDL_kmsdrmdyn.c
+++ b/src/video/kmsdrm/SDL_kmsdrmdyn.c
@@ -58,8 +58,9 @@ KMSDRM_GetSym(const char *fnname, int *pHasModule)
     for (i = 0; i < SDL_TABLESIZE(kmsdrmlibs); i++) {
         if (kmsdrmlibs[i].lib != NULL) {
             fn = SDL_LoadFunction(kmsdrmlibs[i].lib, fnname);
-            if (fn != NULL)
+            if (fn != NULL) {
                 break;
+            }
         }
     }
 
@@ -70,8 +71,9 @@ KMSDRM_GetSym(const char *fnname, int *pHasModule)
         SDL_Log("KMSDRM: Symbol '%s' NOT FOUND!\n", fnname);
 #endif
 
-    if (fn == NULL)
-        *pHasModule = 0;  /* kill this module. */
+    if (fn == NULL) {
+        *pHasModule = 0; /* kill this module. */
+    } 
 
     return fn;
 }
diff --git a/src/video/kmsdrm/SDL_kmsdrmmouse.c b/src/video/kmsdrm/SDL_kmsdrmmouse.c
index 5722e041a..08cf26c72 100644
--- a/src/video/kmsdrm/SDL_kmsdrmmouse.c
+++ b/src/video/kmsdrm/SDL_kmsdrmmouse.c
@@ -158,7 +158,7 @@ KMSDRM_DumpCursorToBO(SDL_VideoDisplay *display, SDL_Cursor *cursor)
     int i;
     int ret;
 
-    if (!curdata || !dispdata->cursor_bo) {
+    if (curdata == NULL || !dispdata->cursor_bo) {
         return SDL_SetError("Cursor or display not initialized properly.");
     }
 
@@ -169,7 +169,7 @@ KMSDRM_DumpCursorToBO(SDL_VideoDisplay *display, SDL_Cursor *cursor)
 
     ready_buffer = (uint8_t*)SDL_calloc(1, bufsize);
 
-    if (!ready_buffer) {
+    if (ready_buffer == NULL) {
         ret = SDL_OutOfMemory();
         goto cleanup;
     }
@@ -249,12 +249,12 @@ KMSDRM_CreateCursor(SDL_Surface * surface, int hot_x, int hot_y)
     ret = NULL;
 
     cursor = (SDL_Cursor *) SDL_calloc(1, sizeof(*cursor));
-    if (!cursor) {
+    if (cursor == NULL) {
         SDL_OutOfMemory();
         goto cleanup;
     }
     curdata = (KMSDRM_CursorData *) SDL_calloc(1, sizeof(*curdata));
-    if (!curdata) {
+    if (curdata == NULL) {
         SDL_OutOfMemory();
         goto cleanup;
     }
@@ -319,13 +319,13 @@ KMSDRM_ShowCursor(SDL_Cursor * cursor)
     /* Get the mouse focused window, if any. */
 
     mouse = SDL_GetMouse();
-    if (!mouse) {
+    if (mouse == NULL) {
         return SDL_SetError("No mouse.");
     }
 
     window = mouse->focus;
 
-    if (!window || !cursor) {
+    if (window == NULL || cursor == NULL) {
 
             /* If no window is focused by mouse or cursor is NULL,
                since we have no window (no mouse->focus) and hence
diff --git a/src/video/kmsdrm/SDL_kmsdrmopengles.c b/src/video/kmsdrm/SDL_kmsdrmopengles.c
index 253e34ecd..6657da427 100644
--- a/src/video/kmsdrm/SDL_kmsdrmopengles.c
+++ b/src/video/kmsdrm/SDL_kmsdrmopengles.c
@@ -136,7 +136,7 @@ KMSDRM_GLES_SwapWindow(_THIS, SDL_Window * window) {
 
     /* Get an actual usable fb for the next front buffer. */
     fb_info = KMSDRM_FBFromBO(_this, windata->next_bo);
-    if (!fb_info) {
+    if (fb_info == NULL) {
         SDL_LogError(SDL_LOG_CATEGORY_VIDEO, "Could not get a framebuffer");
         return 0;
     }
diff --git a/src/video/kmsdrm/SDL_kmsdrmvideo.c b/src/video/kmsdrm/SDL_kmsdrmvideo.c
index 6c05bbd9b..db1b9429f 100644
--- a/src/video/kmsdrm/SDL_kmsdrmvideo.c
+++ b/src/video/kmsdrm/SDL_kmsdrmvideo.c
@@ -90,7 +90,7 @@ get_driindex(void)
 
     SDL_strlcpy(device, kmsdrm_dri_path, sizeof(device));
     folder = opendir(device);
-    if (!folder) {
+    if (folder == NULL) {
         SDL_SetError("Failed to open directory '%s'", device);
         return -ENOENT;
     }
@@ -128,7 +128,7 @@ get_driindex(void)
                                     KMSDRM_drmModeGetConnector(
                                         drm_fd, resources->connectors[i]);
 
-                                if (!conn) {
+                                if (conn == NULL) {
                                     continue;
                                 }
 
@@ -245,13 +245,13 @@ KMSDRM_CreateDevice(void)
     }
 
     device = (SDL_VideoDevice *) SDL_calloc(1, sizeof(SDL_VideoDevice));
-    if (!device) {
+    if (device == NULL) {
         SDL_OutOfMemory();
         return NULL;
     }
 
     viddata = (SDL_VideoData *) SDL_calloc(1, sizeof(SDL_VideoData));
-    if (!viddata) {
+    if (viddata == NULL) {
         SDL_OutOfMemory();
         goto cleanup;
     }
@@ -310,8 +310,9 @@ KMSDRM_CreateDevice(void)
 cleanup:
     SDL_free(device);
 
-    if (viddata)
+    if (viddata) {
         SDL_free(viddata);
+    }
     return NULL;
 }
 
@@ -353,7 +354,7 @@ KMSDRM_FBFromBO(_THIS, struct gbm_bo *bo)
        when the backing buffer is destroyed */
     fb_info = (KMSDRM_FBInfo *)SDL_calloc(1, sizeof(KMSDRM_FBInfo));
 
-    if (!fb_info) {
+    if (fb_info == NULL) {
         SDL_OutOfMemory();
         return NULL;
     }
@@ -477,7 +478,7 @@ KMSDRM_WaitPageflip(_THIS, SDL_WindowData *windata) {
    because it's ordered, while the list on the connector is mostly random.*/
 static drmModeModeInfo*
 KMSDRM_GetClosestDisplayMode(SDL_VideoDisplay * display,
-uint32_t width, uint32_t height, uint32_t refresh_rate){
+uint32_t width, uint32_t height, uint32_t refresh_rate) {
 
     SDL_DisplayData *dispdata = (SDL_DisplayData *) display->driverdata;
     drmModeConnector *connector = dispdata->connector;
@@ -545,11 +546,13 @@ KMSDRM_CrtcGetPropId(uint32_t drm_fd,
         drmModePropertyPtr drm_prop =
                      KMSDRM_drmModeGetProperty(drm_fd, props->props[i]);
 
-        if (!drm_prop)
+        if (!drm_prop) {
             continue;
+        }
 
-        if (strcmp(drm_prop->name, name) == 0)
+        if (SDL_strcmp(drm_prop->name, name) == 0) {
             prop_id = drm_prop->prop_id;
+        }
 
         KMSDRM_drmModeFreeProperty(drm_prop);
    }
@@ -564,8 +567,9 @@ static SDL_bool KMSDRM_VrrPropId(uint32_t drm_fd, uint32_t crtc_id, uint32_t *vr
                                            crtc_id,
                                            DRM_MODE_OBJECT_CRTC);
 
-    if (!drm_props)
+    if (!drm_props) {
         return SDL_FALSE;
+    }
 
     *vrr_prop_id = KMSDRM_CrtcGetPropId(drm_fd,
                                        drm_props,
@@ -590,24 +594,27 @@ KMSDRM_ConnectorCheckVrrCapable(uint32_t drm_fd,
                                        output_id,
                                        DRM_MODE_OBJECT_CONNECTOR);
 
-    if(!props)
+    if (!props) {
         return SDL_FALSE;
+    }
 
     for (i = 0; !found && i < props->count_props; ++i) {
         drmModePropertyPtr drm_prop = KMSDRM_drmModeGetProperty(drm_fd, props->props[i]);
 
-        if (!drm_prop)
+        if (!drm_prop) {
             continue;
+        }
 
-        if (strcasecmp(drm_prop->name, name) == 0) {
+        if (SDL_strcasecmp(drm_prop->name, name) == 0) {
             prop_value = props->prop_values[i];
             found = SDL_TRUE;
         }
 
         KMSDRM_drmModeFreeProperty(drm_prop);
     }
-    if(found)
-        return prop_value ? SDL_TRUE: SDL_FALSE;
+    if (found) {
+        return prop_value ? SDL_TRUE : SDL_FALSE;
+    }
 
     return SDL_FALSE;
 }
@@ -616,8 +623,9 @@ void
 KMSDRM_CrtcSetVrr(uint32_t drm_fd, uint32_t crtc_id, SDL_bool enabled)
 {
     uint32_t vrr_prop_id;
-    if (!KMSDRM_VrrPropId(drm_fd, crtc_id, &vrr_prop_id)) 
+    if (!KMSDRM_VrrPropId(drm_fd, crtc_id, &vrr_prop_id)) {
         return;
+    }
 
     KMSDRM_drmModeObjectSetProperty(drm_fd,
                              crtc_id,
@@ -634,22 +642,25 @@ KMSDRM_CrtcGetVrr(uint32_t drm_fd, uint32_t crtc_id)
     SDL_bool object_prop_value;
     int i;
 
-    if (!KMSDRM_VrrPropId(drm_fd, crtc_id, &vrr_prop_id)) 
+    if (!KMSDRM_VrrPropId(drm_fd, crtc_id, &vrr_prop_id)) {
         return SDL_FALSE;
+    }
 
 
     props = KMSDRM_drmModeObjectGetProperties(drm_fd,
                                        crtc_id,
                                        DRM_MODE_OBJECT_CRTC);
 
-    if(!props)
+    if (!props) {
         return SDL_FALSE;
+    }
 
     for (i = 0; i < props->count_props; ++i) {
         drmModePropertyPtr drm_prop = KMSDRM_drmModeGetProperty(drm_fd, props->props[i]);
 
-        if (!drm_prop)
+        if (!drm_prop) {
             continue;
+        }
 
         object_prop_id = drm_prop->prop_id;
         object_prop_value = props->prop_values[i] ? SDL_TRUE : SDL_FALSE;
@@ -680,7 +691,7 @@ KMSDRM_AddDisplay (_THIS, drmModeConnector *connector, drmModeRes *resources)
 
     /* Reserve memory for the new display's driverdata. */
     dispdata = (SDL_DisplayData *) SDL_calloc(1, sizeof(SDL_DisplayData));
-    if (!dispdata) {
+    if (dispdata == NULL) {
         ret = SDL_OutOfMemory();
         goto cleanup;
     }
@@ -701,7 +712,7 @@ KMSDRM_AddDisplay (_THIS, drmModeConnector *connector, drmModeRes *resources)
     for (i = 0; i < resources->count_encoders; i++) {
         encoder = KMSDRM_drmModeGetEncoder(viddata->drm_fd, resources->encoders[i]);
 
-        if (!encoder) {
+        if (encoder == NULL) {
           continue;
         }
 
@@ -713,13 +724,13 @@ KMSDRM_AddDisplay (_THIS, drmModeConnector *connector, drmModeRes *resources)
         encoder = NULL;
     }
 
-    if (!encoder) {
+    if (encoder == NULL) {
         /* No encoder was connected, find the first supported one */
         for (i = 0; i < resources->count_encoders; i++) {
             encoder = KMSDRM_drmModeGetEncoder(viddata->drm_fd,
                           resources->encoders[i]);
 
-            if (!encoder) {
+            if (encoder == NULL) {
                 continue;
             }
 
@@ -738,7 +749,7 @@ KMSDRM_AddDisplay (_THIS, drmModeConnector *connector, drmModeRes *resources)
         }
     }
 
-    if (!encoder) {
+    if (encoder == NULL) {
         ret = SDL_SetError("No connected encoder found for connector.");
         goto cleanup;
     }
@@ -748,7 +759,7 @@ KMSDRM_AddDisplay (_THIS, drmModeConnector *connector, drmModeRes *resources)
 
     /* If no CRTC was connected to the encoder, find the first CRTC
        that is supported by the encoder, and use that. */
-    if (!crtc) {
+    if (crtc == NULL) {
         for (i = 0; i < resources->count_crtcs; i++) {
             if (encoder->possible_crtcs & (1 << i)) {
                 encoder->crtc_id = resources->crtcs[i];
@@ -758,7 +769,7 @@ KMSDRM_AddDisplay (_THIS, drmModeConnector *connector, drmModeRes *resources)
         }
     }
 
-    if (!crtc) {
+    if (crtc == NULL) {
         ret = SDL_SetError("No CRTC found for connector.");
         goto cleanup;
     }
@@ -830,7 +841,7 @@ KMSDRM_AddDisplay (_THIS, drmModeConnector *connector, drmModeRes *resources)
     /* save previous vrr state */
     dispdata->saved_vrr = KMSDRM_CrtcGetVrr(viddata->drm_fd, crtc->crtc_id);
     /* try to enable vrr */
-    if(KMSDRM_ConnectorCheckVrrCapable(viddata->drm_fd, connector->connector_id, "VRR_CAPABLE")) {
+    if (KMSDRM_ConnectorCheckVrrCapable(viddata->drm_fd, connector->connector_id, "VRR_CAPABLE")) {
         SDL_LogDebug(SDL_LOG_CATEGORY_VIDEO, "Enabling VRR");
         KMSDRM_CrtcSetVrr(viddata->drm_fd, crtc->crtc_id, SDL_TRUE);
     }
@@ -843,7 +854,7 @@ KMSDRM_AddDisplay (_THIS, drmModeConnector *connector, drmModeRes *resources)
        There's no problem with it being still incomplete. */
     modedata = SDL_calloc(1, sizeof(SDL_DisplayModeData));
 
-    if (!modedata) {
+    if (modedata == NULL) {
         ret = SDL_OutOfMemory();
         goto cleanup;
     }
@@ -862,8 +873,9 @@ KMSDRM_AddDisplay (_THIS, drmModeConnector *connector, drmModeRes *resources)
     SDL_AddVideoDisplay(&display, SDL_FALSE);
 
 cleanup:
-    if (encoder)
+    if (encoder) {
         KMSDRM_drmModeFreeEncoder(encoder);
+    }
     if (ret) {
         /* Error (complete) cleanup */
         if (dispdata) {
@@ -912,7 +924,7 @@ KMSDRM_InitDisplays (_THIS) {
 
     /* Get all of the available connectors / devices / crtcs */
     resources = KMSDRM_drmModeGetResources(viddata->drm_fd);
-    if (!resources) {
+    if (resources == NULL) {
         ret = SDL_SetError("drmModeGetResources(%d) failed", viddata->drm_fd);
         goto cleanup;
     }
@@ -923,7 +935,7 @@ KMSDRM_InitDisplays (_THIS) {
         drmModeConnector *connector = KMSDRM_drmModeGetConnector(viddata->drm_fd,
             resources->connectors[i]);
 
-        if (!connector) {
+        if (connector == NULL) {
             continue;
         }
 
@@ -933,8 +945,7 @@ KMSDRM_InitDisplays (_THIS) {
                so if it fails (no encoder for connector, no valid video mode for
                connector etc...) we can keep looking for connected connectors. */
             KMSDRM_AddDisplay(_this, connector, resources);
-        }
-        else {
+        } else {
             /* If it's not, free it now. */
             KMSDRM_drmModeFreeConnector(connector);
         }
@@ -963,8 +974,9 @@ KMSDRM_InitDisplays (_THIS) {
     viddata->drm_fd = -1;
 
 cleanup:
-    if (resources)
+    if (resources) {
         KMSDRM_drmModeFreeResources(resources);
+    }
     if (ret) {
         if (viddata->drm_fd >= 0) {
             close(viddata->drm_fd);
@@ -1056,7 +1068,7 @@ KMSDRM_DestroySurfaces(_THIS, SDL_Window *window)
                 &dispdata->original_mode);
     }
 
-    if(ret) {
+    if (ret) {
         SDL_LogError(SDL_LOG_CATEGORY_VIDEO, "Could not restore CRTC");
     }
 
@@ -1310,7 +1322,7 @@ KMSDRM_SetDisplayMode(_THIS, SDL_VideoDisplay * display, SDL_DisplayMode * mode)
         return 0;
     }
 
-    if (!modedata) {
+    if (modedata == NULL) {
         return SDL_SetError("Mode doesn't have an associated index");
     }
 
@@ -1334,7 +1346,7 @@ KMSDRM_DestroyWindow(_THIS, SDL_Window *window)
     SDL_bool is_vulkan = window->flags & SDL_WINDOW_VULKAN; /* Is this a VK window? */
     unsigned int i, j;
 
-    if (!windata) {
+    if (windata == NULL) {
         return;
     }
 
@@ -1419,8 +1431,8 @@ KMSDRM_CreateWindow(_THIS, SDL_Window * window)
 
     /* Allocate window internal data */
     windata = (SDL_WindowData *)SDL_calloc(1, sizeof(SDL_WindowData));
-    if (!windata) {
-        return(SDL_OutOfMemory());
+    if (windata == NULL) {
+        return SDL_OutOfMemory();
     }
 
     /* Setup driver data for this window */
@@ -1452,7 +1464,7 @@ KMSDRM_CreateWindow(_THIS, SDL_Window * window)
                but only when we come here for the first time,
                and only if it's not a VK window. */
             if ((ret = KMSDRM_GBMInit(_this, dispdata))) {
-                return (SDL_SetError("Can't init GBM on window creation."));
+                return SDL_SetError("Can't init GBM on window creation.");
             }
         }
 
@@ -1469,10 +1481,10 @@ KMSDRM_CreateWindow(_THIS, SDL_Window * window)
                 _this->gl_config.major_version = 2;
                 _this->gl_config.minor_version = 0;
                 if (SDL_EGL_LoadLibrary(_this, NULL, egl_display, EGL_PLATFORM_GBM_MESA) < 0) {
-                    return (SDL_SetError("Can't load EGL/GL library on window creation."));
+                    return SDL_SetError("Can't load EGL/GL library on window creation.");
                 }
             }
-
+            
             _this->gl_config.driver_loaded = 1;
 
         }
@@ -1502,7 +1514,7 @@ KMSDRM_CreateWindow(_THIS, SDL_Window * window)
         /* Create the window surfaces with the size we have just chosen.
            Needs the window diverdata in place. */
         if ((ret = KMSDRM_CreateSurfaces(_this, window))) {
-            return (SDL_SetError("Can't window GBM/EGL surfaces on window creation."));
+            return SDL_SetError("Can't window GBM/EGL surfaces on window creation.");
         }
     } /* NON-Vulkan block ends. */
 
@@ -1516,7 +1528,7 @@ KMSDRM_CreateWindow(_THIS, SDL_Window * window)
         viddata->max_windows = new_max_windows;
 
         if (!viddata->windows) {
-            return (SDL_OutOfMemory());
+            return SDL_OutOfMemory();
         }
     }
 
diff --git a/src/video/kmsdrm/SDL_kmsdrmvulkan.c b/src/video/kmsdrm/SDL_kmsdrmvulkan.c
index d404fd802..4c64c9441 100644
--- a/src/video/kmsdrm/SDL_kmsdrmvulkan.c
+++ b/src/video/kmsdrm/SDL_kmsdrmvulkan.c
@@ -51,19 +51,23 @@ int KMSDRM_Vulkan_LoadLibrary(_THIS, const char *path)
     SDL_bool hasDisplayExtension = SDL_FALSE;
     PFN_vkGetInstanceProcAddr vkGetInstanceProcAddr = NULL;
 
-    if(_this->vulkan_config.loader_handle)
+    if (_this->vulkan_config.loader_handle) {
         return SDL_SetError("Vulkan already loaded");
+    }
 
     /* Load the Vulkan library */
-    if(!path)
+    if (path == NULL) {
         path = SDL_getenv("SDL_VULKAN_LIBRARY");
-    if(!path)
+    }
+    if (path == NULL) {
         path = DEFAULT_VULKAN;
+    }
 
     _this->vulkan_config.loader_handle = SDL_LoadObject(path);
 
-    if(!_this->vulkan_config.loader_handle)
+    if (!_this->vulkan_config.loader_handle) {
         return -1;
+    }
 
     SDL_strlcpy(_this->vulkan_config.loader_path, path,
                 SDL_arraysize(_this->vulkan_config.loader_path));
@@ -71,43 +75,44 @@ int KMSDRM_Vulkan_LoadLibrary(_THIS, const char *path)
     vkGetInstanceProcAddr = (PFN_vkGetInstanceProcAddr)SDL_LoadFunction(
         _this->vulkan_config.loader_handle, "vkGetInstanceProcAddr");
 
-    if(!vkGetInstanceProcAddr)
+    if (!vkGetInstanceProcAddr) {
         goto fail;
+    }
 
     _this->vulkan_config.vkGetInstanceProcAddr = (void *)vkGetInstanceProcAddr;
     _this->vulkan_config.vkEnumerateInstanceExtensionProperties =
         (void *)((PFN_vkGetInstanceProcAddr)_this->vulkan_config.vkGetInstanceProcAddr)(
             VK_NULL_HANDLE, "vkEnumerateInstanceExtensionProperties");
 
-    if(!_this->vulkan_config.vkEnumerateInstanceExtensionProperties)
+    if (!_this->vulkan_config.vkEnumerateInstanceExtensionProperties) {
         goto fail;
+    }
 
     extensions = SDL_Vulkan_CreateInstanceExtensionsList(
         (PFN_vkEnumerateInstanceExtensionProperties)
             _this->vulkan_config.vkEnumerateInstanceExtensionProperties,
         &extensionCount);
 
-    if(!extensions)
+    if (extensions == NULL) {
         goto fail;
+    }
 
-    for(i = 0; i < extensionCount; i++)
+    for (i = 0; i < extensionCount; i++)
     {
-        if(SDL_strcmp(VK_KHR_SURFACE_EXTENSION_NAME, extensions[i].extensionName) == 0)
+        if (SDL_strcmp(VK_KHR_SURFACE_EXTENSION_NAME, extensions[i].extensionName) == 0) {
             hasSurfaceExtension = SDL_TRUE;
-        else if(SDL_strcmp(VK_KHR_DISPLAY_EXTENSION_NAME, extensions[i].extensionName) == 0)
+        } else if (SDL_strcmp(VK_KHR_DISPLAY_EXTENSION_NAME, extensions[i].extensionName) == 0) {
             hasDisplayExtension = SDL_TRUE;
+        }
     }
 
     SDL_free(extensions);
 
-    if(!hasSurfaceExtension)
-    {
+    if (!hasSurfaceExtension) {
         SDL_SetError("Installed Vulkan doesn't implement the "
                      VK_KHR_SURFACE_EXTENSION_NAME " extension");
         goto fail;
-    }
-    else if(!hasDisplayExtension)
-    {
+    } else if (!hasDisplayExtension) {
         SDL_SetError("Installed Vulkan doesn't implement the "
                      VK_KHR_DISPLAY_EXTENSION_NAME "extension");
         goto fail;
@@ -123,8 +128,7 @@ fail:
 
 void KMSDRM_Vulkan_UnloadLibrary(_THIS)
 {
-    if(_this->vulkan_config.loader_handle)
-    {
+    if (_this->vulkan_config.loader_handle) {
         SDL_UnloadObject(_this->vulkan_config.loader_handle);
         _this->vulkan_config.loader_handle = NULL;
     }
@@ -148,8 +152,7 @@ SDL_bool KMSDRM_Vulkan_GetInstanceExtensions(_THIS,
     static const char *const extensionsForKMSDRM[] = {
         VK_KHR_SURFACE_EXTENSION_NAME, VK_KHR_DISPLAY_EXTENSION_NAME
     };
-    if(!_this->vulkan_config.loader_handle)
-    {
+    if (!_this->vulkan_config.loader_handle) {
         SDL_SetError("Vulkan is not loaded");
         return SDL_FALSE;
     }
@@ -257,8 +260,7 @@ SDL_bool KMSDRM_Vulkan_CreateSurface(_THIS,
         (PFN_vkCreateDisplayModeKHR)vkGetInstanceProcAddr(
             instance, "vkCreateDisplayModeKHR");
 
-    if(!_this->vulkan_config.loader_handle)
-    {
+    if (!_this->vulkan_config.loader_handle) {
         SDL_SetError("Vulkan is not loaded");
         goto clean;
     }
@@ -272,8 +274,7 @@ SDL_bool KMSDRM_Vulkan_CreateSurface(_THIS,
     /* that the VK_KHR_Display extension is active on the instance. */
     /* That's the central extension we need for x-less VK!          */
     /****************************************************************/
-    if(!vkCreateDisplayPlaneSurfaceKHR)
-    {
+    if (!vkCreateDisplayPlaneSurfaceKHR) {
         SDL_SetError(VK_KHR_DISPLAY_EXTENSION_NAME
                      " extension is not enabled in the Vulkan instance.");
         goto clean;
@@ -443,9 +444,9 @@ SDL_bool KMSDRM_Vulkan_CreateSurface(_THIS,
 
         /* The plane must be bound to the chosen display, or not in use.
            If none of these is true, iterate to another plane. */
-        if (!((plane_props[i].currentDisplay == display) ||
-              (plane_props[i].currentDisplay == VK_NULL_HANDLE))) 
+        if (!((plane_props[i].currentDisplay == display) || (plane_props[i].currentDisplay == VK_NULL_HANDLE))) {
             continue;
+        }
 
         /* Iterate the list of displays supported by this plane
            in order to find out if the chosen display is among them. */
@@ -500,8 +501,7 @@ SDL_bool KMSDRM_Vulkan_CreateSurface(_THIS,
                                      &display_plane_surface_create_info,
                                      NULL,
                                      surface);
-    if(result != VK_SUCCESS)
-    {
+    if (result != VK_SUCCESS) {
         SDL_SetError("vkCreateDisplayPlaneSurfaceKHR failed: %s",
             SDL_Vulkan_GetResultString(result));
         goto clean;
@@ -510,16 +510,21 @@ SDL_bool KMSDRM_Vulkan_CreateSurface(_THIS,
     ret = SDL_TRUE;
 
 clean:
-    if (physical_devices)
-        SDL_free (physical_devices);
-    if (display_props)
-        SDL_free (display_props);
-    if (device_props)
-        SDL_free (device_props);
-    if (plane_props)
-        SDL_free (plane_props);
-    if (mode_props)
-        SDL_free (mode_props);
+    if (physical_devices) {
+        SDL_free(physical_devices);
+    }
+    if (display_props) {
+        SDL_free(display_props);
+    }
+    if (device_props) {
+        SDL_free(device_props);
+    }
+    if (plane_props) {
+        SDL_free(plane_props);
+    }
+    if (mode_props) {
+        SDL_free(mode_props);
+    }
 
     return ret;
 }
diff --git a/src/video/n3ds/SDL_n3dsframebuffer.c b/src/video/n3ds/SDL_n3dsframebuffer.c
index ba4ec51bf..1de24d023 100644
--- a/src/video/n3ds/SDL_n3dsframebuffer.c
+++ b/src/video/n3ds/SDL_n3dsframebuffer.c
@@ -48,7 +48,7 @@ SDL_N3DS_CreateWindowFramebuffer(_THIS, SDL_Window *window, Uint32 *format, void
     FreePreviousWindowFramebuffer(window);
     framebuffer = CreateNewWindowFramebuffer(window);
 
-    if (!framebuffer) {
+    if (framebuffer == NULL) {
         return SDL_OutOfMemory();
     }
 
@@ -86,7 +86,7 @@ SDL_N3DS_UpdateWindowFramebuffer(_THIS, SDL_Window *window, const SDL_Rect *rect
     u32 bufsize;
 
     surface = (SDL_Surface *) SDL_GetWindowData(window, N3DS_SURFACE);
-    if (!surface) {
+    if (surface == NULL) {
         return SDL_SetError("%s: Unable to get the window surface.", __func__);
     }
 
@@ -94,8 +94,8 @@ SDL_N3DS_UpdateWindowFramebuffer(_THIS, SDL_Window *window, const SDL_Rect *rect
     framebuffer = (u32 *) gfxGetFramebuffer(drv_data->screen, GFX_LEFT, &width, &height);
     bufsize = width * height * 4;
 
-    CopyFramebuffertoN3DS(framebuffer, (Dimensions){ width, height },
-                          surface->pixels, (Dimensions){ surface->w, surface->h });
+    CopyFramebuffertoN3DS(framebuffer, (Dimensions) { width, height },
+                          surface->pixels, (Dimensions) { surface->w, surface->h });
     FlushN3DSBuffer(framebuffer, bufsize, drv_data->screen);
 
     return 0;
diff --git a/src/video/n3ds/SDL_n3dsvideo.c b/src/video/n3ds/SDL_n3dsvideo.c
index d4a46ad06..490e4110b 100644
--- a/src/video/n3ds/SDL_n3dsvideo.c
+++ b/src/video/n3ds/SDL_n3dsvideo.c
@@ -59,9 +59,9 @@ static SDL_VideoDevice *
 N3DS_CreateDevice(void)
 {
     SDL_VideoDevice *device = (SDL_VideoDevice *) SDL_calloc(1, sizeof(SDL_VideoDevice));
-    if (!device) {
+    if (device == NULL) {
         SDL_OutOfMemory();
-        return (0);
+        return 0;
     }
 
     device->VideoInit = N3DS_VideoInit;
diff --git a/src/video/ngage/SDL_ngageevents.cpp b/src/video/ngage/SDL_ngageevents.cpp
index a13633376..71d9975db 100644
--- a/src/video/ngage/SDL_ngageevents.cpp
+++ b/src/video/ngage/SDL_ngageevents.cpp
@@ -47,8 +47,7 @@ NGAGE_PumpEvents(_THIS)
 {
     SDL_VideoData *phdata = (SDL_VideoData*)_this->driverdata;
 
-    while (phdata->NGAGE_WsEventStatus != KRequestPending)
-    {
+    while (phdata->NGAGE_WsEventStatus != KRequestPending) {
         phdata->NGAGE_WsSession.GetEvent(phdata->NGAGE_WsEvent);
 
         HandleWsEvent(_this, phdata->NGAGE_WsEvent);
diff --git a/src/video/ngage/SDL_ngageframebuffer.cpp b/src/video/ngage/SDL_ngageframebuffer.cpp
index 98ff9ff71..f8cea52bd 100644
--- a/src/video/ngage/SDL_ngageframebuffer.cpp
+++ b/src/video/ngage/SDL_ngageframebuffer.cpp
@@ -57,7 +57,7 @@ int SDL_NGAGE_CreateWindowFramebuffer(_THIS, SDL_Window * window, Uint32 * forma
     /* Create a new one */
     SDL_GetWindowSize(window, &w, &h);
     surface = SDL_CreateRGBSurfaceWithFormat(0, w, h, 0, surface_format);
-    if (! surface) {
+    if (surface == NULL) {
         return -1;
     }
 
@@ -98,21 +98,16 @@ int SDL_NGAGE_CreateWindowFramebuffer(_THIS, SDL_Window * window, Uint32 * forma
      *
      * In 12 bpp machines the table has 16 entries.
      */
-    if (phdata->NGAGE_HasFrameBuffer && GetBpp(displayMode) == 8)
-    {
+    if (phdata->NGAGE_HasFrameBuffer && GetBpp(displayMode) == 8) {
         phdata->NGAGE_FrameBuffer += 512;
-    }
-    else
-    {
+    } else {
         phdata->NGAGE_FrameBuffer += 32;
     }
     #if 0
-    if (phdata->NGAGE_HasFrameBuffer && GetBpp(displayMode) == 12)
-    {
+    if (phdata->NGAGE_HasFrameBuffer && GetBpp(displayMode) == 12) {
         phdata->NGAGE_FrameBuffer += 16 * 2;
     }
-    if (phdata->NGAGE_HasFrameBuffer && GetBpp(displayMode) == 16)
-    {
+    if (phdata->NGAGE_HasFrameBuffer && GetBpp(displayMode) == 16) {
         phdata->NGAGE_FrameBuffer += 16 * 2;
     }
     #endif
@@ -154,14 +149,12 @@ int SDL_NGAGE_UpdateWindowFramebuffer(_THIS, SDL_Window * window, const SDL_Rect
     SDL_Surface *surface;
 
     surface = (SDL_Surface *) SDL_GetWindowData(window, NGAGE_SURFACE);
-    if (! surface)
-    {
+    if (surface == NULL) {
         return SDL_SetError("Couldn't find ngage surface for window");
     }
 
     /* Send the data to the display */
-    if (SDL_getenv("SDL_VIDEO_NGAGE_SAVE_FRAMES"))
-    {
+    if (SDL_getenv("SDL_VIDEO_NGAGE_SAVE_FRAMES")) {
         char file[128];
         SDL_snprintf(file, sizeof(file), "SDL_window%d-%8.8d.bmp",
                      (int)SDL_GetWindowID(window), ++frame_number);
@@ -231,8 +224,7 @@ void DirectDraw(_THIS, int numrects, SDL_Rect *rects, TUint16* screenBuffer)
 
     /* Render the rectangles in the list */
 
-    for (i = 0; i < numrects; ++i)
-    {
+    for (i = 0; i < numrects; ++i) {
         const SDL_Rect& currentRect = rects[i];
         SDL_Rect        rect2;
         rect2.x = currentRect.x;
@@ -240,8 +232,7 @@ void DirectDraw(_THIS, int numrects, SDL_Rect *rects, TUint16* screenBuffer)
         rect2.w = currentRect.w;
         rect2.h = currentRect.h;
 
-        if (rect2.w <= 0 || rect2.h <= 0) /* Sanity check */
-        {
+        if (rect2.w <= 0 || rect2.h <= 0) /* Sanity check */ {
             continue;
         }
 
@@ -250,8 +241,7 @@ void DirectDraw(_THIS, int numrects, SDL_Rect *rects, TUint16* screenBuffer)
         /* Check rects validity, i.e. upper and lower bounds */
         TInt maxX = Min(screenW - 1, rect2.x + rect2.w - 1);
         TInt maxY = Min(screenH - 1, rect2.y + rect2.h - 1);
-        if (maxX < 0 || maxY < 0) /* sanity check */
-        {
+        if (maxX < 0 || maxY < 0) /* sanity check */ {
             continue;
         }
         /* Clip from bottom */
@@ -274,22 +264,19 @@ void DirectDraw(_THIS, int numrects, SDL_Rect *rects, TUint16* screenBuffer)
                 TUint16* bitmapLine   = (TUint16*)screen->pixels + sourceStartOffset;
                 TUint16* screenMemory = screenBuffer + targetStartOffset;
 
-                if (skipValue == 1)
-                {
-                    for(TInt y = 0 ; y < sourceRectHeight ; y++)
+                if (skipValue == 1) {
+                    for (TInt y = 0 ; y < sourceRectHeight ; y++)
                     {
                         Mem::Copy(screenMemory, bitmapLine, sourceRectWidthInBytes);
                         bitmapLine   += sourceScanlineLength;
                         screenMemory += targetScanlineLength;
                     }
-                }
-                else
-                {
-                    for(TInt y = 0 ; y < sourceRectHeight ; y++)
+                } else {
+                    for (TInt y = 0 ; y < sourceRectHeight ; y++)
                     {
                         TUint16* bitmapPos           = bitmapLine;   /* 2 bytes per pixel */
                         TUint16* screenMemoryLinePos = screenMemory; /* 2 bytes per pixel */
-                        for(TInt x = 0 ; x < sourceRectWidth ; x++)
+                        for (TInt x = 0 ; x < sourceRectWidth ; x++)
                         {
                             __ASSERT_DEBUG(screenMemory < (screenBuffer + phdata->NGAGE_ScreenSize.iWidth * phdata->NGAGE_ScreenSize.iHeight), User::Panic(_L("SDL"), KErrCorrupt));
                             __ASSERT_DEBUG(screenMemory >= screenBuffer, User::Panic(_L("SDL"), KErrCorrupt));
@@ -308,17 +295,16 @@ void DirectDraw(_THIS, int numrects, SDL_Rect *rects, TUint16* screenBuffer)
             // 256 color paletted mode: 8 bpp --> 12 bpp
             default:
             {
-                if(phdata->NGAGE_BytesPerPixel <= 2)
-                {
+                if (phdata->NGAGE_BytesPerPixel <= 2) {
                     TUint8*  bitmapLine   = (TUint8*)screen->pixels + sourceStartOffset;
                     TUint16* screenMemory = screenBuffer + targetStartOffset;
 
-                    for(TInt y = 0 ; y < sourceRectHeight ; y++)
+                    for (TInt y = 0 ; y < sourceRectHeight ; y++)
                     {
                         TUint8*  bitmapPos           = bitmapLine;   /* 1 byte per pixel */
                         TUint16* screenMemoryLinePos = screenMemory; /* 2 bytes per pixel */
                         /* Convert each pixel from 256 palette to 4k color values */
-                        for(TInt x = 0 ; x < sourceRectWidth ; x++)
+                        for (TInt x = 0 ; x < sourceRectWidth ; x++)
                         {
                             __ASSERT_DEBUG(screenMemoryLinePos < (screenBuffer + (phdata->NGAGE_ScreenSize.iWidth * phdata->NGAGE_ScreenSize.iHeight)), User::Panic(_L("SDL"), KErrCorrupt));
                             __ASSERT_DEBUG(screenMemoryLinePos >= screenBuffer, User::Panic(_L("SDL"), KErrCorrupt));
@@ -329,17 +315,15 @@ void DirectDraw(_THIS, int numrects, SDL_Rect *rects, TUint16* screenBuffer)
                         bitmapLine   += sourceScanlineLength;
                         screenMemory += targetScanlineLength;
                     }
-                }
-                else
-                {
+                } else {
                     TUint8*  bitmapLine   = (TUint8*)screen->pixels + sourceStartOffset;
                     TUint32* screenMemory = reinterpret_cast<TUint32*>(screenBuffer + targetStartOffset);
-                    for(TInt y = 0 ; y < sourceRectHeight ; y++)
+                    for (TInt y = 0 ; y < sourceRectHeight ; y++)
                     {
                         TUint8*  bitmapPos           = bitmapLine;   /* 1 byte per pixel */
                         TUint32* screenMemoryLinePos = screenMemory; /* 2 bytes per pixel */
                         /* Convert each pixel from 256 palette to 4k color values */
-                        for(TInt x = 0 ; x < sourceRectWidth ; x++)
+                        for (TInt x = 0 ; x < sourceRectWidth ; x++)
                         {
                             __ASSERT_DEBUG(screenMemoryLinePos < (reinterpret_cast<TUint32*>(screenBuffer) + (phdata->NGAGE_ScreenSize.iWidth * phdata->NGAGE_ScreenSize.iHeight)), User::Panic(_L("SDL"), KErrCorrupt));
                             __ASSERT_DEBUG(screenMemoryLinePos >= reinterpret_cast<TUint32*>(screenBuffer), User::Panic(_L("SDL"), KErrCorrupt));
@@ -360,8 +344,7 @@ void DirectUpdate(_THIS, int numrects, SDL_Rect *rects)
 {
     SDL_VideoData *phdata = (SDL_VideoData*)_this->driverdata;
 
-    if (! phdata->NGAGE_IsWindowFocused)
-    {
+    if (! phdata->NGAGE_IsWindowFocused) {
         SDL_PauseAudio(1);
         SDL_Delay(1000);
         return;
@@ -372,18 +355,15 @@ void DirectUpdate(_THIS, int numrects, SDL_Rect *rects)
     TUint16* screenBuffer = (TUint16*)phdata->NGAGE_FrameBuffer;
 
 #if 0
-    if (phdata->NGAGE_ScreenOrientation == CFbsBitGc::EGraphicsOrientationRotated270)
-    {
+    if (phdata->NGAGE_ScreenOrientation == CFbsBitGc::EGraphicsOrientationRotated270) {
         // ...
-    }
-    else
+    } else
 #endif
     {
         DirectDraw(_this, numrects, rects, screenBuffer);
     }
 
-    for (int i = 0; i < numrects; ++i)
-    {
+    for (int i = 0; i < numrects; ++i) {
         TInt  aAx   = rects[i].x;
         TInt  aAy   = rects[i].y;
         TInt  aBx   = rects[i].w;
diff --git a/src/video/ngage/SDL_ngagevideo.cpp b/src/video/ngage/SDL_ngagevideo.cpp
index d0ed05f20..0f753da63 100644
--- a/src/video/ngage/SDL_ngagevideo.cpp
+++ b/src/video/ngage/SDL_ngagevideo.cpp
@@ -59,29 +59,24 @@ NGAGE_DeleteDevice(SDL_VideoDevice * device)
 {
     SDL_VideoData *phdata = (SDL_VideoData*)device->driverdata;
 
-    if (phdata)
-    {
+    if (phdata) {
         /* Free Epoc resources */
 
         /* Disable events for me */
-        if (phdata->NGAGE_WsEventStatus != KRequestPending)
-        {
+        if (phdata->NGAGE_WsEventStatus != KRequestPending) {
             phdata->NGAGE_WsSession.EventReadyCancel();
         }
-        if (phdata->NGAGE_RedrawEventStatus != KRequestPending)
-        {
+        if (phdata->NGAGE_RedrawEventStatus != KRequestPending) {
             phdata->NGAGE_WsSession.RedrawReadyCancel();
         }
 
         free(phdata->NGAGE_DrawDevice);
 
-        if (phdata->NGAGE_WsWindow.WsHandle())
-        {
+        if (phdata->NGAGE_WsWindow.WsHandle()) {
             phdata->NGAGE_WsWindow.Close();
         }
 
-        if (phdata->NGAGE_WsWindowGroup.WsHandle())
-        {
+        if (phdata->NGAGE_WsWindowGroup.WsHandle()) {
             phdata->NGAGE_WsWindowGroup.Close();
         }
 
@@ -91,8 +86,7 @@ NGAGE_DeleteDevice(SDL_VideoDevice * device)
         delete phdata->NGAGE_WsScreen;
         phdata->NGAGE_WsScreen = NULL;
 
-        if (phdata->NGAGE_WsSession.WsHandle())
-        {
+        if (phdata->NGAGE_WsSession.WsHandle()) {
             phdata->NGAGE_WsSession.Close();
         }
 
@@ -100,8 +94,7 @@ NGAGE_DeleteDevice(SDL_VideoDevice * device)
         phdata = NULL;
     }
 
-    if (device)
-    {
+    if (device) {
         SDL_free(device);
         device = NULL;
     }
@@ -115,18 +108,17 @@ NGAGE_CreateDevice(void)
 
     /* Initialize all variables that we clean on shutdown */
     device = (SDL_VideoDevice *) SDL_calloc(1, sizeof(SDL_VideoDevice));
-    if (!device) {
+    if (device == NULL) {
         SDL_OutOfMemory();
-        return (0);
+        return 0;
     }
 
     /* Initialize internal N-Gage specific data */
     phdata = (SDL_VideoData *) SDL_calloc(1, sizeof(SDL_VideoData));
-    if (! phdata)
-    {
+    if (phdata == NULL) {
         SDL_OutOfMemory();
         SDL_free(device);
-        return (0);
+        return 0;
     }
 
     /* General video */
diff --git a/src/video/ngage/SDL_ngagewindow.cpp b/src/video/ngage/SDL_ngagewindow.cpp
index 5b0682b29..206e8b83d 100644
--- a/src/video/ngage/SDL_ngagewindow.cpp
+++ b/src/video/ngage/SDL_ngagewindow.cpp
@@ -37,7 +37,7 @@ NGAGE_CreateWindow(_THIS, SDL_Window* window)
 {
     NGAGE_Window* ngage_window = (NGAGE_Window*)SDL_calloc(1, sizeof(NGAGE_Window));
 
-    if (!ngage_window) {
+    if (ngage_window == NULL) {
         return SDL_OutOfMemory();
     }
 
diff --git a/src/video/offscreen/SDL_offscreenframebuffer.c b/src/video/offscreen/SDL_offscreenframebuffer.c
index 376058856..2e97e58f3 100644
--- a/src/video/offscreen/SDL_offscreenframebuffer.c
+++ b/src/video/offscreen/SDL_offscreenframebuffer.c
@@ -40,7 +40,7 @@ int SDL_OFFSCREEN_CreateWindowFramebuffer(_THIS, SDL_Window * window, Uint32 * f
     /* Create a new one */
     SDL_GetWindowSize(window, &w, &h);
     surface = SDL_CreateRGBSurfaceWithFormat(0, w, h, 0, surface_format);
-    if (!surface) {
+    if (surface == NULL) {
         return -1;
     }
 
@@ -58,7 +58,7 @@ int SDL_OFFSCREEN_UpdateWindowFramebuffer(_THIS, SDL_Window * window, const SDL_
     SDL_Surface *surface;
 
     surface = (SDL_Surface *) SDL_GetWindowData(window, OFFSCREEN_SURFACE);
-    if (!surface) {
+    if (surface == NULL) {
         return SDL_SetError("Couldn't find offscreen surface for window");
     }
 
diff --git a/src/video/offscreen/SDL_offscreenvideo.c b/src/video/offscreen/SDL_offscreenvideo.c
index 8e62e88fb..84439fb64 100644
--- a/src/video/offscreen/SDL_offscreenvideo.c
+++ b/src/video/offscreen/SDL_offscreenvideo.c
@@ -60,9 +60,9 @@ OFFSCREEN_CreateDevice(void)
 
     /* Initialize all variables that we clean on shutdown */
     device = (SDL_VideoDevice *) SDL_calloc(1, sizeof(SDL_VideoDevice));
-    if (!device) {
+    if (device == NULL) {
         SDL_OutOfMemory();
-        return (0);
+        return 0;
     }
 
     /* General video */
diff --git a/src/video/offscreen/SDL_offscreenwindow.c b/src/video/offscreen/SDL_offscreenwindow.c
index fd85f77e5..a6aa4d463 100644
--- a/src/video/offscreen/SDL_offscreenwindow.c
+++ b/src/video/offscreen/SDL_offscreenwindow.c
@@ -32,7 +32,7 @@ OFFSCREEN_CreateWindow(_THIS, SDL_Window* window)
 {
     OFFSCREEN_Window *offscreen_window = SDL_calloc(1, sizeof(OFFSCREEN_Window));
 
-    if (!offscreen_window) {
+    if (offscreen_window == NULL) {
         return SDL_OutOfMemory();
     }
 
diff --git a/src/video/ps2/SDL_ps2video.c b/src/video/ps2/SDL_ps2video.c
index 9ada4edaf..2cecf7f42 100644
--- a/src/video/ps2/SDL_ps2video.c
+++ b/src/video/ps2/SDL_ps2video.c
@@ -108,9 +108,9 @@ static SDL_VideoDevice *PS2_CreateDevice(void)
 
     /* Initialize all variables that we clean on shutdown */
     device = (SDL_VideoDevice *) SDL_calloc(1, sizeof(SDL_VideoDevice));
-    if (!device) {
+    if (device == NULL) {
         SDL_OutOfMemory();
-        return (0);
+        return 0;
     }
 
     /* Set the function pointers */
diff --git a/src/video/psp/SDL_pspevents.c b/src/video/psp/SDL_pspevents.c
index dd2c67f17..f5022f4bc 100644
--- a/src/video/psp/SDL_pspevents.c
+++ b/src/video/psp/SDL_pspevents.c
@@ -89,9 +89,9 @@ void PSP_PumpEvents(_THIS)
     /* HPRM Keyboard */
     changed = old_keys ^ keys;
     old_keys = keys;
-    if(changed) {
-        for(i=0; i<sizeof(keymap_psp)/sizeof(keymap_psp[0]); i++) {
-            if(changed & keymap_psp[i].id) {
+    if (changed) {
+        for (i=0; i<sizeof(keymap_psp)/sizeof(keymap_psp[0]); i++) {
+            if (changed & keymap_psp[i].id) {
                 SDL_SendKeyboardKey((keys & keymap_psp[i].id) ?
                                     SDL_PRESSED : SDL_RELEASED, SDL_GetScancodeFromKey(keymap_psp[i].sym));
             }
@@ -104,10 +104,10 @@ void PSP_PumpEvents(_THIS)
         int i, length, count;
         SIrKeybScanCodeData *scanData;
 
-            if(pspIrKeybReadinput(buffer, &length) >= 0) {
-                if((length % sizeof(SIrKeybScanCodeData)) == 0){
+            if (pspIrKeybReadinput(buffer, &length) >= 0) {
+                if ((length % sizeof(SIrKeybScanCodeData)) == 0) {
                     count = length / sizeof(SIrKeybScanCodeData);
-                    for( i=0; i < count; i++ ) {
+                    for ( i=0; i < count; i++ ) {
                 unsigned char raw, pressed;
                         scanData=(SIrKeybScanCodeData*) buffer+i;
                         raw = scanData->raw;
@@ -133,8 +133,9 @@ void PSP_InitOSKeymap(_THIS)
 {
 #ifdef PSPIRKEYB
     int i;
-    for (i=0; i<SDL_TABLESIZE(keymap); ++i)
+    for (i = 0; i < SDL_TABLESIZE(keymap); ++i) {
         keymap[i] = SDLK_UNKNOWN;
+    }
 
     keymap[KEY_ESC] = SDLK_ESCAPE;
 
@@ -252,12 +253,12 @@ void PSP_EventInit(_THIS)
     }
 #endif
     /* Start thread to read data */
-    if((event_sem =  SDL_CreateSemaphore(1)) == NULL) {
+    if ((event_sem =  SDL_CreateSemaphore(1)) == NULL) {
         SDL_SetError("Can't create input semaphore");
         return;
     }
     running = 1;
-    if((thread = SDL_CreateThreadInternal(EventUpdate, "PSPInputThread", 4096, NULL)) == NULL) {
+    if ((thread = SDL_CreateThreadInternal(EventUpdate, "PSPInputThread", 4096, NULL)) == NULL) {
         SDL_SetError("Can't create input thread");
         return;
     }
diff --git a/src/video/psp/SDL_pspgl.c b/src/video/psp/SDL_pspgl.c
index ca55ea251..abbae8353 100644
--- a/src/video/psp/SDL_pspgl.c
+++ b/src/video/psp/SDL_pspgl.c
@@ -103,13 +103,11 @@ PSP_GL_CreateContext(_THIS, SDL_Window * window)
         attribs[i++] = EGL_DEPTH_SIZE;
         attribs[i++] = _this->gl_config.depth_size;
 
-        if (_this->gl_config.alpha_size)
-        {
+        if (_this->gl_config.alpha_size) {
             attribs[i++] = EGL_ALPHA_SIZE;
             attribs[i++] = _this->gl_config.alpha_size;
         }
-        if (_this->gl_config.stencil_size)
-        {
+        if (_this->gl_config.stencil_size) {
             attribs[i++] = EGL_STENCIL_SIZE;
             attribs[i++] = _this->gl_config.stencil_size;
         }
@@ -118,8 +116,7 @@ PSP_GL_CreateContext(_THIS, SDL_Window * window)
 
         EGLCHK(eglChooseConfig(display, attribs, &config, 1, &num_configs));
 
-        if (num_configs == 0)
-        {
+        if (num_configs == 0) {
             SDL_SetError("No valid EGL configs for requested mode");
             return 0;
         }
diff --git a/src/video/raspberry/SDL_rpivideo.c b/src/video/raspberry/SDL_rpivideo.c
index 4503f56df..39a7db0f9 100644
--- a/src/video/raspberry/SDL_rpivideo.c
+++ b/src/video/raspberry/SDL_rpivideo.c
@@ -351,7 +351,7 @@ RPI_DestroyWindow(_THIS, SDL_Window * window)
     SDL_VideoDisplay *display = SDL_GetDisplayForWindow(window);
     SDL_DisplayData *displaydata = (SDL_DisplayData *) display->driverdata;
 
-    if(data) {
+    if (data) {
         if (data->double_buffer) {
             /* Wait for vsync, and then stop vsync callbacks and destroy related stuff, if needed */
             SDL_LockMutex(data->vsync_cond_mutex);
diff --git a/src/video/riscos/SDL_riscosevents.c b/src/video/riscos/SDL_riscosevents.c
index fcca47011..362a67c0a 100644
--- a/src/video/riscos/SDL_riscosevents.c
+++ b/src/video/riscos/SDL_riscosevents.c
@@ -148,8 +148,9 @@ RISCOS_InitEvents(_THIS)
     _kernel_swi_regs regs;
     int i, status;
 
-    for (i = 0; i < RISCOS_MAX_KEYS_PRESSED; i++)
+    for (i = 0; i < RISCOS_MAX_KEYS_PRESSED; i++) {
         driverdata->key_pressed[i] = 255;
+    }
 
     status = (_kernel_osbyte(202, 0, 255) & 0xFF);
     SDL_ToggleModState(KMOD_NUM,    (status & (1 << 2)) == 0);
diff --git a/src/video/riscos/SDL_riscosmessagebox.c b/src/video/riscos/SDL_riscosmessagebox.c
index 8144a9df6..de465d5a9 100644
--- a/src/video/riscos/SDL_riscosmessagebox.c
+++ b/src/video/riscos/SDL_riscosmessagebox.c
@@ -41,10 +41,12 @@ RISCOS_ShowMessageBox(const SDL_MessageBoxData *messageboxdata, int *buttonid)
     regs.r[0] = (unsigned int)&error;
 
     regs.r[1] = (1 << 8) | (1 << 4);
-    if (messageboxdata->flags == SDL_MESSAGEBOX_INFORMATION)
+    if (messageboxdata->flags == SDL_MESSAGEBOX_INFORMATION) {
         regs.r[1] |= (1 << 9);
-    else if (messageboxdata->flags == SDL_MESSAGEBOX_WARNING)
+    } else if (messageboxdata->flags == SDL_MESSAGEBOX_WARNING) {
         regs.r[1] |= (2 << 9);
+    }
+    
     regs.r[2] = (unsigned int)messageboxdata->title;
     regs.r[3] = 0;
     regs.r[4] = 0;
@@ -52,8 +54,9 @@ RISCOS_ShowMessageBox(const SDL_MessageBoxData *messageboxdata, int *buttonid)
     SDL_strlcpy(buttonstring, "" , 1024);
     for (i = 0; i < messageboxdata->numbuttons; i++) {
         SDL_strlcat(buttonstring, messageboxdata->buttons[i].text, 1024);
-        if (i + 1 < messageboxdata->numbuttons)
+        if (i + 1 < messageboxdata->numbuttons) {
             SDL_strlcat(buttonstring, ",", 1024);
+        }
     }
     regs.r[5] = (unsigned int)buttonstring;
 
diff --git a/src/video/riscos/SDL_riscosmodes.c b/src/video/riscos/SDL_riscosmodes.c
index 9500b2229..383a4bdf8 100644
--- a/src/video/riscos/SDL_riscosmodes.c
+++ b/src/video/riscos/SDL_riscosmodes.c
@@ -88,7 +88,7 @@ static size_t
 measure_mode_block(const int *block)
 {
     size_t blockSize = ((block[0] & 0xFF) == 3) ? 7 : 5;
-    while(block[blockSize] != -1) {
+    while (block[blockSize] != -1) {
         blockSize += 2;
     }
     blockSize++;
@@ -169,7 +169,7 @@ convert_mode_block(const int *block)
     }
 
     dst = SDL_malloc(40);
-    if (!dst) {
+    if (dst == NULL) {
         return NULL;
     }
 
@@ -249,7 +249,7 @@ RISCOS_GetDisplayModes(_THIS, SDL_VideoDisplay * display)
     }
 
     block = SDL_malloc(-regs.r[7]);
-    if (!block) {
+    if (block == NULL) {
         SDL_OutOfMemory();
         return;
     }
@@ -268,8 +268,9 @@ RISCOS_GetDisplayModes(_THIS, SDL_VideoDisplay * display)
             continue;
         }
 
-        if (mode.format == SDL_PIXELFORMAT_UNKNOWN)
+        if (mode.format == SDL_PIXELFORMAT_UNKNOWN) {
             continue;
+        }
 
         mode.driverdata = convert_mode_block(pos + 4);
         if (!mode.driverdata) {
diff --git a/src/video/riscos/SDL_riscosvideo.c b/src/video/riscos/SDL_riscosvideo.c
index 476301100..7ae30e478 100644
--- a/src/video/riscos/SDL_riscosvideo.c
+++ b/src/video/riscos/SDL_riscosvideo.c
@@ -58,9 +58,9 @@ RISCOS_CreateDevice(void)
 
     /* Initialize all variables that we clean on shutdown */
     device = (SDL_VideoDevice *) SDL_calloc(1, sizeof(SDL_VideoDevice));
-    if (!device) {
+    if (device == NULL) {
         SDL_OutOfMemory();
-        return (0);
+        return 0;
     }
 
     /* Initialize internal data */
diff --git a/src/video/riscos/SDL_riscoswindow.c b/src/video/riscos/SDL_riscoswindow.c
index f47d33ad7..290c72feb 100644
--- a/src/video/riscos/SDL_riscoswindow.c
+++ b/src/video/riscos/SDL_riscoswindow.c
@@ -37,7 +37,7 @@ RISCOS_CreateWindow(_THIS, SDL_Window * window)
     SDL_WindowData *driverdata;
 
     driverdata = (SDL_WindowData *) SDL_calloc(1, sizeof(*driverdata));
-    if (!driverdata) {
+    if (driverdata == NULL) {
         return SDL_OutOfMemory();
     }
     driverdata->window = window;
@@ -56,8 +56,9 @@ RISCOS_DestroyWindow(_THIS, SDL_Window * window)
 {
     SDL_WindowData *driverdata = (SDL_WindowData *) window->driverdata;
 
-    if (!driverdata)
+    if (driverdata == NULL) {
         return;
+    }
 
     SDL_free(driverdata);
     window->driverdata = NULL;
diff --git a/src/video/vita/SDL_vitaframebuffer.c b/src/video/vita/SDL_vitaframebuffer.c
index 1c558486b..c14700f62 100644
--- a/src/video/vita/SDL_vitaframebuffer.c
+++ b/src/video/vita/SDL_vitaframebuffer.c
@@ -43,11 +43,13 @@ void *vita_gpu_alloc(unsigned int type, unsigned int size, SceUID *uid)
 
     *uid = sceKernelAllocMemBlock("gpu_mem", type, size, NULL);
 
-    if (*uid < 0)
+    if (*uid < 0) {
         return NULL;
+    }
 
-    if (sceKernelGetMemBlockBase(*uid, &mem) < 0)
+    if (sceKernelGetMemBlockBase(*uid, &mem) < 0) {
         return NULL;
+    }
 
     return mem;
 }
@@ -55,8 +57,9 @@ void *vita_gpu_alloc(unsigned int type, unsigned int size, SceUID *uid)
 void vita_gpu_free(SceUID uid)
 {
     void *mem = NULL;
-    if (sceKernelGetMemBlockBase(uid, &mem) < 0)
+    if (sceKernelGetMemBlockBase(uid, &mem) < 0) {
         return;
+    }
     sceKernelFreeMemBlock(uid);
 }
 
@@ -101,7 +104,7 @@ void VITA_DestroyWindowFramebuffer(_THIS, SDL_Window * window)
 {
     SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
 
-    if (!data) {
+    if (data == NULL) {
         /* The window wasn't fully initialized */
         return;
     }
diff --git a/src/video/vita/SDL_vitagl_pvr.c b/src/video/vita/SDL_vitagl_pvr.c
index d51150c03..11b4d5db4 100644
--- a/src/video/vita/SDL_vitagl_pvr.c
+++ b/src/video/vita/SDL_vitagl_pvr.c
@@ -54,10 +54,8 @@ VITA_GL_LoadLibrary(_THIS, const char *path)
     char* default_path = "app0:module";
     char target_path[MAX_PATH];
 
-    if (skip_init == NULL) // we don't care about actual value
-    {
-        if (override != NULL)
-        {
+    if (skip_init == NULL) // we don't care about actual value {
+        if (override != NULL) {
           default_path = override;
         }
 
@@ -101,8 +99,7 @@ VITA_GL_CreateContext(_THIS, SDL_Window * window)
 
     context = SDL_EGL_CreateContext(_this, ((SDL_WindowData *) window->driverdata)->egl_surface);
 
-    if (context != NULL)
-    {
+    if (context != NULL) {
         FB_WIDTH = window->w;
         FB_HEIGHT = window->h;
         set_getprocaddress((void *(*)(const char *))eglGetProcAddress);
diff --git a/src/video/vita/SDL_vitagles.c b/src/video/vita/SDL_vitagles.c
index 18ca7d57b..f9b6fb6d1 100644
--- a/src/video/vita/SDL_vitagles.c
+++ b/src/video/vita/SDL_vitagles.c
@@ -138,8 +138,7 @@ VITA_GLES_CreateContext(_THIS, SDL_Window * window)
 
     EGLCHK(eglChooseConfig(display, attribs, &config, 1, &num_configs));
 
-    if (num_configs == 0)
-    {
+    if (num_configs == 0) {
         SDL_SetError("No valid EGL configs for requested mode");
         return 0;
     }
diff --git a/src/video/vita/SDL_vitagles_pvr.c b/src/video/vita/SDL_vitagles_pvr.c
index bb06d2946..0f1d5f56f 100644
--- a/src/video/vita/SDL_vitagles_pvr.c
+++ b/src/video/vita/SDL_vitagles_pvr.c
@@ -43,10 +43,8 @@ VITA_GLES_LoadLibrary(_THIS, const char *path)
     char* default_path = "app0:module";
     char target_path[MAX_PATH];
 
-    if (skip_init == NULL) // we don't care about actual value
-    {
-        if (override != NULL)
-        {
+    if (skip_init == NULL) // we don't care about actual value {
+        if (override != NULL) {
           default_path = override;
         }
 
diff --git a/src/video/vita/SDL_vitakeyboard.c b/src/video/vita/SDL_vitakeyboard.c
index 409d424b1..9e5a6387d 100644
--- a/src/video/vita/SDL_vitakeyboard.c
+++ b/src/video/vita/SDL_vitakeyboard.c
@@ -52,17 +52,16 @@ void
 VITA_PollKeyboard(void)
 {
     // We skip polling keyboard if no window is created
-    if (Vita_Window == NULL)
+    if (Vita_Window == NULL) {
         return;
+    }
 
-    if (keyboard_hid_handle > 0)
-    {
+    if (keyboard_hid_handle > 0) {
         int numReports = sceHidKeyboardRead(keyboard_hid_handle, (SceHidKeyboardReport**)&k_reports, SCE_HID_MAX_REPORT);
 
         if (numReports < 0) {
             keyboard_hid_handle = 0;
-        }
-        else if (numReports) {
+        } else if (numReports) {
             // Numlock and Capslock state changes only on a SDL_PRESSED event
             // The k_report only reports the state of the LED
             if (k_reports[numReports - 1].modifiers[1] & 0x1) {
@@ -70,8 +69,7 @@ VITA_PollKeyboard(void)
                     SDL_SendKeyboardKey(SDL_PRESSED, SDL_SCANCODE_NUMLOCKCLEAR);
                     locks |= 0x1;
                 }
-            }
-            else {
+            } else {
                 if (locks & 0x1) {
                     SDL_SendKeyboardKey(SDL_RELEASED, SDL_SCANCODE_NUMLOCKCLEAR);
                     SDL_SendKeyboardKey(SDL_PRESSED, SDL_SCANCODE_NUMLOCKCLEAR);
@@ -85,8 +83,7 @@ VITA_PollKeyboard(void)
                     SDL_SendKeyboardKey(SDL_PRESSED, SDL_SCANCODE_CAPSLOCK);
                     locks |= 0x2;
                 }
-            }
-            else {
+            } else {
                 if (locks & 0x2) {
                     SDL_SendKeyboardKey(SDL_RELEASED, SDL_SCANCODE_CAPSLOCK);
                     SDL_SendKeyboardKey(SDL_PRESSED, SDL_SCANCODE_CAPSLOCK);
@@ -100,8 +97,7 @@ VITA_PollKeyboard(void)
                     SDL_SendKeyboardKey(SDL_PRESSED, SDL_SCANCODE_SCROLLLOCK);
                     locks |= 0x4;
                 }
-            }
-            else {
+            } else {
                 if (locks & 0x4) {
                     SDL_SendKeyboardKey(SDL_RELEASED, SDL_SCANCODE_SCROLLLOCK);
                     locks &= ~0x4;
@@ -114,64 +110,56 @@ VITA_PollKeyboard(void)
                 if (changed_modifiers & 0x01) {
                     if (prev_modifiers & 0x01) {
                         SDL_SendKeyboardKey(SDL_RELEASED, SDL_SCANCODE_LCTRL);
-                    }
-                    else {
+                    } else {
                         SDL_SendKeyboardKey(SDL_PRESSED, SDL_SCANCODE_LCTRL);
                     }
                 }
                 if (changed_modifiers & 0x02) {
                     if (prev_modifiers & 0x02) {
                         SDL_SendKeyboardKey(SDL_RELEASED, SDL_SCANCODE_LSHIFT);
-                    }
-                else {
+                    } else {
                         SDL_SendKeyboardKey(SDL_PRESSED, SDL_SCANCODE_LSHIFT);
                     }
                 }
                 if (changed_modifiers & 0x04) {
                     if (prev_modifiers & 0x04) {
                         SDL_SendKeyboardKey(SDL_RELEASED, SDL_SCANCODE_LALT);
-                    }
-                    else {
+                    } else {
                         SDL_SendKeyboardKey(SDL_PRESSED, SDL_SCANCODE_LALT);
                     }
                 }
                 if (changed_modifiers & 0x08) {
                     if (prev_modifiers & 0x08) {
                         SDL_SendKeyboardKey(SDL_RELEASED, SDL_SCANCODE_LGUI);
-                    }
-                    else {
+                    } else {
                         SDL_SendKeyboardKey(SDL_PRESSED, SDL_SCANCODE_LGUI);
                     }
                 }
                 if (changed_modifiers & 0x10) {
                     if (prev_modifiers & 0x10) {
                         SDL_SendKeyboardKey(SDL_RELEASED, SDL_SCANCODE_RCTRL);
-                    }
-                    else {
+                    } else {
                         SDL_SendKeyboardKey(SDL_PRESSED, SDL_SCANCODE_RCTRL);
                     }
             }
                 if (changed_modifiers & 0x20) {
                     if (prev_modifiers & 0x20) {
                         SDL_SendKeyboardKey(SDL_RELEASED, SDL_SCANCODE_RSHIFT);
-                    }
-                    else {
+                    } else {
                         SDL_SendKeyboardKey(SDL_PRESSED, SDL_SCANCODE_RSHIFT);
                     }
                 }
                 if (changed_modifiers & 0x40) {
                     if (prev_modifiers & 0x40) {
                         SDL_SendKeyboardKey(SDL_RELEASED, SDL_SCANCODE_RALT);
-                    }
-                    else {
+                    } else {
                         SDL_SendKeyboardKey(SDL_PRESSED, SDL_SCANCODE_RALT);
                     }
                 }
                 if (changed_modifiers & 0x80) {
                     if (prev_modifiers & 0x80) {
                         SDL_SendKeyboardKey(SDL_RELEASED, SDL_SCANCODE_RGUI);
-                    }
-                    else {
+                    } else {
                         SDL_SendKeyboardKey(SDL_PRESSED, SDL_SCANCODE_RGUI);
                     }
                 }
diff --git a/src/video/vita/SDL_vitamessagebox.c b/src/video/vita/SDL_vitamessagebox.c
index 492113986..6fe7048f4 100644
--- a/src/video/vita/SDL_vitamessagebox.c
+++ b/src/video/vita/SDL_vitamessagebox.c
@@ -43,8 +43,7 @@ int VITA_ShowMessageBox(const SDL_MessageBoxData *messageboxdata, int *buttonid)
     SceCommonDialogErrorCode init_result;
     SDL_bool setup_minimal_gxm = SDL_FALSE;
 
-    if (messageboxdata->numbuttons > 3)
-    {
+    if (messageboxdata->numbuttons > 3) {
         return -1;
     }
 
@@ -58,20 +57,15 @@ int VITA_ShowMessageBox(const SDL_MessageBoxData *messageboxdata, int *buttonid)
     msgParam.msg = (const SceChar8*)message;
     SDL_zero(buttonParam);
 
-    if (messageboxdata->numbuttons == 3)
-    {
+    if (messageboxdata->numbuttons == 3) {
         msgParam.buttonType = SCE_MSG_DIALOG_BUTTON_TYPE_3BUTTONS;
         msgParam.buttonParam = &buttonParam;
         buttonParam.msg1 = messageboxdata->buttons[0].text;
         buttonParam.msg2 = messageboxdata->buttons[1].text;
         buttonParam.msg3 = messageboxdata->buttons[2].text;
-    }
-    else if (messageboxdata->numbuttons == 2)
-    {
+    } else if (messageboxdata->numbuttons == 2) {
         msgParam.buttonType = SCE_MSG_DIALOG_BUTTON_TYPE_YESNO;
-    }
-    else if (messageboxdata->numbuttons == 1)
-    {
+    } else if (messageboxdata->numbuttons == 1) {
         msgParam.buttonType = SCE_MSG_DIALOG_BUTTON_TYPE_OK;
     }
     param.userMsgParam = &msgParam;
@@ -81,8 +75,7 @@ int VITA_ShowMessageBox(const SDL_MessageBoxData *messageboxdata, int *buttonid)
     init_result = sceMsgDialogInit(&param);
 
     // Setup display if it hasn't been initialized before
-    if (init_result == SCE_COMMON_DIALOG_ERROR_GXM_IS_UNINITIALIZED)
-    {
+    if (init_result == SCE_COMMON_DIALOG_ERROR_GXM_IS_UNINITIALIZED) {
         gxm_minimal_init_for_common_dialog();
         init_result = sceMsgDialogInit(&param);
         setup_minimal_gxm = SDL_TRUE;
@@ -90,50 +83,34 @@ int VITA_ShowMessageBox(const SDL_MessageBoxData *messageboxdata, int *buttonid)
 
     gxm_init_for_common_dialog();
 
-    if (init_result >= 0)
-    {
-        while (sceMsgDialogGetStatus() == SCE_COMMON_DIALOG_STATUS_RUNNING)
-        {
+    if (init_result >= 0) {
+        while (sceMsgDialogGetStatus() == SCE_COMMON_DIALOG_STATUS_RUNNING) {
             gxm_swap_for_common_dialog();
         }
         SDL_zero(dialog_result);
         sceMsgDialogGetResult(&dialog_result);
 
-        if (dialog_result.buttonId == SCE_MSG_DIALOG_BUTTON_ID_BUTTON1)
-        {
+        if (dialog_result.buttonId == SCE_MSG_DIALOG_BUTTON_ID_BUTTON1) {
             *buttonid = messageboxdata->buttons[0].buttonid;
-        }
-        else if (dialog_result.buttonId == SCE_MSG_DIALOG_BUTTON_ID_BUTTON2)
-        {
+        } else if (dialog_result.buttonId == SCE_MSG_DIALOG_BUTTON_ID_BUTTON2) {
             *buttonid = messageboxdata->buttons[1].buttonid;
-        }
-        else if (dialog_result.buttonId == SCE_MSG_DIALOG_BUTTON_ID_BUTTON3)
-        {
+        } else if (dialog_result.buttonId == SCE_MSG_DIALOG_BUTTON_ID_BUTTON3) {
             *buttonid = messageboxdata->buttons[2].buttonid;
-        }
-        else if (dialog_result.buttonId == SCE_MSG_DIALOG_BUTTON_ID_YES)
-        {
+        } else if (dialog_result.buttonId == SCE_MSG_DIALOG_BUTTON_ID_YES) {
             *buttonid = messageboxdata->buttons[0].buttonid;
-        }
-        else if (dialog_result.buttonId == SCE_MSG_DIALOG_BUTTON_ID_NO)
-        {
+        } else if (dialog_result.buttonId == SCE_MSG_DIALOG_BUTTON_ID_NO) {
             *buttonid = messageboxdata->buttons[1].buttonid;
-        }
-        else if (dialog_result.buttonId == SCE_MSG_DIALOG_BUTTON_ID_OK)
-        {
+        } else if (dialog_result.buttonId == SCE_MSG_DIALOG_BUTTON_ID_OK) {
             *buttonid = messageboxdata->buttons[0].buttonid;
         }
         sceMsgDialogTerm();
-    }
-    else
-    {
+    } else {
         return -1;
     }
 
     gxm_term_for_common_dialog();
 
-    if (setup_minimal_gxm)
-    {
+    if (setup_minimal_gxm) {
         gxm_minimal_term_for_common_dialog();
     }
 
diff --git a/src/video/vita/SDL_vitamouse.c b/src/video/vita/SDL_vitamouse.c
index 398a19483..46d3471a3 100644
--- a/src/video/vita/SDL_vitamouse.c
+++ b/src/video/vita/SDL_vitamouse.c
@@ -47,16 +47,14 @@ void
 VITA_PollMouse(void)
 {
     // We skip polling mouse if no window is created
-    if (Vita_Window == NULL)
+    if (Vita_Window == NULL) {
         return;
+    }
 
-    if (mouse_hid_handle > 0)
-    {
+    if (mouse_hid_handle > 0) {
         int numReports = sceHidMouseRead(mouse_hid_handle, (SceHidMouseReport**)&m_reports, SCE_HID_MAX_REPORT);
-        if (numReports > 0)
-        {
-            for (int i = 0; i <= numReports - 1; i++)
-            {
+        if (numReports > 0) {
+            for (int i = 0; i <= numReports - 1; i++) {
                 Uint8 changed_buttons = m_reports[i].buttons ^ prev_buttons;
 
                 if (changed_buttons & 0x1) {
@@ -80,8 +78,7 @@ VITA_PollMouse(void)
 
                 prev_buttons = m_reports[i].buttons;
 
-                if (m_reports[i].rel_x || m_reports[i].rel_y)
-                {
+                if (m_reports[i].rel_x || m_reports[i].rel_y) {
                     SDL_SendMouseMotion(Vita_Window, 0, 1, m_reports[i].rel_x, m_reports[i].rel_y);
                 }
             }
diff --git a/src/video/vita/SDL_vitatouch.c b/src/video/vita/SDL_vitatouch.c
index 43a3ecbd2..e28dd3d3a 100644
--- a/src/video/vita/SDL_vitatouch.c
+++ b/src/video/vita/SDL_vitatouch.c
@@ -56,7 +56,7 @@ VITA_InitTouch(void)
     sceTouchEnableTouchForce(SCE_TOUCH_PORT_FRONT);
     sceTouchEnableTouchForce(SCE_TOUCH_PORT_BACK);
 
-    for(int port = 0; port < SCE_TOUCH_PORT_MAX_NUM; port++) {
+    for (int port = 0; port < SCE_TOUCH_PORT_MAX_NUM; port++) {
         SceTouchPanelInfo panelinfo;
         sceTouchGetPanelInfo(port, &panelinfo);
 
@@ -75,7 +75,7 @@ VITA_InitTouch(void)
 }
 
 void 
-VITA_QuitTouch(void){
+VITA_QuitTouch(void) {
     sceTouchDisableTouchForce(SCE_TOUCH_PORT_FRONT);
     sceTouchDisableTouchForce(SCE_TOUCH_PORT_BACK);
 }
@@ -87,20 +87,20 @@ VITA_PollTouch(void)
     int port;
 
     // We skip polling touch if no window is created
-    if (Vita_Window == NULL)
+    if (Vita_Window == NULL) {
         return;
+    }
 
     SDL_memcpy(touch_old, touch, sizeof(touch_old));
 
-    for(port = 0; port < SCE_TOUCH_PORT_MAX_NUM; port++) {
+    for (port = 0; port < SCE_TOUCH_PORT_MAX_NUM; port++) {
         /** Skip polling of Touch Device if environment variable is set **/
         if (((port == 0) && disableFrontPoll) || ((port == 1) && disableBackPoll)) {
             continue;
         }
         sceTouchPeek(port, &touch[port], 1);
         if (touch[port].reportNum > 0) {
-            for (int i = 0; i < touch[port].reportNum; i++)
-            {
+            for (int i = 0; i < touch[port].reportNum; i++) {
                 // adjust coordinates and forces to return normalized values
                 // for the front, screen area is used as a reference (for direct touch)
                 // e.g. touch_x = 1.0 corresponds to screen_x = 960
@@ -122,7 +122,7 @@ VITA_PollTouch(void)
                 finger_id = (SDL_FingerID) touch[port].report[i].id;
 
                 // Skip if finger was already previously down
-                if(!finger_down) {
+                if (!finger_down) {
                     // Send an initial touch
                     SDL_SendTouch((SDL_TouchID)port,
                         finger_id,
diff --git a/src/video/vita/SDL_vitavideo.c b/src/video/vita/SDL_vitavideo.c
index 33758d691..34b5c6250 100644
--- a/src/video/vita/SDL_vitavideo.c
+++ b/src/video/vita/SDL_vitavideo.c
@@ -143,7 +143,7 @@ VITA_Create()
 
 #if defined(SDL_VIDEO_VITA_PIB) || defined(SDL_VIDEO_VITA_PVR)
 #if defined(SDL_VIDEO_VITA_PVR_OGL)
-if(SDL_getenv("VITA_PVR_OGL") != NULL) {
+if (SDL_getenv("VITA_PVR_OGL") != NULL) {
     device->GL_LoadLibrary = VITA_GL_LoadLibrary;
     device->GL_CreateContext = VITA_GL_CreateContext;
     device->GL_GetProcAddress = VITA_GL_GetProcAddress;
@@ -273,8 +273,7 @@ VITA_CreateWindow(_THIS, SDL_Window * window)
     window->driverdata = wdata;
 
     // Vita can only have one window
-    if (Vita_Window != NULL)
-    {
+    if (Vita_Window != NULL) {
         return SDL_SetError("Only one window supported");
     }
 
@@ -298,7 +297,7 @@ VITA_CreateWindow(_THIS, SDL_Window * window)
         win.windowSize = PSP2_WINDOW_960X544;
     }
     if ((window->flags & SDL_WINDOW_OPENGL) != 0) {
-      if(SDL_getenv("VITA_PVR_OGL") != NULL) {
+      if (SDL_getenv("VITA_PVR_OGL") != NULL) {
         /* Set version to 2.1 and PROFILE to ES */
         temp_major = _this->gl_config.major_version;
         temp_minor = _this->gl_config.minor_version;
@@ -312,7 +311,7 @@ VITA_CreateWindow(_THIS, SDL_Window * window)
       if (wdata->egl_surface == EGL_NO_SURFACE) {
           return SDL_SetError("Could not create GLES window surface");
       }
-      if(SDL_getenv("VITA_PVR_OGL") != NULL) {
+      if (SDL_getenv("VITA_PVR_OGL") != NULL) {
         /* Revert */
         _this->gl_config.major_version = temp_major;
         _this->gl_config.minor_version = temp_minor;
@@ -427,10 +426,10 @@ static void utf16_to_utf8(const uint16_t *src, uint8_t *dst) {
   for (i = 0; src[i]; i++) {
     if ((src[i] & 0xFF80) == 0) {
       *(dst++) = src[i] & 0xFF;
-    } else if((src[i] & 0xF800) == 0) {
+    } else if ((src[i] & 0xF800) == 0) {
       *(dst++) = ((src[i] >> 6) & 0xFF) | 0xC0;
       *(dst++) = (src[i] & 0x3F) | 0x80;
-    } else if((src[i] & 0xFC00) == 0xD800 && (src[i + 1] & 0xFC00) == 0xDC00) {
+    } else if ((src[i] & 0xFC00) == 0xD800 && (src[i + 1] & 0xFC00) == 0xDC00) {
       *(dst++) = (((src[i] + 64) >> 8) & 0x3) | 0xF0;
       *(dst++) = (((src[i] >> 2) + 16) & 0x3F) | 0x80;
       *(dst++) = ((src[i] >> 4) & 0x30) | 0x80 | ((src[i + 1] << 2) & 0xF);
@@ -461,13 +460,11 @@ void VITA_ImeEventHandler(void *arg, const SceImeEventData *e)
         if (e->param.text.caretIndex == 0) {
             SDL_SendKeyboardKeyAutoRelease(SDL_SCANCODE_BACKSPACE);
             sceImeSetText((SceWChar16 *)libime_initval, 4);
-        }
-        else {
+        } else {
             scancode = SDL_GetScancodeFromKey(*(SceWChar16 *)&libime_out[1]);
             if (scancode == SDL_SCANCODE_SPACE) {
                 SDL_SendKeyboardKeyAutoRelease(SDL_SCANCODE_SPACE);
-            }
-            else {
+            } else {
                 utf16_to_utf8((SceWChar16 *)&libime_out[1], utf8_buffer);
                 SDL_SendKeyboardText((const char*)utf8_buffer);
             }
@@ -577,7 +574,7 @@ SDL_bool VITA_IsScreenKeyboardShown(_THIS, SDL_Window *window)
     return videodata->ime_active;
 #else
     SceCommonDialogStatus dialogStatus = sceImeDialogGetStatus();
-    return (dialogStatus == SCE_COMMON_DIALOG_STATUS_RUNNING);
+    return dialogStatus == SCE_COMMON_DIALOG_STATUS_RUNNING;
 #endif
 }
 
@@ -614,8 +611,9 @@ void VITA_PumpEvents(_THIS)
             SDL_SendKeyboardText((const char*)utf8_buffer);
 
             // Send enter key only on enter
-            if (result.button == SCE_IME_DIALOG_BUTTON_ENTER)
+            if (result.button == SCE_IME_DIALOG_BUTTON_ENTER) {
                 SDL_SendKeyboardKeyAutoRelease(SDL_SCANCODE_RETURN);
+            }
 
             sceImeDialogTerm();
 
diff --git a/src/video/vivante/SDL_vivantevulkan.c b/src/video/vivante/SDL_vivantevulkan.c
index fe6a6b0ae..7935cd32a 100644
--- a/src/video/vivante/SDL_vivantevulkan.c
+++ b/src/video/vivante/SDL_vivantevulkan.c
@@ -42,19 +42,19 @@ int VIVANTE_Vulkan_LoadLibrary(_THIS, const char *path)
     SDL_bool hasSurfaceExtension = SDL_FALSE;
     SDL_bool hasDisplayExtension = SDL_FALSE;
     PFN_vkGetInstanceProcAddr vkGetInstanceProcAddr = NULL;
-    if(_this->vulkan_config.loader_handle)
+    if (_this->vulkan_config.loader_handle) {
         return SDL_SetError("Vulkan already loaded");
+    }
 
     /* Load the Vulkan loader library */
-    if(!path)
+    if (path == NULL) {
         path = SDL_getenv("SDL_VULKAN_LIBRARY");
-    if(!path)
-    {
+    }
+    if (path == NULL) {
         /* If no path set, try Vivante fb vulkan driver explicitly */
         path = "libvulkan-fb.so";
         _this->vulkan_config.loader_handle = SDL_LoadObject(path);
-        if(!_this->vulkan_config.loader_handle)
-        {
+        if (!_this->vulkan_config.loader_handle) {
             /* If that couldn't be loaded, fall back to default name */
             path = "libvulkan.so";
             _this->vulkan_config.loader_handle = SDL_LoadObject(path);
@@ -62,43 +62,45 @@ int VIVANTE_Vulkan_LoadLibrary(_THIS, const char *path)
     } else {
         _this->vulkan_config.loader_handle = SDL_LoadObject(path);
     }
-    if(!_this->vulkan_config.loader_handle)
+    if (!_this->vulkan_config.loader_handle) {
         return -1;
+    }
     SDL_strlcpy(_this->vulkan_config.loader_path, path,
                 SDL_arraysize(_this->vulkan_config.loader_path));
     SDL_LogDebug(SDL_LOG_CATEGORY_VIDEO, "vivante: Loaded vulkan driver %s", path);
     vkGetInstanceProcAddr = (PFN_vkGetInstanceProcAddr)SDL_LoadFunction(
         _this->vulkan_config.loader_handle, "vkGetInstanceProcAddr");
-    if(!vkGetInstanceProcAddr)
+    if (!vkGetInstanceProcAddr) {
         goto fail;
+    }
     _this->vulkan_config.vkGetInstanceProcAddr = (void *)vkGetInstanceProcAddr;
     _this->vulkan_config.vkEnumerateInstanceExtensionProperties =
         (void *)((PFN_vkGetInstanceProcAddr)_this->vulkan_config.vkGetInstanceProcAddr)(
             VK_NULL_HANDLE, "vkEnumerateInstanceExtensionProperties");
-    if(!_this->vulkan_config.vkEnumerateInstanceExtensionProperties)
+    if (!_this->vulkan_config.vkEnumerateInstanceExtensionProperties) {
         goto fail;
+    }
     extensions = SDL_Vulkan_CreateInstanceExtensionsList(
         (PFN_vkEnumerateInstanceExtensionProperties)
             _this->vulkan_config.vkEnumerateInstanceExtensionProperties,
         &extensionCount);
-    if(!extensions)
+    if (extensions == NULL) {
         goto fail;
-    for(i = 0; i < extensionCount; i++)
+    }
+    for (i = 0; i < extensionCount; i++)
     {
-        if(SDL_strcmp(VK_KHR_SURFACE_EXTENSION_NAME, extensions[i].extensionName) == 0)
+        if (SDL_strcmp(VK_KHR_SURFACE_EXTENSION_NAME, extensions[i].extensionName) == 0) {
             hasSurfaceExtension = SDL_TRUE;
-        else if(SDL_strcmp(VK_KHR_DISPLAY_EXTENSION_NAME, extensions[i].extensionName) == 0)
+        } else if (SDL_strcmp(VK_KHR_DISPLAY_EXTENSION_NAME, extensions[i].extensionName) == 0) {
             hasDisplayExtension = SDL_TRUE;
+        }
     }
     SDL_free(extensions);
-    if(!hasSurfaceExtension)
-    {
+    if (!hasSurfaceExtension) {
         SDL_SetError("Installed Vulkan doesn't implement the "
                      VK_KHR_SURFACE_EXTENSION_NAME " extension");
         goto fail;
-    }
-    else if(!hasDisplayExtension)
-    {
+    } else if (!hasDisplayExtension) {
         SDL_SetError("Installed Vulkan doesn't implement the "
                      VK_KHR_DISPLAY_EXTENSION_NAME "extension");
         goto fail;
@@ -113,8 +115,7 @@ fail:
 
 void VIVANTE_Vulkan_UnloadLibrary(_THIS)
 {
-    if(_this->vulkan_config.loader_handle)
-    {
+    if (_this->vulkan_config.loader_handle) {
         SDL_UnloadObject(_this->vulkan_config.loader_handle);
         _this->vulkan_config.loader_handle = NULL;
     }
@@ -128,8 +129,7 @@ SDL_bool VIVANTE_Vulkan_GetInstanceExtensions(_THIS,
     static const char *const extensionsForVivante[] = {
         VK_KHR_SURFACE_EXTENSION_NAME, VK_KHR_DISPLAY_EXTENSION_NAME
     };
-    if(!_this->vulkan_config.loader_handle)
-    {
+    if (!_this->vulkan_config.loader_handle) {
         SDL_SetError("Vulkan is not loaded");
         return SDL_FALSE;
     }
@@ -143,8 +143,7 @@ SDL_bool VIVANTE_Vulkan_CreateSurface(_THIS,
                                   VkInstance instance,
                                   VkSurfaceKHR *surface)
 {
-    if(!_this->vulkan_config.loader_handle)
-    {
+    if (!_this->vulkan_config.loader_handle) {
         SDL_SetError("Vulkan is not loaded");
         return SDL_FALSE;
     }
diff --git a/src/video/wayland/SDL_waylanddyn.c b/src/video/wayland/SDL_waylanddyn.c
index 6c91e0bcf..68ea1cf48 100644
--- a/src/video/wayland/SDL_waylanddyn.c
+++ b/src/video/wayland/SDL_waylanddyn.c
@@ -67,8 +67,9 @@ WAYLAND_GetSym(const char *fnname, int *pHasModule)
     for (i = 0; i < SDL_TABLESIZE(waylandlibs); i++) {
         if (waylandlibs[i].lib != NULL) {
             fn = SDL_LoadFunction(waylandlibs[i].lib, fnname);
-            if (fn != NULL)
+            if (fn != NULL) {
                 break;
+            }
         }
     }
 
@@ -79,8 +80,9 @@ WAYLAND_GetSym(const char *fnname, int *pHasModule)
         SDL_Log("WAYLAND: Symbol '%s' NOT FOUND!\n", fnname);
 #endif
 
-    if (fn == NULL)
-        *pHasModule = 0;  /* kill this module. */
+    if (fn == NULL) {
+        *pHasModule = 0; /* kill this module. */
+    }
 
     return fn;
 }
diff --git a/src/video/wayland/SDL_waylandevents.c b/src/video/wayland/SDL_waylandevents.c
index 5ccffd9dd..c5863d9ff 100644
--- a/src/video/wayland/SDL_waylandevents.c
+++ b/src/video/wayland/SDL_waylandevents.c
@@ -433,7 +433,7 @@ pointer_handle_enter(void *data, struct wl_pointer *pointer,
     struct SDL_WaylandInput *input = data;
     SDL_WindowData *window;
 
-    if (!surface) {
+    if (surface == NULL) {
         /* enter event for a window we've just destroyed */
         return;
     }
@@ -472,7 +472,7 @@ pointer_handle_leave(void *data, struct wl_pointer *pointer,
 {
     struct SDL_WaylandInput *input = data;
 
-    if (!surface || !SDL_WAYLAND_own_surface(surface)) {
+    if (surface == NULL || !SDL_WAYLAND_own_surface(surface)) {
         return;
     }
 
@@ -737,7 +737,7 @@ pointer_handle_axis(void *data, struct wl_pointer *pointer,
 {
     struct SDL_WaylandInput *input = data;
 
-    if(wl_seat_get_version(input->seat) >= 5)
+    if (wl_seat_get_version(input->seat) >= 5)
         pointer_handle_axis_common(input, AXIS_EVENT_CONTINUOUS, axis, value);
     else
         pointer_handle_axis_common_v1(input, time, axis, value);
@@ -964,7 +964,7 @@ keyboard_handle_keymap(void *data, struct wl_keyboard *keyboard,
     char *map_str;
     const char *locale;
 
-    if (!data) {
+    if (data == NULL) {
         close(fd);
         return;
     }
@@ -1103,7 +1103,7 @@ keyboard_handle_enter(void *data, struct wl_keyboard *keyboard,
     SDL_WindowData *window;
     uint32_t *key;
 
-    if (!surface) {
+    if (surface == NULL) {
         /* enter event for a window we've just destroyed */
         return;
     }
@@ -1146,7 +1146,7 @@ keyboard_handle_leave(void *data, struct wl_keyboard *keyboard,
     struct SDL_WaylandInput *input = data;
     SDL_WindowData *window;
 
-    if (!surface || !SDL_WAYLAND_own_surface(surface)) {
+    if (surface == NULL || !SDL_WAYLAND_own_surface(surface)) {
         return;
     }
 
@@ -1175,7 +1175,7 @@ keyboard_input_get_text(char text[8], const struct SDL_WaylandInput *input, uint
     const xkb_keysym_t *syms;
     xkb_keysym_t sym;
 
-    if (!window || window->keyboard_device != input || !input->xkb.state) {
+    if (window == NULL || window->keyboard_device != input || !input->xkb.state) {
         return SDL_FALSE;
     }
 
@@ -1290,7 +1290,7 @@ keyboard_handle_modifiers(void *data, struct wl_keyboard *keyboard,
     }
 
     /* If a key is repeating, update the text to apply the modifier. */
-    if(keyboard_repeat_is_set(&input->keyboard_repeat)) {
+    if (keyboard_repeat_is_set(&input->keyboard_repeat)) {
         char text[8];
         const uint32_t key = keyboard_repeat_get_key(&input->keyboard_repeat);
 
@@ -1712,8 +1712,11 @@ static char* Wayland_URIToLocal(char* uri) {
     char *file = NULL;
     SDL_bool local;
 
-    if (SDL_memcmp(uri,"file:/",6) == 0) uri += 6;      /* local file? */
-    else if (SDL_strstr(uri,":/") != NULL) return file; /* wrong scheme */
+    if (SDL_memcmp(uri,"file:/",6) == 0) {
+        uri += 6;      /* local file? */
+    } else if (SDL_strstr(uri, ":/") != NULL) {
+        return file; /* wrong scheme */
+    }
 
     local = uri[0] != '/' || (uri[0] != '\0' && uri[1] == '/');
 
@@ -2095,7 +2098,7 @@ tablet_tool_handle_proximity_in(void* data, struct zwp_tablet_tool_v2* tool, uin
     struct SDL_WaylandTabletInput* input = data;
     SDL_WindowData* window;
 
-    if (!surface) {
+    if (surface == NULL) {
         return;
     }
 
@@ -2155,7 +2158,7 @@ tablet_tool_handle_down(void* data, struct zwp_tablet_tool_v2* tool, uint32_t se
     struct SDL_WaylandTabletInput* input = data;
     SDL_WindowData* window = input->tool_focus;
     input->is_down = SDL_TRUE;
-    if (!window) {
+    if (window == NULL) {
         /* tablet_tool_handle_proximity_out gets called when moving over the libdecoration csd.
          * that sets input->tool_focus (window) to NULL, but handle_{down,up} events are still
          * received. To prevent SIGSEGV this returns when this is the case.
@@ -2174,7 +2177,7 @@ tablet_tool_handle_up(void* data, struct zwp_tablet_tool_v2* tool)
 
     input->is_down = SDL_FALSE;
 
-    if (!window) {
+    if (window == NULL) {
         /* tablet_tool_handle_proximity_out gets called when moving over the libdecoration csd.
          * that sets input->tool_focus (window) to NULL, but handle_{down,up} events are still
          * received. To prevent SIGSEGV this returns when this is the case.
@@ -2376,7 +2379,7 @@ Wayland_input_add_tablet(struct SDL_WaylandInput *input, struct SDL_WaylandTable
 {
     struct SDL_WaylandTabletInput* tablet_input;
 
-    if (!tablet_manager || !input || !input->seat) {
+    if (tablet_manager == NULL || input == NULL || !input->seat) {
         return;
     }
 
@@ -2416,8 +2419,9 @@ Wayland_display_add_input(SDL_VideoData *d, uint32_t id, uint32_t version)
     struct SDL_WaylandInput *input;
 
     input = SDL_calloc(1, sizeof *input);
-    if (input == NULL)
+    if (input == NULL) {
         return;
+    }
 
     input->display = d;
     input->seat = wl_registry_bind(d->registry, id, &wl_seat_interface, SDL_min(SDL_WL_SEAT_VERSION, version));
@@ -2450,8 +2454,9 @@ void Wayland_display_destroy_input(SDL_VideoData *d)
 {
     struct SDL_WaylandInput *input = d->input;
 
-    if (!input)
+    if (input == NULL) {
         return;
+    }
 
     if (input->data_device != NULL) {
         Wayland_data_device_clear_selection(input->data_device);
@@ -2472,11 +2477,13 @@ void Wayland_display_destroy_input(SDL_VideoData *d)
         SDL_free(input->text_input);
     }
 
-    if (input->keyboard)
+    if (input->keyboard) {
         wl_keyboard_destroy(input->keyboard);
+    }
 
-    if (input->pointer)
+    if (input->pointer) {
         wl_pointer_destroy(input->pointer);
+    }
 
     if (input->touch) {
         SDL_DelTouch(1);
@@ -2487,20 +2494,25 @@ void Wayland_display_destroy_input(SDL_VideoData *d)
         Wayland_input_destroy_tablet(input);
     }
 
-    if (input->seat)
+    if (input->seat) {
         wl_seat_destroy(input->seat);
+    }
 
-    if (input->xkb.compose_state)
+    if (input->xkb.compose_state) {
         WAYLAND_xkb_compose_state_unref(input->xkb.compose_state);
+    }
 
-    if (input->xkb.compose_table)
+    if (input->xkb.compose_table) {
         WAYLAND_xkb_compose_table_unref(input->xkb.compose_table);
+    }
 
-    if (input->xkb.state)
+    if (input->xkb.state) {
         WAYLAND_xkb_state_unref(input->xkb.state);
+    }
 
-    if (input->xkb.keymap)
+    if (input->xkb.keymap) {
         WAYLAND_xkb_keymap_unref(input->xkb.keymap);
+    }
 
     SDL_free(input);
     d->input = NULL;
@@ -2516,8 +2528,9 @@ void Wayland_display_add_relative_pointer_manager(SDL_VideoData *d, uint32_t id)
 
 void Wayland_display_destroy_relative_pointer_manager(SDL_VideoData *d)
 {
-    if (d->relative_pointer_manager)
+    if (d->relative_pointer_manager) {
         zwp_relative_pointer_manager_v1_destroy(d->relative_pointer_manager);
+    }
 }
 
 void Wayland_display_add_pointer_constraints(SDL_VideoData *d, uint32_t id)
@@ -2529,8 +2542,9 @@ void Wayland_display_add_pointer_constraints(SDL_VideoData *d, uint32_t id)
 
 void Wayland_display_destroy_pointer_constraints(SDL_VideoData *d)
 {
-    if (d->pointer_constraints)
+    if (d->pointer_constraints) {
         zwp_pointer_constraints_v1_destroy(d->pointer_constraints);
+    }
 }
 
 static void
@@ -2595,8 +2609,9 @@ lock_pointer_to_window(SDL_Window *window,
     SDL_VideoData *d = input->display;
     struct zwp_locked_pointer_v1 *locked_pointer;
 
-    if (w->locked_pointer)
+    if (w->locked_pointer) {
         return;
+    }
 
     locked_pointer =
         zwp_pointer_constraints_v1_lock_pointer(d->pointer_constraints,
@@ -2627,20 +2642,24 @@ int Wayland_input_lock_pointer(struct SDL_WaylandInput *input)
     SDL_Window *window;
     struct zwp_relative_pointer_v1 *relative_pointer;
 
-    if (!d->relative_pointer_manager)
+    if (!d->relative_pointer_manager) {
         return -1;
+    }
 
-    if (!d->pointer_constraints)
+    if (!d->pointer_constraints) {
         return -1;
+    }
 
-    if (!input->pointer)
+    if (!input->pointer) {
         return -1;
+    }
 
     /* If we have a pointer confine active, we must destroy it here because
      * creating a locked pointer otherwise would be a protocol error.
      */
-    for (window = vd->windows; window; window = window->next)
+    for (window = vd->windows; window; window = window->next) {
         pointer_confine_destroy(window);
+    }
 
     if (!input->relative_pointer) {
         relative_pointer =
@@ -2653,8 +2672,9 @@ int Wayland_input_lock_pointer(struct SDL_WaylandInput *input)
         input->relative_pointer = relative_pointer;
     }
 
-    for (window = vd->windows; window; window = window->next)
+    for (window = vd->windows; window; window = window->next) {
         lock_pointer_to_window(window, input);
+    }
 
     d->relative_mouse_mode = 1;
 
@@ -2670,8 +2690,9 @@ int Wayland_input_unlock_pointer(struct SDL_WaylandInput *input)
 
     for (window = vd->windows; window; window = window->next) {
         w = window->driverdata;
-        if (w->locked_pointer)
+        if (w->locked_pointer) {
             zwp_locked_pointer_v1_destroy(w->locked_pointer);
+        }
         w->locked_pointer = NULL;
     }
 
@@ -2680,8 +2701,9 @@ int Wayland_input_unlock_pointer(struct SDL_WaylandInput *input)
 
     d->relative_mouse_mode = 0;
 
-    for (window = vd->windows; window; window = window->next)
+    for (window = vd->windows; window; window = window->next) {
         Wayland_input_confine_pointer(input, window);
+    }
 
     return 0;
 }
@@ -2710,11 +2732,13 @@ int Wayland_input_confine_pointer(struct SDL_WaylandInput *input, SDL_Window *wi
     struct zwp_confined_pointer_v1 *confined_pointer;
     struct wl_region *confine_rect;
 
-    if (!d->pointer_constraints)
+    if (!d->pointer_constraints) {
         return -1;
+    }
 
-    if (!input->pointer)
+    if (!input->pointer) {
         return -1;
+    }
 
     /* A confine may already be active, in which case we should destroy it and
      * create a new one.
@@ -2724,12 +2748,14 @@ int Wayland_input_confine_pointer(struct SDL_WaylandInput *input, SDL_Window *wi
     /* We cannot create a confine if the pointer is already locked. Defer until
      * the pointer is unlocked.
      */
-    if (d->relative_mouse_mode)
+    if (d->relative_mouse_mode) {
         return 0;
+    }
 
     /* Don't confine the pointer if it shouldn't be confined. */
-    if (SDL_RectEmpty(&window->mouse_rect) && !(window->flags & SDL_WINDOW_MOUSE_GRABBED))
+    if (SDL_RectEmpty(&window->mouse_rect) && !(window->flags & SDL_WINDOW_MOUSE_GRABBED)) {
         return 0;
+    }
 
     if (SDL_RectEmpty(&window->mouse_rect)) {
         confine_rect = NULL;
@@ -2778,11 +2804,13 @@ int Wayland_input_grab_keyboard(SDL_Window *window, struct SDL_WaylandInput *inp
     SDL_WindowData *w = window->driverdata;
     SDL_VideoData *d = input->display;
 
-    if (!d->key_inhibitor_manager)
+    if (!d->key_inhibitor_manager) {
         return -1;
+    }
 
-    if (w->key_inhibitor)
+    if (w->key_inhibitor) {
         return 0;
+    }
 
     w->key_inhibitor =
         zwp_keyboard_shortcuts_inhibit_manager_v1_inhibit_shortcuts(d->key_inhibitor_manager,
diff --git a/src/video/wayland/SDL_waylandkeyboard.c b/src/video/wayland/SDL_waylandkeyboard.c
index 5cea5effc..1f3900b01 100644
--- a/src/video/wayland/SDL_waylandkeyboard.c
+++ b/src/video/wayland/SDL_waylandkeyboard.c
@@ -62,8 +62,9 @@ Wayland_StartTextInput(_THIS)
             const SDL_Rect *rect = &input->text_input->cursor_rect;
 
             /* Don't re-enable if we're already enabled. */
-            if (input->text_input->is_enabled)
+            if (input->text_input->is_enabled) {
                 return;
+            }
 
             /* For some reason this has to be done twice, it appears to be a
              * bug in mutter? Maybe?
@@ -118,7 +119,7 @@ Wayland_SetTextInputRect(_THIS, const SDL_Rect *rect)
 {
     SDL_VideoData *driverdata = _this->driverdata;
 
-    if (!rect) {
+    if (rect == NULL) {
         SDL_InvalidParamError("rect");
         return;
     }
@@ -126,8 +127,7 @@ Wayland_SetTextInputRect(_THIS, const SDL_Rect *rect)
     if (driverdata->text_input_manager) {
         struct SDL_WaylandInput *input = driverdata->input;
         if (input != NULL && input->text_input) {
-            if (!SDL_RectEquals(rect, &input->text_input->cursor_rect))
-            {
+            if (!SDL_RectEquals(rect, &input->text_input->cursor_rect)) {
                 SDL_copyp(&input->text_input->cursor_rect, rect);
                 zwp_text_input_v3_set_cursor_rectangle(input->text_input->text_input,
                                                        rect->x,
@@ -156,7 +156,7 @@ Wayland_HasScreenKeyboardSupport(_THIS)
     SDL_VideoData *driverdata = _this->driverdata;
     SDL_bool haskeyboard = (driverdata->input != NULL) && (driverdata->input->keyboard != NULL);
     SDL_bool hastextmanager = (driverdata->text_input_manager != NULL);
-    return (!haskeyboard && hastextmanager);
+    return !haskeyboard && hastextmanager;
 }
 
 #endif /* SDL_VIDEO_DRIVER_WAYLAND */
diff --git a/src/video/wayland/SDL_waylandmessagebox.c b/src/video/wayland/SDL_waylandmessagebox.c
index fe66c61fd..e2a3b9bc3 100644
--- a/src/video/wayland/SDL_waylandmessagebox.c
+++ b/src/video/wayland/SDL_waylandmessagebox.c
@@ -140,14 +140,14 @@ Wayland_ShowMessageBox(const SDL_MessageBoxData *messageboxdata, int *buttonid)
                         }
                     }
                     output = SDL_malloc(output_len + 1);
-                    if (!output) {
+                    if (output == NULL) {
                         close(fd_pipe[0]);
                         return SDL_OutOfMemory();
                     }
                     output[0] = '\0';
 
                     outputfp = fdopen(fd_pipe[0], "r");
-                    if (!outputfp) {
+                    if (outputfp == NULL) {
                         SDL_free(output);
                         close(fd_pipe[0]);
                         return SDL_SetError("Couldn't open pipe for reading: %s", strerror(errno));
diff --git a/src/video/wayland/SDL_waylandmouse.c b/src/video/wayland/SDL_waylandmouse.c
index 20c5efca0..2e3a60ed8 100644
--- a/src/video/wayland/SDL_waylandmouse.c
+++ b/src/video/wayland/SDL_waylandmouse.c
@@ -118,7 +118,7 @@ wayland_dbus_read_cursor_size(int *size)
     DBusMessage *reply;
     SDL_DBusContext *dbus = SDL_DBus_GetContext();
 
-    if (!dbus || !size) {
+    if (dbus == NULL || size == NULL) {
         return SDL_FALSE;
     }
 
@@ -141,7 +141,7 @@ wayland_dbus_read_cursor_theme(char **theme)
     DBusMessage *reply;
     SDL_DBusContext *dbus = SDL_DBus_GetContext();
 
-    if (!dbus || !theme) {
+    if (dbus == NULL || theme == NULL) {
         return SDL_FALSE;
     }
 
@@ -297,7 +297,7 @@ wayland_create_tmp_file(off_t size)
     int fd;
 
     xdg_path = SDL_getenv("XDG_RUNTIME_DIR");
-    if (!xdg_path) {
+    if (xdg_path == NULL) {
         return -1;
     }
 
@@ -305,8 +305,9 @@ wayland_create_tmp_file(off_t size)
     SDL_strlcat(tmp_path, template, PATH_MAX);
 
     fd = mkostemp(tmp_path, O_CLOEXEC);
-    if (fd < 0)
+    if (fd < 0) {
         return -1;
+    }
 
     if (ftruncate(fd, size) < 0) {
         close(fd);
@@ -341,8 +342,7 @@ create_buffer_from_shm(Wayland_CursorData *d,
     int shm_fd;
 
     shm_fd = wayland_create_tmp_file(size);
-    if (shm_fd < 0)
-    {
+    if (shm_fd < 0) {
         return SDL_SetError("Creating mouse cursor buffer failed.");
     }
 
@@ -387,7 +387,7 @@ Wayland_CreateCursor(SDL_Surface *surface, int hot_x, int hot_y)
         SDL_VideoDevice *vd = SDL_GetVideoDevice ();
         SDL_VideoData *wd = (SDL_VideoData *) vd->driverdata;
         Wayland_CursorData *data = SDL_calloc (1, sizeof (Wayland_CursorData));
-        if (!data) {
+        if (data == NULL) {
             SDL_OutOfMemory();
             SDL_free(cursor);
             return NULL;
@@ -433,7 +433,7 @@ Wayland_CreateSystemCursor(SDL_SystemCursor id)
     cursor = SDL_calloc(1, sizeof (*cursor));
     if (cursor) {
         Wayland_CursorData *cdata = SDL_calloc (1, sizeof (Wayland_CursorData));
-        if (!cdata) {
+        if (cdata == NULL) {
             SDL_OutOfMemory();
             SDL_free(cursor);
             return NULL;
@@ -479,7 +479,7 @@ Wayland_FreeCursorData(Wayland_CursorData *d)
 static void
 Wayland_FreeCursor(SDL_Cursor *cursor)
 {
-    if (!cursor) {
+    if (cursor == NULL) {
         return;
     }
 
@@ -504,11 +504,11 @@ Wayland_ShowCursor(SDL_Cursor *cursor)
     struct wl_pointer *pointer = d->pointer;
     float scale = 1.0f;
 
-    if (!pointer)
+    if (pointer == NULL) {
         return -1;
+    }
 
-    if (cursor)
-    {
+    if (cursor) {
         Wayland_CursorData *data = cursor->driverdata;
 
         /* TODO: High-DPI custom cursors? -flibit */
@@ -535,9 +535,7 @@ Wayland_ShowCursor(SDL_Cursor *cursor)
             input->relative_mode_override = SDL_FALSE;
         }
 	    
-    }
-    else
-    {
+    } else {
         input->cursor_visible = SDL_FALSE;
         wl_pointer_set_cursor(pointer, input->pointer_enter_serial, NULL, 0, 0);
     }
@@ -579,8 +577,9 @@ Wayland_SetRelativeMouseMode(SDL_bool enabled)
 
     if (enabled) {
         /* Disable mouse warp emulation if it's enabled. */
-        if (data->input->relative_mode_override)
+        if (data->input->relative_mode_override) {
             data->input->relative_mode_override = SDL_FALSE;
+        }
 
         /* If the app has used relative mode before, it probably shouldn't
          * also be emulating it using repeated mouse warps, so disable
diff --git a/src/video/wayland/SDL_waylandopengles.c b/src/video/wayland/SDL_waylandopengles.c
index a0af3f5a4..4a85a4d61 100644
--- a/src/video/wayland/SDL_waylandopengles.c
+++ b/src/video/wayland/SDL_waylandopengles.c
@@ -185,8 +185,7 @@ Wayland_GLES_MakeCurrent(_THIS, SDL_Window * window, SDL_GLContext context)
 
     if (window && context) {
         ret = SDL_EGL_MakeCurrent(_this, ((SDL_WindowData *) window->driverdata)->egl_surface, context);
-    }
-    else {
+    } else {
         ret = SDL_EGL_MakeCurrent(_this, NULL, NULL);
     }
 
diff --git a/src/video/wayland/SDL_waylandtouch.h b/src/video/wayland/SDL_waylandtouch.h
index e4436f9f4..8487adb9a 100644
--- a/src/video/wayland/SDL_waylandtouch.h
+++ b/src/video/wayland/SDL_waylandtouch.h
@@ -99,7 +99,7 @@ qt_surface_extension_get_extended_surface(struct qt_surface_extension *qt_surfac
 
     id = wl_proxy_create((struct wl_proxy *) qt_surface_extension,
                  &qt_extended_surface_interface);
-    if (!id)
+    if (id == NULL)
         return NULL;
 
     WAYLAND_wl_proxy_marshal((struct wl_proxy *) qt_surface_extension,
diff --git a/src/video/wayland/SDL_waylandvideo.c b/src/video/wayland/SDL_waylandvideo.c
index 76b93cd09..7600afb1b 100644
--- a/src/video/wayland/SDL_waylandvideo.c
+++ b/src/video/wayland/SDL_waylandvideo.c
@@ -204,7 +204,7 @@ Wayland_CreateDevice(void)
 
     /* Initialize all variables that we clean on shutdown */
     device = SDL_calloc(1, sizeof(SDL_VideoDevice));
-    if (!device) {
+    if (device == NULL) {
         SDL_free(data);
         WAYLAND_wl_display_disconnect(display);
         SDL_WAYLAND_UnloadSymbols();
@@ -599,7 +599,7 @@ display_handle_done(void *data,
 
     if (driverdata->has_logical_size) { /* If xdg-output is present, calculate the true scale of the desktop */
         driverdata->scale_factor = (float)native_mode.w / (float)driverdata->width;
-    } else  { /* Scale the desktop coordinates, if xdg-output isn't present */
+    } else { /* Scale the desktop coordinates, if xdg-output isn't present */
         driverdata->width /= driverdata->scale_factor;
         driverdata->height /= driverdata->scale_factor;
     }
@@ -705,7 +705,7 @@ Wayland_add_display(SDL_VideoData *d, uint32_t id)
     SDL_WaylandOutputData *data;
 
     output = wl_registry_bind(d->registry, id, &wl_output_interface, 2);
-    if (!output) {
+    if (output == NULL) {
         SDL_SetError("Failed to retrieve output.");
         return;
     }
diff --git a/src/video/wayland/SDL_waylandvulkan.c b/src/video/wayland/SDL_waylandvulkan.c
index f76efd094..a736816e6 100644
--- a/src/video/wayland/SDL_waylandvulkan.c
+++ b/src/video/wayland/SDL_waylandvulkan.c
@@ -48,51 +48,56 @@ int Wayland_Vulkan_LoadLibrary(_THIS, const char *path)
     SDL_bool hasSurfaceExtension = SDL_FALSE;
     SDL_bool hasWaylandSurfaceExtension = SDL_FALSE;
     PFN_vkGetInstanceProcAddr vkGetInstanceProcAddr = NULL;
-    if(_this->vulkan_config.loader_handle)
+    if (_this->vulkan_config.loader_handle) {
         return SDL_SetError("Vulkan already loaded");
+    }
 
     /* Load the Vulkan loader library */
-    if(!path)
+    if (path == NULL) {
         path = SDL_getenv("SDL_VULKAN_LIBRARY");
-    if(!path)
+    }
+    if (path == NULL) {
         path = DEFAULT_VULKAN;
+    }
     _this->vulkan_config.loader_handle = SDL_LoadObject(path);
-    if(!_this->vulkan_config.loader_handle)
+    if (!_this->vulkan_config.loader_handle) {
         return -1;
+    }
     SDL_strlcpy(_this->vulkan_config.loader_path, path,
                 SDL_arraysize(_this->vulkan_config.loader_path));
     vkGetInstanceProcAddr = (PFN_vkGetInstanceProcAddr)SDL_LoadFunction(
         _this->vulkan_config.loader_handle, "vkGetInstanceProcAddr");
-    if(!vkGetInstanceProcAddr)
+    if (!vkGetInstanceProcAddr) {
         goto fail;
+    }
     _this->vulkan_config.vkGetInstanceProcAddr = (void *)vkGetInstanceProcAddr;
     _this->vulkan_config.vkEnumerateInstanceExtensionProperties =
         (void *)((PFN_vkGetInstanceProcAddr)_this->vulkan_config.vkGetInstanceProcAddr)(
             VK_NULL_HANDLE, "vkEnumerateInstanceExtensionProperties");
-    if(!_this->vulkan_config.vkEnumerateInstanceExtensionProperties)
+    if (!_this->vulkan_config.vkEnumerateInstanceExtensionProperties) {
         goto fail;
+    }
     extensions = SDL_Vulkan_CreateInstanceExtensionsList(
         (PFN_vkEnumerateInstanceExtensionProperties)
             _this->vulkan_config.vkEnumerateInstanceExtensionProperties,
         &extensionCount);
-    if(!extensions)
+    if (extensions == NULL) {
         goto fail;
-    for(i = 0; i < extensionCount; i++)
+    }
+    for (i = 0; i < extensionCount; i++)
     {
-        if(SDL_strcmp(VK_KHR_SURFACE_EXTENSION_NAME, extensions[i].extensionName) == 0)
+        if (SDL_strcmp(VK_KHR_SURFACE_EXTENSION_NAME, extensions[i].extensionName) == 0) {
             hasSurfaceExtension = SDL_TRUE;
-        else if(SDL_strcmp(VK_KHR_WAYLAND_SURFACE_EXTENSION_NAME, extensions[i].extensionName) == 0)
+        } else if (SDL_strcmp(VK_KHR_WAYLAND_SURFACE_EXTENSION_NAME, extensions[i].extensionName) == 0) {
             hasWaylandSurfaceExtension = SDL_TRUE;
+        }
     }
     SDL_free(extensions);
-    if(!hasSurfaceExtension)
-    {
+    if (!hasSurfaceExtension) {
         SDL_SetError("Installed Vulkan doesn't implement the "
                      VK_KHR_SURFACE_EXTENSION_NAME " extension");
         goto fail;
-    }
-    else if(!hasWaylandSurfaceExtension)
-    {
+    } else if (!hasWaylandSurfaceExtension) {
         SDL_SetError("Installed Vulkan doesn't implement the "
                      VK_KHR_WAYLAND_SURFACE_EXTENSION_NAME "extension");
         goto fail;
@@ -107,8 +112,7 @@ fail:
 
 void Wayland_Vulkan_UnloadLibrary(_THIS)
 {
-    if(_this->vulkan_config.loader_handle)
-    {
+    if (_this->vulkan_config.loader_handle) {
         SDL_UnloadObject(_this->vulkan_config.loader_handle);
         _this->vulkan_config.loader_handle = NULL;
     }
@@ -122,8 +126,7 @@ SDL_bool Wayland_Vulkan_GetInstanceExtensions(_THIS,
     static const char *const extensionsForWayland[] = {
         VK_KHR_SURFACE_EXTENSION_NAME, VK_KHR_WAYLAND_SURFACE_EXTENSION_NAME
     };
-    if(!_this->vulkan_config.loader_handle)
-    {
+    if (!_this->vulkan_config.loader_handle) {
         SDL_SetError("Vulkan is not loaded");
         return SDL_FALSE;
     }
@@ -147,14 +150,12 @@ SDL_bool Wayland_Vulkan_CreateSurface(_THIS,
     VkWaylandSurfaceCreateInfoKHR createInfo;
     VkResult result;
 
-    if(!_this->vulkan_config.loader_handle)
-    {
+    if (!_this->vulkan_config.loader_handle) {
         SDL_SetError("Vulkan is not loaded");
         return SDL_FALSE;
     }
 
-    if(!vkCreateWaylandSurfaceKHR)
-    {
+    if (!vkCreateWaylandSurfaceKHR) {
         SDL_SetError(VK_KHR_WAYLAND_SURFACE_EXTENSION_NAME
                      " extension is not enabled in the Vulkan instance.");
         return SDL_FALSE;
@@ -167,8 +168,7 @@ SDL_bool Wayland_Vulkan_CreateSurface(_THIS,
     createInfo.surface =  windowData->surface;
     result = vkCreateWaylandSurfaceKHR(instance, &createInfo,
                                        NULL, surface);
-    if(result != VK_SUCCESS)
-    {
+    if (result != VK_SUCCESS) {
         SDL_SetError("vkCreateWaylandSurfaceKHR failed: %s",
                      SDL_Vulkan_GetResultString(result));
         return SDL_FALSE;
diff --git a/src/video/wayland/SDL_waylandwindow.c b/src/video/wayland/SDL_waylandwindow.c
index a31f6baf6..5f43bcc20 100644
--- a/src/video/wayland/SDL_waylandwindow.c
+++ b/src/video/wayland/SDL_waylandwindow.c
@@ -1958,8 +1958,9 @@ int Wayland_CreateWindow(_THIS, SDL_Window *window)
     SDL_VideoData *c;
 
     data = SDL_calloc(1, sizeof *data);
-    if (data == NULL)
+    if (data == NULL) {
         return SDL_OutOfMemory();
+    }
 
     c = _this->driverdata;
     window->driverdata = data;
diff --git a/src/video/windows/SDL_windowsclipboard.c b/src/video/windows/SDL_windowsclipboard.c
index e961a2be4..4ba650e2e 100644
--- a/src/video/windows/SDL_windowsclipboard.c
+++ b/src/video/windows/SDL_windowsclipboard.c
@@ -125,7 +125,7 @@ WIN_GetClipboardText(_THIS)
         }
         CloseClipboard();
     }
-    if (!text) {
+    if (text == NULL) {
         text = SDL_strdup("");
     }
     return text;
diff --git a/src/video/windows/SDL_windowsevents.c b/src/video/windows/SDL_windowsevents.c
index 7370f9e5c..f608b39b3 100644
--- a/src/video/windows/SDL_windowsevents.c
+++ b/src/video/windows/SDL_windowsevents.c
@@ -278,8 +278,7 @@ WIN_CheckWParamMouseButton(SDL_bool bwParamMousePressed, Uint32 mouseFlags, SDL_
     if (bSwapButtons) {
         if (button == SDL_BUTTON_LEFT) {
             button = SDL_BUTTON_RIGHT;
-        }
-        else if (button == SDL_BUTTON_RIGHT) {
+        } else if (button == SDL_BUTTON_RIGHT) {
             button = SDL_BUTTON_LEFT;
         }
     }
@@ -332,26 +331,36 @@ WIN_CheckRawMouseButtons(ULONG rawButtons, SDL_WindowData *data, SDL_MouseID mou
     if (rawButtons != data->mouse_button_flags) {
         Uint32 mouseFlags = SDL_GetMouseState(NULL, NULL);
         SDL_bool swapButtons = GetSystemMetrics(SM_SWAPBUTTON) != 0;
-        if ((rawButtons & RI_MOUSE_BUTTON_1_DOWN))
+        if ((rawButtons & RI_MOUSE_BUTTON_1_DOWN)) {
             WIN_CheckWParamMouseButton((rawButtons & RI_MOUSE_BUTTON_1_DOWN), mouseFlags, swapButtons, data, SDL_BUTTON_LEFT, mouseID);
-        if ((rawButtons & RI_MOUSE_BUTTON_1_UP))
+        }
+        if ((rawButtons & RI_MOUSE_BUTTON_1_UP)) {
             WIN_CheckWParamMouseButton(!(rawButtons & RI_MOUSE_BUTTON_1_UP), mouseFlags, swapButtons, data, SDL_BUTTON_LEFT, mouseID);
-        if ((rawButtons & RI_MOUSE_BUTTON_2_DOWN))
+        }
+        if ((rawButtons & RI_MOUSE_BUTTON_2_DOWN)) {
             WIN_CheckWParamMouseButton((rawButtons & RI_MOUSE_BUTTON_2_DOWN), mouseFlags, swapButtons, data, SDL_BUTTON_RIGHT, mouseID);
-        if ((rawButtons & RI_MOUSE_BUTTON_2_UP))
+        }
+        if ((rawButtons & RI_MOUSE_BUTTON_2_UP)) {
             WIN_CheckWParamMouseButton(!(rawButtons & RI_MOUSE_BUTTON_2_UP), mouseFlags, swapButtons, data, SDL_BUTTON_RIGHT, mouseID);
-        if ((rawButtons & RI_MOUSE_BUTTON_3_DOWN))
+        }
+        if ((rawButtons & RI_MOUSE_BUTTON_3_DOWN)) {
             WIN_CheckWParamMouseButton((rawButtons & RI_MOUSE_BUTTON_3_DOWN), mouseFlags, swapButtons, data, SDL_BUTTON_MIDDLE, mouseID);
-        if ((rawButtons & RI_MOUSE_BUTTON_3_UP))
+        }
+        if ((rawButtons & RI_MOUSE_BUTTON_3_UP)) {
             WIN_CheckWParamMouseButton(!(rawButtons & RI_MOUSE_BUTTON_3_UP), mouseFlags, swapButtons, data, SDL_BUTTON_MIDDLE, mouseID);
-        if ((rawButtons & RI_MOUSE_BUTTON_4_DOWN))
+        }
+        if ((rawButtons & RI_MOUSE_BUTTON_4_DOWN)) {
             WIN_CheckWParamMouseButton((rawButtons & RI_MOUSE_BUTTON_4_DOWN), mouseFlags, swapButtons, data, SDL_BUTTON_X1, mouseID);
-        if ((rawButtons & RI_MOUSE_BUTTON_4_UP))
+        }
+        if ((rawButtons & RI_MOUSE_BUTTON_4_UP)) {
             WIN_CheckWParamMouseButton(!(rawButtons & RI_MOUSE_BUTTON_4_UP), mouseFlags, swapButtons, data, SDL_BUTTON_X1, mouseID);
-        if ((rawButtons & RI_MOUSE_BUTTON_5_DOWN))
+        }
+        if ((rawButtons & RI_MOUSE_BUTTON_5_DOWN)) {
             WIN_CheckWParamMouseButton((rawButtons & RI_MOUSE_BUTTON_5_DOWN), mouseFlags, swapButtons, data, SDL_BUTTON_X2, mouseID);
-        if ((rawButtons & RI_MOUSE_BUTTON_5_UP))
+        }
+        if ((rawButtons & RI_MOUSE_BUTTON_5_UP)) {
             WIN_CheckWParamMouseButton(!(rawButtons & RI_MOUSE_BUTTON_5_UP), mouseFlags, swapButtons, data, SDL_BUTTON_X2, mouseID);
+        }
         data->mouse_button_flags = rawButtons;
     }
 }
@@ -650,12 +659,12 @@ WIN_WindowProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
     /* Get the window data for the window */
     data = WIN_GetWindowDataFromHWND(hwnd);
 #if !defined(__XBOXONE__) && !defined(__XBOXSERIES__)
-    if (!data) {
+    if (data == NULL) {
         /* Fallback */
         data = (SDL_WindowData *) GetProp(hwnd, TEXT("SDL_WindowData"));
     }
 #endif
-    if (!data) {
+    if (data == NULL) {
         return CallWindowProc(DefWindowProc, hwnd, msg, wParam, lParam);
     }
 
@@ -672,8 +681,9 @@ WIN_WindowProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
 #endif /* WMMSG_DEBUG */
 
 #if !defined(__XBOXONE__) && !defined(__XBOXSERIES__)
-    if (IME_HandleMessage(hwnd, msg, wParam, &lParam, data->videodata))
+    if (IME_HandleMessage(hwnd, msg, wParam, &lParam, data->videodata)) {
         return 0;
+    }
 #endif
 
     switch (msg) {
@@ -1271,8 +1281,7 @@ WIN_WindowProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
 
         /* We'll do our own drawing, prevent flicker */
     case WM_ERASEBKGND:
-        if (!data->videodata->cleared)
-        {
+        if (!data->videodata->cleared) {
             RECT client_rect;
             HBRUSH brush;
             data->videodata->cleared = SDL_TRUE;
@@ -1281,12 +1290,12 @@ WIN_WindowProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
             FillRect(GetDC(hwnd), &client_rect, brush);
             DeleteObject(brush);
         }
-        return (1);
+        return 1;
 
     case WM_SYSCOMMAND:
         {
             if ((wParam & 0xFFF0) == SC_KEYMENU) {
-                return (0);
+                return 0;
             }
 
 #if defined(SC_SCREENSAVE) || defined(SC_MONITORPOWER)
@@ -1294,7 +1303,7 @@ WIN_WindowProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
             if ((wParam & 0xFFF0) == SC_SCREENSAVE ||
                 (wParam & 0xFFF0) == SC_MONITORPOWER) {
                 if (SDL_GetVideoDevice()->suspend_screensaver) {
-                    return (0);
+                    return 0;
                 }
             }
 #endif /* System has screensaver support */
@@ -1372,15 +1381,10 @@ WIN_WindowProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
          * If we're handling our own touches, we don't want any gestures.
          * Not all of these settings are documented.
          * The use of the undocumented ones was suggested by https://github.com/bjarkeck/GCGJ/blob/master/Monogame/Windows/WinFormsGameForm.cs . */
-        return TABLET_DISABLE_PRESSANDHOLD |    /*  disables press and hold (right-click) gesture */
-            TABLET_DISABLE_PENTAPFEEDBACK |     /*  disables UI feedback on pen up (waves) */
-            TABLET_DISABLE_PENBARRELFEEDBACK |  /*  disables UI feedback on pen button down (circle) */
-            TABLET_DISABLE_TOUCHUIFORCEON |
-            TABLET_DISABLE_TOUCHUIFORCEOFF |
-            TABLET_DISABLE_TOUCHSWITCH |
-            TABLET_DISABLE_FLICKS |             /*  disables pen flicks (back, forward, drag down, drag up) */
-            TABLET_DISABLE_SMOOTHSCROLLING |
-            TABLET_DISABLE_FLICKFALLBACKKEYS;
+        return TABLET_DISABLE_PRESSANDHOLD | TABLET_DISABLE_PENTAPFEEDBACK | TABLET_DISABLE_PENBARRELFEEDBACK | TABLET_DISABLE_TOUCHUIFORCEON | TABLET_DISABLE_TOUCHUIFORCEOFF | TABLET_DISABLE_TOUCHSWITCH | TABLET_DISABLE_FLICKS | TABLET_DISABLE_SMOOTHSCROLLING | TABLET_DISABLE_FLICKFALLBACKKEYS;    /*  disables press and hold (right-click) gesture */
+            /*  disables UI feedback on pen up (waves) */
+            /*  disables UI feedback on pen button down (circle) */
+            /*  disables pen flicks (back, forward, drag down, drag up) */
 
 #endif /* HAVE_TPCSHRD_H */
 
@@ -1839,7 +1843,7 @@ WIN_PumpEvents(_THIS)
        not grabbing the keyboard. Note: If we *are* grabbing the keyboard, GetKeyState()
        will return inaccurate results for VK_LWIN and VK_RWIN but we don't need it anyway. */
     focusWindow = SDL_GetKeyboardFocus();
-    if (!focusWindow || !(focusWindow->flags & SDL_WINDOW_KEYBOARD_GRABBED)) {
+    if (focusWindow == NULL || !(focusWindow->flags & SDL_WINDOW_KEYBOARD_GRABBED)) {
         if ((keystate[SDL_SCANCODE_LGUI] == SDL_PRESSED) && !(GetKeyState(VK_LWIN) & 0x8000)) {
             SDL_SendKeyboardKey(SDL_RELEASED, SDL_SCANCODE_LGUI);
         }
@@ -1869,8 +1873,12 @@ HINSTANCE SDL_Instance = NULL;
 static void WIN_CleanRegisterApp(WNDCLASSEX wcex)
 {
 #if !defined(__XBOXONE__) && !defined(__XBOXSERIES__)
-    if (wcex.hIcon) DestroyIcon(wcex.hIcon);
-    if (wcex.hIconSm) DestroyIcon(wcex.hIconSm);
+    if (wcex.hIcon) {
+        DestroyIcon(wcex.hIcon);
+    }
+    if (wcex.hIconSm) {
+        DestroyIcon(wcex.hIconSm);
+    }
 #endif
     SDL_free(SDL_Appname);
     SDL_Appname = NULL;
@@ -1889,10 +1897,10 @@ SDL_RegisterApp(const char *name, Uint32 style, void *hInst)
     /* Only do this once... */
     if (app_registered) {
         ++app_registered;
-        return (0);
+        return 0;
     }
     SDL_assert(SDL_Appname == NULL);
-    if (!name) {
+    if (name == NULL) {
         name = "SDL_app";
 #if defined(CS_BYTEALIGNCLIENT) || defined(CS_OWNDC)
         style = (CS_BYTEALIGNCLIENT | CS_OWNDC);
diff --git a/src/video/windows/SDL_windowsframebuffer.c b/src/video/windows/SDL_windowsframebuffer.c
index 4076e6f52..389cf94f8 100644
--- a/src/video/windows/SDL_windowsframebuffer.c
+++ b/src/video/windows/SDL_windowsframebuffer.c
@@ -65,8 +65,7 @@ int WIN_CreateWindowFramebuffer(_THIS, SDL_Window * window, Uint32 * format, voi
         masks = (Uint32*)((Uint8*)info + info->bmiHeader.biSize);
         *format = SDL_MasksToPixelFormatEnum(bpp, masks[0], masks[1], masks[2], 0);
     }
-    if (*format == SDL_PIXELFORMAT_UNKNOWN)
-    {
+    if (*format == SDL_PIXELFORMAT_UNKNOWN) {
         /* We'll use RGB format for now */
         *format = SDL_PIXELFORMAT_RGB888;
 
@@ -112,7 +111,7 @@ void WIN_DestroyWindowFramebuffer(_THIS, SDL_Window * window)
 {
     SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
 
-    if (!data) {
+    if (data == NULL) {
         /* The window wasn't fully initialized */
         return;
     }
diff --git a/src/video/windows/SDL_windowskeyboard.c b/src/video/windows/SDL_windowskeyboard.c
index a62ba0717..68ec749e2 100644
--- a/src/video/windows/SDL_windowskeyboard.c
+++ b/src/video/windows/SDL_windowskeyboard.c
@@ -249,7 +249,7 @@ WIN_SetTextInputRect(_THIS, const SDL_Rect *rect)
     SDL_VideoData *videodata = (SDL_VideoData *)_this->driverdata;
     HIMC himc = 0;
 
-    if (!rect) {
+    if (rect == NULL) {
         SDL_InvalidParamError("rect");
         return;
     }
@@ -258,8 +258,7 @@ WIN_SetTextInputRect(_THIS, const SDL_Rect *rect)
     videodata->ime_rect = *rect;
 
     himc = ImmGetContext(videodata->ime_hwnd_current);
-    if (himc)
-    {
+    if (himc) {
         COMPOSITIONFORM cof;
         CANDIDATEFORM caf;
 
@@ -438,15 +437,17 @@ IME_Init(SDL_VideoData *videodata, HWND hwnd)
 static void
 IME_Enable(SDL_VideoData *videodata, HWND hwnd)
 {
-    if (!videodata->ime_initialized || !videodata->ime_hwnd_current)
+    if (!videodata->ime_initialized || !videodata->ime_hwnd_current) {
         return;
+    }
 
     if (!videodata->ime_available) {
         IME_Disable(videodata, hwnd);
         return;
     }
-    if (videodata->ime_hwnd_current == videodata->ime_hwnd_main)
+    if (videodata->ime_hwnd_current == videodata->ime_hwnd_main) {
         ImmAssociateContext(videodata->ime_hwnd_current, videodata->ime_himc);
+    }
 
     videodata->ime_enabled = SDL_TRUE;
     IME_UpdateInputLocale(videodata);
@@ -456,12 +457,14 @@ IME_Enable(SDL_VideoData *videodata, HWND hwnd)
 static void
 IME_Disable(SDL_VideoData *videodata, HWND hwnd)
 {
-    if (!videodata->ime_initialized || !videodata->ime_hwnd_current)
+    if (!videodata->ime_initialized || !videodata->ime_hwnd_current) {
         return;
+    }
 
     IME_ClearComposition(videodata);
-    if (videodata->ime_hwnd_current == videodata->ime_hwnd_main)
+    if (videodata->ime_hwnd_current == videodata->ime_hwnd_main) {
         ImmAssociateContext(videodata->ime_hwnd_current, (HIMC)0);
+    }
 
     videodata->ime_enabled = SDL_FALSE;
     UILess_DisableUIUpdates(videodata);
@@ -470,12 +473,14 @@ IME_Disable(SDL_VideoData *videodata, HWND hwnd)
 static void
 IME_Quit(SDL_VideoData *videodata)
 {
-    if (!videodata->ime_initialized)
+    if (!videodata->ime_initialized) {
         return;
+    }
 
     UILess_ReleaseSinks(videodata);
-    if (videodata->ime_hwnd_main)
+    if (videodata->ime_hwnd_main) {
         ImmAssociateContext(videodata->ime_hwnd_main, videodata->ime_himc);
+    }
 
     videodata->ime_hwnd_main = 0;
     videodata->ime_himc = 0;
@@ -507,30 +512,33 @@ IME_GetReadingString(SDL_VideoData *videodata, HWND hwnd)
     BOOL vertical = FALSE;
     UINT maxuilen = 0;
 
-    if (videodata->ime_uiless)
+    if (videodata->ime_uiless) {
         return;
+    }
 
     videodata->ime_readingstring[0] = 0;
     
     id = IME_GetId(videodata, 0);
-    if (!id)
+    if (!id) {
         return;
+    }
 
     himc = ImmGetContext(hwnd);
-    if (!himc)
+    if (!himc) {
         return;
+    }
 
     if (videodata->GetReadingString) {
         len = videodata->GetReadingString(himc, 0, 0, &err, &vertical, &maxuilen);
         if (len) {
-            if (len > SDL_arraysize(buffer))
+            if (len > SDL_arraysize(buffer)) {
                 len = SDL_arraysize(buffer);
+            }
 
             len = videodata->GetReadingString(himc, len, s, &err, &vertical, &maxuilen);
         }
         SDL_wcslcpy(videodata->ime_readingstring, s, len);
-    }
-    else {
+    } else {
         LPINPUTCONTEXT2 lpimc = videodata->ImmLockIMC(himc);
         LPBYTE p = 0;
         s = 0;
@@ -540,8 +548,9 @@ IME_GetReadingString(SDL_VideoData *videodata, HWND hwnd)
         case IMEID_CHT_VER43:
         case IMEID_CHT_VER44:
             p = *(LPBYTE *)((LPBYTE)videodata->ImmLockIMCC(lpimc->hPrivate) + 24);
-            if (!p)
+            if (!p) {
                 break;
+            }
 
             len = *(DWORD *)(p + 7*4 + 32*4);
             s = (WCHAR *)(p + 56);
@@ -550,12 +559,14 @@ IME_GetReadingString(SDL_VideoData *videodata, HWND hwnd)
         case IMEID_CHT_VER52:
         case IMEID_CHS_VER53:
             p = *(LPBYTE *)((LPBYTE)videodata->ImmLockIMCC(lpimc->hPrivate) + 4);
-            if (!p)
+            if (!p) {
                 break;
+            }
 
             p = *(LPBYTE *)((LPBYTE)p + 1*4 + 5*4);
-            if (!p)
+            if (!p) {
                 break;
+            }
 
             len = *(DWORD *)(p + 1*4 + (16*2+2*4) + 5*4 + 16*2);
             s = (WCHAR *)(p + 1*4 + (16*2+2*4) + 5*4);
@@ -564,8 +575,9 @@ IME_GetReadingString(SDL_VideoData *videodata, HWND hwnd)
             {
                 int offset = (IME_GetId(videodata, 1) >= 0x00000002) ? 8 : 7;
                 p = *(LPBYTE *)((LPBYTE)videodata->ImmLockIMCC(lpimc->hPrivate) + offset * 4);
-                if (!p)
+                if (!p) {
                     break;
+                }
 
                 len = *(DWORD *)(p + 7*4 + 16*2*4);
                 s = (WCHAR *)(p + 6*4 + 16*2*1);
@@ -573,8 +585,9 @@ IME_GetReadingString(SDL_VideoData *videodata, HWND hwnd)
             break;
         case IMEID_CHS_VER42:
             p = *(LPBYTE *)((LPBYTE)videodata->ImmLockIMCC(lpimc->hPrivate) + 1*4 + 1*4 + 6*4);
-            if (!p)
+            if (!p) {
                 break;
+            }
 
             len = *(DWORD *)(p + 1*4 + (16*2+2*4) + 5*4 + 16*2);
             s = (WCHAR *)(p + 1*4 + (16*2+2*4) + 5*4);
@@ -597,8 +610,9 @@ IME_InputLangChanged(SDL_VideoData *videodata)
 {
     UINT lang = PRIMLANG();
     IME_UpdateInputLocale(videodata);
-    if (!videodata->ime_uiless)
+    if (!videodata->ime_uiless) {
         videodata->ime_candlistindexbase = (videodata->ime_hkl == CHT_HKL_DAYI) ? 0 : 1;
+    }
 
     IME_SetupAPI(videodata);
     if (lang != PRIMLANG()) {
@@ -622,8 +636,9 @@ IME_GetId(SDL_VideoData *videodata, UINT uIndex)
     SDL_assert(uIndex < sizeof(dwRet) / sizeof(dwRet[0]));
 
     hkl = videodata->ime_hkl;
-    if (hklprev == hkl)
+    if (hklprev == hkl) {
         return dwRet[uIndex];
+    }
     hklprev = hkl;
 
     SDL_assert(uIndex == 0);
@@ -703,16 +718,19 @@ IME_SetupAPI(SDL_VideoData *videodata)
     HKL hkl = 0;
     videodata->GetReadingString = 0;
     videodata->ShowReadingWindow = 0;
-    if (videodata->ime_uiless)
+    if (videodata->ime_uiless) {
         return;
+    }
 
     hkl = videodata->ime_hkl;
-    if (!ImmGetIMEFileNameA(hkl, ime_file, sizeof(ime_file) - 1))
+    if (!ImmGetIMEFileNameA(hkl, ime_file, sizeof(ime_file) - 1)) {
         return;
+    }
 
     hime = SDL_LoadObject(ime_file);
-    if (!hime)
+    if (hime == NULL) {
         return;
+    }
 
     videodata->GetReadingString = (UINT (WINAPI *)(HIMC, UINT, LPWSTR, PINT, BOOL*, PUINT))
         SDL_LoadFunction(hime, "GetReadingString");
@@ -735,8 +753,9 @@ IME_SetWindow(SDL_VideoData* videodata, HWND hwnd)
     if (videodata->ime_threadmgr) {
         struct ITfDocumentMgr *document_mgr = 0;
         if (SUCCEEDED(videodata->ime_threadmgr->lpVtbl->AssociateFocus(videodata->ime_threadmgr, hwnd, NULL, &document_mgr))) {
-            if (document_mgr)
+            if (document_mgr) {
                 document_mgr->lpVtbl->Release(document_mgr);
+            }
         }
     }
 }
@@ -746,8 +765,9 @@ IME_UpdateInputLocale(SDL_VideoData *videodata)
 {
     HKL hklnext = GetKeyboardLayout(0);
 
-    if (hklnext == videodata->ime_hkl)
+    if (hklnext == videodata->ime_hkl) {
         return;
+    }
 
     videodata->ime_hkl = hklnext;
     videodata->ime_candvertical = (PRIMLANG() == LANG_KOREAN || LANG() == LANG_CHS) ? SDL_FALSE : SDL_TRUE;
@@ -757,16 +777,19 @@ static void
 IME_ClearComposition(SDL_VideoData *videodata)
 {
     HIMC himc = 0;
-    if (!videodata->ime_initialized)
+    if (!videodata->ime_initialized) {
         return;
+    }
 
     himc = ImmGetContext(videodata->ime_hwnd_current);
-    if (!himc)
+    if (!himc) {
         return;
+    }
 
     ImmNotifyIME(himc, NI_COMPOSITIONSTR, CPS_CANCEL, 0);
-    if (videodata->ime_uiless)
+    if (videodata->ime_uiless) {
         ImmSetCompositionString(himc, SCS_SETSTR, TEXT(""), sizeof(TCHAR), TEXT(""), sizeof(TCHAR));
+    }
 
     ImmNotifyIME(himc, NI_CLOSECANDIDATE, 0, 0);
     ImmReleaseContext(videodata->ime_hwnd_current, himc);
@@ -776,8 +799,9 @@ IME_ClearComposition(SDL_VideoData *videodata)
 static SDL_bool
 IME_IsTextInputShown(SDL_VideoData* videodata)
 {
-    if (!videodata->ime_initialized || !videodata->ime_available || !videodata->ime_enabled)
+    if (!videodata->ime_initialized || !videodata->ime_available || !videodata->ime_enabled) {
         return SDL_FALSE;
+    }
 
     return videodata->ime_uicontext != 0 ? SDL_TRUE : SDL_FALSE;
 }
@@ -790,8 +814,9 @@ IME_GetCompositionString(SDL_VideoData *videodata, HIMC himc, DWORD string)
 
     length = ImmGetCompositionStringW(himc, string, NULL, 0);
     if (length > 0 && videodata->ime_composition_length < length) {
-        if (videodata->ime_composition != NULL)
+        if (videodata->ime_composition != NULL) {
             SDL_free(videodata->ime_composition);
+        }
 
         videodata->ime_composition = (WCHAR*)SDL_malloc(length + sizeof(WCHAR));
         videodata->ime_composition_length = length;
@@ -804,8 +829,9 @@ IME_GetCompositionString(SDL_VideoData *videodata, HIMC himc, DWORD string)
         videodata->ime_composition_length
     );
 
-    if (length < 0)
+    if (length < 0) {
         length = 0;
+    }
 
     length /= sizeof(WCHAR);
     videodata->ime_cursor = LOWORD(ImmGetCompositionStringW(himc, GCS_CURSORPOS, 0, 0));
@@ -816,8 +842,9 @@ IME_GetCompositionString(SDL_VideoData *videodata, HIMC himc, DWORD string)
         // Traditional Chinese IMEs add a placeholder U+3000
         // Simplified Chinese IMEs seem to add a placeholder U+0020 sometimes
         int i;
-        for (i = videodata->ime_cursor + 1; i < length; ++i)
+        for (i = videodata->ime_cursor + 1; i < length; ++i) {
             videodata->ime_composition[i - 1] = videodata->ime_composition[i];
+        }
 
         --length;
     }
@@ -835,15 +862,15 @@ IME_GetCompositionString(SDL_VideoData *videodata, HIMC himc, DWORD string)
             ImmGetCompositionString(himc, GCS_COMPATTR, attributes, length);
 
             for (start = 0; start < length; ++start) {
-                if (attributes[start] == ATTR_TARGET_CONVERTED ||
-                    attributes[start] == ATTR_TARGET_NOTCONVERTED)
+                if (attributes[start] == ATTR_TARGET_CONVERTED || attributes[start] == ATTR_TARGET_NOTCONVERTED) {
                     break;
+                }
             }
 
             for (end = start; end < length; ++end) {
-                if (attributes[end] != ATTR_TARGET_CONVERTED &&
-                    attributes[end] != ATTR_TARGET_NOTCONVERTED)
+                if (attributes[end] != ATTR_TARGET_CONVERTED && attributes[end] != ATTR_TARGET_NOTCONVERTED) {
                     break;
+                }
             }
 
             if (start == length) {
@@ -887,8 +914,7 @@ IME_SendEditingEvent(SDL_VideoData *videodata)
         SDL_wcslcpy(buffer, videodata->ime_composition, len + 1);
         SDL_wcslcat(buffer, videodata->ime_readingstring, size);
         SDL_wcslcat(buffer, &videodata->ime_composition[len], size);
-    }
-    else {
+    } else {
         buffer = (WCHAR*)SDL_malloc(size + sizeof(WCHAR));
         buffer[0] = 0;
         SDL_wcslcpy(buffer, videodata->ime_composition, size);
@@ -907,11 +933,13 @@ IME_AddCandidate(SDL_VideoData *videodata, UINT i, LPCWSTR candidate)
     LPWSTR end = &dst[MAX_CANDLENGTH - 1];
     SDL_COMPILE_TIME_ASSERT(IME_CANDIDATE_INDEXING_REQUIRES, MAX_CANDLIST == 10);
     *dst++ = (WCHAR)(TEXT('0') + ((i + videodata->ime_candlistindexbase) % 10));
-    if (videodata->ime_candvertical)
+    if (videodata->ime_candvertical) {
         *dst++ = TEXT(' ');
+    }
 
-    while (*candidate && dst < end)
+    while (*candidate && dst < end) {
         *dst++ = *candidate++;
+    }
 
     *dst = (WCHAR)'\0';
 }
@@ -923,11 +951,13 @@ IME_GetCandidateList(HWND hwnd, SDL_VideoData *videodata)
     DWORD size;
     LPCANDIDATELIST cand_list;
 
-    if (IME_ShowCandidateList(videodata) < 0)
+    if (IME_ShowCandidateList(videodata) < 0) {
         return;
+    }
     himc = ImmGetContext(hwnd);
-    if (!himc)
+    if (!himc) {
         return;
+    }
     size = ImmGetCandidateListW(himc, 0, 0, 0);
     if (size != 0) {
         cand_list = (LPCANDIDATELIST)SDL_malloc(size);
@@ -946,13 +976,13 @@ IME_GetCandidateList(HWND hwnd, SDL_VideoData *videodata)
                     for (i = 0; i < videodata->ime_candcount; ++i) {
                         size_t len = SDL_wcslen((LPWSTR)((DWORD_PTR)cand_list + cand_list->dwOffset[i])) + 1;
                         if (len + cchars > maxcandchar) {
-                            if (i > cand_list->dwSelection)
+                            if (i > cand_list->dwSelection) {
                                 break;
+                            }
 
                             page_start = i;
                             cchars = len;
-                        }
-                        else {
+                        } else {
                             cchars += len;
                         }
                     }
@@ -983,11 +1013,13 @@ IME_ShowCandidateList(SDL_VideoData *videodata)
 
     videodata->ime_candcount = 0;
     candidates = SDL_realloc(videodata->ime_candidates, MAX_CANDSIZE);
-    if (candidates != NULL)
+    if (candidates != NULL) {
         videodata->ime_candidates = (WCHAR *)candidates;
+    }
 
-    if (videodata->ime_candidates == NULL)
+    if (videodata->ime_candidates == NULL) {
         return -1;
+    }
 
     SDL_memset(videodata->ime_candidates, 0, MAX_CANDSIZE);
 
@@ -1012,17 +1044,16 @@ IME_HandleMessage(HWND hwnd, UINT msg, WPARAM wParam, LPARAM *lParam, SDL_VideoD
 {
     SDL_bool trap = SDL_FALSE;
     HIMC himc = 0;
-    if (!videodata->ime_initialized || !videodata->ime_available || !videodata->ime_enabled)
+    if (!videodata->ime_initialized || !videodata->ime_available || !videodata->ime_enabled) {
         return SDL_FALSE;
+    }
 
     switch (msg) {
     case WM_KEYDOWN:
-        if (wParam == VK_PROCESSKEY)
-        {
+        if (wParam == VK_PROCESSKEY) {
             videodata->ime_uicontext = 1;
             trap = SDL_TRUE;
-        }
-        else
+        } else
             videodata->ime_uicontext = 0;
         break;
     case WM_INPUTLANGCHANGE:
@@ -1047,8 +1078,9 @@ IME_HandleMessage(HWND hwnd, UINT msg, WPARAM wParam, LPARAM *lParam, SDL_VideoD
             IME_SendInputEvent(videodata);
         }
         if (*lParam & GCS_COMPSTR) {
-            if (!videodata->ime_uiless)
+            if (!videodata->ime_uiless) {
                 videodata->ime_readingstring[0] = 0;
+            }
 
             IME_GetCompositionString(videodata, himc, GCS_COMPSTR);
             IME_SendEditingEvent(videodata);
@@ -1060,8 +1092,9 @@ IME_HandleMessage(HWND hwnd, UINT msg, WPARAM wParam, LPARAM *lParam, SDL_VideoD
         videodata->ime_composition[0] = 0;
         videodata->ime_readingstring[0] = 0;
         videodata->ime_cursor = 0;
-        if (videodata->ime_suppress_endcomposition_event == SDL_FALSE)
+        if (videodata->ime_suppress_endcomposition_event == SDL_FALSE) {
             SDL_SendEditingText("", 0, 0);
+        }
         videodata->ime_suppress_endcomposition_event = SDL_FALSE;
         break;
     case WM_IME_NOTIFY:
@@ -1072,8 +1105,9 @@ IME_HandleMessage(HWND hwnd, UINT msg, WPARAM wParam, LPARAM *lParam, SDL_VideoD
             break;
         case IMN_OPENCANDIDATE:
         case IMN_CHANGECANDIDATE:
-            if (videodata->ime_uiless)
+            if (videodata->ime_uiless) {
                 break;
+            }
 
             trap = SDL_TRUE;
             videodata->ime_uicontext = 1;
@@ -1095,8 +1129,9 @@ IME_HandleMessage(HWND hwnd, UINT msg, WPARAM wParam, LPARAM *lParam, SDL_VideoD
                 case IMEID_CHT_VER44:
                 case IMEID_CHS_VER41:
                 case IMEID_CHS_VER42:
-                    if (*lParam == 1 || *lParam == 2)
+                    if (*lParam == 1 || *lParam == 2) {
                         trap = SDL_TRUE;
+                    }
 
                     break;
                 case IMEID_CHT_VER50:
@@ -1104,12 +1139,9 @@ IME_HandleMessage(HWND hwnd, UINT msg, WPARAM wParam, LPARAM *lParam, SDL_VideoD
                 case IMEID_CHT_VER52:
                 case IMEID_CHT_VER60:
                 case IMEID_CHS_VER53:
-                    if (*lParam == 16
-                        || *lParam == 17
-                        || *lParam == 26
-                        || *lParam == 27
-                        || *lParam == 28)
+                    if (*lParam == 16 || *lParam == 17 || *lParam == 26 || *lParam == 27 || *lParam == 28) {
                         trap = SDL_TRUE;
+                    }
                     break;
                 }
             }
@@ -1143,8 +1175,9 @@ UILess_GetCandidateList(SDL_VideoData *videodata, ITfCandidateListUIElement *pca
     DWORD pgsize = 0;
     UINT i, j;
 
-    if (IME_ShowCandidateList(videodata) < 0)
+    if (IME_ShowCandidateList(videodata) < 0) {
         return;
+    }
 
     pcandlist->lpVtbl->GetSelection(pcandlist, &selection);
     pcandlist->lpVtbl->GetCount(pcandlist, &count);
@@ -1200,14 +1233,16 @@ STDMETHODIMP_(ULONG) TSFSink_Release(TSFSink *sink)
 
 STDMETHODIMP UIElementSink_QueryInterface(TSFSink *sink, REFIID riid, PVOID *ppv)
 {
-    if (!ppv)
+    if (ppv == NULL) {
         return E_INVALIDARG;
+    }
 
     *ppv = 0;
-    if (WIN_IsEqualIID(riid, &IID_IUnknown))
+    if (WIN_IsEqualIID(riid, &IID_IUnknown)) {
         *ppv = (IUnknown *)sink;
-    else if (WIN_IsEqualIID(riid, &IID_ITfUIElementSink))
+    } else if (WIN_IsEqualIID(riid, &IID_ITfUIElementSink)) {
         *ppv = (ITfUIElementSink *)sink;
+    }
 
     if (*ppv) {
         TSFSink_AddRef(sink);
@@ -1235,8 +1270,9 @@ STDMETHODIMP UIElementSink_BeginUIElement(TSFSink *sink, DWORD dwUIElementId, BO
     ITfReadingInformationUIElement *preading = 0;
     ITfCandidateListUIElement *pcandlist = 0;
     SDL_VideoData *videodata = (SDL_VideoData *)sink->data;
-    if (!element)
+    if (element == NULL) {
         return E_INVALIDARG;
+    }
 
     *pbShow = FALSE;
     if (SUCCEEDED(element->lpVtbl->QueryInterface(element, &IID_ITfReadingInformationUIElement, (LPVOID *)&preading))) {
@@ -1245,8 +1281,7 @@ STDMETHODIMP UIElementSink_BeginUIElement(TSFSink *sink, DWORD dwUIElementId, BO
             SysFreeString(bstr);
         }
         preading->lpVtbl->Release(preading);
-    }
-    else if (SUCCEEDED(element->lpVtbl->QueryInterface(element, &IID_ITfCandidateListUIElement, (LPVOID *)&pcandlist))) {
+    } else if (SUCCEEDED(element->lpVtbl->QueryInterface(element, &IID_ITfCandidateListUIElement, (LPVOID *)&pcandlist))) {
         videodata->ime_candref++;
         UILess_GetCandidateList(videodata, pcandlist);
         pcandlist->lpVtbl->Release(pcandlist);
@@ -1260,8 +1295,9 @@ STDMETHODIMP UIElementSink_UpdateUIElement(TSFSink *sink, DWORD dwUIElementId)
     ITfReadingInformationUIElement *preading = 0;
     ITfCandidateListUIElement *pcandlist = 0;
     SDL_VideoData *videodata = (SDL_VideoData *)sink->data;
-    if (!element)
+    if (element == NULL) {
         return E_INVALIDARG;
+    }
 
     if (SUCCEEDED(element->lpVtbl->QueryInterface(element, &IID_ITfReadingInformationUIElement, (LPVOID *)&preading))) {
         BSTR bstr;
@@ -1272,8 +1308,7 @@ STDMETHODIMP UIElementSink_UpdateUIElement(TSFSink *sink, DWORD dwUIElementId)
             SysFreeString(bstr);
         }
         preading->lpVtbl->Release(preading);
-    }
-    else if (SUCCEEDED(element->lpVtbl->QueryInterface(element, &IID_ITfCandidateListUIElement, (LPVOID *)&pcandlist))) {
+    } else if (SUCCEEDED(element->lpVtbl->QueryInterface(element, &IID_ITfCandidateListUIElement, (LPVOID *)&pcandlist))) {
         UILess_GetCandidateList(videodata, pcandlist);
         pcandlist->lpVtbl->Release(pcandlist);
     }
@@ -1286,8 +1321,9 @@ STDMETHODIMP UIElementSink_EndUIElement(TSFSink *sink, DWORD dwUIElementId)
     ITfReadingInformationUIElement *preading = 0;
     ITfCandidateListUIElement *pcandlist = 0;
     SDL_VideoData *videodata = (SDL_VideoData *)sink->data;
-    if (!element)
+    if (element == NULL) {
         return E_INVALIDARG;
+    }
 
     if (SUCCEEDED(element->lpVtbl->QueryInterface(element, &IID_ITfReadingInformationUIElement, (LPVOID *)&preading))) {
         videodata->ime_readingstring[0] = 0;
@@ -1296,8 +1332,9 @@ STDMETHODIMP UIElementSink_EndUIElement(TSFSink *sink, DWORD dwUIElementId)
     }
     if (SUCCEEDED(element->lpVtbl->QueryInterface(element, &IID_ITfCandidateListUIElement, (LPVOID *)&pcandlist))) {
         videodata->ime_candref--;
-        if (videodata->ime_candref == 0)
+        if (videodata->ime_candref == 0) {
             IME_CloseCandidateList(videodata);
+        }
 
         pcandlist->lpVtbl->Release(pcandlist);
     }
@@ -1306,14 +1343,16 @@ STDMETHODIMP UIElementSink_EndUIElement(TSFSink *sink, DWORD dwUIElementId)
 
 STDMETHODIMP IPPASink_QueryInterface(TSFSink *sink, REFIID riid, PVOID *ppv)
 {
-    if (!ppv)
+    if (ppv == NULL) {
         return E_INVALIDARG;
+    }
 
     *ppv = 0;
-    if (WIN_IsEqualIID(riid, &IID_IUnknown))
+    if (WIN_IsEqualIID(riid, &IID_IUnknown)) {
         *ppv = (IUnknown *)sink;
-    else if (WIN_IsEqualIID(riid, &IID_ITfInputProcessorProfileActivationSink))
+    } else if (WIN_IsEqualIID(riid, &IID_ITfInputProcessorProfileActivationSink)) {
         *ppv = (ITfInputProcessorProfileActivationSink *)sink;
+    }
 
     if (*ppv) {
         TSFSink_AddRef(sink);
@@ -1327,8 +1366,9 @@ STDMETHODIMP IPPASink_OnActivated(TSFSink *sink, DWORD dwProfileType, LANGID lan
     static const GUID TF_PROFILE_DAYI = { 0x037B2C25, 0x480C, 0x4D7F, { 0xB0, 0x27, 0xD6, 0xCA, 0x6B, 0x69, 0x78, 0x8A } };
     SDL_VideoData *videodata = (SDL_VideoData *)sink->data;
     videodata->ime_candlistindexbase = WIN_IsEqualGUID(&TF_PROFILE_DAYI, guidProfile) ? 0 : 1;
-    if (WIN_IsEqualIID(catid, &GUID_TFCAT_TIP_KEYBOARD) && (dwFlags & TF_IPSINK_FLAG_ACTIVE))
+    if (WIN_IsEqualIID(catid, &GUID_TFCAT_TIP_KEYBOARD) && (dwFlags & TF_IPSINK_FLAG_ACTIVE)) {
         IME_InputLangChanged((SDL_VideoData *)sink->data);
+    }
 
     IME_HideCandidateList(videodata);
     return S_OK;
@@ -1354,8 +1394,9 @@ static void
 UILess_EnableUIUpdates(SDL_VideoData *videodata)
 {
     ITfSource *source = 0;
-    if (!videodata->ime_threadmgrex || videodata->ime_uielemsinkcookie != TF_INVALID_COOKIE)
+    if (!videodata->ime_threadmgrex || videodata->ime_uielemsinkcookie != TF_INVALID_COOKIE) {
         return;
+    }
 
     if (SUCCEEDED(videodata->ime_threadmgrex->lpVtbl->QueryInterface(videodata->ime_threadmgrex, &IID_ITfSource, (LPVOID *)&source))) {
         source->lpVtbl->AdviseSink(source, &IID_ITfUIElementSink, (IUnknown *)videodata->ime_uielemsink, &videodata->ime_uielemsinkcookie);
@@ -1367,8 +1408,9 @@ static void
 UILess_DisableUIUpdates(SDL_VideoData *videodata)
 {
     ITfSource *source = 0;
-    if (!videodata->ime_threadmgrex || videodata->ime_uielemsinkcookie == TF_INVALID_COOKIE)
+    if (!videodata->ime_threadmgrex || videodata->ime_uielemsinkcookie == TF_INVALID_COOKIE) {
         return;
+    }
 
     if (SUCCEEDED(videodata->ime_threadmgrex->lpVtbl->QueryInterface(videodata->ime_threadmgrex, &IID_ITfSource, (LPVOID *)&source))) {
         source->lpVtbl->UnadviseSink(source, videodata->ime_uielemsinkcookie);
@@ -1383,11 +1425,13 @@ UILess_SetupSinks(SDL_VideoData *videodata)
     TfClientId clientid = 0;
     SDL_bool result = SDL_FALSE;
     ITfSource *source = 0;
-    if (FAILED(CoCreateInstance(&CLSID_TF_ThreadMgr, NULL, CLSCTX_INPROC_SERVER, &IID_ITfThreadMgrEx, (LPVOID *)&videodata->ime_threadmgrex)))
+    if (FAILED(CoCreateInstance(&CLSID_TF_ThreadMgr, NULL, CLSCTX_INPROC_SERVER, &IID_ITfThreadMgrEx, (LPVOID *)&videodata->ime_threadmgrex))) {
         return SDL_FALSE;
+    }
 
-    if (FAILED(videodata->ime_threadmgrex->lpVtbl->ActivateEx(videodata->ime_threadmgrex, &clientid, TF_TMAE_UIELEMENTENABLEDONLY)))
+    if (FAILED(videodata->ime_threadmgrex->lpVtbl->ActivateEx(videodata->ime_threadmgrex, &clientid, TF_TMAE_UIELEMENTENABLEDONLY))) {
         return SDL_FALSE;
+    }
 
     videodata->ime_uielemsink = SDL_malloc(sizeof(TSFSink));
     videodata->ime_ippasink = SDL_malloc(sizeof(TSFSink));
@@ -1451,8 +1495,9 @@ StartDrawToBitmap(HDC hdc, HBITMAP *hhbm, int width, int height)
         infoHeader->biBitCount = 32;
         infoHeader->biCompression = BI_RGB;
         *hhbm = CreateDIBSection(hdc, &info, DIB_RGB_COLORS, (void **)&bits, 0, 0);
-        if (*hhbm)
+        if (*hhbm) {
             SelectObject(hdc, *hhbm);
+        }
     }
     return bits;
 }
@@ -1507,8 +1552,9 @@ IME_PositionCandidateList(SDL_VideoData *videodata, SIZE size)
         left -= right - winw;
         right = winw;
     }
-    if (bottom < winh)
+    if (bottom < winh) {
         ok = SDL_TRUE;
+    }
 
     /* Top */
     if (!ok) {
@@ -1520,8 +1566,9 @@ IME_PositionCandidateList(SDL_VideoData *videodata, SIZE size)
             left -= right - winw;
             right = winw;
         }
-        if (top >= 0)
+        if (top >= 0) {
             ok = SDL_TRUE;
+        }
     }
 
     /* Right */
@@ -1530,8 +1577,9 @@ IME_PositionCandidateList(SDL_VideoData *videodata, SIZE size)
         top = 0;
         right = left + size.cx;
         bottom = size.cy;
-        if (right < winw)
+        if (right < winw) {
             ok = SDL_TRUE;
+        }
     }
 
     /* Left */
@@ -1540,8 +1588,9 @@ IME_PositionCandidateList(SDL_VideoData *videodata, SIZE size)
         top = 0;
         right = videodata->ime_rect.x;
         bottom = size.cy;
-        if (right >= 0)
+        if (right >= 0) {
             ok = SDL_TRUE;
+        }
     }
 
     /* Window too small, show at (0,0) */
@@ -1625,8 +1674,7 @@ IME_RenderCandidateList(SDL_VideoData *videodata, HDC hdc)
             (candcount * candpadding * 2) +
             (candcount * maxcandsize.cy)
             ;
-    }
-    else {
+    } else {
         size.cx =
             (listborder * 2) +
             (listpadding * 2) +
@@ -1635,8 +1683,9 @@ IME_RenderCandidateList(SDL_VideoData *videodata, HDC hdc)
             (candcount * candpadding * 2) +
             ((candcount - 1) * horzcandspacing);
 
-        for (i = 0; i < candcount; ++i)
+        for (i = 0; i < candcount; ++i) {
             size.cx += candsizes[i].cx;
+        }
 
         size.cy =
             (listborder * 2) +
@@ -1668,12 +1717,12 @@ IME_RenderCandidateList(SDL_VideoData *videodata, HDC hdc)
             top = listborder + listpadding + (i * candborder * 2) + (i * candpadding * 2) + ((i + 1) * candmargin) + (i * maxcandsize.cy);
             right = size.cx - listborder - listpadding - candmargin;
             bottom = top + maxcandsize.cy + (candpadding * 2) + (candborder * 2);
-        }
-        else {
+        } else {
             left = listborder + listpadding + (i * candborder * 2) + (i * candpadding * 2) + ((i + 1) * candmargin) + (i * horzcandspacing);
 
-            for (j = 0; j < i; ++j)
+            for (j = 0; j < i; ++j) {
                 left += candsizes[j].cx;
+            }
 
             top = listborder + listpadding + candmargin;
             right = left + candsizes[i].cx + (candpadding * 2) + (candborder * 2);
@@ -1684,8 +1733,7 @@ IME_RenderCandidateList(SDL_VideoData *videodata, HDC hdc)
             SelectObject(hdc, selpen);
             SelectObject(hdc, selbrush);
             SetTextColor(hdc, seltextcolor);
-        }
-        else {
+        } else {
             SelectObject(hdc, candpen);
             SelectObject(hdc, candbrush);
             SetTextColor(hdc, candtextcolor);
@@ -1712,8 +1760,9 @@ IME_Render(SDL_VideoData *videodata)
 {
     HDC hdc = CreateCompatibleDC(NULL);
 
-    if (videodata->ime_candlist)
+    if (videodata->ime_candlist) {
         IME_RenderCandidateList(videodata, hdc);
+    }
 
     DeleteDC(hdc);
 
@@ -1722,8 +1771,9 @@ IME_Render(SDL_VideoData *videodata)
 
 void IME_Present(SDL_VideoData *videodata)
 {
-    if (videodata->ime_dirty)
+    if (videodata->ime_dirty) {
         IME_Render(videodata);
+    }
 
     /* FIXME: Need to show the IME bitmap */
 }
diff --git a/src/video/windows/SDL_windowsmessagebox.c b/src/video/windows/SDL_windowsmessagebox.c
index 25d40a19a..bfbf3c3bb 100644
--- a/src/video/windows/SDL_windowsmessagebox.c
+++ b/src/video/windows/SDL_windowsmessagebox.c
@@ -345,7 +345,7 @@ static SDL_bool ExpandDialogSpace(WIN_DialogData *dialog, size_t space)
 
     if (size > dialog->size) {
         void *data = SDL_realloc(dialog->data, size);
-        if (!data) {
+        if (data == NULL) {
             SDL_OutOfMemory();
             return SDL_FALSE;
         }
@@ -388,12 +388,12 @@ static SDL_bool AddDialogString(WIN_DialogData *dialog, const char *string)
     size_t count;
     SDL_bool status;
 
-    if (!string) {
+    if (string == NULL) {
         string = "";
     }
 
     wstring = WIN_UTF8ToStringW(string);
-    if (!wstring) {
+    if (wstring == NULL) {
         return SDL_FALSE;
     }
 
@@ -523,7 +523,7 @@ static WIN_DialogData *CreateDialogData(int w, int h, const char *caption)
     Vec2ToDLU(&dialogTemplate.cx, &dialogTemplate.cy);
 
     dialog = (WIN_DialogData *)SDL_calloc(1, sizeof(*dialog));
-    if (!dialog) {
+    if (dialog == NULL) {
         return NULL;
     }
 
@@ -566,8 +566,10 @@ static WIN_DialogData *CreateDialogData(int w, int h, const char *caption)
         {
             HDC ScreenDC = GetDC(NULL);
             int LogicalPixelsY = GetDeviceCaps(ScreenDC, LOGPIXELSY);
-            if (!LogicalPixelsY) /* This can happen if the application runs out of GDI handles */
-                LogicalPixelsY = 72;
+            if (!LogicalPixelsY) {
+                LogicalPixelsY = 72; /* This can happen if the application runs out of GDI handles */
+            }
+
             WordToPass = (WORD)(-72 * NCM.lfMessageFont.lfHeight / LogicalPixelsY);
             ReleaseDC(NULL, ScreenDC);
         }
@@ -805,8 +807,9 @@ WIN_ShowOldMessageBox(const SDL_MessageBoxData *messageboxdata, int *buttonid)
     }
 
     /* Ensure the size is wide enough for all of the buttons. */
-    if (Size.cx < messageboxdata->numbuttons * (ButtonWidth + ButtonMargin) + ButtonMargin)
+    if (Size.cx < messageboxdata->numbuttons * (ButtonWidth + ButtonMargin) + ButtonMargin) {
         Size.cx = messageboxdata->numbuttons * (ButtonWidth + ButtonMargin) + ButtonMargin;
+    }
 
     /* Reset the height to the icon size if it is actually bigger than the text. */
     if (icon && Size.cy < IconMargin * 2 + IconHeight) {
@@ -817,7 +820,7 @@ WIN_ShowOldMessageBox(const SDL_MessageBoxData *messageboxdata, int *buttonid)
     Size.cy += ButtonHeight + TextMargin;
 
     dialog = CreateDialogData(Size.cx, Size.cy, messageboxdata->title);
-    if (!dialog) {
+    if (dialog == NULL) {
         return -1;
     }
 
@@ -977,8 +980,7 @@ WIN_ShowMessageBox(const SDL_MessageBoxData *messageboxdata, int *buttonid)
     pButtons = SDL_malloc(sizeof (TASKDIALOG_BUTTON) * messageboxdata->numbuttons);
     TaskConfig.nDefaultButton = 0;
     nCancelButton = 0;
-    for (i = 0; i < messageboxdata->numbuttons; i++)
-    {
+    for (i = 0; i < messageboxdata->numbuttons; i++) {
         const char *buttontext;
         if (messageboxdata->flags & SDL_MESSAGEBOX_BUTTONS_LEFT_TO_RIGHT) {
             pButton = &pButtons[i];
diff --git a/src/video/windows/SDL_windowsmodes.c b/src/video/windows/SDL_windowsmodes.c
index 2e4414014..78af47917 100644
--- a/src/video/windows/SDL_windowsmodes.c
+++ b/src/video/windows/SDL_windowsmodes.c
@@ -174,7 +174,7 @@ WIN_GetDisplayMode(_THIS, LPCWSTR deviceName, DWORD index, SDL_DisplayMode * mod
     }
 
     data = (SDL_DisplayModeData *) SDL_malloc(sizeof(*data));
-    if (!data) {
+    if (data == NULL) {
         return SDL_FALSE;
     }
 
@@ -217,7 +217,7 @@ WIN_GetDisplayNameVista(const WCHAR *deviceName)
     LONG rc;
 
     dll = SDL_LoadObject("USER32.DLL");
-    if (!dll) {
+    if (dll == NULL) {
         return NULL;
     }
 
@@ -225,7 +225,7 @@ WIN_GetDisplayNameVista(const WCHAR *deviceName)
     pQueryDisplayConfig = (SDL_WIN32PROC_QueryDisplayConfig) SDL_LoadFunction(dll, "QueryDisplayConfig");
     pDisplayConfigGetDeviceInfo = (SDL_WIN32PROC_DisplayConfigGetDeviceInfo) SDL_LoadFunction(dll, "DisplayConfigGetDeviceInfo");
 
-    if (!pGetDisplayConfigBufferSizes || !pQueryDisplayConfig || !pDisplayConfigGetDeviceInfo) {
+    if (pGetDisplayConfigBufferSizes == NULL || pQueryDisplayConfig == NULL || pDisplayConfigGetDeviceInfo == NULL) {
         goto WIN_GetDisplayNameVista_failed;
     }
 
@@ -316,7 +316,7 @@ WIN_AddDisplay(_THIS, HMONITOR hMonitor, const MONITORINFOEXW *info, SDL_bool se
     // Prevent adding duplicate displays. Do this after we know the display is
     // ready to be added to allow any displays that we can't fully query to be
     // removed
-    for(i = 0; i < _this->num_displays; ++i) {
+    for (i = 0; i < _this->num_displays; ++i) {
         SDL_DisplayData *driverdata = (SDL_DisplayData *)_this->displays[i].driverdata;
         if (SDL_wcscmp(driverdata->DeviceName, info->szDevice) == 0) {
             driverdata->MonitorHandle = hMonitor;
@@ -333,7 +333,7 @@ WIN_AddDisplay(_THIS, HMONITOR hMonitor, const MONITORINFOEXW *info, SDL_bool se
     }
 
     displaydata = (SDL_DisplayData *) SDL_calloc(1, sizeof(*displaydata));
-    if (!displaydata) {
+    if (displaydata == NULL) {
         return SDL_FALSE;
     }
     SDL_memcpy(displaydata->DeviceName, info->szDevice, sizeof(displaydata->DeviceName));
@@ -583,7 +583,7 @@ void WIN_ScreenPointFromSDL(int *x, int *y, int *dpiOut)
         *dpiOut = 96;
     }
 
-    if (!videodevice || !videodevice->driverdata) {
+    if (videodevice == NULL || !videodevice->driverdata) {
         return;
     }
 
@@ -637,7 +637,7 @@ void WIN_ScreenPointToSDL(int *x, int *y)
     float ddpi, hdpi, vdpi;
     int x_pixels, y_pixels;
 
-    if (!videodevice || !videodevice->driverdata) {
+    if (videodevice == NULL || !videodevice->driverdata) {
         return;
     }
 
diff --git a/src/video/windows/SDL_windowsmouse.c b/src/video/windows/SDL_windowsmouse.c
index 2ef0f1452..31d8f608e 100644
--- a/src/video/windows/SDL_windowsmouse.c
+++ b/src/video/windows/SDL_windowsmouse.c
@@ -235,7 +235,7 @@ WIN_FreeCursor(SDL_Cursor * cursor)
 static int
 WIN_ShowCursor(SDL_Cursor * cursor)
 {
-    if (!cursor) {
+    if (cursor == NULL) {
         cursor = SDL_blank_cursor;
     }
     if (cursor) {
diff --git a/src/video/windows/SDL_windowsopengl.c b/src/video/windows/SDL_windowsopengl.c
index c1df7f6b9..53f27d5f8 100644
--- a/src/video/windows/SDL_windowsopengl.c
+++ b/src/video/windows/SDL_windowsopengl.c
@@ -189,7 +189,7 @@ WIN_GL_GetProcAddress(_THIS, const char *proc)
 
     /* This is to pick up extensions */
     func = _this->gl_data->wglGetProcAddress(proc);
-    if (!func) {
+    if (func == NULL) {
         /* This is probably a normal GL function */
         func = GetProcAddress(_this->gl_config.dll_handle, proc);
     }
@@ -352,11 +352,13 @@ HasExtension(const char *extension, const char *extensions)
 
     /* Extension names should not have spaces. */
     where = SDL_strchr(extension, ' ');
-    if (where || *extension == '\0')
+    if (where || *extension == '\0') {
         return SDL_FALSE;
+    }
 
-    if (!extensions)
+    if (extensions == NULL) {
         return SDL_FALSE;
+    }
 
     /* It takes a bit of care to be fool-proof about parsing the
      * OpenGL extensions string. Don't be fooled by sub-strings,
@@ -366,13 +368,16 @@ HasExtension(const char *extension, const char *extensions)
 
     for (;;) {
         where = SDL_strstr(start, extension);
-        if (!where)
+        if (where == NULL) {
             break;
+        }
 
         terminator = where + SDL_strlen(extension);
-        if (where == start || *(where - 1) == ' ')
-            if (*terminator == ' ' || *terminator == '\0')
+        if (where == start || *(where - 1) == ' ') {
+            if (*terminator == ' ' || *terminator == '\0') {
                 return SDL_TRUE;
+            }
+        }
 
         start = terminator;
     }
@@ -663,11 +668,7 @@ WIN_GL_UseEGL(_THIS)
     SDL_assert(_this->gl_data != NULL);
     SDL_assert(_this->gl_config.profile_mask == SDL_GL_CONTEXT_PROFILE_ES);
 
-    return (SDL_GetHintBoolean(SDL_HINT_OPENGL_ES_DRIVER, SDL_FALSE)
-            || _this->gl_config.major_version == 1 /* No WGL extension for OpenGL ES 1.x profiles. */
-            || _this->gl_config.major_version > _this->gl_data->es_profile_max_supported_version.major
-            || (_this->gl_config.major_version == _this->gl_data->es_profile_max_supported_version.major
-                && _this->gl_config.minor_version > _this->gl_data->es_profile_max_supported_version.minor));
+    return SDL_GetHintBoolean(SDL_HINT_OPENGL_ES_DRIVER, SDL_FALSE) || _this->gl_config.major_version == 1 || _this->gl_config.major_version > _this->gl_data->es_profile_max_supported_version.major || (_this->gl_config.major_version == _this->gl_data->es_profile_max_supported_version.major && _this->gl_config.minor_version > _this->gl_data->es_profile_max_supported_version.minor); /* No WGL extension for OpenGL ES 1.x profiles. */
 }
 
 SDL_GLContext
@@ -712,7 +713,7 @@ WIN_GL_CreateContext(_THIS, SDL_Window * window)
         _this->gl_config.flags == 0) {
         /* Create legacy context */
         context = _this->gl_data->wglCreateContext(hdc);
-        if( share_context != 0 ) {
+        if ( share_context != 0 ) {
             _this->gl_data->wglShareLists(share_context, context);
         }
     } else {
@@ -810,15 +811,15 @@ WIN_GL_MakeCurrent(_THIS, SDL_Window * window, SDL_GLContext context)
     }
 
     /* sanity check that higher level handled this. */
-    SDL_assert(window || (!window && !context));
+    SDL_assert(window || (window == NULL && !context));
 
     /* Some Windows drivers freak out if hdc is NULL, even when context is
        NULL, against spec. Since hdc is _supposed_ to be ignored if context
        is NULL, we either use the current GL window, or do nothing if we
        already have no current context. */
-    if (!window) {
+    if (window == NULL) {
         window = SDL_GL_GetCurrentWindow();
-        if (!window) {
+        if (window == NULL) {
             SDL_assert(SDL_GL_GetCurrentContext() == NULL);
             return 0;  /* already done. */
         }
diff --git a/src/video/windows/SDL_windowsshape.c b/src/video/windows/SDL_windowsshape.c
index 484566dd3..64af5a691 100644
--- a/src/video/windows/SDL_windowsshape.c
+++ b/src/video/windows/SDL_windowsshape.c
@@ -29,7 +29,7 @@ SDL_WindowShaper*
 Win32_CreateShaper(SDL_Window * window) {
     int resized_properly;
     SDL_WindowShaper* result = (SDL_WindowShaper *)SDL_malloc(sizeof(SDL_WindowShaper));
-    if (!result) {
+    if (result == NULL) {
         SDL_OutOfMemory();
         return NULL;
     }
@@ -60,14 +60,13 @@ Win32_CreateShaper(SDL_Window * window) {
 static void
 CombineRectRegions(SDL_ShapeTree* node,void* closure) {
     HRGN mask_region = *((HRGN*)closure),temp_region = NULL;
-    if(node->kind == OpaqueShape) {
+    if (node->kind == OpaqueShape) {
         /* Win32 API regions exclude their outline, so we widen the region by one pixel in each direction to include the real outline. */
         temp_region = CreateRectRgn(node->data.shape.x,node->data.shape.y,node->data.shape.x + node->data.shape.w + 1,node->data.shape.y + node->data.shape.h + 1);
-        if(mask_region != NULL) {
+        if (mask_region != NULL) {
             CombineRgn(mask_region,mask_region,temp_region,RGN_OR);
             DeleteObject(temp_region);
-        }
-        else
+        } else
             *((HRGN*)closure) = temp_region;
     }
 }
@@ -77,7 +76,7 @@ Win32_SetWindowShape(SDL_WindowShaper *shaper,SDL_Surface *shape,SDL_WindowShape
     SDL_ShapeData *data;
     HRGN mask_region = NULL;
 
-    if( (shaper == NULL) ||
+    if ( (shaper == NULL) ||
         (shape == NULL) ||
         ((shape->format->Amask == 0) && (shape_mode->mode != ShapeModeColorKey)) ||
         (shape->w != shaper->window->w) ||
@@ -86,8 +85,9 @@ Win32_SetWindowShape(SDL_WindowShaper *shaper,SDL_Surface *shape,SDL_WindowShape
     }
 
     data = (SDL_ShapeData*)shaper->driverdata;
-    if(data->mask_tree != NULL)
+    if (data->mask_tree != NULL) {
         SDL_FreeShapeTree(&data->mask_tree);
+    }
     data->mask_tree = SDL_CalculateShapeTree(*shape_mode,shape);
 
     SDL_TraverseShapeTree(data->mask_tree,&CombineRectRegions,&mask_region);
@@ -102,15 +102,18 @@ int
 Win32_ResizeWindowShape(SDL_Window *window) {
     SDL_ShapeData* data;
 
-    if (window == NULL)
+    if (window == NULL) {
         return -1;
+    }
     data = (SDL_ShapeData *)window->shaper->driverdata;
-    if (data == NULL)
+    if (data == NULL) {
         return -1;
+    }
 
-    if(data->mask_tree != NULL)
+    if (data->mask_tree != NULL) {
         SDL_FreeShapeTree(&data->mask_tree);
-    if(window->shaper->hasshape == SDL_TRUE) {
+    }
+    if (window->shaper->hasshape == SDL_TRUE) {
         window->shaper->userx = window->x;
         window->shaper->usery = window->y;
         SDL_SetWindowPosition(window,-1000,-1000);
diff --git a/src/video/windows/SDL_windowsvideo.c b/src/video/windows/SDL_windowsvideo.c
index 0dc107bdf..54cdd72cf 100644
--- a/src/video/windows/SDL_windowsvideo.c
+++ b/src/video/windows/SDL_windowsvideo.c
@@ -552,7 +552,7 @@ SDL_Direct3D9GetAdapterIndex(int displayIndex)
         SDL_DisplayData *pData = (SDL_DisplayData *)SDL_GetDisplayDriverData(displayIndex);
         int adapterIndex = D3DADAPTER_DEFAULT;
 
-        if (!pData) {
+        if (pData == NULL) {
             SDL_SetError("Invalid display index");
             adapterIndex = -1; /* make sure we return something invalid */
         } else {
@@ -620,8 +620,12 @@ SDL_bool
 SDL_DXGIGetOutputInfo(int displayIndex, int *adapterIndex, int *outputIndex)
 {
 #if !HAVE_DXGI_H
-    if (adapterIndex) *adapterIndex = -1;
-    if (outputIndex) *outputIndex = -1;
+    if (adapterIndex) {
+        *adapterIndex = -1;
+    }
+    if (outputIndex) {
+        *outputIndex = -1;
+    }
     SDL_SetError("SDL was compiled without DXGI support due to missing dxgi.h header");
     return SDL_FALSE;
 #else
@@ -633,12 +637,12 @@ SDL_DXGIGetOutputInfo(int displayIndex, int *adapterIndex, int *outputIndex)
     IDXGIAdapter *pDXGIAdapter;
     IDXGIOutput* pDXGIOutput;
 
-    if (!adapterIndex) {
+    if (adapterIndex == NULL) {
         SDL_InvalidParamError("adapterIndex");
         return SDL_FALSE;
     }
 
-    if (!outputIndex) {
+    if (outputIndex == NULL) {
         SDL_InvalidParamError("outputIndex");
         return SDL_FALSE;
     }
@@ -646,7 +650,7 @@ SDL_DXGIGetOutputInfo(int displayIndex, int *adapterIndex, int *outputIndex)
     *adapterIndex = -1;
     *outputIndex = -1;
 
-    if (!pData) {
+    if (pData == NULL) {
         SDL_SetError("Invalid display index");
         return SDL_FALSE;
     }
diff --git a/src/video/windows/SDL_windowsvulkan.c b/src/video/windows/SDL_windowsvulkan.c
index 2a66f4398..36af273cc 100644
--- a/src/video/windows/SDL_windowsvulkan.c
+++ b/src/video/windows/SDL_windowsvulkan.c
@@ -43,51 +43,56 @@ int WIN_Vulkan_LoadLibrary(_THIS, const char *path)
     SDL_bool hasSurfaceExtension = SDL_FALSE;
     SDL_bool hasWin32SurfaceExtension = SDL_FALSE;
     PFN_vkGetInstanceProcAddr vkGetInstanceProcAddr = NULL;
-    if(_this->vulkan_config.loader_handle)
+    if (_this->vulkan_config.loader_handle) {
         return SDL_SetError("Vulkan already loaded");
+    }
 
     /* Load the Vulkan loader library */
-    if(!path)
+    if (path == NULL) {
         path = SDL_getenv("SDL_VULKAN_LIBRARY");
-    if(!path)
+    }
+    if (path == NULL) {
         path = "vulkan-1.dll";
+    }
     _this->vulkan_config.loader_handle = SDL_LoadObject(path);
-    if(!_this->vulkan_config.loader_handle)
+    if (!_this->vulkan_config.loader_handle) {
         return -1;
+    }
     SDL_strlcpy(_this->vulkan_config.loader_path, path,
                 SDL_arraysize(_this->vulkan_config.loader_path));
     vkGetInstanceProcAddr = (PFN_vkGetInstanceProcAddr)SDL_LoadFunction(
         _this->vulkan_config.loader_handle, "vkGetInstanceProcAddr");
-    if(!vkGetInstanceProcAddr)
+    if (!vkGetInstanceProcAddr) {
         goto fail;
+    }
     _this->vulkan_config.vkGetInstanceProcAddr = (void *)vkGetInstanceProcAddr;
     _this->vulkan_config.vkEnumerateInstanceExtensionProperties =
         (void *)((PFN_vkGetInstanceProcAddr)_this->vulkan_config.vkGetInstanceProcAddr)(
             VK_NULL_HANDLE, "vkEnumerateInstanceExtensionProperties");
-    if(!_this->vulkan_config.vkEnumerateInstanceExtensionProperties)
+    if (!_this->vulkan_config.vkEnumerateInstanceExtensionProperties) {
         goto fail;
+    }
     extensions = SDL_Vulkan_CreateInstanceExtensionsList(
         (PFN_vkEnumerateInstanceExtensionProperties)
             _this->vulkan_config.vkEnumerateInstanceExtensionProperties,
         &extensionCount);
-    if(!extensions)
+    if (extensions == NULL) {
         goto fail;
-    for(i = 0; i < extensionCount; i++)
+    }
+    for (i = 0; i < extensionCount; i++)
     {
-        if(SDL_strcmp(VK_KHR_SURFACE_EXTENSION_NAME, extensions[i].extensionName) == 0)
+        if (SDL_strcmp(VK_KHR_SURFACE_EXTENSION_NAME, extensions[i].extensionName) == 0) {
             hasSurfaceExtension = SDL_TRUE;
-        else if(SDL_strcmp(VK_KHR_WIN32_SURFACE_EXTENSION_NAME, extensions[i].extensionName) == 0)
+        } else if (SDL_strcmp(VK_KHR_WIN32_SURFACE_EXTENSION_NAME, extensions[i].extensionName) == 0) {
             hasWin32SurfaceExtension = SDL_TRUE;
+        }
     }
     SDL_free(extensions);
-    if(!hasSurfaceExtension)
-    {
+    if (!hasSurfaceExtension) {
         SDL_SetError("Installed Vulkan doesn't implement the "
                      VK_KHR_SURFACE_EXTENSION_NAME " extension");
         goto fail;
-    }
-    else if(!hasWin32SurfaceExtension)
-    {
+    } else if (!hasWin32SurfaceExtension) {
         SDL_SetError("Installed Vulkan doesn't implement the "
                      VK_KHR_WIN32_SURFACE_EXTENSION_NAME "extension");
         goto fail;
@@ -102,8 +107,7 @@ fail:
 
 void WIN_Vulkan_UnloadLibrary(_THIS)
 {
-    if(_this->vulkan_config.loader_handle)
-    {
+    if (_this->vulkan_config.loader_handle) {
         SDL_UnloadObject(_this->vulkan_config.loader_handle);
         _this->vulkan_config.loader_handle = NULL;
     }
@@ -117,8 +121,7 @@ SDL_bool WIN_Vulkan_GetInstanceExtensions(_THIS,
     static const char *const extensionsForWin32[] = {
         VK_KHR_SURFACE_EXTENSION_NAME, VK_KHR_WIN32_SURFACE_EXTENSION_NAME
     };
-    if(!_this->vulkan_config.loader_handle)
-    {
+    if (!_this->vulkan_config.loader_handle) {
         SDL_SetError("Vulkan is not loaded");
         return SDL_FALSE;
     }
@@ -142,14 +145,12 @@ SDL_bool WIN_Vulkan_CreateSurface(_THIS,
     VkWin32SurfaceCreateInfoKHR createInfo;
     VkResult result;
 
-    if(!_this->vulkan_config.loader_handle)
-    {
+    if (!_this->vulkan_config.loader_handle) {
         SDL_SetError("Vulkan is not loaded");
         return SDL_FALSE;
     }
 
-    if(!vkCreateWin32SurfaceKHR)
-    {
+    if (!vkCreateWin32SurfaceKHR) {
         SDL_SetError(VK_KHR_WIN32_SURFACE_EXTENSION_NAME
                      " extension is not enabled in the Vulkan instance.");
         return SDL_FALSE;
@@ -161,8 +162,7 @@ SDL_bool WIN_Vulkan_CreateSurface(_THIS,
     createInfo.hwnd = windowData->hwnd;
     result = vkCreateWin32SurfaceKHR(instance, &createInfo,
                                        NULL, surface);
-    if(result != VK_SUCCESS)
-    {
+    if (result != VK_SUCCESS) {
         SDL_SetError("vkCreateWin32SurfaceKHR failed: %s",
                      SDL_Vulkan_GetResultString(result));
         return SDL_FALSE;
diff --git a/src/video/windows/SDL_windowswindow.c b/src/video/windows/SDL_windowswindow.c
index d260f15c6..151c369ef 100644
--- a/src/video/windows/SDL_windowswindow.c
+++ b/src/video/windows/SDL_windowswindow.c
@@ -305,7 +305,7 @@ SetupWindowData(_THIS, SDL_Window * window, HWND hwnd, HWND parent, SDL_bool cre
 
     /* Allocate the window data */
     data = (SDL_WindowData *) SDL_calloc(1, sizeof(*data));
-    if (!data) {
+    if (data == NULL) {
         return SDL_OutOfMemory();
     }
     data->window = window;
@@ -841,8 +841,7 @@ WIN_RaiseWindow(_THIS, SDL_Window * window)
     DWORD dwCurID = 0u;
 
     HWND hwnd = ((SDL_WindowData *) window->driverdata)->hwnd;
-    if(bForce)
-    {
+    if (bForce) {
         hCurWnd = GetForegroundWindow();
         dwMyID = GetCurrentThreadId();
         dwCurID = GetWindowThreadProcessId(hCurWnd, NULL);
@@ -852,8 +851,7 @@ WIN_RaiseWindow(_THIS, SDL_Window * window)
         SetWindowPos(hwnd, HWND_NOTOPMOST, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE);
     }
     SetForegroundWindow(hwnd);
-    if (bForce)
-    {
+    if (bForce) {
         AttachThreadInput(dwCurID, dwMyID, FALSE);
         SetFocus(hwnd);
         SetActiveWindow(hwnd);
@@ -1079,7 +1077,7 @@ WIN_GetWindowICCProfile(_THIS, SDL_Window * window, size_t * size)
     filename_utf8 = WIN_StringToUTF8(data->ICMFileName);
     if (filename_utf8) {
         iccProfileData = SDL_LoadFile(filename_utf8, size);
-        if (!iccProfileData) {
+        if (iccProfileData == NULL) {
             SDL_SetError("Could not open ICC profile");
         }
         SDL_free(filename_utf8);
@@ -1293,7 +1291,7 @@ void WIN_OnWindowEnter(_THIS, SDL_Window * window)
 {
     SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
 
-    if (!data || !data->hwnd) {
+    if (data == NULL || !data->hwnd) {
         /* The window wasn't fully initialized */
         return;
     }
@@ -1451,8 +1449,9 @@ WIN_ClientPointToSDL(const SDL_Window *window, int *x, int *y)
     const SDL_WindowData *data = ((SDL_WindowData *)window->driverdata);
     const SDL_VideoData *videodata = data->videodata;
 
-    if (!videodata->dpi_scaling_enabled)
+    if (!videodata->dpi_scaling_enabled) {
         return;
+    }
 
     *x = MulDiv(*x, 96, data->scaling_dpi);
     *y = MulDiv(*y, 96, data->scaling_dpi);
@@ -1469,8 +1468,9 @@ WIN_ClientPointFromSDL(const SDL_Window *window, int *x, int *y)
     const SDL_WindowData *data = ((SDL_WindowData *)window->driverdata);
     const SDL_VideoData *videodata = data->videodata;
 
-    if (!videodata->dpi_scaling_enabled)
+    if (!videodata->dpi_scaling_enabled) {
         return;
+    }
     
     *x = MulDiv(*x, data->scaling_dpi, 96);
     *y = MulDiv(*y, data->scaling_dpi, 96);
diff --git a/src/video/winrt/SDL_winrtgamebar.cpp b/src/video/winrt/SDL_winrtgamebar.cpp
index 2b1235721..ae16092ff 100644
--- a/src/video/winrt/SDL_winrtgamebar.cpp
+++ b/src/video/winrt/SDL_winrtgamebar.cpp
@@ -121,7 +121,7 @@ WINRT_HandleGameBarIsInputRedirected_MainThread()
         return;
     }
     gameBar = WINRT_GetGameBar();
-    if (!gameBar) {
+    if (gameBar == NULL) {
         /* Shouldn't happen, but just in case... */
         return;
     }
@@ -175,11 +175,11 @@ WINRT_QuitGameBar(_THIS)
 {
     SDL_VideoData *driverdata;
     IGameBarStatics_ *gameBar;
-    if (!_this || !_this->driverdata) {
+    if (_this == NULL || _this->driverdata == NULL) {
         return;
     }
     gameBar = WINRT_GetGameBar();
-    if (!gameBar) {
+    if (gameBar == NULL) {
         return;
     }
     driverdata = (SDL_VideoData *)_this->driverdata;
diff --git a/src/video/winrt/SDL_winrtvideo.cpp b/src/video/winrt/SDL_winrtvideo.cpp
index 7511aa531..aae34b998 100644
--- a/src/video/winrt/SDL_winrtvideo.cpp
+++ b/src/video/winrt/SDL_winrtvideo.cpp
@@ -124,16 +124,16 @@ WINRT_CreateDevice(void)
 
     /* Initialize all variables that we clean on shutdown */
     device = (SDL_VideoDevice *) SDL_calloc(1, sizeof(SDL_VideoDevice));
-    if (!device) {
+    if (device == NULL) {
         SDL_OutOfMemory();
-        return (0);
+        return 0;
     }
 
     data = (SDL_VideoData *) SDL_calloc(1, sizeof(SDL_VideoData));
-    if (!data) {
+    if (data == NULL) {
         SDL_OutOfMemory();
         SDL_free(device);
-        return (0);
+        return 0;
     }
     device->driverdata = data;
 
@@ -351,7 +351,7 @@ WINRT_AddDisplaysForOutput (_THIS, IDXGIAdapter1 * dxgiAdapter1, int outputIndex
         }
 
         dxgiModes = (DXGI_MODE_DESC *)SDL_calloc(numModes, sizeof(DXGI_MODE_DESC));
-        if ( ! dxgiModes) {
+        if (dxgiModes == NULL) {
             SDL_OutOfMemory();
             goto done;
         }
@@ -613,7 +613,7 @@ WINRT_IsCoreWindowActive(CoreWindow ^ coreWindow)
     if (coreWindow->CustomProperties->HasKey("SDLHelperWindowActivationState")) {
         CoreWindowActivationState activationState = \
             safe_cast<CoreWindowActivationState>(coreWindow->CustomProperties->Lookup("SDLHelperWindowActivationState"));
-        return (activationState != CoreWindowActivationState::Deactivated);
+        return activationState != CoreWindowActivationState::Deactivated;
     }
 
     /* Assume that non-SDL tracked windows are active, although this should
diff --git a/src/video/x11/SDL_x11clipboard.c b/src/video/x11/SDL_x11clipboard.c
index fd198bd20..6bb6ef03a 100644
--- a/src/video/x11/SDL_x11clipboard.c
+++ b/src/video/x11/SDL_x11clipboard.c
@@ -217,7 +217,7 @@ GetSlectionText(_THIS, Atom selection_type)
         X11_XFree(src);
     }
 
-    if (!text) {
+    if (text == NULL) {
         text = SDL_strdup("");
     }
 
diff --git a/src/video/x11/SDL_x11dyn.c b/src/video/x11/SDL_x11dyn.c
index 3c6474a07..93747a537 100644
--- a/src/video/x11/SDL_x11dyn.c
+++ b/src/video/x11/SDL_x11dyn.c
@@ -78,8 +78,9 @@ X11_GetSym(const char *fnname, int *pHasModule)
     for (i = 0; i < SDL_TABLESIZE(x11libs); i++) {
         if (x11libs[i].lib != NULL) {
             fn = SDL_LoadFunction(x11libs[i].lib, fnname);
-            if (fn != NULL)
+            if (fn != NULL) {
                 break;
+            }
         }
     }
 
@@ -90,8 +91,9 @@ X11_GetSym(const char *fnname, int *pHasModule)
         printf("X11: Symbol '%s' NOT FOUND!\n", fnname);
 #endif
 
-    if (fn == NULL)
-        *pHasModule = 0;  /* kill this module. */
+    if (fn == NULL) {
+        *pHasModule = 0; /* kill this module. */
+    }
 
     return fn;
 }
diff --git a/src/video/x11/SDL_x11events.c b/src/video/x11/SDL_x11events.c
index 6b6b834b4..13188240f 100644
--- a/src/video/x11/SDL_x11events.c
+++ b/src/video/x11/SDL_x11events.c
@@ -100,7 +100,9 @@ static void X11_ReadProperty(SDL_x11Prop *p, Display *disp, Window w, Atom prop)
     int bytes_fetch = 0;
 
     do {
-        if (ret != NULL) X11_XFree(ret);
+        if (ret != NULL) {
+            X11_XFree(ret);
+        }
         X11_XGetWindowProperty(disp, w, prop, 0, bytes_fetch, False, AnyPropertyType, &type, &fmt, &count, &bytes_left, &ret);
         bytes_fetch += bytes_left;
     } while (bytes_left != 0);
@@ -134,9 +136,15 @@ static Atom X11_PickTargetFromAtoms(Display *disp, Atom a0, Atom a1, Atom a2)
 {
     int count=0;
     Atom atom[3];
-    if (a0 != None) atom[count++] = a0;
-    if (a1 != None) atom[count++] = a1;
-    if (a2 != None) atom[count++] = a2;
+    if (a0 != None) {
+        atom[count++] = a0;
+    }
+    if (a1 != None) {
+        atom[count++] = a1;
+    }
+    if (a2 != None) {
+        atom[count++] = a2;
+    }
     return X11_PickTarget(disp, atom, count);
 }
 
@@ -150,10 +158,9 @@ static Bool X11_KeyRepeatCheckIfEvent(Display *display, XEvent *chkev,
     XPointer arg)
 {
     struct KeyRepeatCheckData *d = (struct KeyRepeatCheckData *) arg;
-    if (chkev->type == KeyPress &&
-        chkev->xkey.keycode == d->event->xkey.keycode &&
-        chkev->xkey.time - d->event->xkey.time < 2)
+    if (chkev->type == KeyPress && chkev->xkey.keycode == d->event->xkey.keycode && chkev->xkey.time - d->event->xkey.time < 2) {
         d->found = SDL_TRUE;
+    }
     return False;
 }
 
@@ -166,9 +173,9 @@ static SDL_bool X11_KeyRepeat(Display *display, XEvent *event)
     struct KeyRepeatCheckData d;
     d.event = event;
     d.found = SDL_FALSE;
-    if (X11_XPending(display))
-        X11_XCheckIfEvent(display, &dummyev, X11_KeyRepeatCheckIfEvent,
-            (XPointer) &d);
+    if (X11_XPending(display)) {
+        X11_XCheckIfEvent(display, &dummyev, X11_KeyRepeatCheckIfEvent, (XPointer)&d);
+    }
     return d.found;
 }
 
@@ -270,8 +277,11 @@ static char* X11_URIToLocal(char* uri) {
     char *file = NULL;
     SDL_bool local;
 
-    if (SDL_memcmp(uri,"file:/",6) == 0) uri += 6;      /* local file? */
-    else if (SDL_strstr(uri,":/") != NULL) return file; /* wrong scheme */
+    if (SDL_memcmp(uri,"file:/",6) == 0) {
+        uri += 6;      /* local file? */
+    } else if (SDL_strstr(uri, ":/") != NULL) {
+        return file; /* wrong scheme */
+    }
 
     local = uri[0] != '/' || (uri[0] != '\0' && uri[1] == '/');
 
@@ -340,8 +350,8 @@ X11_GetNumLockModifierMask(_THIS)
 
     xmods = X11_XGetModifierMapping(display);
     n = xmods->max_keypermod;
-    for(i = 3; i < 8; i++) {
-        for(j = 0; j < n; j++) {
+    for (i = 3; i < 8; i++) {
+        for (j = 0; j < n; j++) {
             KeyCode kc = xmods->modifiermap[i * n + j];
             if (viddata->key_layout[kc] == SDL_SCANCODE_NUMLOCKCLEAR) {
                 num_mask = 1 << i;
@@ -366,8 +376,8 @@ X11_GetScrollLockModifierMask(_THIS)
 
     xmods = X11_XGetModifierMapping(display);
     n = xmods->max_keypermod;
-    for(i = 3; i < 8; i++) {
-        for(j = 0; j < n; j++) {
+    for (i = 3; i < 8; i++) {
+        for (j = 0; j < n; j++) {
             KeyCode kc = xmods->modifiermap[i * n + j];
             if (viddata->key_layout[kc] == SDL_SCANCODE_SCROLLLOCK) {
                 num_mask = 1 << i;
@@ -527,8 +537,9 @@ InitiateWindowResize(_THIS, const SDL_WindowData *data, const SDL_Point *point,
     Display *display = viddata->display;
     XEvent evt;
 
-    if (direction < _NET_WM_MOVERESIZE_SIZE_TOPLEFT || direction > _NET_WM_MOVERESIZE_SIZE_LEFT)
+    if (direction < _NET_WM_MOVERESIZE_SIZE_TOPLEFT || direction > _NET_WM_MOVERESIZE_SIZE_LEFT) {
         return;
+    }
 
     /* !!! FIXME: we need to regrab this if necessary when the drag is done. */
     X11_XUngrabPointer(display, 0L);
@@ -644,8 +655,9 @@ X11_HandleClipboardEvent(_THIS, const XEvent *xevent)
             if (req->target == XA_TARGETS) {
                 supportedFormats[0] = XA_TARGETS;
                 mime_formats = 1;
-                for (i = 0; i < SDL_X11_CLIPBOARD_MIME_TYPE_MAX; ++i)
+                for (i = 0; i < SDL_X11_CLIPBOARD_MIME_TYPE_MAX; ++i) {
                     supportedFormats[mime_formats++] = X11_GetSDLCutBufferClipboardExternalFormat(display, i);
+                }
                 X11_XChangeProperty(display, req->requestor, req->property,
                     XA_ATOM, 32, PropModeReplace,
                     (unsigned char*)supportedFormats,
@@ -654,8 +666,9 @@ X11_HandleClipboardEvent(_THIS, const XEvent *xevent)
                 sevent.xselection.target = XA_TARGETS;
             } else {
                 for (i = 0; i < SDL_X11_CLIPBOARD_MIME_TYPE_MAX; ++i) {
-                    if (X11_GetSDLCutBufferClipboardExternalFormat(display, i) != req->target)
+                    if (X11_GetSDLCutBufferClipboardExternalFormat(display, i) != req->target) {
                         continue;
+                    }
                     if (X11_XGetWindowProperty(display, DefaultRootWindow(display),
                         X11_GetSDLCutBufferClipboardType(display, i, req->selection), 0, INT_MAX/4, False, X11_GetSDLCutBufferClipboardInternalFormat(display, i),
                         &sevent.xselection.target, &seln_format, &nbytes,
@@ -796,7 +809,7 @@ X11_DispatchEvent(_THIS, XEvent *xevent)
     }
 
 #if SDL_VIDEO_DRIVER_X11_SUPPORTS_GENERIC_EVENTS
-    if(xevent->type == GenericEvent) {
+    if (xevent->type == GenericEvent) {
         X11_HandleGenericEvent(videodata, xevent);
         return;
     }
@@ -839,7 +852,7 @@ X11_DispatchEvent(_THIS, XEvent *xevent)
             }
         }
     }
-    if (!data) {
+    if (data == NULL) {
         /* The window for KeymapNotify, etc events is 0 */
         if (xevent->type == KeymapNotify) {
 #ifdef DEBUG_XEVENTS
@@ -884,7 +897,9 @@ X11_DispatchEvent(_THIS, XEvent *xevent)
                 }
             }
 
-            if (name_of_atom) X11_XFree(name_of_atom);
+            if (name_of_atom) {
+                X11_XFree(name_of_atom);
+            }
         }
         return;
     }
@@ -899,10 +914,12 @@ X11_DispatchEvent(_THIS, XEvent *xevent)
                    xevent->xcrossing.x,
                    xevent->xcrossing.y,
                    xevent->xcrossing.mode);
-            if (xevent->xcrossing.mode == NotifyGrab)
+            if (xevent->xcrossing.mode == NotifyGrab) {
                 printf("Mode: NotifyGrab\n");
-            if (xevent->xcrossing.mode == NotifyUngrab)
+            }
+            if (xevent->xcrossing.mode == NotifyUngrab) {
                 printf("Mode: NotifyUngrab\n");
+            }
 #endif
             SDL_SetMouseFocus(data->window);
 
@@ -934,10 +951,12 @@ X11_DispatchEvent(_THIS, XEvent *xevent)
                    xevent->xcrossing.x,
                    xevent->xcrossing.y,
                    xevent->xcrossing.mode);
-            if (xevent->xcrossing.mode == NotifyGrab)
+            if (xevent->xcrossing.mode == NotifyGrab) {
                 printf("Mode: NotifyGrab\n");
-            if (xevent->xcrossing.mode == NotifyUngrab)
+            }
+            if (xevent->xcrossing.mode == NotifyUngrab) {
                 printf("Mode: NotifyUngrab\n");
+            }
 #endif
             if (!SDL_GetMouse()->relative_mode) {
                 SDL_SendMouseMotion(data->window, 0, 0, xevent->xcrossing.x, xevent->xcrossing.y);
@@ -977,14 +996,11 @@ X11_DispatchEvent(_THIS, XEvent *xevent)
 #ifdef DEBUG_XEVENTS
             printf("window %p: FocusIn!\n", data);
 #endif
-            if (!videodata->last_mode_change_deadline) /* no recent mode changes */
-            {
+            if (!videodata->last_mode_change_deadline) /* no recent mode changes */ {
                 data->pending_focus = PENDING_FOCUS_NONE;
                 data->pending_focus_time = 0;
                 X11_DispatchFocusIn(_this, data);
-            }
-            else
-            {
+            } else {
                 data->pending_focus = PENDING_FOCUS_IN;
                 data->pending_focus_time = SDL_GetTicks() + PENDING_FOCUS_TIME;
             }
@@ -1013,14 +1029,11 @@ X11_DispatchEvent(_THIS, XEvent *xevent)
 #ifdef DEBUG_XEVENTS
             printf("window %p: FocusOut!\n", data);
 #endif
-            if (!videodata->last_mode_change_deadline) /* no recent mode changes */
-            {
+            if (!videodata->last_mode_change_deadline) /* no recent mode changes */ {
                 data->pending_focus = PENDING_FOCUS_NONE;
                 data->pending_focus_time = 0;
                 X11_DispatchFocusOut(_this, data);
-            }
-            else
-            {
+            } else {
                 data->pending_focus = PENDING_FOCUS_OUT;
                 data->pending_focus_time = SDL_GetTicks() + PENDING_FOCUS_TIME;
             }
@@ -1070,7 +1083,7 @@ X11_DispatchEvent(_THIS, XEvent *xevent)
 #endif
 
 #ifdef SDL_USE_IME
-            if(SDL_GetEventState(SDL_TEXTINPUT) == SDL_ENABLE){
+            if (SDL_GetEventState(SDL_TEXTINPUT) == SDL_ENABLE) {
                 handled_by_ime = SDL_IME_ProcessKeyEvent(keysym, keycode, (xevent->type == KeyPress ? SDL_PRESSED : SDL_RELEASED));
             }
 #endif
@@ -1163,7 +1176,7 @@ X11_DispatchEvent(_THIS, XEvent *xevent)
                 SDL_SendWindowEvent(data->window, SDL_WINDOWEVENT_MOVED,
                                     xevent->xconfigure.x, xevent->xconfigure.y);
 #ifdef SDL_USE_IME
-                if(SDL_GetEventState(SDL_TEXTINPUT) == SDL_ENABLE){
+                if (SDL_GetEventState(SDL_TEXTINPUT) == SDL_ENABLE) {
                     /* Update IME candidate list position */
                     SDL_IME_UpdateTextRect(NULL);
                 }
@@ -1206,12 +1219,11 @@ X11_DispatchEvent(_THIS, XEvent *xevent)
                     /* pick from list of three */
                     data->xdnd_req = X11_PickTargetFromAtoms(display, xevent->xclient.data.l[2], xevent->xclient.data.l[3], xevent->xclient.data.l[4]);
                 }
-            }
-            else if (xevent->xclient.message_type == videodata->XdndPosition) {
+            } else if (xevent->xclient.message_type == videodata->XdndPosition) {
 
 #ifdef DEBUG_XEVENTS
                 Atom act= videodata->XdndActionCopy;
-                if(xdnd_version >= 2) {
+                if (xdnd_version >= 2) {
                     act = xevent->xclient.data.l[4];
                 }
                 printf("Action requested by user is : %s\n", X11_XGetAtomName(display , act));
@@ -1233,8 +1245,7 @@ X11_DispatchEvent(_THIS, XEvent *xevent)
 
                 X11_XSendEvent(display, xevent->xclient.data.l[0], False, NoEventMask, (XEvent*)&m);
                 X11_XFlush(display);
-            }
-            else if(xevent->xclient.message_type == videodata->XdndDrop) {
+            } else if (xevent->xclient.message_type == videodata->XdndDrop) {
                 if (data->xdnd_req == None) {
                     /* say again - not interested! */
                     SDL_memset(&m, 0, sizeof(XClientMessageEvent));
@@ -1249,14 +1260,13 @@ X11_DispatchEvent(_THIS, XEvent *xevent)
                     X11_XSendEvent(display, xevent->xclient.data.l[0], False, NoEventMask, (XEvent*)&m);
                 } else {
                     /* convert */
-                    if(xdnd_version >= 1) {
+                    if (xdnd_version >= 1) {
                         X11_XConvertSelection(display, videodata->XdndSelection, data->xdnd_req, videodata->PRIMARY, data->xwindow, xevent->xclient.data.l[2]);
                     } else {
                         X11_XConvertSelection(display, videodata->XdndSelection, data->xdnd_req, videodata->PRIMARY, data->xwindow, CurrentTime);
                     }
                 }
-            }
-            else if ((xevent->xclient.message_type == videodata->WM_PROTOCOLS) &&
+            } else if ((xevent->xclient.message_type == videodata->WM_PROTOCOLS) &&
                 (xevent->xclient.format == 32) &&
                 (xevent->xclient.data.l[0] == videodata->_NET_WM_PING)) {
                 Window root = DefaultRootWindow(display);
@@ -1278,8 +1288,7 @@ X11_DispatchEvent(_THIS, XEvent *xevent)
 #endif
                 SDL_SendWindowEvent(data->window, SDL_WINDOWEVENT_CLOSE, 0, 0);
                 break;
-            }
-            else if ((xevent->xclient.message_type == videodata->WM_PROTOCOLS) &&
+            } else if ((xevent->xclient.message_type == videodata->WM_PROTOCOLS) &&
                 (xevent->xclient.format == 32) &&
                 (xevent->xclient.data.l[0] == videodata->WM_TAKE_FOCUS)) {
 
@@ -1303,7 +1312,7 @@ X11_DispatchEvent(_THIS, XEvent *xevent)
 
     case MotionNotify:{
             SDL_Mouse *mouse = SDL_GetMouse();
-            if(!mouse->relative_mode || mouse->relative_mode_warp) {
+            if (!mouse->relative_mode || mouse->relative_mode_warp) {
 #ifdef DEBUG_MOTION
                 printf("window %p: X11 motion: %d,%d\n", data, xevent->xmotion.x, xevent->xmotion.y);
 #endif
@@ -1323,13 +1332,12 @@ X11_DispatchEvent(_THIS, XEvent *xevent)
             } else {
                 SDL_bool ignore_click = SDL_FALSE;
                 int button = xevent->xbutton.button;
-                if(button == Button1) {
+                if (button == Button1) {
                     if (ProcessHitTest(_this, data, xevent)) {
                         SDL_SendWindowEvent(data->window, SDL_WINDOWEVENT_HIT_TEST, 0, 0);
                         break;  /* don't pass this event on to app. */
                     }
-                }
-                else if(button > 7) {
+                } else if (button > 7) {
                     /* X button values 4-7 are used for scrolling, so X1 is 8, X2 is 9, ...
                        => subtract (8-SDL_BUTTON_X1) to get value SDL expects */
                     button -= (8-SDL_BUTTON_X1);
@@ -1672,7 +1680,7 @@ X11_WaitEventTimeout(_THIS, int timeout)
     X11_DispatchEvent(_this, &xevent);
 
 #ifdef SDL_USE_IME
-    if(SDL_GetEventState(SDL_TEXTINPUT) == SDL_ENABLE){
+    if (SDL_GetEventState(SDL_TEXTINPUT) == SDL_ENABLE) {
         SDL_IME_PumpEvents();
     }
 #endif
@@ -1715,7 +1723,7 @@ X11_PumpEvents(_THIS)
     }
 
 #ifdef SDL_USE_IME
-    if(SDL_GetEventState(SDL_TEXTINPUT) == SDL_ENABLE){
+    if (SDL_GetEventState(SDL_TEXTINPUT) == SDL_ENABLE) {
         SDL_IME_PumpEvents();
     }
 #endif
diff --git a/src/video/x11/SDL_x11framebuffer.c b/src/video/x11/SDL_x11framebuffer.c
index 123ad8ffb..b98d27e93 100644
--- a/src/video/x11/SDL_x11framebuffer.c
+++ b/src/video/x11/SDL_x11framebuffer.c
@@ -35,9 +35,9 @@ static int shm_errhandler(Display *d, XErrorEvent *e)
 {
         if ( e->error_code == BadAccess ) {
             shm_error = True;
-            return(0);
+            return 0;
         } else
-        return(X_handler(d,e));
+        return X_handler(d, e);
 }
 
 static SDL_bool have_mitshm(Display *dpy)
@@ -95,8 +95,9 @@ X11_CreateWindowFramebuffer(_THIS, SDL_Window * window, Uint32 * format,
                 X11_XShmAttach(display, shminfo);
                 X11_XSync(display, False);
                 X11_XSetErrorHandler(X_handler);
-                if ( shm_error )
+                if (shm_error) {
                     shmdt(shminfo->shmaddr);
+                }
             } else {
                 shm_error = True;
             }
@@ -160,26 +161,25 @@ X11_UpdateWindowFramebuffer(_THIS, SDL_Window * window, const SDL_Rect * rects,
                 /* Clipped? */
                 continue;
             }
-            if (x < 0)
-            {
+            if (x < 0) {
                 x += w;
                 w += rects[i].x;
             }
-            if (y < 0)
-            {
+            if (y < 0) {
                 y += h;
                 h += rects[i].y;
             }
-            if (x + w > window->w)
+            if (x + w > window->w) {
                 w = window->w - x;
-            if (y + h > window->h)
+            }
+            if (y + h > window->h) {
                 h = window->h - y;
+            }
 
             X11_XShmPutImage(display, data->xwindow, data->gc, data->ximage,
                 x, y, x, y, w, h, False);
         }
-    }
-    else
+    } else
 #endif /* !NO_SHARED_MEMORY */
     {
         for (i = 0; i < numrects; ++i) {
@@ -192,20 +192,20 @@ X11_UpdateWindowFramebuffer(_THIS, SDL_Window * window, const SDL_Rect * rects,
                 /* Clipped? */
                 continue;
             }
-            if (x < 0)
-            {
+            if (x < 0) {
                 x += w;
                 w += rects[i].x;
             }
-            if (y < 0)
-            {
+            if (y < 0) {
                 y += h;
                 h += rects[i].y;
             }
-            if (x + w > window->w)
+            if (x + w > window->w) {
                 w = window->w - x;
-            if (y + h > window->h)
+            }
+            if (y + h > window->h) {
                 h = window->h - y;
+            }
 
             X11_XPutImage(display, data->xwindow, data->gc, data->ximage,
                 x, y, x, y, w, h);
@@ -223,7 +223,7 @@ X11_DestroyWindowFramebuffer(_THIS, SDL_Window * window)
     SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
     Display *display;
 
-    if (!data) {
+    if (data == NULL) {
         /* The window wasn't fully initialized */
         return;
     }
diff --git a/src/video/x11/SDL_x11keyboard.c b/src/video/x11/SDL_x11keyboard.c
index bad202964..edc0147e5 100644
--- a/src/video/x11/SDL_x11keyboard.c
+++ b/src/video/x11/SDL_x11keyboard.c
@@ -434,7 +434,7 @@ X11_StopTextInput(_THIS)
 void
 X11_SetTextInputRect(_THIS, const SDL_Rect *rect)
 {
-    if (!rect) {
+    if (rect == NULL) {
         SDL_InvalidParamError("rect");
         return;
     }
diff --git a/src/video/x11/SDL_x11messagebox.c b/src/video/x11/SDL_x11messagebox.c
index 9bc9702c0..f7e917059 100644
--- a/src/video/x11/SDL_x11messagebox.c
+++ b/src/video/x11/SDL_x11messagebox.c
@@ -250,7 +250,7 @@ X11_MessageBoxInitPositions( SDL_MessageBoxDataX11 *data )
         const int linecount = CountLinesOfText(text);
         TextLineData *plinedata = (TextLineData *) SDL_malloc(sizeof (TextLineData) * linecount);
 
-        if (!plinedata) {
+        if (plinedata == NULL) {
             return SDL_OutOfMemory();
         }
 
@@ -278,8 +278,9 @@ X11_MessageBoxInitPositions( SDL_MessageBoxDataX11 *data )
             text += length + 1;
 
             /* Break if there are no more linefeeds. */
-            if ( !lf )
+            if (lf == NULL) {
                 break;
+            }
         }
 
         /* Bump up the text height slightly. */
@@ -632,7 +633,7 @@ X11_MessageBoxLoop( SDL_MessageBoxDataX11 *data )
     data->button_press_index = -1;  /* Reset what button is currently depressed. */
     data->mouse_over_index = -1;    /* Reset what button the mouse is over. */
 
-    while( !close_dialog ) {
+    while ( !close_dialog ) {
         XEvent e;
         SDL_bool draw = SDL_TRUE;
 
@@ -642,8 +643,9 @@ X11_MessageBoxLoop( SDL_MessageBoxDataX11 *data )
 
         /* If X11_XFilterEvent returns True, then some input method has filtered the
            event, and the client should discard the event. */
-        if ( ( e.type != Expose ) && X11_XFilterEvent( &e, None ) )
+        if ((e.type != Expose) && X11_XFilterEvent(&e, None)) {
             continue;
+        }
 
         switch( e.type ) {
         case Expose:
@@ -693,13 +695,15 @@ X11_MessageBoxLoop( SDL_MessageBoxDataX11 *data )
             KeySym key = X11_XLookupKeysym( &e.xkey, 0 );
 
             /* If this is a key release for something we didn't get the key down for, then bail. */
-            if ( key != last_key_pressed )
+            if (key != last_key_pressed) {
                 break;
+            }
 
-            if ( key == XK_Escape )
+            if ( key == XK_Escape ) {
                 mask = SDL_MESSAGEBOX_BUTTON_ESCAPEKEY_DEFAULT;
-            else if ( ( key == XK_Return ) || ( key == XK_KP_Enter ) )
+            } else if ((key == XK_Return) || (key == XK_KP_Enter)) {
                 mask = SDL_MESSAGEBOX_BUTTON_RETURNKEY_DEFAULT;
+            }
 
             if ( mask ) {
                 int i;
@@ -763,8 +767,9 @@ X11_ShowMessageBoxImpl(const SDL_MessageBoxData *messageboxdata, int *buttonid)
 
     SDL_zero(data);
 
-    if ( !SDL_X11_LoadSymbols() )
+    if (!SDL_X11_LoadSymbols()) {
         return -1;
+    }
 
 #if SDL_SET_LOCALE
     origlocale = setlocale(LC_ALL, NULL);
diff --git a/src/video/x11/SDL_x11modes.c b/src/video/x11/SDL_x11modes.c
index da63afdcb..ce7c21897 100644
--- a/src/video/x11/SDL_x11modes.c
+++ b/src/video/x11/SDL_x11modes.c
@@ -333,7 +333,7 @@ X11_AddXRandRDisplay(_THIS, Display *dpy, int screen, RROutput outputid, XRRScre
     }
 
     output_info = X11_XRRGetOutputInfo(dpy, res, outputid);
-    if (!output_info || !output_info->crtc || output_info->connection == RR_Disconnected) {
+    if (output_info == NULL || !output_info->crtc || output_info->connection == RR_Disconnected) {
         X11_XRRFreeOutputInfo(output_info);
         return 0;  /* ignore this one. */
     }
@@ -345,7 +345,7 @@ X11_AddXRandRDisplay(_THIS, Display *dpy, int screen, RROutput outputid, XRRScre
     X11_XRRFreeOutputInfo(output_info);
 
     crtc = X11_XRRGetCrtcInfo(dpy, res, output_crtc);
-    if (!crtc) {
+    if (crtc == NULL) {
         return 0;  /* oh well, ignore it. */
     }
 
@@ -361,12 +361,12 @@ X11_AddXRandRDisplay(_THIS, Display *dpy, int screen, RROutput outputid, XRRScre
     X11_XRRFreeCrtcInfo(crtc);
 
     displaydata = (SDL_DisplayData *) SDL_calloc(1, sizeof(*displaydata));
-    if (!displaydata) {
+    if (displaydata == NULL) {
         return SDL_OutOfMemory();
     }
 
     modedata = (SDL_DisplayModeData *) SDL_calloc(1, sizeof(SDL_DisplayModeData));
-    if (!modedata) {
+    if (modedata == NULL) {
         SDL_free(displaydata);
         return SDL_OutOfMemory();
     }
@@ -436,7 +436,7 @@ X11_HandleXRandROutputChange(_THIS, const XRROutputChangeNotifyEvent *ev)
             XVisualInfo vinfo;
             if (get_visualinfo(dpy, screen, &vinfo) == 0) {
                 XRRScreenResources *res = X11_XRRGetScreenResourcesCurrent(dpy, RootWindow(dpy, screen));
-                if (!res || res->noutput == 0) {
+                if (res == NULL || res->noutput == 0) {
                     if (res) {
                         X11_XRRFreeScreenResources(res);
                     }
@@ -495,13 +495,13 @@ X11_InitModes_XRandR(_THIS)
             }
 
             res = X11_XRRGetScreenResourcesCurrent(dpy, RootWindow(dpy, screen));
-            if (!res || res->noutput == 0) {
+            if (res == NULL || res->noutput == 0) {
                 if (res) {
                     X11_XRRFreeScreenResources(res);
                 }
 
                 res = X11_XRRGetScreenResources(dpy, RootWindow(dpy, screen));
-                if (!res) {
+                if (res == NULL) {
                     continue;
                 }
             }
@@ -540,7 +540,7 @@ GetXftDPI(Display* dpy)
 
     xdefault_resource = X11_XGetDefault(dpy, "Xft", "dpi");
 
-    if(!xdefault_resource) {
+    if (xdefault_resource == NULL) {
         return 0;
     }
 
@@ -593,12 +593,12 @@ static int X11_InitModes_StdXlib(_THIS)
     mode.refresh_rate = 0;  /* don't know it, sorry. */
 
     displaydata = (SDL_DisplayData *) SDL_calloc(1, sizeof(*displaydata));
-    if (!displaydata) {
+    if (displaydata == NULL) {
         return SDL_OutOfMemory();
     }
 
     modedata = (SDL_DisplayModeData *) SDL_calloc(1, sizeof(SDL_DisplayModeData));
-    if (!modedata) {
+    if (modedata == NULL) {
         SDL_free(displaydata);
         return SDL_OutOfMemory();
     }
@@ -615,7 +615,7 @@ static int X11_InitModes_StdXlib(_THIS)
     displaydata->ddpi = SDL_ComputeDiagonalDPI(mode.w, mode.h, ((float) display_mm_width) / 25.4f,((float) display_mm_height) / 25.4f);
 
     xft_dpi = GetXftDPI(dpy);
-    if(xft_dpi > 0) {
+    if (xft_dpi > 0) {
         displaydata->hdpi = (float)xft_dpi;
         displaydata->vdpi = (float)xft_dpi;
     }
@@ -700,7 +700,7 @@ X11_GetDisplayModes(_THIS, SDL_VideoDisplay * sdl_display)
             if (output_info && output_info->connection != RR_Disconnected) {
                 for (i = 0; i < output_info->nmode; ++i) {
                     modedata = (SDL_DisplayModeData *) SDL_calloc(1, sizeof(SDL_DisplayModeData));
-                    if (!modedata) {
+                    if (modedata == NULL) {
                         continue;
                     }
                     mode.driverdata = modedata;
@@ -769,18 +769,18 @@ X11_SetDisplayMode(_THIS, SDL_VideoDisplay * sdl_display, SDL_DisplayMode * mode
         Status status;
 
         res = X11_XRRGetScreenResources (display, RootWindow(display, data->screen));
-        if (!res) {
+        if (res == NULL) {
             return SDL_SetError("Couldn't get XRandR screen resources");
         }
 
         output_info = X11_XRRGetOutputInfo(display, res, data->xrandr_output);
-        if (!output_info || output_info->connection == RR_Disconnected) {
+        if (output_info == NULL || output_info->connection == RR_Disconnected) {
             X11_XRRFreeScreenResources(res);
             return SDL_SetError("Couldn't get XRandR output info");
         }
 
         crtc = X11_XRRGetCrtcInfo(display, res, output_info->crtc);
-        if (!crtc) {
+        if (crtc == NULL) {
             X11_XRRFreeOutputInfo(output_info);
             X11_XRRFreeScreenResources(res);
             return SDL_SetError("Couldn't get XRandR crtc info");
diff --git a/src/video/x11/SDL_x11mouse.c b/src/video/x11/SDL_x11mouse.c
index 96a25a2b9..2e6dd07f7 100644
--- a/src/video/x11/SDL_x11mouse.c
+++ b/src/video/x11/SDL_x11mouse.c
@@ -94,7 +94,7 @@ X11_CreateXCursorCursor(SDL_Surface * surface, int hot_x, int hot_y)
     XcursorImage *image;
 
     image = X11_XcursorImageCreate(surface->w, surface->h);
-    if (!image) {
+    if (image == NULL) {
         SDL_OutOfMemory();
         return None;
     }
@@ -128,13 +128,13 @@ X11_CreatePixmapCursor(SDL_Surface * surface, int hot_x, int hot_y)
     unsigned int width_bytes = ((surface->w + 7) & ~7) / 8;
 
     data_bits = SDL_calloc(1, surface->h * width_bytes);
-    if (!data_bits) {
+    if (data_bits == NULL) {
         SDL_OutOfMemory();
         return None;
     }
 
     mask_bits = SDL_calloc(1, surface->h * width_bytes);
-    if (!mask_bits) {
+    if (mask_bits == NULL) {
         SDL_free(data_bits);
         SDL_OutOfMemory();
         return None;
@@ -175,15 +175,13 @@ X11_CreatePixmapCursor(SDL_Surface * surface, int hot_x, int hot_y)
         fg.red   = rfg * 257 / fgBits;
         fg.green = gfg * 257 / fgBits;
         fg.blue  = bfg * 257 / fgBits;
-    }
-    else fg.red = fg.green = fg.blue = 0;
+    } else fg.red = fg.green = fg.blue = 0;
 
     if (bgBits) {
         bg.red   = rbg * 257 / bgBits;
         bg.green = gbg * 257 / bgBits;
         bg.blue  = bbg * 257 / bgBits;
-    }
-    else bg.red = bg.green = bg.blue = 0;
+    } else bg.red = bg.green = bg.blue = 0;
 
     data_pixmap = X11_XCreateBitmapFromData(display, DefaultRootWindow(display),
                                         (char*)data_bits,
@@ -360,8 +358,9 @@ static int
 X11_SetRelativeMouseMode(SDL_bool enabled)
 {
 #if SDL_VIDEO_DRIVER_X11_XINPUT2
-    if(X11_Xinput2IsInitialized())
+    if (X11_Xinput2IsInitialized()) {
         return 0;
+    }
 #else
     SDL_Unsupported();
 #endif
diff --git a/src/video/x11/SDL_x11opengl.c b/src/video/x11/SDL_x11opengl.c
index 60b2203cd..aafaa2fb4 100644
--- a/src/video/x11/SDL_x11opengl.c
+++ b/src/video/x11/SDL_x11opengl.c
@@ -307,13 +307,15 @@ HasExtension(const char *extension, const char *extensions)
     const char *start;
     const char *where, *terminator;
 
-    if (!extensions)
+    if (!extensions) {
         return SDL_FALSE;
+    }
 
     /* Extension names should not have spaces. */
     where = SDL_strchr(extension, ' ');
-    if (where || *extension == '\0')
+    if (where || *extension == '\0') {
         return SDL_FALSE;
+    }
 
     /* It takes a bit of care to be fool-proof about parsing the
      * OpenGL extensions string. Don't be fooled by sub-strings,
@@ -323,13 +325,16 @@ HasExtension(const char *extension, const char *extensions)
 
     for (;;) {
         where = SDL_strstr(start, extension);
-        if (!where)
+        if (!where) {
             break;
+        }
 
         terminator = where + SDL_strlen(extension);
-        if (where == start || *(where - 1) == ' ')
-            if (*terminator == ' ' || *terminator == '\0')
+        if (where == start || *(where - 1) == ' ') {
+            if (*terminator == ' ' || *terminator == '\0') {
                 return SDL_TRUE;
+            }
+        }
 
         start = terminator;
     }
@@ -500,7 +505,7 @@ X11_GL_GetAttributes(_THIS, Display * display, int screen, int * attribs, int si
     SDL_assert(size >= MAX_ATTRIBUTES);
 
     /* Setup our GLX attributes according to the gl_config. */
-    if( for_FBConfig ) {
+    if ( for_FBConfig ) {
         attribs[i++] = GLX_RENDER_TYPE;
         if (_this->gl_config.floatbuffers) {
             attribs[i++] = GLX_RGBA_FLOAT_BIT_ARB;
@@ -524,7 +529,7 @@ X11_GL_GetAttributes(_THIS, Display * display, int screen, int * attribs, int si
 
     if (_this->gl_config.double_buffer) {
         attribs[i++] = GLX_DOUBLEBUFFER;
-        if( for_FBConfig ) {
+        if ( for_FBConfig ) {
             attribs[i++] = True;
         }
     }
@@ -559,7 +564,7 @@ X11_GL_GetAttributes(_THIS, Display * display, int screen, int * attribs, int si
 
     if (_this->gl_config.stereo) {
         attribs[i++] = GLX_STEREO;
-        if( for_FBConfig ) {
+        if ( for_FBConfig ) {
             attribs[i++] = True;
         }
     }
@@ -669,18 +674,14 @@ X11_GL_ErrorHandler(Display * d, XErrorEvent * e)
     char x11_error_locale[256];
 
     errorCode = e->error_code;
-    if (X11_XGetErrorText(d, errorCode, x11_error_locale, sizeof(x11_error_locale)) == Success)
-    {
+    if (X11_XGetErrorText(d, errorCode, x11_error_locale, sizeof(x11_error_locale)) == Success) {
         x11_error = SDL_iconv_string("UTF-8", "", x11_error_locale, SDL_strlen(x11_error_locale)+1);
     }
 
-    if (x11_error)
-    {
+    if (x11_error) {
         SDL_SetError("Could not %s: %s", errorHandlerOperation, x11_error);
         SDL_free(x11_error);
-    }
-    else
-    {
+    } else {
         SDL_SetError("Could not %s: %i (Base %i)", errorHandlerOperation, errorCode, errorBase);
     }
 
@@ -752,19 +753,19 @@ X11_GL_CreateContext(_THIS, SDL_Window * window)
             int iattr = 4;
 
             /* SDL profile bits match GLX profile bits */
-            if( _this->gl_config.profile_mask != 0 ) {
+            if ( _this->gl_config.profile_mask != 0 ) {
                 attribs[iattr++] = GLX_CONTEXT_PROFILE_MASK_ARB;
                 attribs[iattr++] = _this->gl_config.profile_mask;
             }
 
             /* SDL flags match GLX flags */
-            if( _this->gl_config.flags != 0 ) {
+            if ( _this->gl_config.flags != 0 ) {
                 attribs[iattr++] = GLX_CONTEXT_FLAGS_ARB;
                 attribs[iattr++] = _this->gl_config.flags;
             }
 
             /* only set if glx extension is available */
-            if( _this->gl_data->HAS_GLX_ARB_context_flush_control ) {
+            if ( _this->gl_data->HAS_GLX_ARB_context_flush_control ) {
                 attribs[iattr++] = GLX_CONTEXT_RELEASE_BEHAVIOR_ARB;
                 attribs[iattr++] = 
                     _this->gl_config.release_behavior ? 
@@ -773,7 +774,7 @@ X11_GL_CreateContext(_THIS, SDL_Window * window)
             }
 
             /* only set if glx extension is available */
-            if( _this->gl_data->HAS_GLX_ARB_create_context_robustness ) {
+            if ( _this->gl_data->HAS_GLX_ARB_create_context_robustness ) {
                 attribs[iattr++] = GLX_CONTEXT_RESET_NOTIFICATION_STRATEGY_ARB;
                 attribs[iattr++] =
                     _this->gl_config.reset_notification ?
@@ -782,7 +783,7 @@ X11_GL_CreateContext(_THIS, SDL_Window * window)
             }
 
             /* only set if glx extension is available */
-            if( _this->gl_data->HAS_GLX_ARB_create_context_no_error ) {
+            if ( _this->gl_data->HAS_GLX_ARB_create_context_no_error ) {
                 attribs[iattr++] = GLX_CONTEXT_OPENGL_NO_ERROR_ARB;
                 attribs[iattr++] = _this->gl_config.no_error;
             }
diff --git a/src/video/x11/SDL_x11shape.c b/src/video/x11/SDL_x11shape.c
index 7d4e32c22..fe288454e 100644
--- a/src/video/x11/SDL_x11shape.c
+++ b/src/video/x11/SDL_x11shape.c
@@ -35,7 +35,7 @@ X11_CreateShaper(SDL_Window* window) {
 #if SDL_VIDEO_DRIVER_X11_XSHAPE
     if (SDL_X11_HAVE_XSHAPE) {  /* Make sure X server supports it. */
         result = SDL_malloc(sizeof(SDL_WindowShaper));
-        if (!result) {
+        if (result == NULL) {
             SDL_OutOfMemory();
             return NULL;
         }
@@ -44,7 +44,7 @@ X11_CreateShaper(SDL_Window* window) {
         result->mode.parameters.binarizationCutoff = 1;
         result->userx = result->usery = 0;
         data = SDL_malloc(sizeof(SDL_ShapeData));
-        if (!data) {
+        if (data == NULL) {
             SDL_free(result);
             SDL_OutOfMemory();
             return NULL;
@@ -71,14 +71,15 @@ X11_ResizeWindowShape(SDL_Window* window) {
     unsigned int bitmapsize = window->w / 8;
     SDL_assert(data != NULL);
 
-    if(window->w % 8 > 0)
+    if (window->w % 8 > 0) {
         bitmapsize += 1;
+    }
     bitmapsize *= window->h;
-    if(data->bitmapsize != bitmapsize || data->bitmap == NULL) {
+    if (data->bitmapsize != bitmapsize || data->bitmap == NULL) {
         data->bitmapsize = bitmapsize;
         SDL_free(data->bitmap);
         data->bitmap = SDL_malloc(data->bitmapsize);
-        if(data->bitmap == NULL) {
+        if (data->bitmap == NULL) {
             return SDL_OutOfMemory();
         }
     }
@@ -97,14 +98,17 @@ X11_SetWindowShape(SDL_WindowShaper *shaper,SDL_Surface *shape,SDL_WindowShapeMo
     SDL_WindowData *windowdata = NULL;
     Pixmap shapemask;
     
-    if(shaper == NULL || shape == NULL || shaper->driverdata == NULL)
+    if (shaper == NULL || shape == NULL || shaper->driverdata == NULL) {
         return -1;
+    }
 
 #if SDL_VIDEO_DRIVER_X11_XSHAPE
-    if(shape->format->Amask == 0 && SDL_SHAPEMODEALPHA(shape_mode->mode))
+    if (shape->format->Amask == 0 && SDL_SHAPEMODEALPHA(shape_mode->mode)) {
         return -2;
-    if(shape->w != shaper->window->w || shape->h != shaper->window->h)
+    }
+    if (shape->w != shaper->window->w || shape->h != shaper->window->h) {
         return -3;
+    }
     data = shaper->driverdata;
 
     /* Assume that shaper->alphacutoff already has a value, because SDL_SetWindowShape() should have given it one. */
diff --git a/src/video/x11/SDL_x11video.c b/src/video/x11/SDL_x11video.c
index 49f5c5b9b..42d3f9e5e 100644
--- a/src/video/x11/SDL_x11video.c
+++ b/src/video/x11/SDL_x11video.c
@@ -167,19 +167,19 @@ X11_CreateDevice(void)
     /* Open the display first to be sure that X11 is available */
     x11_display = X11_XOpenDisplay(display);
 
-    if (!x11_display) {
+    if (x11_display == NULL) {
         SDL_X11_UnloadSymbols();
         return NULL;
     }
 
     /* Initialize all variables that we clean on shutdown */
     device = (SDL_VideoDevice *) SDL_calloc(1, sizeof(SDL_VideoDevice));
-    if (!device) {
+    if (device == NULL) {
         SDL_OutOfMemory();
         return NULL;
     }
     data = (struct SDL_VideoData *) SDL_calloc(1, sizeof(SDL_VideoData));
-    if (!data) {
+    if (data == NULL) {
         SDL_free(device);
         SDL_OutOfMemory();
         return NULL;
@@ -339,9 +339,9 @@ static int
 X11_CheckWindowManagerErrorHandler(Display * d, XErrorEvent * e)
 {
     if (e->error_code == BadWindow) {
-        return (0);
+        return 0;
     } else {
-        return (handler(d, e));
+        return handler(d, e);
     }
 }
 
diff --git a/src/video/x11/SDL_x11vulkan.c b/src/video/x11/SDL_x11vulkan.c
index b9eb34b88..2bdce9821 100644
--- a/src/video/x11/SDL_x11vulkan.c
+++ b/src/video/x11/SDL_x11vulkan.c
@@ -51,73 +51,76 @@ int X11_Vulkan_LoadLibrary(_THIS, const char *path)
     SDL_bool hasXCBSurfaceExtension = SDL_FALSE;
     PFN_vkGetInstanceProcAddr vkGetInstanceProcAddr = NULL;
     Uint32 i;
-    if(_this->vulkan_config.loader_handle)
+    if (_this->vulkan_config.loader_handle) {
         return SDL_SetError("Vulkan already loaded");
+    }
 
     /* Load the Vulkan loader library */
-    if(!path)
+    if (path == NULL) {
         path = SDL_getenv("SDL_VULKAN_LIBRARY");
-    if(!path)
+    }
+    if (path == NULL) {
         path = DEFAULT_VULKAN;
+    }
     _this->vulkan_config.loader_handle = SDL_LoadObject(path);
-    if(!_this->vulkan_config.loader_handle)
+    if (!_this->vulkan_config.loader_handle) {
         return -1;
+    }
     SDL_strlcpy(_this->vulkan_config.loader_path, path, SDL_arraysize(_this->vulkan_config.loader_path));
     vkGetInstanceProcAddr = (PFN_vkGetInstanceProcAddr)SDL_LoadFunction(
         _this->vulkan_config.loader_handle, "vkGetInstanceProcAddr");
-    if(!vkGetInstanceProcAddr)
+    if (!vkGetInstanceProcAddr) {
         goto fail;
+    }
     _this->vulkan_config.vkGetInstanceProcAddr = (void *)vkGetInstanceProcAddr;
     _this->vulkan_config.vkEnumerateInstanceExtensionProperties =
         (void *)((PFN_vkGetInstanceProcAddr)_this->vulkan_config.vkGetInstanceProcAddr)(
             VK_NULL_HANDLE, "vkEnumerateInstanceExtensionProperties");
-    if(!_this->vulkan_config.vkEnumerateInstanceExtensionProperties)
+    if (!_this->vulkan_config.vkEnumerateInstanceExtensionProperties) {
         goto fail;
+    }
     extensions = SDL_Vulkan_CreateInstanceExtensionsList(
         (PFN_vkEnumerateInstanceExtensionProperties)
             _this->vulkan_config.vkEnumerateInstanceExtensionProperties,
         &extensionCount);
-    if(!extensions)
+    if (extensions == NULL) {
         goto fail;
-    for(i = 0; i < extensionCount; i++)
+    }
+    for (i = 0; i < extensionCount; i++)
     {
-        if(SDL_strcmp(VK_KHR_SURFACE_EXTENSION_NAME, extensions[i].extensionName) == 0)
+        if (SDL_strcmp(VK_KHR_SURFACE_EXTENSION_NAME, extensions[i].extensionName) == 0) {
             hasSurfaceExtension = SDL_TRUE;
-        else if(SDL_strcmp(VK_KHR_XCB_SURFACE_EXTENSION_NAME, extensions[i].extensionName) == 0)
+        } else if (SDL_strcmp(VK_KHR_XCB_SURFACE_EXTENSION_NAME, extensions[i].extensionName) == 0) {
             hasXCBSurfaceExtension = SDL_TRUE;
-        else if(SDL_strcmp(VK_KHR_XLIB_SURFACE_EXTENSION_NAME, extensions[i].extensionName) == 0)
+        } else if (SDL_strcmp(VK_KHR_XLIB_SURFACE_EXTENSION_NAME, extensions[i].extensionName) == 0) {
             hasXlibSurfaceExtension = SDL_TRUE;
+        }
     }
     SDL_free(extensions);
-    if(!hasSurfaceExtension)
-    {
+    if (!hasSurfaceExtension) {
         SDL_SetError("Installed Vulkan doesn't implement the "
                      VK_KHR_SURFACE_EXTENSION_NAME " extension");
         goto fail;
     }
-    if(hasXlibSurfaceExtension)
-    {
+    if (hasXlibSurfaceExtension) {
         videoData->vulkan_xlib_xcb_library = NULL;
-    }
-    else if(!hasXCBSurfaceExtension)
-    {
+    } else if (!hasXCBSurfaceExtension) {
         SDL_SetError("Installed Vulkan doesn't implement either the "
                      VK_KHR_XCB_SURFACE_EXTENSION_NAME "extension or the "
                      VK_KHR_XLIB_SURFACE_EXTENSION_NAME " extension");
         goto fail;
-    }
-    else
-    {
+    } else {
         const char *libX11XCBLibraryName = SDL_getenv("SDL_X11_XCB_LIBRARY");
-        if(!libX11XCBLibraryName)
+        if (libX11XCBLibraryName == NULL) {
             libX11XCBLibraryName = "libX11-xcb.so";
+        }
         videoData->vulkan_xlib_xcb_library = SDL_LoadObject(libX11XCBLibraryName);
-        if(!videoData->vulkan_xlib_xcb_library)
+        if (!videoData->vulkan_xlib_xcb_library) {
             goto fail;
+        }
         videoData->vulkan_XGetXCBConnection =
             SDL_LoadFunction(videoData->vulkan_xlib_xcb_library, "XGetXCBConnection");
-        if(!videoData->vulkan_XGetXCBConnection)
-        {
+        if (!videoData->vulkan_XGetXCBConnection) {
             SDL_UnloadObject(videoData->vulkan_xlib_xcb_library);
             goto fail;
         }
@@ -133,10 +136,10 @@ fail:
 void X11_Vulkan_UnloadLibrary(_THIS)
 {
     SDL_VideoData *videoData = (SDL_VideoData *)_this->driverdata;
-    if(_this->vulkan_config.loader_handle)
-    {
-        if(videoData->vulkan_xlib_xcb_library)
+    if (_this->vulkan_config.loader_handle) {
+        if (videoData->vulkan_xlib_xcb_library) {
             SDL_UnloadObject(videoData->vulkan_xlib_xcb_library);
+        }
         SDL_UnloadObject(_this->vulkan_config.loader_handle);
         _this->vulkan_config.loader_handle = NULL;
     }
@@ -148,21 +151,17 @@ SDL_bool X11_Vulkan_GetInstanceExtensions(_THIS,
                                           const char **names)
 {
     SDL_VideoData *videoData = (SDL_VideoData *)_this->driverdata;
-    if(!_this->vulkan_config.loader_handle)
-    {
+    if (!_this->vulkan_config.loader_handle) {
         SDL_SetError("Vulkan is not loaded");
         return SDL_FALSE;
     }
-    if(videoData->vulkan_xlib_xcb_library)
-    {
+    if (videoData->vulkan_xlib_xcb_library) {
         static const char *const extensionsForXCB[] = {
             VK_KHR_SURFACE_EXTENSION_NAME, VK_KHR_XCB_SURFACE_EXTENSION_NAME,
         };
         return SDL_Vulkan_GetInstanceExtensions_Helper(
             count, names, SDL_arraysize(extensionsForXCB), extensionsForXCB);
-    }
-    else
-    {
+    } else {
         static const char *const extensionsForXlib[] = {
             VK_KHR_SURFACE_EXTENSION_NAME, VK_KHR_XLIB_SURFACE_EXTENSION_NAME,
         };
@@ -179,21 +178,18 @@ SDL_bool X11_Vulkan_CreateSurface(_THIS,
     SDL_VideoData *videoData = (SDL_VideoData *)_this->driverdata;
     SDL_WindowData *windowData = (SDL_WindowData *)window->driverdata;
     PFN_vkGetInstanceProcAddr vkGetInstanceProcAddr;
-    if(!_this->vulkan_config.loader_handle)
-    {
+    if (!_this->vulkan_config.loader_handle) {
         SDL_SetError("Vulkan is not loaded");
         return SDL_FALSE;
     }
     vkGetInstanceProcAddr = (PFN_vkGetInstanceProcAddr)_this->vulkan_config.vkGetInstanceProcAddr;
-    if(videoData->vulkan_xlib_xcb_library)
-    {
+    if (videoData->vulkan_xlib_xcb_library) {
         PFN_vkCreateXcbSurfaceKHR vkCreateXcbSurfaceKHR =
             (PFN_vkCreateXcbSurfaceKHR)vkGetInstanceProcAddr(instance,
                                                              "vkCreateXcbSurfaceKHR");
         VkXcbSurfaceCreateInfoKHR createInfo;
         VkResult result;
-        if(!vkCreateXcbSurfaceKHR)
-        {
+        if (!vkCreateXcbSurfaceKHR) {
             SDL_SetError(VK_KHR_XCB_SURFACE_EXTENSION_NAME
                          " extension is not enabled in the Vulkan instance.");
             return SDL_FALSE;
@@ -201,30 +197,25 @@ SDL_bool X11_Vulkan_CreateSurface(_THIS,
         SDL_zero(createInfo);
         createInfo.sType = VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR;
         createInfo.connection = videoData->vulkan_XGetXCBConnection(videoData->display);
-        if(!createInfo.connection)
-        {
+        if (!createInfo.connection) {
             SDL_SetError("XGetXCBConnection failed");
             return SDL_FALSE;
         }
         createInfo.window = (xcb_window_t)windowData->xwindow;
         result = vkCreateXcbSurfaceKHR(instance, &createInfo,
                                        NULL, surface);
-        if(result != VK_SUCCESS)
-        {
+        if (result != VK_SUCCESS) {
             SDL_SetError("vkCreateXcbSurfaceKHR failed: %s", SDL_Vulkan_GetResultString(result));
             return SDL_FALSE;
         }
         return SDL_TRUE;
-    }
-    else
-    {
+    } else {
         PFN_vkCreateXlibSurfaceKHR vkCreateXlibSurfaceKHR =
             (PFN_vkCreateXlibSurfaceKHR)vkGetInstanceProcAddr(instance,
                                                               "vkCreateXlibSurfaceKHR");
         VkXlibSurfaceCreateInfoKHR createInfo;
         VkResult result;
-        if(!vkCreateXlibSurfaceKHR)
-        {
+        if (!vkCreateXlibSurfaceKHR) {
             SDL_SetError(VK_KHR_XLIB_SURFACE_EXTENSION_NAME
                          " extension is not enabled in the Vulkan instance.");
             return SDL_FALSE;
@@ -235,8 +226,7 @@ SDL_bool X11_Vulkan_CreateSurface(_THIS,
         createInfo.window = (xcb_window_t)windowData->xwindow;
         result = vkCreateXlibSurfaceKHR(instance, &createInfo,
                                         NULL, surface);
-        if(result != VK_SUCCESS)
-        {
+        if (result != VK_SUCCESS) {
             SDL_SetError("vkCreateXlibSurfaceKHR failed: %s", SDL_Vulkan_GetResultString(result));
             return SDL_FALSE;
         }
diff --git a/src/video/x11/SDL_x11window.c b/src/video/x11/SDL_x11window.c
index 6d4e53f20..4c5d5de8b 100644
--- a/src/video/x11/SDL_x11window.c
+++ b/src/video/x11/SDL_x11window.c
@@ -102,10 +102,8 @@ X11_IsActionAllowed(SDL_Window *window, Atom action)
     Atom *list;
     SDL_bool ret = SDL_FALSE;
 
-    if (X11_XGetWindowProperty(display, data->xwindow, _NET_WM_ALLOWED_ACTIONS, 0, 1024, False, XA_ATOM, &type, &form, &len, &remain, (unsigned char **)&list) == Success)
-    {
-        for (i=0; i<len; ++i)
-        {
+    if (X11_XGetWindowProperty(display, data->xwindow, _NET_WM_ALLOWED_ACTIONS, 0, 1024, False, XA_ATOM, &type, &form, &len, &remain, (unsigned char **)&list) == Success) {
+        for (i=0; i<len; ++i) {
             if (list[i] == action) {
                 ret = SDL_TRUE;
                 break;
@@ -265,7 +263,7 @@ SetupWindowData(_THIS, SDL_Window * window, Window w, BOOL created)
 
     /* Allocate the window data */
     data = (SDL_WindowData *) SDL_calloc(1, sizeof(*data));
-    if (!data) {
+    if (data == NULL) {
         return SDL_OutOfMemory();
     }
     data->window = window;
@@ -292,7 +290,7 @@ SetupWindowData(_THIS, SDL_Window * window, Window w, BOOL created)
             (SDL_WindowData **) SDL_realloc(windowlist,
                                             (numwindows +
                                              1) * sizeof(*windowlist));
-        if (!windowlist) {
+        if (windowlist == NULL) {
             SDL_free(data);
             return SDL_OutOfMemory();
         }
@@ -326,8 +324,7 @@ SetupWindowData(_THIS, SDL_Window * window, Window w, BOOL created)
         Window FocalWindow;
         int RevertTo=0;
         X11_XGetInputFocus(data->videodata->display, &FocalWindow, &RevertTo);
-        if (FocalWindow==w)
-        {
+        if (FocalWindow==w) {
             window->flags |= SDL_WINDOW_INPUT_FOCUS;
         }
 
@@ -405,8 +402,7 @@ X11_CreateWindow(_THIS, SDL_Window * window)
 #if SDL_VIDEO_OPENGL_GLX || SDL_VIDEO_OPENGL_EGL
     const char *forced_visual_id = SDL_GetHint(SDL_HINT_VIDEO_X11_WINDOW_VISUALID);
 
-    if (forced_visual_id != NULL && forced_visual_id[0] != '\0')
-    {
+    if (forced_visual_id != NULL && forced_visual_id[0] != '\0') {
         XVisualInfo *vi, template;
         int nvis;
 
@@ -417,13 +413,10 @@ X11_CreateWindow(_THIS, SDL_Window * window)
             visual = vi->visual;
             depth = vi->depth;
             X11_XFree(vi);
-        }
-        else
-        {
+        } else {
             return -1;
         }
-    }
-    else if ((window->flags & SDL_WINDOW_OPENGL) &&
+    } else if ((window->flags & SDL_WINDOW_OPENGL) &&
         !SDL_getenv("SDL_VIDEO_X11_VISUALID")) {
         XVisualInfo *vinfo = NULL;
 
@@ -443,7 +436,7 @@ X11_CreateWindow(_THIS, SDL_Window * window)
 #endif
         }
 
-        if (!vinfo) {
+        if (vinfo == NULL) {
             return -1;
         }
         visual = vinfo->visual;
@@ -480,7 +473,7 @@ X11_CreateWindow(_THIS, SDL_Window * window)
 
         /* OK, we got a colormap, now fill it in as best as we can */
         colorcells = SDL_malloc(visual->map_entries * sizeof(XColor));
-        if (!colorcells) {
+        if (colorcells == NULL) {
             return SDL_OutOfMemory();
         }
         ncolors = visual->map_entries;
@@ -1031,7 +1024,7 @@ X11_SetWindowOpacity(_THIS, SDL_Window * window, float opacity)
 
     if (opacity == 1.0f) {
         X11_XDeleteProperty(display, data->xwindow, _NET_WM_WINDOW_OPACITY);
-    } else  {
+    } else {
         const Uint32 FullyOpaque = 0xFFFFFFFF;
         const long alpha = (long) ((double)opacity * (double)FullyOpaque);
         X11_XChangeProperty(display, data->xwindow, _NET_WM_WINDOW_OPACITY, XA_CARDINAL, 32,
@@ -1180,8 +1173,9 @@ X11_ShowWindow(_THIS, SDL_Window * window)
         /* Blocking wait for "MapNotify" event.
          * We use X11_XIfEvent because pXWindowEvent takes a mask rather than a type,
          * and XCheckTypedWindowEvent doesn't block */
-        if(!(window->flags & SDL_WINDOW_FOREIGN))
+        if (!(window->flags & SDL_WINDOW_FOREIGN)) {
             X11_XIfEvent(display, &event, &isMapNotify, (XPointer)&data->xwindow);
+        }
         X11_XFlush(display);
     }
 
@@ -1204,8 +1198,9 @@ X11_HideWindow(_THIS, SDL_Window * window)
     if (X11_IsWindowMapped(_this, window)) {
         X11_XWithdrawWindow(display, data->xwindow, displaydata->screen);
         /* Blocking wait for "UnmapNotify" event */
-        if(!(window->flags & SDL_WINDOW_FOREIGN))
+        if (!(window->flags & SDL_WINDOW_FOREIGN)) {
             X11_XIfEvent(display, &event, &isUnmapNotify, (XPointer)&data->xwindow);
+        }
         X11_XFlush(display);
     }
 }
@@ -1562,7 +1557,9 @@ static void X11_ReadProperty(SDL_x11Prop *p, Display *disp, Window w, Atom prop)
     int bytes_fetch = 0;
 
     do {
-        if (ret != NULL) X11_XFree(ret);
+        if (ret != NULL) {
+            X11_XFree(ret);
+        }
         X11_XGetWindowProperty(disp, w, prop, 0, bytes_fetch, False, AnyPropertyType, &type, &fmt, &count, &bytes_left, &ret);
         bytes_fetch += bytes_left;
     } while (bytes_left != 0);
@@ -1611,7 +1608,7 @@ X11_GetWindowICCProfile(_THIS, SDL_Window * window, size_t * size)
     }
 
     ret_icc_profile_data = SDL_malloc(real_nitems);
-    if (!ret_icc_profile_data) {
+    if (ret_icc_profile_data == NULL) {
         SDL_OutOfMemory();
         return NULL;
     }
@@ -1766,7 +1763,7 @@ X11_GetWindowWMInfo(_THIS, SDL_Window * window, SDL_SysWMinfo * info)
     SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
     Display *display;
 
-    if (!data) {
+    if (data == NULL) {
         /* This sometimes happens in SDL_IBus_UpdateTextRect() while creating the window */
         SDL_SetError("Window not initialized");
         return SDL_FALSE;
@@ -1816,7 +1813,7 @@ X11_FlashWindow(_THIS, SDL_Window * window, SDL_FlashOperation operation)
     XWMHints *wmhints;
 
     wmhints = X11_XGetWMHints(display, data->xwindow);
-    if (!wmhints) {
+    if (wmhints == NULL) {
         return SDL_SetError("Couldn't get WM hints");
     }
 
diff --git a/src/video/x11/SDL_x11xfixes.c b/src/video/x11/SDL_x11xfixes.c
index 95027d46b..dfe3a4c64 100644
--- a/src/video/x11/SDL_x11xfixes.c
+++ b/src/video/x11/SDL_x11xfixes.c
@@ -35,13 +35,13 @@ query_xfixes_version(Display *display, int major, int minor)
 {
     /* We don't care if this fails, so long as it sets major/minor on it's way out the door. */
     X11_XFixesQueryVersion(display, &major, &minor);
-    return ((major * 1000) + minor);
+    return (major * 1000) + minor;
 }
 
 static SDL_bool
 xfixes_version_atleast(const int version, const int wantmajor, const int wantminor)
 {
-    return (version >= ((wantmajor * 1000) + wantminor));
+    return version >= ((wantmajor * 1000) + wantminor);
 }
 
 void
diff --git a/src/video/x11/SDL_x11xinput2.c b/src/video/x11/SDL_x11xinput2.c
index db3187b01..a23e58744 100644
--- a/src/video/x11/SDL_x11xinput2.c
+++ b/src/video/x11/SDL_x11xinput2.c
@@ -46,8 +46,9 @@ static void parse_valuators(const double *input_values, const unsigned char *mas
                             double *output_values,int output_values_len) {
     int i = 0,z = 0;
     int top = mask_len * 8;
-    if (top > MAX_AXIS)
+    if (top > MAX_AXIS) {
         top = MAX_AXIS;
+    }
 
     SDL_memset(output_values,0,output_values_len * sizeof(double));
     for (; i < top && z < output_values_len; i++) {
@@ -65,13 +66,13 @@ query_xinput2_version(Display *display, int major, int minor)
 {
     /* We don't care if this fails, so long as it sets major/minor on it's way out the door. */
     X11_XIQueryVersion(display, &major, &minor);
-    return ((major * 1000) + minor);
+    return (major * 1000) + minor;
 }
 
 static SDL_bool
 xinput2_version_atleast(const int version, const int wantmajor, const int wantminor)
 {
-    return ( version >= ((wantmajor * 1000) + wantminor) );
+    return version >= ((wantmajor * 1000) + wantminor);
 }
 
 #if SDL_VIDEO_DRIVER_X11_XINPUT2_SUPPORTS_MULTITOUCH
@@ -232,13 +233,13 @@ xinput2_get_device_info(SDL_VideoData *videodata, const int device_id)
 
     /* don't know about this device yet, query and cache it. */
     devinfo = (SDL_XInput2DeviceInfo *) SDL_calloc(1, sizeof (SDL_XInput2DeviceInfo));
-    if (!devinfo) {
+    if (devinfo == NULL) {
         SDL_OutOfMemory();
         return NULL;
     }
 
     xidevinfo = X11_XIQueryDevice(videodata->display, device_id, &i);
-    if (!xidevinfo) {
+    if (xidevinfo == NULL) {
         SDL_free(devinfo);
         return NULL;
     }
@@ -292,7 +293,7 @@ X11_HandleXinput2Event(SDL_VideoData *videodata, XGenericEventCookie *cookie)
             }
 
             devinfo = xinput2_get_device_info(videodata, rawev->deviceid);
-            if (!devinfo) {
+            if (devinfo == NULL) {
                 return 0;  /* oh well. */
             }
 
@@ -417,8 +418,9 @@ X11_InitXinput2Multitouch(_THIS)
             XITouchClassInfo *t = (XITouchClassInfo*)class;
 
             /* Only touch devices */
-            if (class->type != XITouchClass)
+            if (class->type != XITouchClass) {
                 continue;
+            }
 
             if (t->mode == XIDependentTouch) {
                 touchType = SDL_TOUCH_DEVICE_INDIRECT_RELATIVE;
diff --git a/test/checkkeys.c b/test/checkkeys.c
index 9167c5c0a..de827f869 100644
--- a/test/checkkeys.c
+++ b/test/checkkeys.c
@@ -68,30 +68,42 @@ print_modifiers(char **text, size_t *maxlen)
         print_string(text, maxlen, " (none)");
         return;
     }
-    if (mod & KMOD_LSHIFT)
+    if (mod & KMOD_LSHIFT) {
         print_string(text, maxlen, " LSHIFT");
-    if (mod & KMOD_RSHIFT)
+    }
+    if (mod & KMOD_RSHIFT) {
         print_string(text, maxlen, " RSHIFT");
-    if (mod & KMOD_LCTRL)
+    }
+    if (mod & KMOD_LCTRL) {
         print_string(text, maxlen, " LCTRL");
-    if (mod & KMOD_RCTRL)
+    }
+    if (mod & KMOD_RCTRL) {
         print_string(text, maxlen, " RCTRL");
-    if (mod & KMOD_LALT)
+    }
+    if (mod & KMOD_LALT) {
         print_string(text, maxlen, " LALT");
-    if (mod & KMOD_RALT)
+    }
+    if (mod & KMOD_RALT) {
         print_string(text, maxlen, " RALT");
-    if (mod & KMOD_LGUI)
+    }
+    if (mod & KMOD_LGUI) {
         print_string(text, maxlen, " LGUI");
-    if (mod & KMOD_RGUI)
+    }
+    if (mod & KMOD_RGUI) {
         print_string(text, maxlen, " RGUI");
-    if (mod & KMOD_NUM)
+    }
+    if (mod & KMOD_NUM) {
         print_string(text, maxlen, " NUM");
-    if (mod & KMOD_CAPS)
+    }
+    if (mod & KMOD_CAPS) {
         print_string(text, maxlen, " CAPS");
-    if (mod & KMOD_MODE)
+    }
+    if (mod & KMOD_MODE) {
         print_string(text, maxlen, " MODE");
-    if (mod & KMOD_SCROLL)
+    }
+    if (mod & KMOD_SCROLL) {
         print_string(text, maxlen, " SCROLL");
+    }
 }
 
 static void
@@ -147,8 +159,7 @@ PrintText(const char *eventtype, const char *text)
     char expanded[1024];
 
     expanded[0] = '\0';
-    for ( spot = text; *spot; ++spot )
-    {
+    for ( spot = text; *spot; ++spot ) {
         size_t length = SDL_strlen(expanded);
         SDL_snprintf(expanded + length, sizeof(expanded) - length, "\\x%.2x", (unsigned char)*spot);
     }
@@ -253,21 +264,21 @@ main(int argc, char *argv[])
     /* Initialize SDL */
     if (SDL_Init(SDL_INIT_VIDEO) < 0) {
         SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Couldn't initialize SDL: %s\n", SDL_GetError());
-        return (1);
+        return 1;
     }
 
     /* Set 640x480 video mode */
     window = SDL_CreateWindow("CheckKeys Test",
                               SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED,
                               640, 480, 0);
-    if (!window) {
+    if (window == NULL) {
         SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Couldn't create 640x480 window: %s\n",
                 SDL_GetError());
         quit(2);
     }
 
     renderer = SDL_CreateRenderer(window, -1, 0);
-    if (!renderer) {
+    if (renderer == NULL) {
         SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Couldn't create renderer: %s\n",
                 SDL_GetError());
         quit(2);
@@ -298,7 +309,7 @@ main(int argc, char *argv[])
 #endif
 
     SDL_Quit();
-    return (0);
+    return 0;
 }
 
 /* vi: set ts=4 sw=4 expandtab: */
diff --git a/test/checkkeysthreads.c b/test/checkkeysthreads.c
index 0716d0f7c..00fb71bfe 100644
--- a/test/checkkeysthreads.c
+++ b/test/checkkeysthreads.c
@@ -64,30 +64,42 @@ print_modifiers(char **text, size_t *maxlen)
         print_string(text, maxlen, " (none)");
         return;
     }
-    if (mod & KMOD_LSHIFT)
+    if (mod & KMOD_LSHIFT) {
         print_string(text, maxlen, " LSHIFT");
-    if (mod & KMOD_RSHIFT)
+    }
+    if (mod & KMOD_RSHIFT) {
         print_string(text, maxlen, " RSHIFT");
-    if (mod & KMOD_LCTRL)
+    }
+    if (mod & KMOD_LCTRL) {
         print_string(text, maxlen, " LCTRL");
-    if (mod & KMOD_RCTRL)
+    }
+    if (mod & KMOD_RCTRL) {
         print_string(text, maxlen, " RCTRL");
-    if (mod & KMOD_LALT)
+    }
+    if (mod & KMOD_LALT) {
         print_string(text, maxlen, " LALT");
-    if (mod & KMOD_RALT)
+    }
+    if (mod & KMOD_RALT) {
         print_string(text, maxlen, " RALT");
-    if (mod & KMOD_LGUI)
+    }
+    if (mod & KMOD_LGUI) {
         print_string(text, maxlen, " LGUI");
-    if (mod & KMOD_RGUI)
+    }
+    if (mod & KMOD_RGUI) {
         print_string(text, maxlen, " RGUI");
-    if (mod & KMOD_NUM)
+    }
+    if (mod & KMOD_NUM) {
         print_string(text, maxlen, " NUM");
-    if (mod & KMOD_CAPS)
+    }
+    if (mod & KMOD_CAPS) {
         print_string(text, maxlen, " CAPS");
-    if (mod & KMOD_MODE)
+    }
+    if (mod & KMOD_MODE) {
         print_string(text, maxlen, " MODE");
-    if (mod & KMOD_SCROLL)
+    }
+    if (mod & KMOD_SCROLL) {
         print_string(text, maxlen, " SCROLL");
+    }
 }
 
 static void
@@ -144,8 +156,7 @@ PrintText(const char *eventtype, const char *text)
     char expanded[1024];
 
     expanded[0] = '\0';
-    for ( spot = text; *spot; ++spot )
-    {
+    for ( spot = text; *spot; ++spot ) {
         size_t length = SDL_strlen(expanded);
         SDL_snprintf(expanded + length, sizeof(expanded) - length, "\\x%.2x", (unsigned char)*spot);
     }
@@ -235,14 +246,14 @@ main(int argc, char *argv[])
     /* Initialize SDL */
     if (SDL_Init(SDL_INIT_VIDEO) < 0) {
         SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Couldn't initialize SDL: %s\n", SDL_GetError());
-        return (1);
+        return 1;
     }
 
     /* Set 640x480 video mode */
     window = SDL_CreateWindow("CheckKeys Test",
                               SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED,
                               640, 480, 0);
-    if (!window) {
+    if (window == NULL) {
         SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Couldn't create 640x480 window: %s\n",
                 SDL_GetError());
         quit(2);
@@ -280,7 +291,7 @@ main(int argc, char *argv[])
 
     SDL_WaitThread(thread, NULL);
     SDL_Quit();
-    return (0);
+    return 0;
 }
 
 /* vi: set ts=4 sw=4 expandtab: */
diff --git a/test/controllermap.c b/test/controllermap.c
index 22ab19e37..e4181363e 100644
--- a/test/controllermap.c
+++ b/test/controllermap.c
@@ -199,8 +199,7 @@ SetCurrentBinding(int iBinding)
         return;
     }
 
-    if (s_arrBindingOrder[iBinding] == -1)
-    {
+    if (s_arrBindingOrder[iBinding] == -1) {
         SetCurrentBinding(iBinding + 1);
         return;
     }
@@ -227,8 +226,7 @@ SetCurrentBinding(int iBinding)
 static SDL_bool
 BBindingContainsBinding(const SDL_GameControllerExtendedBind *pBindingA, const SDL_GameControllerExtendedBind *pBindingB)
 {
-    if (pBindingA->bindType != pBindingB->bindType)
-    {
+    if (pBindingA->bindType != pBindingB->bindType) {
         return SDL_FALSE;
     }
     switch (pBindingA->bindType)
@@ -245,7 +243,7 @@ BBindingContainsBinding(const SDL_GameControllerExtendedBind *pBindingA, const S
             int maxA = SDL_max(pBindingA->value.axis.axis_min, pBindingA->value.axis.axis_max);
             int minB = SDL_min(pBindingB->value.axis.axis_min, pBindingB->value.axis.axis_max);
             int maxB = SDL_max(pBindingB->value.axis.axis_min, pBindingB->value.axis.axis_max);
-            return (minA <= minB && maxA >= maxB);
+            return minA <= minB && maxA >= maxB;
         }
         /* Not reached */
     default:
diff --git a/test/loopwave.c b/test/loopwave.c
index 1b5fa95f0..026c8e619 100644
--- a/test/loopwave.c
+++ b/test/loopwave.c
@@ -107,8 +107,9 @@ static int done = 0;
 void
 loop()
 {
-    if(done || (SDL_GetAudioDeviceStatus(device) != SDL_AUDIO_PLAYING))
+    if (done || (SDL_GetAudioDeviceStatus(device) != SDL_AUDIO_PLAYING)) {
         emscripten_cancel_main_loop();
+    }
 }
 #endif
 
@@ -124,7 +125,7 @@ main(int argc, char *argv[])
     /* Load the SDL library */
     if (SDL_Init(SDL_INIT_AUDIO|SDL_INIT_EVENTS) < 0) {
         SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Couldn't initialize SDL: %s\n", SDL_GetError());
-        return (1);
+        return 1;
     }
 
     filename = GetResourceFilename(argc > 1 ? argv[1] : NULL, "sample.wav");
@@ -178,7 +179,7 @@ main(int argc, char *argv[])
     SDL_FreeWAV(wave.sound);
     SDL_free(filename);
     SDL_Quit();
-    return (0);
+    return 0;
 }
 
 /* vi: set ts=4 sw=4 expandtab: */
diff --git a/test/loopwavequeue.c b/test/loopwavequeue.c
index 1996d784a..8893e3b62 100644
--- a/test/loopwavequeue.c
+++ b/test/loopwavequeue.c
@@ -56,8 +56,7 @@ loop()
 #ifdef __EMSCRIPTEN__
     if (done || (SDL_GetAudioStatus() != SDL_AUDIO_PLAYING)) {
         emscripten_cancel_main_loop();
-    }
-    else
+    } else
 #endif
     {
         /* The device from SDL_OpenAudio() is always device #1. */
@@ -84,7 +83,7 @@ main(int argc, char *argv[])
     /* Load the SDL library */
     if (SDL_Init(SDL_INIT_AUDIO) < 0) {
         SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Couldn't initialize SDL: %s\n", SDL_GetError());
-        return (1);
+        return 1;
     }
 
     filename = GetResourceFilename(argc > 1 ? argv[1] : NULL, "sample.wav");
@@ -135,8 +134,7 @@ main(int argc, char *argv[])
 #ifdef __EMSCRIPTEN__
     emscripten_set_main_loop(loop, 0, 1);
 #else
-    while (!done && (SDL_GetAudioStatus() == SDL_AUDIO_PLAYING))
-    {
+    while (!done && (SDL_GetAudioStatus() == SDL_AUDIO_PLAYING)) {
         loop();
 
         SDL_Delay(100);  /* let it play for awhile. */
diff --git a/test/testatomic.c b/test/testatomic.c
index 9efbb29c0..ffb11c675 100644
--- a/test/testatomic.c
+++ b/test/testatomic.c
@@ -25,8 +25,7 @@ tf(SDL_bool _tf)
     static const char *t = "TRUE";
     static const char *f = "FALSE";
 
-    if (_tf)
-    {
+    if (_tf) {
        return t;
     }
 
@@ -142,11 +141,13 @@ void runAdder(void)
 
     SDL_AtomicSet(&threadsRunning, NThreads);
 
-    while (T--)
+    while (T--) {
         SDL_CreateThread(adder, "Adder", NULL);
+    }
 
-    while (SDL_AtomicGet(&threadsRunning) > 0)
+    while (SDL_AtomicGet(&threadsRunning) > 0) {
         SDL_SemWait(threadDone);
+    }
 
     SDL_DestroySemaphore(threadDone);
 
diff --git a/test/testaudiocapture.c b/test/testaudiocapture.c
index 03d373273..0a9170343 100644
--- a/test/testaudiocapture.c
+++ b/test/testaudiocapture.c
@@ -101,7 +101,7 @@ main(int argc, char **argv)
     /* Load the SDL library */
     if (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO) < 0) {
         SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Couldn't initialize SDL: %s\n", SDL_GetError());
-        return (1);
+        return 1;
     }
 
     window = SDL_CreateWindow("testaudiocapture", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, 320, 240, 0);
diff --git a/test/testaudiohotplug.c b/test/testaudiohotplug.c
index dc84a782f..1b906e74a 100644
--- a/test/testaudiohotplug.c
+++ b/test/testaudiohotplug.c
@@ -90,8 +90,9 @@ iteration()
         if (e.type == SDL_QUIT) {
             done = 1;
         } else if (e.type == SDL_KEYUP) {
-            if (e.key.keysym.sym == SDLK_ESCAPE)
+            if (e.key.keysym.sym == SDLK_ESCAPE) {
                 done = 1;
+            }
         } else if (e.type == SDL_AUDIODEVICEADDED) {
             int index = e.adevice.which;
             int iscapture = e.adevice.iscapture;
@@ -127,7 +128,7 @@ iteration()
 void
 loop()
 {
-    if(done)
+    if (done)
         emscripten_cancel_main_loop();
     else
         iteration();
@@ -146,7 +147,7 @@ main(int argc, char *argv[])
     /* Load the SDL library */
     if (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO) < 0) {
         SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Couldn't initialize SDL: %s\n", SDL_GetError());
-        return (1);
+        return 1;
     }
 
     /* Some targets (Mac CoreAudio) need an event queue for audio hotplug, so make and immediately hide a window. */
@@ -201,7 +202,7 @@ main(int argc, char *argv[])
     SDL_FreeWAV(sound);
     SDL_free(filename);
     SDL_Quit();
-    return (0);
+    return 0;
 }
 
 /* vi: set ts=4 sw=4 expandtab: */
diff --git a/test/testaudioinfo.c b/test/testaudioinfo.c
index 9e3bfcdf7..d2ea229e2 100644
--- a/test/testaudioinfo.c
+++ b/test/testaudioinfo.c
@@ -57,7 +57,7 @@ main(int argc, char **argv)
     /* Load the SDL library */
     if (SDL_Init(SDL_INIT_AUDIO) < 0) {
         SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Couldn't initialize SDL: %s\n", SDL_GetError());
-        return (1);
+        return 1;
     }
 
     /* Print available audio drivers */
diff --git a/test/testautomation.c b/test/testautomation.c
index 5f469db2b..0245d1148 100644
--- a/test/testautomation.c
+++ b/test/testautomation.c
@@ -42,7 +42,7 @@ main(int argc, char *argv[])
 
     /* Initialize test framework */
     state = SDLTest_CommonCreateState(argv, SDL_INIT_VIDEO);
-    if (!state) {
+    if (state == NULL) {
         return 1;
     }
 
@@ -56,23 +56,22 @@ main(int argc, char *argv[])
             if (SDL_strcasecmp(argv[i], "--iterations") == 0) {
                 if (argv[i + 1]) {
                     testIterations = SDL_atoi(argv[i + 1]);
-                    if (testIterations < 1) testIterations = 1;
+                    if (testIterations < 1) {
+                        testIterations = 1;
+                    }
                     consumed = 2;
                 }
-            }
-            else if (SDL_strcasecmp(argv[i], "--execKey") == 0) {
+            } else if (SDL_strcasecmp(argv[i], "--execKey") == 0) {
                 if (argv[i + 1]) {
                     SDL_sscanf(argv[i + 1], "%"SDL_PRIu64, &userExecKey);
                     consumed = 2;
                 }
-            }
-            else if (SDL_strcasecmp(argv[i], "--seed") == 0) {
+            } else if (SDL_strcasecmp(argv[i], "--seed") == 0) {
                 if (argv[i + 1]) {
                     userRunSeed = SDL_strdup(argv[i + 1]);
                     consumed = 2;
                 }
-            }
-            else if (SDL_strcasecmp(argv[i], "--filter") == 0) {
+            } else if (SDL_strcasecmp(argv[i], "--filter") == 0) {
                 if (argv[i + 1]) {
                     filter = SDL_strdup(argv[i + 1]);
                     consumed = 2;
@@ -105,7 +104,7 @@ main(int argc, char *argv[])
 
     /* Empty event queue */
     done = 0;
-    for (i=0; i<100; i++)  {
+    for (i=0; i<100; i++) {
       while (SDL_PollEvent(&event)) {
         SDLTest_CommonEvent(state, &event, &done);
       }
@@ -118,7 +117,7 @@ main(int argc, char *argv[])
 
     /* Shutdown everything */
     quit(result);
-    return(result);
+    return result;
 }
 
 /* vi: set ts=4 sw=4 expandtab: */
diff --git a/test/testautomation_audio.c b/test/testautomation_audio.c
index e6127b573..86eb87574 100644
--- a/test/testautomation_audio.c
+++ b/test/testautomation_audio.c
@@ -461,8 +461,7 @@ int audio_printAudioDrivers()
    SDLTest_AssertCheck(n>=0, "Verify number of audio drivers >= 0, got: %i", n);
 
    /* List drivers. */
-   if (n>0)
-   {
+   if (n>0) {
       for (i=0; i<n; i++) {
          name = SDL_GetAudioDriver(i);
          SDLTest_AssertPass("Call to SDL_GetAudioDriver(%i)", i);
@@ -712,7 +711,9 @@ int audio_openCloseAndGetAudioStatus()
        device = SDL_GetAudioDeviceName(i, 0);
        SDLTest_AssertPass("SDL_GetAudioDeviceName(%i,0)", i);
        SDLTest_AssertCheck(device != NULL, "Validate device name is not NULL; got: %s", (device != NULL) ? device : "NULL");
-       if (device == NULL) return TEST_ABORTED;
+       if (device == NULL) {
+         return TEST_ABORTED;
+       }
 
        /* Set standard desired spec */
        desired.freq=22050;
@@ -770,7 +771,9 @@ int audio_lockUnlockOpenAudioDevice()
        device = SDL_GetAudioDeviceName(i, 0);
        SDLTest_AssertPass("SDL_GetAudioDeviceName(%i,0)", i);
        SDLTest_AssertCheck(device != NULL, "Validate device name is not NULL; got: %s", (device != NULL) ? device : "NULL");
-       if (device == NULL) return TEST_ABORTED;
+       if (device == NULL) {
+         return TEST_ABORTED;
+       }
 
        /* Set standard desired spec */
        desired.freq=22050;
@@ -878,7 +881,9 @@ int audio_convertAudio()
             SDLTest_LogError("%s", SDL_GetError());
           } else {
             SDLTest_AssertCheck(cvt.len_mult > 0, "Verify that cvt.len_mult value; expected: >0, got: %i", cvt.len_mult);
-            if (cvt.len_mult < 1) return TEST_ABORTED;
+            if (cvt.len_mult < 1) {
+              return TEST_ABORTED;
+            }
 
             /* Create some random data to convert */
             l = 64;
@@ -887,7 +892,9 @@ int audio_convertAudio()
             cvt.len = l;
             cvt.buf = (Uint8 *)SDL_malloc(ll);
             SDLTest_AssertCheck(cvt.buf != NULL, "Check data buffer to convert is not NULL");
-            if (cvt.buf == NULL) return TEST_ABORTED;
+            if (cvt.buf == NULL) {
+              return TEST_ABORTED;
+            }
 
             /* Convert the data */
             result = SDL_ConvertAudio(&cvt);
@@ -932,7 +939,9 @@ int audio_openCloseAudioDeviceConnected()
        device = SDL_GetAudioDeviceName(i, 0);
        SDLTest_AssertPass("SDL_GetAudioDeviceName(%i,0)", i);
        SDLTest_AssertCheck(device != NULL, "Validate device name is not NULL; got: %s", (device != NULL) ? device : "NULL");
-       if (device == NULL) return TEST_ABORTED;
+       if (device == NULL) {
+         return TEST_ABORTED;
+       }
 
        /* Set standard desired spec */
        desired.freq=22050;
diff --git a/test/testautomation_mouse.c b/test/testautomation_mouse.c
index f8334803e..d9cd4f0bd 100644
--- a/test/testautomation_mouse.c
+++ b/test/testautomation_mouse.c
@@ -230,7 +230,9 @@ mouse_createFreeColorCursor(void *arg)
     /* Get sample surface */
     face = SDLTest_ImageFace();
     SDLTest_AssertCheck(face != NULL, "Validate sample input image is not NULL");
-    if (face == NULL) return TEST_ABORTED;
+    if (face == NULL) {
+        return TEST_ABORTED;
+    }
 
     /* Create a color cursor from surface */
     cursor = SDL_CreateColorCursor(face, 0, 0);
@@ -466,7 +468,9 @@ mouse_warpMouseInWindow(void *arg)
     yPositions[5] = h+1;
     /* Create test window */
     window = _createMouseSuiteTestWindow();
-    if (window == NULL) return TEST_ABORTED;
+    if (window == NULL) {
+      return TEST_ABORTED;
+    }
 
     /* Mouse to random position inside window */
     x = SDLTest_RandomIntegerInRange(1, w-1);
@@ -518,7 +522,9 @@ mouse_getMouseFocus(void *arg)
 
         /* Create test window */
     window = _createMouseSuiteTestWindow();
-    if (window == NULL) return TEST_ABORTED;
+    if (window == NULL) {
+        return TEST_ABORTED;
+    }
 
     /* Mouse to random position inside window */
     x = SDLTest_RandomIntegerInRange(1, w-1);
diff --git a/test/testautomation_pixels.c b/test/testautomation_pixels.c
index 8117c11e4..a61959edb 100644
--- a/test/testautomation_pixels.c
+++ b/test/testautomation_pixels.c
@@ -352,7 +352,7 @@ pixels_allocFreePalette(void *arg)
       if (result->ncolors > 0) {
         SDLTest_AssertCheck(result->colors != NULL, "Verify value of result.colors is not NULL");
         if (result->colors != NULL) {
-          for(i = 0; i < result->ncolors; i++) {
+          for (i = 0; i < result->ncolors; i++) {
             SDLTest_AssertCheck(result->colors[i].r == 255, "Verify value of result.colors[%d].r; expected: 255, got %u", i, result->colors[i].r);
             SDLTest_AssertCheck(result->colors[i].g == 255, "Verify value of result.colors[%d].g; expected: 255, got %u", i, result->colors[i].g);
             SDLTest_AssertCheck(result->colors[i].b == 255, "Verify value of result.colors[%d].b; expected: 255, got %u", i, result->colors[i].b);
diff --git a/test/testautomation_platform.c b/test/testautomation_platform.c
index e86614884..466ee5df7 100644
--- a/test/testautomation_platform.c
+++ b/test/testautomation_platform.c
@@ -305,8 +305,7 @@ int platform_testGetSetClearError(void *arg)
    SDLTest_AssertPass("SDL_GetError()");
    SDLTest_AssertCheck(lastError != NULL,
              "SDL_GetError() != NULL");
-   if (lastError != NULL)
-   {
+   if (lastError != NULL) {
      len = SDL_strlen(lastError);
      SDLTest_AssertCheck(len == 0,
              "SDL_GetError(): no message expected, len: %i", (int) len);
@@ -318,8 +317,7 @@ int platform_testGetSetClearError(void *arg)
    lastError = (char *)SDL_GetError();
    SDLTest_AssertCheck(lastError != NULL,
              "SDL_GetError() != NULL");
-   if (lastError != NULL)
-   {
+   if (lastError != NULL) {
      len = SDL_strlen(lastError);
      SDLTest_AssertCheck(len == SDL_strlen(testError),
              "SDL_GetError(): expected message len %i, was len: %i",
@@ -356,8 +354,7 @@ int platform_testSetErrorEmptyInput(void *arg)
    lastError = (char *)SDL_GetError();
    SDLTest_AssertCheck(lastError != NULL,
              "SDL_GetError() != NULL");
-   if (lastError != NULL)
-   {
+   if (lastError != NULL) {
      len = SDL_strlen(lastError);
      SDLTest_AssertCheck(len == SDL_strlen(testError),
              "SDL_GetError(): expected message len %i, was len: %i",
@@ -405,8 +402,7 @@ int platform_testSetErrorInvalidInput(void *arg)
    lastError = (char *)SDL_GetError();
    SDLTest_AssertCheck(lastError != NULL,
              "SDL_GetError() != NULL");
-   if (lastError != NULL)
-   {
+   if (lastError != NULL) {
      len = SDL_strlen(lastError);
      SDLTest_AssertCheck(len == 0 || SDL_strcmp(lastError, "(null)") == 0,
              "SDL_GetError(): expected message len 0, was len: %i",
@@ -425,8 +421,7 @@ int platform_testSetErrorInvalidInput(void *arg)
    lastError = (char *)SDL_GetError();
    SDLTest_AssertCheck(lastError != NULL,
              "SDL_GetError() != NULL");
-   if (lastError != NULL)
-   {
+   if (lastError != NULL) {
      len = SDL_strlen(lastError);
      SDLTest_AssertCheck(len == 0 || SDL_strcmp( lastError, "(null)" ) == 0,
              "SDL_GetError(): expected message len 0, was len: %i",
@@ -444,8 +439,7 @@ int platform_testSetErrorInvalidInput(void *arg)
    lastError = (char *)SDL_GetError();
    SDLTest_AssertCheck(lastError != NULL,
              "SDL_GetError() != NULL");
-   if (lastError != NULL)
-   {
+   if (lastError != NULL) {
      len = SDL_strlen(lastError);
      SDLTest_AssertCheck(len == SDL_strlen(probeError),
              "SDL_GetError(): expected message len %i, was len: %i",
@@ -493,8 +487,7 @@ int platform_testGetPowerInfo(void *arg)
        "SDL_GetPowerInfo(): state %i is one of the expected values",
        (int)state);
 
-   if (state==SDL_POWERSTATE_ON_BATTERY)
-   {
+   if (state==SDL_POWERSTATE_ON_BATTERY) {
       SDLTest_AssertCheck(
          secs >= 0,
          "SDL_GetPowerInfo(): on battery, secs >= 0, was: %i",
diff --git a/test/testautomation_rect.c b/test/testautomation_rect.c
index 729ff29d7..853f544b5 100644
--- a/test/testautomation_rect.c
+++ b/test/testautomation_rect.c
@@ -1009,10 +1009,18 @@ int rect_testEnclosePoints(void *arg)
             miny = newy;
             maxy = newy;
         } else {
-            if (newx < minx) minx = newx;
-            if (newx > maxx) maxx = newx;
-            if (newy < miny) miny = newy;
-            if (newy > maxy) maxy = newy;
+            if (newx < minx) {
+                minx = newx;
+            }
+            if (newx > maxx) {
+                maxx = newx;
+            }
+            if (newy < miny) {
+                miny = newy;
+            }
+            if (newy > maxy) {
+                maxy = newy;
+            }
         }
     }
 
@@ -1085,10 +1093,18 @@ int rect_testEnclosePointsRepeatedInput(void *arg)
             miny = newy;
             maxy = newy;
         } else {
-            if (newx < minx) minx = newx;
-            if (newx > maxx) maxx = newx;
-            if (newy < miny) miny = newy;
-            if (newy > maxy) maxy = newy;
+            if (newx < minx) {
+                minx = newx;
+            }
+            if (newx > maxx) {
+                maxx = newx;
+            }
+            if (newy < miny) {
+                miny = newy;
+            }
+            if (newy > maxy) {
+                maxy = newy;
+            }
         }
     }
 
@@ -1165,10 +1181,18 @@ int rect_testEnclosePointsWithClipping(void *arg)
                 miny = newy;
                 maxy = newy;
             } else {
-                if (newx < minx) minx = newx;
-                if (newx > maxx) maxx = newx;
-                if (newy < miny) miny = newy;
-                if (newy > maxy) maxy = newy;
+                if (newx < minx) {
+                    minx = newx;
+                }
+                if (newx > maxx) {
+                    maxx = newx;
+                }
+                if (newy < miny) {
+                    miny = newy;
+                }
+                if (newy > maxy) {
+                    maxy = newy;
+                }
             }
             expectedEnclosed = SDL_TRUE;
         }
@@ -1305,10 +1329,18 @@ int rect_testUnionRectOutside(void *arg)
                 refRectB.w=refRectA.w - 2;
                 refRectB.h=refRectA.h - 2;
                 expectedResult = refRectA;
-                if (dx == -1) expectedResult.x--;
-                if (dy == -1) expectedResult.y--;
-                if ((dx == 1) || (dx == -1)) expectedResult.w++;
-                if ((dy == 1) || (dy == -1)) expectedResult.h++;
+                if (dx == -1) {
+                    expectedResult.x--;
+                }
+                if (dy == -1) {
+                    expectedResult.y--;
+                }
+                if ((dx == 1) || (dx == -1)) {
+                    expectedResult.w++;
+                }
+                if ((dy == 1) || (dy == -1)) {
+                    expectedResult.h++;
+                }
                 rectA = refRectA;
                 rectB = refRectB;
                 SDL_UnionRect(&rectA, &rectB, &result);
@@ -1433,10 +1465,18 @@ int rect_testUnionRectInside(void *arg)
                 refRectA.w=SDLTest_RandomIntegerInRange(256, 1024);
                 refRectA.h=SDLTest_RandomIntegerInRange(256, 1024);
                 refRectB = refRectA;
-                if (dx == -1) refRectB.x++;
-                if ((dx == 1) || (dx == -1)) refRectB.w--;
-                if (dy == -1) refRectB.y++;
-                if ((dy == 1) || (dy == -1)) refRectB.h--;
+                if (dx == -1) {
+                    refRectB.x++;
+                }
+                if ((dx == 1) || (dx == -1)) {
+                    refRectB.w--;
+                }
+                if (dy == -1) {
+                    refRectB.y++;
+                }
+                if ((dy == 1) || (dy == -1)) {
+                    refRectB.h--;
+                }
                 expectedResult = refRectA;
                 rectA = refRectA;
                 rectB = refRectB;
diff --git a/test/testautomation_render.c b/test/testautomation_render.c
index 52da1bfe1..6989a022f 100644
--- a/test/testautomation_render.c
+++ b/test/testautomation_render.c
@@ -151,10 +151,14 @@ int render_testPrimitives (void *arg)
    for (y=0; y<3; y++) {
       for (x = y % 2; x<TESTRENDER_SCREEN_W; x+=2) {
          ret = SDL_SetRenderDrawColor(renderer, x*y, x*y/2, x*y/3, SDL_ALPHA_OPAQUE );
-         if (ret != 0) checkFailCount1++;
+         if (ret != 0) {
+            checkFailCount1++;
+         }
 
          ret = SDL_RenderDrawPoint(renderer, x, y );
-         if (ret != 0) checkFailCount2++;
+         if (ret != 0) {
+            checkFailCount2++;
+         }
       }
    }
    SDLTest_AssertCheck(checkFailCount1 == 0, "Validate results from calls to SDL_SetRenderDrawColor, expected: 0, got: %i", checkFailCount1);
@@ -281,16 +285,22 @@ int render_testPrimitivesBlend (void *arg)
    checkFailCount1 = 0;
    checkFailCount2 = 0;
    checkFailCount3 = 0;
-   for (i=0; i<TESTRENDER_SCREEN_W; i+=2)  {
+   for (i=0; i<TESTRENDER_SCREEN_W; i+=2) {
       ret = SDL_SetRenderDrawColor(renderer, 60+2*i, 240-2*i, 50, 3*i );
-      if (ret != 0) checkFailCount1++;
+      if (ret != 0) {
+         checkFailCount1++;
+      }
 
       ret = SDL_SetRenderDrawBlendMode(renderer,(((i/2)%3)==0) ? SDL_BLENDMODE_BLEND :
             (((i/2)%3)==1) ? SDL_BLENDMODE_ADD : SDL_BLENDMODE_NONE );
-      if (ret != 0) checkFailCount2++;
+      if (ret != 0) {
+         checkFailCount2++;
+      }
 
       ret = SDL_RenderDrawLine(renderer, 0, 0, i, 59 );
-      if (ret != 0) checkFailCount3++;
+      if (ret != 0) {
+         checkFailCount3++;
+      }
    }
    SDLTest_AssertCheck(checkFailCount1 == 0, "Validate results from calls to SDL_SetRenderDrawColor, expected: 0, got: %i", checkFailCount1);
    SDLTest_AssertCheck(checkFailCount2 == 0, "Validate results from calls to SDL_SetRenderDrawBlendMode, expected: 0, got: %i", checkFailCount2);
@@ -299,16 +309,22 @@ int render_testPrimitivesBlend (void *arg)
    checkFailCount1 = 0;
    checkFailCount2 = 0;
    checkFailCount3 = 0;
-   for (i=0; i<TESTRENDER_SCREEN_H; i+=2)  {
+   for (i=0; i<TESTRENDER_SCREEN_H; i+=2) {
       ret = SDL_SetRenderDrawColor(renderer, 60+2*i, 240-2*i, 50, 3*i );
-      if (ret != 0) checkFailCount1++;
+      if (ret != 0) {
+         checkFailCount1++;
+      }
 
       ret = SDL_SetRenderDrawBlendMode(renderer,(((i/2)%3)==0) ? SDL_BLENDMODE_BLEND :
             (((i/2)%3)==1) ? SDL_BLENDMODE_ADD : SDL_BLENDMODE_NONE );
-      if (ret != 0) checkFailCount2++;
+      if (ret != 0) {
+         checkFailCount2++;
+      }
 
       ret = SDL_RenderDrawLine(renderer, 0, 0, 79, i );
-      if (ret != 0) checkFailCount3++;
+      if (ret != 0) {
+         checkFailCount3++;
+      }
    }
    SDLTest_AssertCheck(checkFailCount1 == 0, "Validate results from calls to SDL_SetRenderDrawColor, expected: 0, got: %i", checkFailCount1);
    SDLTest_AssertCheck(checkFailCount2 == 0, "Validate results from calls to SDL_SetRenderDrawBlendMode, expected: 0, got: %i", checkFailCount2);
@@ -321,14 +337,20 @@ int render_testPrimitivesBlend (void *arg)
    for (j=0; j<TESTRENDER_SCREEN_H; j+=3) {
       for (i=0; i<TESTRENDER_SCREEN_W; i+=3) {
          ret = SDL_SetRenderDrawColor(renderer, j*4, i*3, j*4, i*3 );
-         if (ret != 0) checkFailCount1++;
+         if (ret != 0) {
+            checkFailCount1++;
+         }
 
          ret = SDL_SetRenderDrawBlendMode(renderer, ((((i+j)/3)%3)==0) ? SDL_BLENDMODE_BLEND :
                ((((i+j)/3)%3)==1) ? SDL_BLENDMODE_ADD : SDL_BLENDMODE_NONE );
-         if (ret != 0) checkFailCount2++;
+         if (ret != 0) {
+             checkFailCount2++;
+         }
 
          ret = SDL_RenderDrawPoint(renderer, i, j );
-         if (ret != 0) checkFailCount3++;
+         if (ret != 0) {
+             checkFailCount3++;
+         }
       }
    }
    SDLTest_AssertCheck(checkFailCount1 == 0, "Validate results from calls to SDL_SetRenderDrawColor, expected: 0, got: %i", checkFailCount1);
@@ -399,7 +421,9 @@ render_testBlit(void *arg)
          rect.x = i;
          rect.y = j;
          ret = SDL_RenderCopy(renderer, tface, NULL, &rect );
-         if (ret != 0) checkFailCount1++;
+         if (ret != 0) {
+            checkFailCount1++;
+         }
       }
    }
    SDLTest_AssertCheck(checkFailCount1 == 0, "Validate results from calls to SDL_RenderCopy, expected: 0, got: %i", checkFailCount1);
@@ -466,13 +490,17 @@ render_testBlitColor (void *arg)
       for (i=0; i <= ni; i+=4) {
          /* Set color mod. */
          ret = SDL_SetTextureColorMod( tface, (255/nj)*j, (255/ni)*i, (255/nj)*j );
-         if (ret != 0) checkFailCount1++;
+         if (ret != 0) {
+            checkFailCount1++;
+         }
 
          /* Blitting. */
          rect.x = i;
          rect.y = j;
          ret = SDL_RenderCopy(renderer, tface, NULL, &rect );
-         if (ret != 0) checkFailCount2++;
+         if (ret != 0) {
+            checkFailCount2++;
+         }
       }
    }
    SDLTest_AssertCheck(checkFailCount1 == 0, "Validate results from calls to SDL_SetTextureColorMod, expected: 0, got: %i", checkFailCount1);
@@ -543,13 +571,17 @@ render_testBlitAlpha (void *arg)
       for (i=0; i <= ni; i+=4) {
          /* Set alpha mod. */
          ret = SDL_SetTextureAlphaMod( tface, (255/ni)*i );
-         if (ret != 0) checkFailCount1++;
+         if (ret != 0) {
+            checkFailCount1++;
+         }
 
          /* Blitting. */
          rect.x = i;
          rect.y = j;
          ret = SDL_RenderCopy(renderer, tface, NULL, &rect );
-         if (ret != 0) checkFailCount2++;
+         if (ret != 0) {
+            checkFailCount2++;
+         }
       }
    }
    SDLTest_AssertCheck(checkFailCount1 == 0, "Validate results from calls to SDL_SetTextureAlphaMod, expected: 0, got: %i", checkFailCount1);
@@ -608,13 +640,17 @@ _testBlitBlendMode( SDL_Texture * tface, int mode )
       for (i=0; i <= ni; i+=4) {
          /* Set blend mode. */
          ret = SDL_SetTextureBlendMode( tface, (SDL_BlendMode)mode );
-         if (ret != 0) checkFailCount1++;
+         if (ret != 0) {
+            checkFailCount1++;
+         }
 
          /* Blitting. */
          rect.x = i;
          rect.y = j;
          ret = SDL_RenderCopy(renderer, tface, NULL, &rect );
-         if (ret != 0) checkFailCount2++;
+         if (ret != 0) {
+            checkFailCount2++;
+         }
       }
    }
    SDLTest_AssertCheck(checkFailCount1 == 0, "Validate results from calls to SDL_SetTextureBlendMode, expected: 0, got: %i", checkFailCount1);
@@ -727,26 +763,39 @@ render_testBlitBlend (void *arg)
 
          /* Set color mod. */
          ret = SDL_SetTextureColorMod( tface, (255/nj)*j, (255/ni)*i, (255/nj)*j );
-         if (ret != 0) checkFailCount1++;
+         if (ret != 0) {
+            checkFailCount1++;
+         }
 
          /* Set alpha mod. */
          ret = SDL_SetTextureAlphaMod( tface, (100/ni)*i );
-         if (ret != 0) checkFailCount2++;
+         if (ret != 0) {
+            checkFailCount2++;
+         }
 
          /* Crazy blending mode magic. */
          mode = (i/4*j/4) % 4;
-         if (mode==0) mode = SDL_BLENDMODE_NONE;
-         else if (mode==1) mode = SDL_BLENDMODE_BLEND;
-         else if (mode==2) mode = SDL_BLENDMODE_ADD;
-         else if (mode==3) mode = SDL_BLENDMODE_MOD;
+         if (mode==0) {
+            mode = SDL_BLENDMODE_NONE;
+         } else if (mode==1) {
+            mode = SDL_BLENDMODE_BLEND;
+         } else if (mode==2) {
+            mode = SDL_BLENDMODE_ADD;
+         } else if (mode == 3) {
+            mode = SDL_BLENDMODE_MOD;
+         }
          ret = SDL_SetTextureBlendMode( tface, (SDL_BlendMode)mode );
-         if (ret != 0) checkFailCount3++;
+         if (ret != 0) {
+            checkFailCount3++;
+         }
 
          /* Blitting. */
          rect.x = i;
          rect.y = j;
          ret = SDL_RenderCopy(renderer, tface, NULL, &rect );
-         if (ret != 0) checkFailCount4++;
+         if (ret != 0) {
+            checkFailCount4++;
+         }
       }
    }
    SDLTest_AssertCheck(checkFailCount1 == 0, "Validate results from calls to SDL_SetTextureColorMod, expected: 0, got: %i", checkFailCount1);
@@ -777,7 +826,7 @@ render_testBlitBlend (void *arg)
 static int
 _isSupported( int code )
 {
-   return (code == 0);
+   return code == 0;
 }
 
 /**
@@ -797,24 +846,28 @@ _hasDrawColor (void)
 
    /* Set color. */
    ret = SDL_SetRenderDrawColor(renderer, 100, 100, 100, 100 );
-   if (!_isSupported(ret))
+   if (!_isSupported(ret)) {
       fail = 1;
+   }
    ret = SDL_GetRenderDrawColor(renderer, &r, &g, &b, &a );
-   if (!_isSupported(ret))
+   if (!_isSupported(ret)) {
       fail = 1;
+   }
 
    /* Restore natural. */
    ret = SDL_SetRenderDrawColor(renderer, 0, 0, 0, SDL_ALPHA_OPAQUE );
-   if (!_isSupported(ret))
+   if (!_isSupported(ret)) {
       fail = 1;
+   }
 
    /* Something failed, consider not available. */
-   if (fail)
+   if (fail) {
       return 0;
-
+   }
    /* Not set properly, consider failed. */
-   else if ((r != 100) || (g != 100) || (b != 100) || (a != 100))
+   else if ((r != 100) || (g != 100) || (b != 100) || (a != 100)) {
       return 0;
+   }
    return 1;
 }
 
@@ -835,41 +888,53 @@ _hasBlendModes (void)
    fail = 0;
 
    ret = SDL_SetRenderDrawBlendMode(renderer, SDL_BLENDMODE_BLEND );
-   if (!_isSupported(ret))
+   if (!_isSupported(ret)) {
       fail = 1;
+   }
    ret = SDL_GetRenderDrawBlendMode(renderer, &mode );
-   if (!_isSupported(ret))
+   if (!_isSupported(ret)) {
       fail = 1;
+   }
    ret = (mode != SDL_BLENDMODE_BLEND);
-   if (!_isSupported(ret))
+   if (!_isSupported(ret)) {
       fail = 1;
+   }
    ret = SDL_SetRenderDrawBlendMode(renderer, SDL_BLENDMODE_ADD );
-   if (!_isSupported(ret))
+   if (!_isSupported(ret)) {
       fail = 1;
+   }
    ret = SDL_GetRenderDrawBlendMode(renderer, &mode );
-   if (!_isSupported(ret))
+   if (!_isSupported(ret)) {
       fail = 1;
+   }
    ret = (mode != SDL_BLENDMODE_ADD);
-   if (!_isSupported(ret))
+   if (!_isSupported(ret)) {
       fail = 1;
+   }
    ret = SDL_SetRenderDrawBlendMode(renderer, SDL_BLENDMODE_MOD );
-   if (!_isSupported(ret))
+   if (!_isSupported(ret)) {
       fail = 1;
+   }
    ret = SDL_GetRenderDrawBlendMode(renderer, &mode );
-   if (!_isSupported(ret))
+   if (!_isSupported(ret)) {
       fail = 1;
+   }
    ret = (mode != SDL_BLENDMODE_MOD);
-   if (!_isSupported(ret))
+   if (!_isSupported(ret)) {
       fail = 1;
+   }
    ret = SDL_SetRenderDrawBlendMode(renderer, SDL_BLENDMODE_NONE );
-   if (!_isSupported(ret))
+   if (!_isSupported(ret)) {
       fail = 1;
+   }
    ret = SDL_GetRenderDrawBlendMode(renderer, &mode );
-   if (!_isSupported(ret))
+   if (!_isSupported(ret)) {
       fail = 1;
+   }
    ret = (mode != SDL_BLENDMODE_NONE);
-   if (!_isSupported(ret))
+   if (!_isSupported(ret)) {
       fail = 1;
+   }
 
    return !fail;
 }
@@ -921,25 +986,29 @@ _hasTexColor (void)
 
    /* Get test face. */
    tface = _loadTestFace();
-   if (tface == NULL)
+   if (tface == NULL) {
       return 0;
+   }
 
    /* See if supported. */
    fail = 0;
    ret = SDL_SetTextureColorMod( tface, 100, 100, 100 );
-   if (!_isSupported(ret))
+   if (!_isSupported(ret)) {
       fail = 1;
+   }
    ret = SDL_GetTextureColorMod( tface, &r, &g, &b );
-   if (!_isSupported(ret))
+   if (!_isSupported(ret)) {
       fail = 1;
+   }
 
    /* Clean up. */
    SDL_DestroyTexture( tface );
 
-   if (fail)
+   if (fail) {
       return 0;
-   else if ((r != 100) || (g != 100) || (b != 100))
+   } else if ((r != 100) || (g != 100) || (b != 100)) {
       return 0;
+   }
    return 1;
 }
 
@@ -961,25 +1030,29 @@ _hasTexAlpha(void)
 
    /* Get test face. */
    tface = _loadTestFace();
-   if (tface == NULL)
+   if (tface == NULL) {
       return 0;
+   }
 
    /* See if supported. */
    fail = 0;
    ret = SDL_SetTextureAlphaMod( tface, 100 );
-   if (!_isSupported(ret))
+   if (!_isSupported(ret)) {
       fail = 1;
+   }
    ret = SDL_GetTextureAlphaMod( tface, &a );
-   if (!_isSupported(ret))
+   if (!_isSupported(ret)) {
       fail = 1;
+   }
 
    /* Clean up. */
    SDL_DestroyTexture( tface );
 
-   if (fail)
+   if (fail) {
       return 0;
-   else if (a != 100)
+   } else if (a != 100) {
       return 0;
+   }
    return 1;
 }
 
@@ -1004,7 +1077,9 @@ _compare(SDL_Surface *referenceSurface, int allowable_error)
    /* Read pixels. */
    pixels = (Uint8 *)SDL_malloc(4*TESTRENDER_SCREEN_W*TESTRENDER_SCREEN_H);
    SDLTest_AssertCheck(pixels != NULL, "Validate allocated temp pixel buffer");
-   if (pixels == NULL) return;
+   if (pixels == NULL) {
+      return;
+   }
 
    /* Explicitly specify the rect in case the window isn't the expected size... */
    rect.x = 0;
diff --git a/test/testautomation_rwops.c b/test/testautomation_rwops.c
index 687ff75de..200917afa 100644
--- a/test/testautomation_rwops.c
+++ b/test/testautomation_rwops.c
@@ -47,7 +47,9 @@ RWopsSetUp(void *arg)
     /* Create a test file */
     handle = fopen(RWopsReadTestFilename, "w");
     SDLTest_AssertCheck(handle != NULL, "Verify creation of file '%s' returned non NULL handle", RWopsReadTestFilename);
-        if (handle == NULL) return;
+        if (handle == NULL) {
+            return;
+    }
 
     /* Write some known text into it */
     fileLen = SDL_strlen(RWopsHelloWorldTestString);
@@ -59,7 +61,9 @@ RWopsSetUp(void *arg)
     /* Create a second test file */
     handle = fopen(RWopsAlphabetFilename, "w");
     SDLTest_AssertCheck(handle != NULL, "Verify creation of file '%s' returned non NULL handle", RWopsAlphabetFilename);
-        if (handle == NULL) return;
+        if (handle == NULL) {
+            return;
+    }
 
     /* Write alphabet text into it */
     fileLen = SDL_strlen(RWopsAlphabetString);
@@ -114,8 +118,7 @@ _testGenericRWopsValidations(SDL_RWops *rw, int write)
    SDLTest_AssertPass("Call to SDL_RWwrite succeeded");
    if (write) {
         SDLTest_AssertCheck(s == (size_t)1, "Verify result of writing one byte with SDL_RWwrite, expected 1, got %i", (int) s);
-   }
-   else {
+   } else {
         SDLTest_AssertCheck(s == (size_t)0, "Verify result of writing with SDL_RWwrite, expected: 0, got %i", (int) s);
    }
 
@@ -236,7 +239,9 @@ rwops_testMem (void)
    SDLTest_AssertCheck(rw != NULL, "Verify opening memory with SDL_RWFromMem does not return NULL");
 
    /* Bail out if NULL */
-   if (rw == NULL) return TEST_ABORTED;
+   if (rw == NULL) {
+      return TEST_ABORTED;
+   }
 
    /* Check type */
    SDLTest_AssertCheck(rw->type == SDL_RWOPS_MEMORY, "Verify RWops type is SDL_RWOPS_MEMORY; expected: %d, got: %" SDL_PRIu32, SDL_RWOPS_MEMORY, rw->type);
@@ -272,7 +277,9 @@ rwops_testConstMem (void)
    SDLTest_AssertCheck(rw != NULL, "Verify opening memory with SDL_RWFromConstMem does not return NULL");
 
    /* Bail out if NULL */
-   if (rw == NULL) return TEST_ABORTED;
+   if (rw == NULL) {
+      return TEST_ABORTED;
+   }
 
    /* Check type */
    SDLTest_AssertCheck(rw->type == SDL_RWOPS_MEMORY_RO, "Verify RWops type is SDL_RWOPS_MEMORY_RO; expected: %d, got: %" SDL_PRIu32, SDL_RWOPS_MEMORY_RO, rw->type);
@@ -308,7 +315,9 @@ rwops_testFileRead(void)
    SDLTest_AssertCheck(rw != NULL, "Verify opening file with SDL_RWFromFile in read mode does not return NULL");
 
    /* Bail out if NULL */
-   if (rw == NULL) return TEST_ABORTED;
+   if (rw == NULL) {
+      return TEST_ABORTED;
+   }
 
    /* Check type */
 #if defined(__ANDROID__)
@@ -355,7 +364,9 @@ rwops_testFileWrite(void)
    SDLTest_AssertCheck(rw != NULL, "Verify opening file with SDL_RWFromFile in write mode does not return NULL");
 
    /* Bail out if NULL */
-   if (rw == NULL) return TEST_ABORTED;
+   if (rw == NULL) {
+      return TEST_ABORTED;
+   }
 
    /* Check type */
 #if defined(__ANDROID__)
@@ -502,7 +513,9 @@ rwops_testAllocFree (void)
    SDL_RWops *rw = SDL_AllocRW();
    SDLTest_AssertPass("Call to SDL_AllocRW() succeeded");
    SDLTest_AssertCheck(rw != NULL, "Validate result from SDL_AllocRW() is not NULL");
-   if (rw==NULL) return TEST_ABORTED;
+   if (rw == NULL) {
+      return TEST_ABORTED;
+   }
 
    /* Check type */
    SDLTest_AssertCheck(
@@ -538,8 +551,7 @@ rwops_testCompareRWFromMemWithRWFromFile(void)
    int result;
 
 
-   for (size=5; size<10; size++)
-   {
+   for (size=5; size<10; size++) {
      /* Terminate buffer */
      buffer_file[slen] = 0;
      buffer_mem[slen] = 0;
@@ -652,7 +664,9 @@ rwops_testFileWriteReadEndian(void)
      SDLTest_AssertCheck(rw != NULL, "Verify opening file with SDL_RWFromFile in write mode does not return NULL");
 
      /* Bail out if NULL */
-     if (rw == NULL) return TEST_ABORTED;
+     if (rw == NULL) {
+        return TEST_ABORTED;
+     }
 
      /* Write test data */
      objectsWritten = SDL_WriteBE16(rw, BE16value);
diff --git a/test/testautomation_stdlib.c b/test/testautomation_stdlib.c
index 7abad3625..dca4d7c26 100644
--- a/test/testautomation_stdlib.c
+++ b/test/testautomation_stdlib.c
@@ -191,7 +191,7 @@ stdlib_getsetenv(void *arg)
   /* Create a random name. This tests SDL_getenv, since we need to */
   /* make sure the variable is not set yet (it shouldn't). */
   do {
-    for(counter = 0; counter < nameLen; counter++) {
+    for (counter = 0; counter < nameLen; counter++) {
       name[counter] = (char)SDLTest_RandomIntegerInRange(65, 90);
     }
     name[nameLen] = '\0';
diff --git a/test/testautomation_surface.c b/test/testautomation_surface.c
index 9b38066ef..5479c607f 100644
--- a/test/testautomation_surface.c
+++ b/test/testautomation_surface.c
@@ -110,12 +110,16 @@ void _testBlitBlendMode(int mode)
 
     /* Check test surface */
     SDLTest_AssertCheck(testSurface != NULL, "Verify testSurface is not NULL");
-    if (testSurface == NULL) return;
+    if (testSurface == NULL) {
+        return;
+    }
 
     /* Create sample surface */
     face = SDLTest_ImageFace();
     SDLTest_AssertCheck(face != NULL, "Verify face surface is not NULL");
-    if (face == NULL) return;
+    if (face == NULL) {
+        return;
+    }
 
         /* Reset alpha modulation */
     ret = SDL_SetSurfaceAlphaMod(face, 255);
@@ -160,14 +164,16 @@ void _testBlitBlendMode(int mode)
         if (mode == -2) {
             /* Set color mod. */
             ret = SDL_SetSurfaceColorMod( face, (255/nj)*j, (255/ni)*i, (255/nj)*j );
-            if (ret != 0) checkFailCount2++;
-        }
-        else if (mode == -3) {
+            if (ret != 0) {
+                checkFailCount2++;
+            }
+        } else if (mode == -3) {
             /* Set alpha mod. */
             ret = SDL_SetSurfaceAlphaMod( face, (255/ni)*i );
-            if (ret != 0) checkFailCount3++;
-        }
-        else if (mode == -4) {
+            if (ret != 0) {
+                checkFailCount3++;
+            }
+        } else if (mode == -4) {
             /* Crazy blending mode magic. */
             nmode = (i/4*j/4) % 4;
             if (nmode==0) {
@@ -184,14 +190,18 @@ void _testBlitBlendMode(int mode)
                 return;
             }
             ret = SDL_SetSurfaceBlendMode( face, bmode );
-            if (ret != 0) checkFailCount4++;
+            if (ret != 0) {
+                checkFailCount4++;
+            }
         }
 
          /* Blitting. */
          rect.x = i;
          rect.y = j;
          ret = SDL_BlitSurface( face, NULL, testSurface, &rect );
-         if (ret != 0) checkFailCount1++;
+         if (ret != 0) {
+            checkFailCount1++;
+         }
       }
     }
     SDLTest_AssertCheck(checkFailCount1 == 0, "Validate results from calls to SDL_BlitSurface, expected: 0, got: %i", checkFailCount1);
@@ -231,7 +241,9 @@ surface_testSaveLoadBitmap(void *arg)
     /* Create sample surface */
     face = SDLTest_ImageFace();
     SDLTest_AssertCheck(face != NULL, "Verify face surface is not NULL");
-    if (face == NULL) return TEST_ABORTED;
+    if (face == NULL) {
+        return TEST_ABORTED;
+    }
 
     /* Delete test file; ignore errors */
     unlink(sampleFilename);
@@ -275,8 +287,9 @@ surface_testSurfaceConversion(void *arg)
     /* Create sample surface */
     face = SDLTest_ImageFace();
     SDLTest_AssertCheck(face != NULL, "Verify face surface is not NULL");
-    if (face == NULL)
+    if (face == NULL) {
         return TEST_ABORTED;
+    }
 
     /* Set transparent pixel as the pixel at (0,0) */
     if (face->format->palette) {
@@ -346,8 +359,9 @@ surface_testCompleteSurfaceConversion(void *arg)
     /* Create sample surface */
     face = SDLTest_ImageFace();
     SDLTest_AssertCheck(face != NULL, "Verify face surface is not NULL");
-    if (face == NULL)
+    if (face == NULL) {
         return TEST_ABORTED;
+    }
 
     /* Set transparent pixel as the pixel at (0,0) */
     if (face->format->palette) {
@@ -756,8 +770,7 @@ surface_testOverflow(void *arg)
         SDLTest_AssertCheck(surface == NULL, "Should detect overflow in width * height * bytes per pixel");
         SDLTest_AssertCheck(SDL_strcmp(SDL_GetError(), expectedError) == 0,
                             "Expected \"%s\", got \"%s\"", expectedError, SDL_GetError());
-    }
-    else {
+    } else {
         SDLTest_Log("Can't easily overflow size_t on this platform");
     }
 
diff --git a/test/testautomation_video.c b/test/testautomation_video.c
index 8d248bf8f..fe8c4f095 100644
--- a/test/testautomation_video.c
+++ b/test/testautomation_video.c
@@ -836,7 +836,9 @@ video_getSetWindowGrab(void *arg)
 
   /* Call against new test window */
   window = _createVideoSuiteTestWindow(title);
-  if (window == NULL) return TEST_ABORTED;
+  if (window == NULL) {
+    return TEST_ABORTED;
+  }
 
   /* Get state */
   originalMouseState = SDL_GetWindowMouseGrab(window);
@@ -980,7 +982,9 @@ video_getWindowId(void *arg)
 
   /* Call against new test window */
   window = _createVideoSuiteTestWindow(title);
-  if (window == NULL) return TEST_ABORTED;
+  if (window == NULL) {
+    return TEST_ABORTED;
+  }
 
   /* Get ID */
   id = SDL_GetWindowID(window);
@@ -1034,7 +1038,9 @@ video_getWindowPixelFormat(void *arg)
 
   /* Call against new test window */
   window = _createVideoSuiteTestWindow(title);
-  if (window == NULL) return TEST_ABORTED;
+  if (window == NULL) {
+    return TEST_ABORTED;
+  }
 
   /* Get format */
   format = SDL_GetWindowPixelFormat(window);
@@ -1072,7 +1078,9 @@ video_getSetWindowPosition(void *arg)
 
   /* Call against new test window */
   window = _createVideoSuiteTestWindow(title);
-  if (window == NULL) return TEST_ABORTED;
+  if (window == NULL) {
+   return TEST_ABORTED;
+  }
 
   for (xVariation = 0; xVariation < 4; xVariation++) {
    for (yVariation = 0; yVariation < 4; yVariation++) {
@@ -1222,11 +1230,15 @@ video_getSetWindowSize(void *arg)
   result = SDL_GetDisplayBounds(0, &display);
   SDLTest_AssertPass("SDL_GetDisplayBounds()");
   SDLTest_AssertCheck(result == 0, "Verify return value; expected: 0, got: %d", result);
-  if (result != 0) return TEST_ABORTED;
+  if (result != 0) {
+   return TEST_ABORTED;
+  }
 
   /* Call against new test window */
   window = _createVideoSuiteTestWindow(title);
-  if (window == NULL) return TEST_ABORTED;
+  if (window == NULL) {
+   return TEST_ABORTED;
+  }
 
 #ifdef __WIN32__
   /* Platform clips window size to screen size */
@@ -1386,11 +1398,15 @@ video_getSetWindowMinimumSize(void *arg)
   result = SDL_GetDisplayBounds(0, &display);
   SDLTest_AssertPass("SDL_GetDisplayBounds()");
   SDLTest_AssertCheck(result == 0, "Verify return value; expected: 0, got: %d", result);
-  if (result != 0) return TEST_ABORTED;
+  if (result != 0) {
+   return TEST_ABORTED;
+  }
 
   /* Call against new test window */
   window = _createVideoSuiteTestWindow(title);
-  if (window == NULL) return TEST_ABORTED;
+  if (window == NULL) {
+   return TEST_ABORTED;
+  }
 
   for (wVariation = 0; wVariation < 5; wVariation++) {
    for (hVariation = 0; hVariation < 5; hVariation++) {
@@ -1525,11 +1541,15 @@ video_getSetWindowMaximumSize(void *arg)
   result = SDL_GetDisplayBounds(0, &display);
   SDLTest_AssertPass("SDL_GetDisplayBounds()");
   SDLTest_AssertCheck(result == 0, "Verify return value; expected: 0, got: %d", result);
-  if (result != 0) return TEST_ABORTED;
+  if (result != 0) {
+   return TEST_ABORTED;
+  }
 
   /* Call against new test window */
   window = _createVideoSuiteTestWindow(title);
-  if (window == NULL) return TEST_ABORTED;
+  if (window == NULL) {
+   return TEST_ABORTED;
+  }
 
   for (wVariation = 0; wVariation < 3; wVariation++) {
    for (hVariation = 0; hVariation < 3; hVariation++) {
@@ -1667,7 +1687,9 @@ video_getSetWindowData(void *arg)
 
   /* Call against new test window */
   window = _createVideoSuiteTestWindow(title);
-  if (window == NULL) return TEST_ABORTED;
+  if (window == NULL) {
+    return TEST_ABORTED;
+  }
 
   /* Create testdata */
   datasize = SDLTest_RandomIntegerInRange(1, 32);
@@ -1879,14 +1901,16 @@ video_setWindowCenteredOnDisplay(void *arg)
     result = SDL_GetDisplayBounds(0 % displayNum, &display0);
     SDLTest_AssertPass("SDL_GetDisplayBounds()");
     SDLTest_AssertCheck(result == 0, "Verify return value; expected: 0, got: %d", result);
-    if (result != 0)
+    if (result != 0) {
         return TEST_ABORTED;
+    }
 
     result = SDL_GetDisplayBounds(1 % displayNum, &display1);
     SDLTest_AssertPass("SDL_GetDisplayBounds()");
     SDLTest_AssertCheck(result == 0, "Verify return value; expected: 0, got: %d", result);
-    if (result != 0)
+    if (result != 0) {
         return TEST_ABORTED;
+    }
 
     for (xVariation = 0; xVariation < 2; xVariation++) {
         for (yVariation = 0; yVariation < 2; yVariation++) {
diff --git a/test/testcustomcursor.c b/test/testcustomcursor.c
index b3ffdbc42..d63a38a56 100644
--- a/test/testcustomcursor.c
+++ b/test/testcustomcursor.c
@@ -216,7 +216,7 @@ main(int argc, char *argv[])
 
     /* Initialize test framework */
     state = SDLTest_CommonCreateState(argv, SDL_INIT_VIDEO);
-    if (!state) {
+    if (state == NULL) {
         return 1;
     }
     for (i = 1; i < argc;) {
@@ -293,7 +293,7 @@ main(int argc, char *argv[])
     quit(0);
 
     /* keep the compiler happy ... */
-    return(0);
+    return 0;
 }
 
 /* vi: set ts=4 sw=4 expandtab: */
diff --git a/test/testdisplayinfo.c b/test/testdisplayinfo.c
index 297632c04..89cdbfd62 100644
--- a/test/testdisplayinfo.c
+++ b/test/testdisplayinfo.c
@@ -20,8 +20,9 @@
 static void
 print_mode(const char *prefix, const SDL_DisplayMode *mode)
 {
-    if (!mode)
+    if (mode == NULL) {
         return;
+    }
 
     SDL_Log("%s: fmt=%s w=%d h=%d refresh=%d\n",
             prefix, SDL_GetPixelFormatName(mode->format),
diff --git a/test/testdraw2.c b/test/testdraw2.c
index 0df5ba3ed..e4be559c1 100644
--- a/test/testdraw2.c
+++ b/test/testdraw2.c
@@ -190,8 +190,9 @@ loop()
     }
     for (i = 0; i < state->num_windows; ++i) {
         SDL_Renderer *renderer = state->renderers[i];
-        if (state->windows[i] == NULL)
+        if (state->windows[i] == NULL) {
             continue;
+        }
         SDL_SetRenderDrawColor(renderer, 0xA0, 0xA0, 0xA0, 0xFF);
         SDL_RenderClear(renderer);
 
@@ -232,7 +233,7 @@ main(int argc, char *argv[])
 
     /* Initialize test framework */
     state = SDLTest_CommonCreateState(argv, SDL_INIT_VIDEO);
-    if (!state) {
+    if (state == NULL) {
         return 1;
     }
     for (i = 1; i < argc;) {
diff --git a/test/testdrawchessboard.c b/test/testdrawchessboard.c
index f3636f389..682b5b732 100644
--- a/test/testdrawchessboard.c
+++ b/test/testdrawchessboard.c
@@ -37,11 +37,11 @@ DrawChessBoard()
     /* Get the Size of drawing surface */
     SDL_RenderGetViewport(renderer, &darea);
 
-    for( ; row < 8; row++)
+    for ( ; row < 8; row++)
     {
         column = row%2;
         x = column;
-        for( ; column < 4+(row%2); column++)
+        for ( ; column < 4+(row%2); column++)
         {
             SDL_SetRenderDrawColor(renderer, 0, 0, 0, 0xFF);
 
@@ -104,8 +104,7 @@ main(int argc, char *argv[])
     SDL_LogSetPriority(SDL_LOG_CATEGORY_APPLICATION, SDL_LOG_PRIORITY_INFO);
 
     /* Initialize SDL */
-    if(SDL_Init(SDL_INIT_VIDEO) != 0)
-    {
+    if (SDL_Init(SDL_INIT_VIDEO) != 0) {
         SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "SDL_Init fail : %s\n", SDL_GetError());
         return 1;
     }
@@ -113,15 +112,13 @@ main(int argc, char *argv[])
 
     /* Create window and renderer for given surface */
     window = SDL_CreateWindow("Chess Board", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, 640, 480, SDL_WINDOW_RESIZABLE);
-    if(!window)
-    {
+    if (window == NULL) {
         SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Window creation fail : %s\n",SDL_GetError());
         return 1;
     }
     surface = SDL_GetWindowSurface(window);
     renderer = SDL_CreateSoftwareRenderer(surface);
-    if(!renderer)
-    {
+    if (renderer == NULL) {
         SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Render creation for surface fail : %s\n",SDL_GetError());
         return 1;
     }
diff --git a/test/testdropfile.c b/test/testdropfile.c
index 95212472a..a2ce5f9a7 100644
--- a/test/testdropfile.c
+++ b/test/testdropfile.c
@@ -36,7 +36,7 @@ main(int argc, char *argv[])
 
     /* Initialize test framework */
     state = SDLTest_CommonCreateState(argv, SDL_INIT_VIDEO);
-    if (!state) {
+    if (state == NULL) {
         return 1;
     }
 
@@ -93,7 +93,7 @@ main(int argc, char *argv[])
 
     quit(0);
     /* keep the compiler happy ... */
-    return(0);
+    return 0;
 }
 
 /* vi: set ts=4 sw=4 expandtab: */
diff --git a/test/testerror.c b/test/testerror.c
index c118abdee..8992ad591 100644
--- a/test/testerror.c
+++ b/test/testerror.c
@@ -38,7 +38,7 @@ ThreadFunc(void *data)
         SDL_Delay(1 * 1000);
     }
     SDL_Log("Child thread error string: %s\n", SDL_GetError());
-    return (0);
+    return 0;
 }
 
 int
@@ -52,7 +52,7 @@ main(int argc, char *argv[])
     /* Load the SDL library */
     if (SDL_Init(0) < 0) {
         SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Couldn't initialize SDL: %s\n", SDL_GetError());
-        return (1);
+        return 1;
     }
 
     /* Set the error value for the main thread */
@@ -78,5 +78,5 @@ main(int argc, char *argv[])
     SDL_Log("Main thread error string: %s\n", SDL_GetError());
 
     SDL_Quit();
-    return (0);
+    return 0;
 }
diff --git a/test/testevdev.c b/test/testevdev.c
index 22465ff81..b762f23f0 100644
--- a/test/testevdev.c
+++ b/test/testevdev.c
@@ -998,8 +998,7 @@ run_test(void)
 
         if (actual == t->expected) {
             printf("\tOK\n");
-        }
-        else {
+        } else {
             printf("\tExpected 0x%08x\n", t->expected);
 
             for (j = 0; device_classes[j].code != 0; j++) {
diff --git a/test/testfile.c b/test/testfile.c
index 25a309201..752cddb6f 100644
--- a/test/testfile.c
+++ b/test/testfile.c
@@ -76,20 +76,25 @@ main(int argc, char *argv[])
 /* test 1 : basic argument test: all those calls to SDL_RWFromFile should fail */
 
     rwops = SDL_RWFromFile(NULL, NULL);
-    if (rwops)
+    if (rwops) {
         RWOP_ERR_QUIT(rwops);
+    }
     rwops = SDL_RWFromFile(NULL, "ab+");
-    if (rwops)
+    if (rwops) {
         RWOP_ERR_QUIT(rwops);
+    }
     rwops = SDL_RWFromFile(NULL, "sldfkjsldkfj");
-    if (rwops)
+    if (rwops) {
         RWOP_ERR_QUIT(rwops);
+    }
     rwops = SDL_RWFromFile("something", "");
-    if (rwops)
+    if (rwops) {
         RWOP_ERR_QUIT(rwops);
+    }
     rwops = SDL_RWFromFile("something", NULL);
-    if (rwops)
+    if (rwops) {
         RWOP_ERR_QUIT(rwops);
+    }
     SDL_Log("test1 OK\n");
 
 /* test 2 : check that inexistent file is not successfully opened/created when required */
@@ -98,29 +103,35 @@ main(int argc, char *argv[])
 
  */
     rwops = SDL_RWFromFile(FBASENAME2, "rb");   /* this file doesn't exist that call must fail */
-    if (rwops)
+    if (rwops) {
         RWOP_ERR_QUIT(rwops);
+    }
     rwops = SDL_RWFromFile(FBASENAME2, "rb+");  /* this file doesn't exist that call must fail */
-    if (rwops)
+    if (rwops) {
         RWOP_ERR_QUIT(rwops);
+    }
     rwops = SDL_RWFromFile(FBASENAME2, "wb");
-    if (!rwops)
+    if (rwops == NULL) {
         RWOP_ERR_QUIT(rwops);
+    }
     rwops->close(rwops);
     unlink(FBASENAME2);
     rwops = SDL_RWFromFile(FBASENAME2, "wb+");
-    if (!rwops)
+    if (rwops == NULL) {
         RWOP_ERR_QUIT(rwops);
+    }
     rwops->close(rwops);
     unlink(FBASENAME2);
     rwops = SDL_RWFromFile(FBASENAME2, "ab");
-    if (!rwops)
+    if (rwops == NULL) {
         RWOP_ERR_QUIT(rwops);
+    }
     rwops->close(rwops);
     unlink(FBASENAME2);
     rwops = SDL_RWFromFile(FBASENAME2, "ab+");
-    if (!rwops)
+    if (rwops == NULL) {
         RWOP_ERR_QUIT(rwops);
+    }
     rwops->close(rwops);
     unlink(FBASENAME2);
     SDL_Log("test2 OK\n");
@@ -129,153 +140,220 @@ main(int argc, char *argv[])
             test : w mode, r mode, w+ mode
  */
     rwops = SDL_RWFromFile(FBASENAME1, "wb");   /* write only */
-    if (!rwops)
+    if (rwops == NULL) {
         RWOP_ERR_QUIT(rwops);
-    if (1 != rwops->write(rwops, "1234567890", 10, 1))
+    }
+    if (1 != rwops->write(rwops, "1234567890", 10, 1)) {
         RWOP_ERR_QUIT(rwops);
-    if (10 != rwops->write(rwops, "1234567890", 1, 10))
+    }
+    if (10 != rwops->write(rwops, "1234567890", 1, 10)) {
         RWOP_ERR_QUIT(rwops);
-    if (7 != rwops->write(rwops, "1234567", 1, 7))
+    }
+    if (7 != rwops->write(rwops, "1234567", 1, 7)) {
         RWOP_ERR_QUIT(rwops);
-    if (0 != rwops->seek(rwops, 0L, RW_SEEK_SET))
+    }
+    if (0 != rwops->seek(rwops, 0L, RW_SEEK_SET)) {
         RWOP_ERR_QUIT(rwops);
-    if (0 != rwops->read(rwops, test_buf, 1, 1))
-        RWOP_ERR_QUIT(rwops);   /* we are in write only mode */
+    }
+    if (0 != rwops->read(rwops, test_buf, 1, 1)) {
+        RWOP_ERR_QUIT(rwops); /* we are in write only mode */
+    } 
+
     rwops->close(rwops);
 
     rwops = SDL_RWFromFile(FBASENAME1, "rb");   /* read mode, file must exists */
-    if (!rwops)
+    if (rwops == NULL) {
         RWOP_ERR_QUIT(rwops);
-    if (0 != rwops->seek(rwops, 0L, RW_SEEK_SET))
+    }
+    if (0 != rwops->seek(rwops, 0L, RW_SEEK_SET)) {
         RWOP_ERR_QUIT(rwops);
-    if (20 != rwops->seek(rwops, -7, RW_SEEK_END))
+    }
+    if (20 != rwops->seek(rwops, -7, RW_SEEK_END)) {
         RWOP_ERR_QUIT(rwops);
-    if (7 != rwops->read(rwops, test_buf, 1, 7))
+    }
+    if (7 != rwops->read(rwops, test_buf, 1, 7)) {
         RWOP_ERR_QUIT(rwops);
-    if (SDL_memcmp(test_buf, "1234567", 7))
+    }
+    if (SDL_memcmp(test_buf, "1234567", 7)) {
         RWOP_ERR_QUIT(rwops);
-    if (0 != rwops->read(rwops, test_buf, 1, 1))
+    }
+    if (0 != rwops->read(rwops, test_buf, 1, 1)) {
         RWOP_ERR_QUIT(rwops);
-    if (0 != rwops->read(rwops, test_buf, 10, 100))
+    }
+    if (0 != rwops->read(rwops, test_buf, 10, 100)) {
         RWOP_ERR_QUIT(rwops);
-    if (0 != rwops->seek(rwops, -27, RW_SEEK_CUR))
+    }
+    if (0 != rwops->seek(rwops, -27, RW_SEEK_CUR)) {
         RWOP_ERR_QUIT(rwops);
-    if (2 != rwops->read(rwops, test_buf, 10, 3))
+    }
+    if (2 != rwops->read(rwops, test_buf, 10, 3)) {
         RWOP_ERR_QUIT(rwops);
-    if (SDL_memcmp(test_buf, "12345678901234567890", 20))
+    }
+    if (SDL_memcmp(test_buf, "12345678901234567890", 20)) {
         RWOP_ERR_QUIT(rwops);
-    if (0 != rwops->write(rwops, test_buf, 1, 1))
-        RWOP_ERR_QUIT(rwops);   /* readonly mode */
+    }
+    if (0 != rwops->write(rwops, test_buf, 1, 1)) {
+        RWOP_ERR_QUIT(rwops); /* readonly mode */
+    }
+
     rwops->close(rwops);
 
 /* test 3: same with w+ mode */
     rwops = SDL_RWFromFile(FBASENAME1, "wb+");  /* write + read + truncation */
-    if (!rwops)
+    if (rwops == NULL) {
         RWOP_ERR_QUIT(rwops);
-    if (1 != rwops->write(rwops, "1234567890", 10, 1))
+    }
+    if (1 != rwops->write(rwops, "1234567890", 10, 1)) {
         RWOP_ERR_QUIT(rwops);
-    if (10 != rwops->write(rwops, "1234567890", 1, 10))
+    }
+    if (10 != rwops->write(rwops, "1234567890", 1, 10)) {
         RWOP_ERR_QUIT(rwops);
-    if (7 != rwops->write(rwops, "1234567", 1, 7))
+    }
+    if (7 != rwops->write(rwops, "1234567", 1, 7)) {
         RWOP_ERR_QUIT(rwops);
-    if (0 != rwops->seek(rwops, 0L, RW_SEEK_SET))
+    }
+    if (0 != rwops->seek(rwops, 0L, RW_SEEK_SET)) {
         RWOP_ERR_QUIT(rwops);
-    if (1 != rwops->read(rwops, test_buf, 1, 1))
-        RWOP_ERR_QUIT(rwops);   /* we are in read/write mode */
-    if (0 != rwops->seek(rwops, 0L, RW_SEEK_SET))
+    }
+    if (1 != rwops->read(rwops, test_buf, 1, 1)) {
+        RWOP_ERR_QUIT(rwops); /* we are in read/write mode */
+    }
+
+    if (0 != rwops->seek(rwops, 0L, RW_SEEK_SET)) {
         RWOP_ERR_QUIT(rwops);
-    if (20 != rwops->seek(rwops, -7, RW_SEEK_END))
+    }
+    if (20 != rwops->seek(rwops, -7, RW_SEEK_END)) {
         RWOP_ERR_QUIT(rwops);
-    if (7 != rwops->read(rwops, test_buf, 1, 7))
+    }
+    if (7 != rwops->read(rwops, test_buf, 1, 7)) {
         RWOP_ERR_QUIT(rwops);
-    if (SDL_memcmp(test_buf, "1234567", 7))
+    }
+    if (SDL_memcmp(test_buf, "1234567", 7)) {
         RWOP_ERR_QUIT(rwops);
-    if (0 != rwops->read(rwops, test_buf, 1, 1))
+    }
+    if (0 != rwops->read(rwops, test_buf, 1, 1)) {
         RWOP_ERR_QUIT(rwops);
-    if (0 != rwops->read(rwops, test_buf, 10, 100))
+    }
+    if (0 != rwops->read(rwops, test_buf, 10, 100)) {
         RWOP_ERR_QUIT(rwops);
-    if (0 != rwops->seek(rwops, -27, RW_SEEK_CUR))
+    }
+    if (0 != rwops->seek(rwops, -27, RW_SEEK_CUR)) {
         RWOP_ERR_QUIT(rwops);
-    if (2 != rwops->read(rwops, test_buf, 10, 3))
+    }
+    if (2 != rwops->read(rwops, test_buf, 10, 3)) {
         RWOP_ERR_QUIT(rwops);
-    if (SDL_memcmp(test_buf, "12345678901234567890", 20))
+    }
+    if (SDL_memcmp(test_buf, "12345678901234567890", 20)) {
         RWOP_ERR_QUIT(rwops);
+    }
     rwops->close(rwops);
     SDL_Log("test3 OK\n");
 
 /* test 4: same in r+ mode */
     rwops = SDL_RWFromFile(FBASENAME1, "rb+");  /* write + read + file must exists, no truncation */
-    if (!rwops)
+    if (rwops == NULL) {
         RWOP_ERR_QUIT(rwops);
-    if (1 != rwops->write(rwops, "1234567890", 10, 1))
+    }
+    if (1 != rwops->write(rwops, "1234567890", 10, 1)) {
         RWOP_ERR_QUIT(rwops);
-    if (10 != rwops->write(rwops, "1234567890", 1, 10))
+    }
+    if (10 != rwops->write(rwops, "1234567890", 1, 10)) {
         RWOP_ERR_QUIT(rwops);
-    if (7 != rwops->write(rwops, "1234567", 1, 7))
+    }
+    if (7 != rwops->write(rwops, "1234567", 1, 7)) {
         RWOP_ERR_QUIT(rwops);
-    if (0 != rwops->seek(rwops, 0L, RW_SEEK_SET))
+    }
+    if (0 != rwops->seek(rwops, 0L, RW_SEEK_SET)) {
         RWOP_ERR_QUIT(rwops);
-    if (1 != rwops->read(rwops, test_buf, 1, 1))
-        RWOP_ERR_QUIT(rwops);   /* we are in read/write mode */
-    if (0 != rwops->seek(rwops, 0L, RW_SEEK_SET))
+    }
+    if (1 != rwops->read(rwops, test_buf, 1, 1)) {
+        RWOP_ERR_QUIT(rwops); /* we are in read/write mode */
+    }
+
+    if (0 != rwops->seek(rwops, 0L, RW_SEEK_SET)) {
         RWOP_ERR_QUIT(rwops);
-    if (20 != rwops->seek(rwops, -7, RW_SEEK_END))
+    }
+    if (20 != rwops->seek(rwops, -7, RW_SEEK_END)) {
         RWOP_ERR_QUIT(rwops);
-    if (7 != rwops->read(rwops, test_buf, 1, 7))
+    }
+    if (7 != rwops->read(rwops, test_buf, 1, 7)) {
         RWOP_ERR_QUIT(rwops);
-    if (SDL_memcmp(test_buf, "1234567", 7))
+    }
+    if (SDL_memcmp(test_buf, "1234567", 7)) {
         RWOP_ERR_QUIT(rwops);
-    if (0 != rwops->read(rwops, test_buf, 1, 1))
+    }
+    if (0 != rwops->read(rwops, test_buf, 1, 1)) {
         RWOP_ERR_QUIT(rwops);
-    if (0 != rwops->read(rwops, test_buf, 10, 100))
+    }
+    if (0 != rwops->read(rwops, test_buf, 10, 100)) {
         RWOP_ERR_QUIT(rwops);
-    if (0 != rwops->seek(rwops, -27, RW_SEEK_CUR))
+    }
+    if (0 != rwops->seek(rwops, -27, RW_SEEK_CUR)) {
         RWOP_ERR_QUIT(rwops);
-    if (2 != rwops->read(rwops, test_buf, 10, 3))
+    }
+    if (2 != rwops->read(rwops, test_buf, 10, 3)) {
         RWOP_ERR_QUIT(rwops);
-    if (SDL_memcmp(test_buf, "12345678901234567890", 20))
+    }
+    if (SDL_memcmp(test_buf, "12345678901234567890", 20)) {
         RWOP_ERR_QUIT(rwops);
+    }
     rwops->close(rwops);
     SDL_Log("test4 OK\n");
 
 /* test5 : append mode */
     rwops = SDL_RWFromFile(FBASENAME1, "ab+");  /* write + read + append */
-    if (!rwops)
+    if (rwops == NULL) {
         RWOP_ERR_QUIT(rwops);
-    if (1 != rwops->write(rwops, "1234567890", 10, 1))
+    }
+    if (1 != rwops->write(rwops, "1234567890", 10, 1)) {
         RWOP_ERR_QUIT(rwops);
-    if (10 != rwops->write(rwops, "1234567890", 1, 10))
+    }
+    if (10 != rwops->write(rwops, "1234567890", 1, 10)) {
         RWOP_ERR_QUIT(rwops);
-    if (7 != rwops->write(rwops, "1234567", 1, 7))
+    }
+    if (7 != rwops->write(rwops, "1234567", 1, 7)) {
         RWOP_ERR_QUIT(rwops);
-    if (0 != rwops->seek(rwops, 0L, RW_SEEK_SET))
+    }
+    if (0 != rwops->seek(rwops, 0L, RW_SEEK_SET)) {
         RWOP_ERR_QUIT(rwops);
+    }
 
-    if (1 != rwops->read(rwops, test_buf, 1, 1))
+    if (1 != rwops->read(rwops, test_buf, 1, 1)) {
         RWOP_ERR_QUIT(rwops);
-    if (0 != rwops->seek(rwops, 0L, RW_SEEK_SET))
+    }
+    if (0 != rwops->seek(rwops, 0L, RW_SEEK_SET)) {
         RWOP_ERR_QUIT(rwops);
+    }
 
-    if (20 + 27 != rwops->seek(rwops, -7, RW_SEEK_END))
+    if (20 + 27 != rwops->seek(rwops, -7, RW_SEEK_END)) {
         RWOP_ERR_QUIT(rwops);
-    if (7 != rwops->read(rwops, test_buf, 1, 7))
+    }
+    if (7 != rwops->read(rwops, test_buf, 1, 7)) {
         RWOP_ERR_QUIT(rwops);
-    if (SDL_memcmp(test_buf, "1234567", 7))
+    }
+    if (SDL_memcmp(test_buf, "1234567", 7)) {
         RWOP_ERR_QUIT(rwops);
-    if (0 != rwops->read(rwops, test_buf, 1, 1))
+    }
+    if (0 != rwops->read(rwops, test_buf, 1, 1)) {
         RWOP_ERR_QUIT(rwops);
-    if (0 != rwops->read(rwops, test_buf, 10, 100))
+    }
+    if (0 != rwops->read(rwops, test_buf, 10, 100)) {
         RWOP_ERR_QUIT(rwops);
+    }
 
-    if (27 != rwops->seek(rwops, -27, RW_SEEK_CUR))
+    if (27 != rwops->seek(rwops, -27, RW_SEEK_CUR)) {
         RWOP_ERR_QUIT(rwops);
+    }
 
-    if (0 != rwops->seek(rwops, 0L, RW_SEEK_SET))
+    if (0 != rwops->seek(rwops, 0L, RW_SEEK_SET)) {
         RWOP_ERR_QUIT(rwops);
-    if (3 != rwops->read(rwops, test_buf, 10, 3))
+    }
+    if (3 != rwops->read(rwops, test_buf, 10, 3)) {
         RWOP_ERR_QUIT(rwops);
-    if (SDL_memcmp(test_buf, "123456789012345678901234567123", 30))
+    }
+    if (SDL_memcmp(test_buf, "123456789012345678901234567123", 30)) {
         RWOP_ERR_QUIT(rwops);
+    }
     rwops->close(rwops);
     SDL_Log("test5 OK\n");
     cleanup();
diff --git a/test/testfilesystem.c b/test/testfilesystem.c
index d60308d0f..2f1e494b3 100644
--- a/test/testfilesystem.c
+++ b/test/testfilesystem.c
@@ -29,7 +29,7 @@ main(int argc, char *argv[])
     }
 
     base_path = SDL_GetBasePath();
-    if(base_path == NULL){
+    if (base_path == NULL) {
       SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Couldn't find base path: %s\n",
                    SDL_GetError());
     } else {
@@ -38,7 +38,7 @@ main(int argc, char *argv[])
     }
 
     pref_path = SDL_GetPrefPath("libsdl", "test_filesystem");
-    if(pref_path == NULL){
+    if (pref_path == NULL) {
       SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Couldn't find pref path: %s\n",
                    SDL_GetError());
     } else {
@@ -47,7 +47,7 @@ main(int argc, char *argv[])
     }
 
     pref_path = SDL_GetPrefPath(NULL, "test_filesystem");
-    if(pref_path == NULL){
+    if (pref_path == NULL) {
       SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Couldn't find pref path without organization: %s\n",
                    SDL_GetError());
     } else {
diff --git a/test/testgamecontroller.c b/test/testgamecontroller.c
index 053bea023..56245ad13 100644
--- a/test/testgamecontroller.c
+++ b/test/testgamecontroller.c
@@ -98,7 +98,7 @@ static SDL_GameControllerButton virtual_button_active = SDL_CONTROLLER_BUTTON_IN
 
 static void UpdateWindowTitle()
 {
-    if (!window) {
+    if (window == NULL) {
         return;
     }
 
@@ -190,13 +190,13 @@ static void AddController(int device_index, SDL_bool verbose)
     }
 
     controller = SDL_GameControllerOpen(device_index);
-    if (!controller) {
+    if (controller == NULL) {
         SDL_Log("Couldn't open controller: %s\n", SDL_GetError());
         return;
     }
 
     controllers = (SDL_GameController **)SDL_realloc(gamecontrollers, (num_controllers + 1) * sizeof(*controllers));
-    if (!controllers) {
+    if (controllers == NULL) {
         SDL_GameControllerClose(controller);
         return;
     }
@@ -403,7 +403,7 @@ static void OpenVirtualController()
         SDL_Log("Couldn't open virtual device: %s\n", SDL_GetError());
     } else {
         virtual_joystick = SDL_JoystickOpen(virtual_index);
-        if (!virtual_joystick) {
+        if (virtual_joystick == NULL) {
             SDL_Log("Couldn't open virtual device: %s\n", SDL_GetError());
         }
     }
@@ -912,7 +912,7 @@ main(int argc, char *argv[])
     button_texture = LoadTexture(screen, "button.bmp", SDL_TRUE, NULL, NULL);
     axis_texture = LoadTexture(screen, "axis.bmp", SDL_TRUE, NULL, NULL);
 
-    if (!background_front || !background_back || !button_texture || !axis_texture) {
+    if (background_front == NULL || background_back == NULL || button_texture == NULL || axis_texture == NULL) {
         SDL_DestroyRenderer(screen);
         SDL_DestroyWindow(window);
         return 2;
diff --git a/test/testgeometry.c b/test/testgeometry.c
index fa8de7542..39e450a16 100644
--- a/test/testgeometry.c
+++ b/test/testgeometry.c
@@ -50,17 +50,17 @@ LoadSprite(const char *file)
         /* This does the SDL_LoadBMP step repeatedly, but that's OK for test code. */
         sprites[i] = LoadTexture(state->renderers[i], file, SDL_TRUE, &sprite_w, &sprite_h);
         if (!sprites[i]) {
-            return (-1);
+            return -1;
         }
         if (SDL_SetTextureBlendMode(sprites[i], blendMode) < 0) {
             SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Couldn't set blend mode: %s\n", SDL_GetError());
             SDL_DestroyTexture(sprites[i]);
-            return (-1);
+            return -1;
         }
     }
 
     /* We're ready to roll. :) */
-    return (0);
+    return 0;
 }
 
 
@@ -99,8 +99,9 @@ loop()
 
     for (i = 0; i < state->num_windows; ++i) {
         SDL_Renderer *renderer = state->renderers[i];
-        if (state->windows[i] == NULL)
+        if (state->windows[i] == NULL) {
             continue;
+        }
         SDL_SetRenderDrawColor(renderer, 0xA0, 0xA0, 0xA0, 0xFF);
         SDL_RenderClear(renderer);
 
@@ -175,7 +176,7 @@ main(int argc, char *argv[])
 
     /* Initialize test framework */
     state = SDLTest_CommonCreateState(argv, SDL_INIT_VIDEO);
-    if (!state) {
+    if (state == NULL) {
         return 1;
     }
     for (i = 1; i < argc;) {
@@ -219,7 +220,7 @@ main(int argc, char *argv[])
     /* Create the windows, initialize the renderers, and load the textures */
     sprites =
         (SDL_Texture **) SDL_malloc(state->num_windows * sizeof(*sprites));
-    if (!sprites) {
+    if (sprites == NULL) {
         SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Out of memory!\n");
         quit(2);
     }
diff --git a/test/testgesture.c b/test/testgesture.c
index 856fd6a2d..9a2d7bf6b 100644
--- a/test/testgesture.c
+++ b/test/testgesture.c
@@ -108,7 +108,7 @@ drawCircle(SDL_Surface *screen, float x, float y, float r, unsigned int c)
     for (ty = (float) -SDL_fabs(r); ty <= (float) SDL_fabs((int) r); ty++) {
         xr = (float) SDL_sqrt(r * r - ty * ty);
         if (r > 0) { /* r > 0 ==> filled circle */
-            for(tx = -xr + 0.5f; tx <= xr - 0.5f; tx++) {
+            for (tx = -xr + 0.5f; tx <= xr - 0.5f; tx++) {
                 setpix(screen, x + tx, y + ty, c);
             }
         } else {
@@ -132,7 +132,7 @@ DrawScreen(SDL_Window *window)
     SDL_Surface *screen = SDL_GetWindowSurface(window);
     int i;
 
-    if (!screen) {
+    if (screen == NULL) {
         return;
     }
 
@@ -272,7 +272,7 @@ loop(void)
 int main(int argc, char* argv[])
 {
     state = SDLTest_CommonCreateState(argv, SDL_INIT_VIDEO);
-    if (!state) {
+    if (state == NULL) {
         return 1;
     }
 
diff --git a/test/testgl2.c b/test/testgl2.c
index f259ddc93..9bc3ec6bd 100644
--- a/test/testgl2.c
+++ b/test/testgl2.c
@@ -229,7 +229,7 @@ main(int argc, char *argv[])
 
     /* Initialize test framework */
     state = SDLTest_CommonCreateState(argv, SDL_INIT_VIDEO);
-    if (!state) {
+    if (state == NULL) {
         return 1;
     }
     for (i = 1; i < argc;) {
@@ -405,8 +405,9 @@ main(int argc, char *argv[])
 
         for (i = 0; i < state->num_windows; ++i) {
             int w, h;
-            if (state->windows[i] == NULL)
+            if (state->windows[i] == NULL) {
                 continue;
+            }
             SDL_GL_MakeCurrent(state->windows[i], context);
             if (update_swap_interval) {
                 SDL_GL_SetSwapInterval(swap_interval);
diff --git a/test/testgles.c b/test/testgles.c
index 745cf8919..1cd09b660 100644
--- a/test/testgles.c
+++ b/test/testgles.c
@@ -119,7 +119,7 @@ main(int argc, char *argv[])
 
     /* Initialize test framework */
     state = SDLTest_CommonCreateState(argv, SDL_INIT_VIDEO);
-    if (!state) {
+    if (state == NULL) {
         return 1;
     }
     for (i = 1; i < argc;) {
@@ -315,8 +315,9 @@ main(int argc, char *argv[])
             SDLTest_CommonEvent(state, &event, &done);
         }
         for (i = 0; i < state->num_windows; ++i) {
-            if (state->windows[i] == NULL)
+            if (state->windows[i] == NULL) {
                 continue;
+            }
             status = SDL_GL_MakeCurrent(state->windows[i], context[i]);
             if (status) {
                 SDL_Log("SDL_GL_MakeCurrent(): %s\n", SDL_GetError());
diff --git a/test/testgles2.c b/test/testgles2.c
index 903f7a822..45e7471cf 100644
--- a/test/testgles2.c
+++ b/test/testgles2.c
@@ -114,7 +114,7 @@ quit(int rc)
         x; \
         { \
           GLenum glError = ctx.glGetError(); \
-          if(glError != GL_NO_ERROR) { \
+          if (glError != GL_NO_ERROR) { \
             SDL_Log("glGetError() = %i (0x%.8x) at line %i\n", glError, glError, __LINE__); \
             quit(1); \
           } \
@@ -239,7 +239,7 @@ process_shader(GLuint *shader, const char * source, GLint shader_type)
     GL_CHECK(ctx.glGetShaderiv(*shader, GL_COMPILE_STATUS, &status));
 
     /* Dump debug info (source and log) if compilation failed. */
-    if(status != GL_TRUE) {
+    if (status != GL_TRUE) {
         ctx.glGetShaderInfoLog(*shader, sizeof(buffer), &length, &buffer[0]);
         buffer[length] = '\0';
         SDL_Log("Shader compilation failed: %s", buffer);
@@ -260,7 +260,7 @@ link_program(struct shader_data *data)
     GL_CHECK(ctx.glLinkProgram(data->shader_program));
     GL_CHECK(ctx.glGetProgramiv(data->shader_program, GL_LINK_STATUS, &status));
 
-    if(status != GL_TRUE) {
+    if (status != GL_TRUE) {
          ctx.glGetProgramInfoLog(data->shader_program, sizeof(buffer), &length, &buffer[0]);
          buffer[length] = '\0';
          SDL_Log("Program linking failed: %s", buffer);
@@ -434,12 +434,24 @@ Render(unsigned int width, unsigned int height, shader_data* data)
     data->angle_y += 2;
     data->angle_z += 1;
 
-    if(data->angle_x >= 360) data->angle_x -= 360;
-    if(data->angle_x < 0) data->angle_x += 360;
-    if(data->angle_y >= 360) data->angle_y -= 360;
-    if(data->angle_y < 0) data->angle_y += 360;
-    if(data->angle_z >= 360) data->angle_z -= 360;
-    if(data->angle_z < 0) data->angle_z += 360;
+    if (data->angle_x >= 360) {
+        data->angle_x -= 360;
+    }
+    if (data->angle_x < 0) {
+        data->angle_x += 360;
+    }
+    if (data->angle_y >= 360) {
+        data->angle_y -= 360;
+    }
+    if (data->angle_y < 0) {
+        data->angle_y += 360;
+    }
+    if (data->angle_z >= 360) {
+        data->angle_z -= 360;
+    }
+    if (data->angle_z < 0) {
+        data->angle_z += 360;
+    }
 
     GL_CHECK(ctx.glViewport(0, 0, width, height));
     GL_CHECK(ctx.glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT));
@@ -555,7 +567,7 @@ main(int argc, char *argv[])
 
     /* Initialize test framework */
     state = SDLTest_CommonCreateState(argv, SDL_INIT_VIDEO);
-    if (!state) {
+    if (state == NULL) {
         return 1;
     }
     for (i = 1; i < argc;) {
diff --git a/test/testgles2_sdf.c b/test/testgles2_sdf.c
index e9e79d6e6..d2d36f99a 100644
--- a/test/testgles2_sdf.c
+++ b/test/testgles2_sdf.c
@@ -117,7 +117,7 @@ quit(int rc)
         x; \
         { \
           GLenum glError = ctx.glGetError(); \
-          if(glError != GL_NO_ERROR) { \
+          if (glError != GL_NO_ERROR) { \
             SDL_Log("glGetError() = %i (0x%.8x) at line %i\n", glError, glError, __LINE__); \
             quit(1); \
           } \
@@ -154,7 +154,7 @@ process_shader(GLuint *shader, const char * source, GLint shader_type)
     GL_CHECK(ctx.glGetShaderiv(*shader, GL_COMPILE_STATUS, &status));
 
     /* Dump debug info (source and log) if compilation failed. */
-    if(status != GL_TRUE) {
+    if (status != GL_TRUE) {
         ctx.glGetProgramInfoLog(*shader, sizeof(buffer), &length, &buffer[0]);
         buffer[length] = '\0';
         SDL_Log("Shader compilation failed: %s", buffer);fflush(stderr);
@@ -357,10 +357,18 @@ void loop()
                 }
 
 
-                if (sym == SDLK_LEFT)  g_val -= 0.05;
-                if (sym == SDLK_RIGHT) g_val += 0.05;
-                if (sym == SDLK_UP)    g_angle -= 1;
-                if (sym == SDLK_DOWN)  g_angle += 1;
+                if (sym == SDLK_LEFT) {
+                    g_val -= 0.05;
+                }
+                if (sym == SDLK_RIGHT) {
+                    g_val += 0.05;
+                }
+                if (sym == SDLK_UP) {
+                    g_angle -= 1;
+                }
+                if (sym == SDLK_DOWN) {
+                        g_angle += 1;
+                }
  
 
                 break;
@@ -402,8 +410,7 @@ void loop()
     matrix_mvp[1][1] = -2.0f / 480.0;
     matrix_mvp[3][1] = 1.0f;
     
-    if (0)
-    {
+    if (0) {
         float *f = (float *) matrix_mvp;
         SDL_Log("-----------------------------------");
         SDL_Log("[ %f, %f, %f, %f ]", *f++, *f++, *f++, *f++);
@@ -466,7 +473,7 @@ main(int argc, char *argv[])
 
     /* Initialize test framework */
     state = SDLTest_CommonCreateState(argv, SDL_INIT_VIDEO);
-    if (!state) {
+    if (state == NULL) {
         return 1;
     }
     for (i = 1; i < argc;) {
@@ -564,8 +571,9 @@ main(int argc, char *argv[])
 #if 1
         path = GetNearbyFilename(f);
 
-        if (path == NULL)
+        if (path == NULL) {
             path = SDL_strdup(f);
+        }
 
         if (path == NULL) {
             SDL_Log("out of memory\n");
@@ -573,7 +581,7 @@ main(int argc, char *argv[])
         }
 
         tmp = SDL_LoadBMP(path);
-        if  (tmp == NULL) {
+        if (tmp == NULL) {
             SDL_Log("missing image file: %s", path);
             exit(-1);
         } else {
diff --git a/test/testhaptic.c b/test/testhaptic.c
index 8e92da347..55fe299af 100644
--- a/test/testhaptic.c
+++ b/test/testhaptic.c
@@ -78,8 +78,9 @@ main(int argc, char **argv)
         /* Try to find matching device */
         else {
             for (i = 0; i < SDL_NumHaptics(); i++) {
-                if (SDL_strstr(SDL_HapticName(i), name) != NULL)
+                if (SDL_strstr(SDL_HapticName(i), name) != NULL) {
                     break;
+                }
             }
 
             if (i >= SDL_NumHaptics()) {
@@ -283,8 +284,9 @@ main(int argc, char **argv)
     }
 
     /* Quit */
-    if (haptic != NULL)
+    if (haptic != NULL) {
         SDL_HapticClose(haptic);
+    }
     SDL_Quit();
 
     return 0;
@@ -317,40 +319,55 @@ HapticPrintSupported(SDL_Haptic * ptr)
     supported = SDL_HapticQuery(ptr);
     SDL_Log("   Supported effects [%d effects, %d playing]:\n",
            SDL_HapticNumEffects(ptr), SDL_HapticNumEffectsPlaying(ptr));
-    if (supported & SDL_HAPTIC_CONSTANT)
+    if (supported & SDL_HAPTIC_CONSTANT) {
         SDL_Log("      constant\n");
-    if (supported & SDL_HAPTIC_SINE)
+    }
+    if (supported & SDL_HAPTIC_SINE) {
         SDL_Log("      sine\n");
+    }
     /* !!! FIXME: put this back when we have more bits in 2.1 */
     /* if (supported & SDL_HAPTIC_SQUARE)
         SDL_Log("      square\n"); */
-    if (supported & SDL_HAPTIC_TRIANGLE)
+    if (supported & SDL_HAPTIC_TRIANGLE) {
         SDL_Log("      triangle\n");
-    if (supported & SDL_HAPTIC_SAWTOOTHUP)
+    }
+    if (supported & SDL_HAPTIC_SAWTOOTHUP) {
         SDL_Log("      sawtoothup\n");
-    if (supported & SDL_HAPTIC_SAWTOOTHDOWN)
+    }
+    if (supported & SDL_HAPTIC_SAWTOOTHDOWN) {
         SDL_Log("      sawtoothdown\n");
-    if (supported & SDL_HAPTIC_RAMP)
+    }
+    if (supported & SDL_HAPTIC_RAMP) {
         SDL_Log("      ramp\n");
-    if (supported & SDL_HAPTIC_FRICTION)
+    }
+    if (supported & SDL_HAPTIC_FRICTION) {
         SDL_Log("      friction\n");
-    if (supported & SDL_HAPTIC_SPRING)
+    }
+    if (supported & SDL_HAPTIC_SPRING) {
         SDL_Log("      spring\n");
-    if (supported & SDL_HAPTIC_DAMPER)
+    }
+    if (supported & SDL_HAPTIC_DAMPER) {
         SDL_Log("      damper\n");
-    if (supported & SDL_HAPTIC_INERTIA)
+    }
+    if (supported & SDL_HAPTIC_INERTIA) {
         SDL_Log("      inertia\n");
-    if (supported & SDL_HAPTIC_CUSTOM)
+    }
+    if (supported & SDL_HAPTIC_CUSTOM) {
         SDL_Log("      custom\n");
-    if (supported & SDL_HAPTIC_LEFTRIGHT)
+    }
+    if (supported & SDL_HAPTIC_LEFTRIGHT) {
         SDL_Log("      left/right\n");
+    }
     SDL_Log("   Supported capabilities:\n");
-    if (supported & SDL_HAPTIC_GAIN)
+    if (supported & SDL_HAPTIC_GAIN) {
         SDL_Log("      gain\n");
-    if (supported & SDL_HAPTIC_AUTOCENTER)
+    }
+    if (supported & SDL_HAPTIC_AUTOCENTER) {
         SDL_Log("      autocenter\n");
-    if (supported & SDL_HAPTIC_STATUS)
+    }
+    if (supported & SDL_HAPTIC_STATUS) {
         SDL_Log("      status\n");
+    }
 }
 
 #else
diff --git a/test/testhittesting.c b/test/testhittesting.c
index c5223a983..24444db26 100644
--- a/test/testhittesting.c
+++ b/test/testhittesting.c
@@ -74,8 +74,7 @@ int main(int argc, char **argv)
         return 1;
     }
 
-    while (!done)
-    {
+    while (!done) {
         SDL_Event e;
         int nothing_to_do = 1;
 
@@ -108,7 +107,7 @@ int main(int argc, char **argv)
                     if (e.key.keysym.sym == SDLK_ESCAPE) {
                         done = 1;
                     } else if (e.key.keysym.sym == SDLK_x) {
-                        if (!areas) {
+                        if (areas == NULL) {
                             areas = drag_areas;
                             numareas = SDL_arraysize(drag_areas);
                         } else {
diff --git a/test/testhotplug.c b/test/testhotplug.c
index a2fb37b55..10b1b1b0e 100644
--- a/test/testhotplug.c
+++ b/test/testhotplug.c
@@ -37,7 +37,7 @@ main(int argc, char *argv[])
         }
     }
 
-    if(enable_haptic) {
+    if (enable_haptic) {
         init_subsystems |= SDL_INIT_HAPTIC;
     }
     
@@ -57,39 +57,31 @@ main(int argc, char *argv[])
     */
 
     SDL_Log("There are %d joysticks at startup\n", SDL_NumJoysticks());
-    if (enable_haptic)
+    if (enable_haptic) {
         SDL_Log("There are %d haptic devices at startup\n", SDL_NumHaptics());
+    }
 
-    while(keepGoing)
-    {
+    while (keepGoing) {
         SDL_Event event;
-        while(SDL_PollEvent(&event))
-        {
+        while (SDL_PollEvent(&event)) {
             switch(event.type)
             {
                 case SDL_QUIT:
                     keepGoing = SDL_FALSE;
                     break;
                 case SDL_JOYDEVICEADDED:
-                    if (joystick != NULL)
-                    {
+                    if (joystick != NULL) {
                         SDL_Log("Only one joystick supported by this test\n");
-                    }
-                    else
-                    {
+                    } else {
                         joystick = SDL_JoystickOpen(event.jdevice.which);
                         instance = SDL_JoystickInstanceID(joystick);
                         SDL_Log("Joy Added  : %" SDL_PRIs32 " : %s\n", event.jdevice.which, SDL_JoystickName(joystick));
-                        if (enable_haptic)
-                        {
-                            if (SDL_JoystickIsHaptic(joystick))
-                            {
+                        if (enable_haptic) {
+                            if (SDL_JoystickIsHaptic(joystick)) {
                                 haptic = SDL_HapticOpenFromJoystick(joystick);
-                                if (haptic)
-                                {
+                                if (haptic) {
                                     SDL_Log("Joy Haptic Opened\n");
-                                    if (SDL_HapticRumbleInit( haptic ) != 0)
-                                    {
+                                    if (SDL_HapticRumbleInit( haptic ) != 0) {
                                         SDL_Log("Could not init Rumble!: %s\n", SDL_GetError());
                                         SDL_HapticClose(haptic);
                                         haptic = NULL;
@@ -97,21 +89,17 @@ main(int argc, char *argv[])
                                 } else {
                                     SDL_Log("Joy haptic open FAILED!: %s\n", SDL_GetError());
                                 }
-                            }
-                            else
-                            {
+                            } else {
                                 SDL_Log("No haptic found\n");
                             }
                         }
                     }
                     break;
                 case SDL_JOYDEVICEREMOVED:
-                    if (instance == event.jdevice.which)
-                    {
+                    if (instance == event.jdevice.which) {
                         SDL_Log("Joy Removed: %" SDL_PRIs32 "\n", event.jdevice.which);
                         instance = -1;
-                        if(enable_haptic && haptic)
-                        {
+                        if (enable_haptic && haptic) {
                             SDL_HapticClose(haptic);
                             haptic = NULL;
                         }
@@ -125,13 +113,13 @@ main(int argc, char *argv[])
 /*
 //                    SDL_Log("Axis Move: %d\n", event.jaxis.axis);
 */
-                    if (enable_haptic)
+                    if (enable_haptic) {
                         SDL_HapticRumblePlay(haptic, 0.25, 250);
+                    }
                     break;
                 case SDL_JOYBUTTONDOWN:
                     SDL_Log("Button Press: %d\n", event.jbutton.button);
-                    if(enable_haptic && haptic)
-                    {
+                    if (enable_haptic && haptic) {
                         SDL_HapticRumblePlay(haptic, 0.25, 250);
                     }
                     if (event.jbutton.button == 0) {
diff --git a/test/testiconv.c b/test/testiconv.c
index fc0806618..e437fe9fb 100644
--- a/test/testiconv.c
+++ b/test/testiconv.c
@@ -62,9 +62,9 @@ main(int argc, char *argv[])
 
     fname = GetResourceFilename(argc > 1 ? argv[1] : NULL, "utf8.txt");
     file = fopen(fname, "rb");
-    if (!file) {
+    if (file == NULL) {
         SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Unable to open %s\n", fname);
-        return (1);
+        return 1;
     }
     SDL_free(fname);
 
@@ -93,5 +93,5 @@ main(int argc, char *argv[])
     fclose(file);
 
     SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "Total errors: %d\n", errors);
-    return (errors ? errors + 1 : 0);
+    return errors ? errors + 1 : 0;
 }
diff --git a/test/testime.c b/test/testime.c
index 9a0b5259e..0d6d4fecc 100644
--- a/test/testime.c
+++ b/test/testime.c
@@ -71,12 +71,13 @@ static Uint8 unifontTextureLoaded[UNIFONT_NUM_TEXTURES] = {0};
 
 static Uint8 dehex(char c)
 {
-    if (c >= '0' && c <= '9')
+    if (c >= '0' && c <= '9') {
         return c - '0';
-    else if (c >= 'a' && c <= 'f')
+    } else if (c >= 'a' && c <= 'f') {
         return c - 'a' + 10;
-    else if (c >= 'A' && c <= 'F')
+    } else if (c >= 'A' && c <= 'F') {
         return c - 'A' + 10;
+    }
     return 255;
 }
 
@@ -88,15 +89,16 @@ static Uint8 dehex2(char c1, char c2)
 static Uint8 validate_hex(const char *cp, size_t len, Uint32 *np)
 {
     Uint32 n = 0;
-    for (; len > 0; cp++, len--)
-    {
+    for (; len > 0; cp++, len--) {
         Uint8 c = dehex(*cp);
-        if (c == 255)
+        if (c == 255) {
             return 0;
+        }
         n = (n << 4) | c;
     }
-    if (np != NULL)
+    if (np != NULL) {
         *np = n;
+    }
     return 1;
 }
 
@@ -113,8 +115,7 @@ static int unifont_init(const char *fontname)
 
     /* Allocate memory for the glyph data so the file can be closed after initialization. */
     unifontGlyph = (struct UnifontGlyph *)SDL_malloc(unifontGlyphSize);
-    if (unifontGlyph == NULL)
-    {
+    if (unifontGlyph == NULL) {
         SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "unifont: Failed to allocate %d KiB for glyph data.\n", (int)(unifontGlyphSize + 1023) / 1024);
         return -1;
     }
@@ -122,8 +123,7 @@ static int unifont_init(const char *fontname)
 
     /* Allocate memory for texture pointers for all renderers. */
     unifontTexture = (SDL_Texture **)SDL_malloc(unifontTextureSize);
-    if (unifontTexture == NULL)
-    {
+    if (unifontTexture == NULL) {
         SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "unifont: Failed to allocate %d KiB for texture pointer data.\n", (int)(unifontTextureSize + 1023) / 1024);
         return -1;
     }
@@ -136,8 +136,7 @@ static int unifont_init(const char *fontname)
     }
     hexFile = SDL_RWFromFile(filename, "rb");
     SDL_free(filename);
-    if (hexFile == NULL)
-    {
+    if (hexFile == NULL) {
         SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "unifont: Failed to open font file: %s\n", fontname);
         return -1;
     }
@@ -150,10 +149,10 @@ static int unifont_init(const char *fontname)
         Uint32 codepoint;
 
         bytesRead = SDL_RWread(hexFile, hexBuffer, 1, 9);
-        if (numGlyphs > 0 && bytesRead == 0)
+        if (numGlyphs > 0 && bytesRead == 0) {
             break; /* EOF */
-        if ((numGlyphs == 0 && bytesRead == 0) || (numGlyphs > 0 && bytesRead < 9))
-        {
+        } 
+        if ((numGlyphs == 0 && bytesRead == 0) || (numGlyphs > 0 && bytesRead < 9)) {
             SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "unifont: Unexpected end of hex file.\n");
             return -1;
         }
@@ -167,59 +166,54 @@ static int unifont_init(const char *fontname)
             codepointHexSize = 6;
         else if (hexBuffer[8] == ':')
             codepointHexSize = 8;
-        else
-        {
+        else {
             SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "unifont: Could not find codepoint and glyph data separator symbol in hex file on line %d.\n", lineNumber);
             return -1;
         }
 
-        if (!validate_hex((const char *)hexBuffer, codepointHexSize, &codepoint))
-        {
+        if (!validate_hex((const char *)hexBuffer, codepointHexSize, &codepoint)) {
             SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "unifont: Malformed hexadecimal number in hex file on line %d.\n", lineNumber);
             return -1;
         }
-        if (codepoint > UNIFONT_MAX_CODEPOINT)
+        if (codepoint > UNIFONT_MAX_CODEPOINT) {
             SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "unifont: Codepoint on line %d exceeded limit of 0x%x.\n", lineNumber, UNIFONT_MAX_CODEPOINT);
+        }
 
         /* If there was glyph data read in the last file read, move it to the front of the buffer. */
         bytesOverread = 8 - codepointHexSize;
-        if (codepointHexSize < 8)
+        if (codepointHexSize < 8) {
             SDL_memmove(hexBuffer, hexBuffer + codepointHexSize + 1, bytesOverread);
+        }
         bytesRead = SDL_RWread(hexFile, hexBuffer + bytesOverread, 1, 33 - bytesOverread);
-        if (bytesRead < (33 - bytesOverread))
-        {
+        if (bytesRead < (33 - bytesOverread)) {
             SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "unifont: Unexpected end of hex file.\n");
             return -1;
         }
         if (hexBuffer[32] == '\n')
             glyphWidth = 8;
-        else
-        {
+        else {
             glyphWidth = 16;
             bytesRead = SDL_RWread(hexFile, hexBuffer + 33, 1, 32);
-            if (bytesRead < 32)
-            {
+            if (bytesRead < 32) {
                 SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "unifont: Unexpected end of hex file.\n");
                 return -1;
             }
         }
 
-        if (!validate_hex((const char *)hexBuffer, glyphWidth * 4, NULL))
-        {
+        if (!validate_hex((const char *)hexBuffer, glyphWidth * 4, NULL)) {
             SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "unifont: Malformed hexadecimal glyph data in hex file on line %d.\n", lineNumber);
             return -1;
         }
 
-        if (codepoint <= UNIFONT_MAX_CODEPOINT)
-        {
+        if (codepoint <= UNIFONT_MAX_CODEPOINT) {
             if (unifontGlyph[codepoint].width > 0)
                 SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "unifont: Ignoring duplicate codepoint 0x%08" SDL_PRIx32 " in hex file on line %d.\n", codepoint, lineNumber);
-            else
-            {
+            else {
                 unifontGlyph[codepoint].width = glyphWidth;
                 /* Pack the hex data into a more compact form. */
-                for (i = 0; i < glyphWidth * 2; i++)
+                for (i = 0; i < glyphWidth * 2; i++) {
                     unifontGlyph[codepoint].data[i] = dehex2(hexBuffer[i * 2], hexBuffer[i * 2 + 1]);
+                }
                 numGlyphs++;
             }
         }
@@ -237,20 +231,15 @@ static void unifont_make_rgba(Uint8 *src, Uint8 *dst, Uint8 width)
     int i, j;
     Uint8 *row = dst;
 
-    for (i = 0; i < width * 2; i++)
-    {
+    for (i = 0; i < width * 2; i++) {
         Uint8 data = src[i];
-        for (j = 0; j < 8; j++)
-        {
-            if (data & 0x80)
-            {
+        for (j = 0; j < 8; j++) {
+            if (data & 0x80) {
                 row[0] = textColor.r;
                 row[1] = textColor.g;
                 row[2] = textColor.b;
                 row[3] = textColor.a;
-            }
-            else
-            {
+            } else {
                 row[0] = 0;
                 row[1] = 0;
                 row[2] = 0;
@@ -260,8 +249,7 @@ static void unifont_make_rgba(Uint8 *src, Uint8 *dst, Uint8 width)
             row += 4;
         }
 
-        if (width == 8 || (width == 16 && i % 2 == 1))
-        {
+        if (width == 8 || (width == 16 && i % 2 == 1)) {
             dst += UNIFONT_TEXTURE_PITCH;
             row = dst;
         }
@@ -273,26 +261,22 @@ static int unifont_load_texture(Uint32 textureID)
     int i;
     Uint8 * textureRGBA;
 
-    if (textureID >= UNIFONT_NUM_TEXTURES)
-    {
+    if (textureID >= UNIFONT_NUM_TEXTURES) {
         SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "unifont: Tried to load out of range texture %" SDL_PRIu32 "\n", textureID);
         return -1;
     }
 
     textureRGBA = (Uint8 *)SDL_malloc(UNIFONT_TEXTURE_SIZE);
-    if (textureRGBA == NULL)
-    {
+    if (textureRGBA == NULL) {
         SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "unifont: Failed to allocate %d MiB for a texture.\n", UNIFONT_TEXTURE_SIZE / 1024 / 1024);
         return -1;
     }
     SDL_memset(textureRGBA, 0, UNIFONT_TEXTURE_SIZE);
 
     /* Copy the glyphs into memory in RGBA format. */
-    for (i = 0; i < UNIFONT_GLYPHS_IN_TEXTURE; i++)
-    {
+    for (i = 0; i < UNIFONT_GLYPHS_IN_TEXTURE; i++) {
         Uint32 codepoint = UNIFONT_GLYPHS_IN_TEXTURE * textureID + i;
-        if (unifontGlyph[codepoint].width > 0)
-        {
+        if (unifontGlyph[codepoint].width > 0) {
             const Uint32 cInTex = codepoint % UNIFONT_GLYPHS_IN_TEXTURE;
             const size_t offset = (cInTex / UNIFONT_GLYPHS_IN_ROW) * UNIFONT_TEXTURE_PITCH * 16 + (cInTex % UNIFONT_GLYPHS_IN_ROW) * 16 * 4;
             unifont_make_rgba(unifontGlyph[codepoint].data, textureRGBA + offset, unifontGlyph[codepoint].width);
@@ -300,22 +284,20 @@ static int unifont_load_texture(Uint32 textureID)
     }
 
     /* Create textures and upload the RGBA data from above. */
-    for (i = 0; i < state->num_windows; ++i)
-    {
+    for (i = 0; i < state->num_windows; ++i) {
         SDL_Renderer *renderer = state->renderers[i];
         SDL_Texture *tex = unifontTexture[UNIFONT_NUM_TEXTURES * i + textureID];
-        if (state->windows[i] == NULL || renderer == NULL || tex != NULL)
+        if (state->windows[i] == NULL || renderer == NULL || tex != NULL) {
             continue;
+        }
         tex = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_ARGB8888, SDL_TEXTUREACCESS_STATIC, UNIFONT_TEXTURE_WIDTH, UNIFONT_TEXTURE_WIDTH);
-        if (tex == NULL)
-        {
+        if (tex == NULL) {
             SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "unifont: Failed to create texture %" SDL_PRIu32 " for renderer %d.\n", textureID, i);
             return -1;
         }
         unifontTexture[UNIFONT_NUM_TEXTURES * i + textureID] = tex;
         SDL_SetTextureBlendMode(tex, SDL_BLENDMODE_BLEND);
-        if (SDL_UpdateTexture(tex, NULL, textureRGBA, UNIFONT_TEXTURE_PITCH) != 0)
-        {
+        if (SDL_UpdateTexture(tex, NULL, textureRGBA, UNIFONT_TEXTURE_PITCH) != 0) {
             SDL_Log("unifont error: Failed to update texture %" SDL_PRIu32 " data for renderer %d.\n", textureID, i);
         }
     }
@@ -340,8 +322,7 @@ static Sint32 unifont_draw_glyph(Uint32 codepoint, int rendererID, SDL_Rect *dst
         }
     }
     texture = unifontTexture[UNIFONT_NUM_TEXTURES * rendererID + textureID];
-    if (texture != NULL)
-    {
+    if (texture != NULL) {
         const Uint32 cInTex = codepoint % UNIFONT_GLYPHS_IN_TEXTURE;
         srcrect.x = cInTex % UNIFONT_GLYPHS_IN_ROW * 16;
         srcrect.y = cInTex / UNIFONT_GLYPHS_IN_ROW * 16;
@@ -353,21 +334,22 @@ static Sint32 unifont_draw_glyph(Uint32 codepoint, int rendererID, SDL_Rect *dst
 static void unifont_cleanup()
 {
     int i, j;
-    for (i = 0; i < state->num_windows; ++i)
-    {
+    for (i = 0; i < state->num_windows; ++i) {
         SDL_Renderer *renderer = state->renderers[i];
-        if (state->windows[i] == NULL || renderer == NULL)
+        if (state->windows[i] == NULL || renderer == NULL) {
             continue;
-        for (j = 0; j < UNIFONT_NUM_TEXTURES; j++)
-        {
+        }
+        for (j = 0; j < UNIFONT_NUM_TEXTURES; j++) {
             SDL_Texture *tex = unifontTexture[UNIFONT_NUM_TEXTURES * i + j];
-            if (tex != NULL)
+            if (tex != NULL) {
                 SDL_DestroyTexture(tex);
+            }
         }
     }
 
-    for (j = 0; j < UNIFONT_NUM_TEXTURES; j++)
-          unifontTextureLoaded[j] = 0;
+    for (j = 0; j < UNIFONT_NUM_TEXTURES; j++) {
+        unifontTextureLoaded[j] = 0;
+    }
 
     SDL_free(unifontTexture);
     SDL_free(unifontGlyph);
@@ -395,14 +377,15 @@ char *utf8_next(char *p)
 {
     size_t len = utf8_length(*p);
     size_t i = 0;
-    if (!len)
+    if (!len) {
         return 0;
+    }
 
-    for (; i < len; ++i)
-    {
+    for (; i < len; ++i) {
         ++p;
-        if (!*p)
+        if (!*p) {
             return 0;
+        }
     }
     return p;
 }
@@ -410,8 +393,7 @@ char *utf8_next(char *p)
 char *utf8_advance(char *p, size_t distance)
 {
     size_t i = 0;
-    for (; i < distance && p; ++i)
-    {
+    for (; i < distance && p; ++i) {
         p = utf8_next(p);
     }
     return p;
@@ -421,20 +403,20 @@ Uint32 utf8_decode(char *p, size_t len)
 {
     Uint32 codepoint = 0;
     size_t i = 0;
-    if (!len)
+    if (!len) {
         return 0;
+    }
 
-    for (; i < len; ++i)
-    {
+    for (; i < len; ++i) {
         if (i == 0)
             codepoint = (0xff >> len) & *p;
-        else
-        {
+        else {
             codepoint <<= 6;
             codepoint |= 0x3f & *p;
         }
-        if (!*p)
+        if (!*p) {
             return 0;
+        }
         p++;
     }
 
@@ -481,8 +463,7 @@ void _Redraw(int rendererID)
     SDL_SetRenderDrawColor(renderer, backColor.r, backColor.g, backColor.b, backColor.a);
     SDL_RenderFillRect(renderer,&textRect);
 
-    if (*text)
-    {
+    if (*text) {
 #ifdef HAVE_SDL_TTF
         SDL_Surface *textSur = TTF_RenderUTF8_Blended(font, text, textColor);
         SDL_Texture *texture;
@@ -510,8 +491,7 @@ void _Redraw(int rendererID)
         drawnTextRect.y = dstrect.y;
         drawnTextRect.h = dstrect.h;
 
-        while ((codepoint = utf8_decode(utext, len = utf8_length(*utext))))
-        {
+        while ((codepoint = utf8_decode(utext, len = utf8_length(*utext)))) {
             Sint32 advance = unifont_draw_glyph(codepoint, rendererID, &dstrect) * UNIFONT_DRAW_SCALE;
             dstrect.x += advance;
             drawnTextRect.w += advance;
@@ -522,14 +502,11 @@ void _Redraw(int rendererID)
 
     markedRect.x = textRect.x + drawnTextRect.w;
     markedRect.w = textRect.w - drawnTextRect.w;
-    if (markedRect.w < 0)
-    {
+    if (markedRect.w < 0) {
         /* Stop text input because we cannot hold any more characters */
         SDL_StopTextInput();
         return;
-    }
-    else
-    {
+    } else {
         SDL_StartTextInput();
     }
 
@@ -544,17 +521,16 @@ void _Redraw(int rendererID)
     SDL_SetRenderDrawColor(renderer, backColor.r, backColor.g, backColor.b, backColor.a);
     SDL_RenderFillRect(renderer,&markedRect);
 
-    if (markedText[0])
-    {
+    if (markedText[0]) {
 #ifdef HAVE_SDL_TTF
         SDL_Surface *textSur;
         SDL_Texture *texture;
-        if (cursor)
-        {
+        if (cursor) {
             char *p = utf8_advance(markedText, cursor);
             char c = 0;
-            if (!p)
+            if (p == NULL) {
                 p = &markedText[SDL_strlen(markedText)];
+            }
 
             c = *p;
             *p = 0;
@@ -587,20 +563,19 @@ void _Redraw(int rendererID)
         drawnTextRect.y = dstrect.y;
         drawnTextRect.h = dstrect.h;
 
-        while ((codepoint = utf8_decode(utext, len = utf8_length(*utext))))
-        {
+        while ((codepoint = utf8_decode(utext, len = utf8_length(*utext)))) {
             Sint32 advance = unifont_draw_glyph(codepoint, rendererID, &dstrect) * UNIFONT_DRAW_SCALE;
             dstrect.x += advance;
             drawnTextRect.w += advance;
-            if (i < cursor)
+            if (i < cursor) {
                 cursorRect.x += advance;
+            }
             i++;
             utext += len;
         }
 #endif
 
-        if (cursor > 0)
-        {
+        if (cursor > 0) {
             cursorRect.y = drawnTextRect.y;
             cursorRect.h = drawnTextRect.h;
         }
@@ -625,8 +600,9 @@ void Redraw()
     int i;
     for (i = 0; i < state->num_windows; ++i) {
         SDL_Renderer *renderer = state->renderers[i];
-        if (state->windows[i] == NULL)
+        if (state->windows[i] == NULL) {
             continue;
+        }
         SDL_SetRenderDrawColor(renderer, 0, 0, 0, 0);
         SDL_RenderClear(renderer);
 
@@ -648,21 +624,19 @@ int main(int argc, char *argv[])
 
     /* Initialize test framework */
     state = SDLTest_CommonCreateState(argv, SDL_INIT_VIDEO);
-    if (!state) {
+    if (state == NULL) {
         return 1;
     }
     for (i = 1; i < argc;i++) {
         SDLTest_CommonArg(state, i);
     }
-    for (argc--, argv++; argc > 0; argc--, argv++)
-    {
+    for (argc--, argv++; argc > 0; argc--, argv++) {
         if (SDL_strcmp(argv[0], "--help") == 0) {
             usage();
             return 0;
         }
 
-        else if (SDL_strcmp(argv[0], "--font") == 0)
-        {
+        else if (SDL_strcmp(argv[0], "--font") == 0) {
             argc--;
             argv++;
 
@@ -685,8 +659,7 @@ int main(int argc, char *argv[])
     TTF_Init();
 
     font = TTF_OpenFont(fontname, DEFAULT_PTSIZE);
-    if (! font)
-    {
+    if (font == NULL) {
         SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Failed to find font: %s\n", TTF_GetError());
         return -1;
     }
@@ -723,42 +696,36 @@ int main(int argc, char *argv[])
                              break;
                         case SDLK_BACKSPACE:
                             /* Only delete text if not in editing mode. */
-                             if (!markedText[0])
-                             {
+                             if (!markedText[0]) {
                                  size_t textlen = SDL_strlen(text);
 
                                  do {
-                                     if (textlen==0)
-                                     {
+                                     if (textlen==0) {
                                          break;
                                      }
-                                     if ((text[textlen-1] & 0x80) == 0x00)
-                                     {
+                                     if ((text[textlen-1] & 0x80) == 0x00) {
                                          /* One byte */
                                          text[textlen-1]=0x00;
                                          break;
                                      }
-                                     if ((text[textlen-1] & 0xC0) == 0x80)
-                                     {
+                                     if ((text[textlen-1] & 0xC0) == 0x80) {
                                          /* Byte from the multibyte sequence */
                                          text[textlen-1]=0x00;
                                          textlen--;
                                      }
-                                     if ((text[textlen-1] & 0xC0) == 0xC0)
-                                     {
+                                     if ((text[textlen-1] & 0xC0) == 0xC0) {
                                          /* First byte of multibyte sequence */
                                          text[textlen-1]=0x00;
                                          break;
                                      }
-                                 } while(1);
+                                 } while (1);
 
                                  Redraw();
                              }
                              break;
                     }
 
-                    if (done)
-                    {
+                    if (done) {
                         break;
                     }
 
@@ -770,14 +737,15 @@ int main(int argc, char *argv[])
                     break;
 
                 case SDL_TEXTINPUT:
-                    if (event.text.text[0] == '\0' || event.text.text[0] == '\n' ||
-                        markedRect.w < 0)
+                    if (event.text.text[0] == '\0' || event.text.text[0] == '\n' || markedRect.w < 0) {
                         break;
+                    }
 
                     SDL_Log("Keyboard: text input \"%s\"\n", event.text.text);
 
-                    if (SDL_strlen(text) + SDL_strlen(event.text.text) < sizeof(text))
+                    if (SDL_strlen(text) + SDL_strlen(event.text.text) < sizeof(text)) {
                         SDL_strlcat(text, event.text.text, sizeof(text));
+                    }
 
                     SDL_Log("text inputed: %s\n", text);
 
diff --git a/test/testintersections.c b/test/testintersections.c
index 29af8e21f..1216adc0c 100644
--- a/test/testintersections.c
+++ b/test/testintersections.c
@@ -22,7 +22,7 @@
 
 #include "SDL_test_common.h"
 
-#define SWAP(typ,a,b) do{typ t=a;a=b;b=t;}while(0)
+#define SWAP(typ,a,b) do{typ t=a;a=b;b=t;}while (0)
 #define NUM_OBJECTS 100
 
 static SDLTest_CommonState *state;
@@ -86,10 +86,12 @@ SDL_Rect lines[MAX_LINES];
 static int
 add_line(int x1, int y1, int x2, int y2)
 {
-    if (num_lines >= MAX_LINES)
+    if (num_lines >= MAX_LINES) {
         return 0;
-    if ((x1 == x2) && (y1 == y2))
+    }
+    if ((x1 == x2) && (y1 == y2)) {
         return 0;
+    }
 
     SDL_Log("adding line (%d, %d), (%d, %d)\n", x1, y1, x2, y2);
     lines[num_lines].x = x1;
@@ -130,15 +132,19 @@ SDL_Rect rects[MAX_RECTS];
 static int
 add_rect(int x1, int y1, int x2, int y2)
 {
-    if (num_rects >= MAX_RECTS)
+    if (num_rects >= MAX_RECTS) {
         return 0;
-    if ((x1 == x2) || (y1 == y2))
+    }
+    if ((x1 == x2) || (y1 == y2)) {
         return 0;
+    }
 
-    if (x1 > x2)
+    if (x1 > x2) {
         SWAP(int, x1, x2);
-    if (y1 > y2)
+    }
+    if (y1 > y2) {
         SWAP(int, y1, y2);
+    }
 
     SDL_Log("adding rect (%d, %d), (%d, %d) [%dx%d]\n", x1, y1, x2, y2,
            x2 - x1, y2 - y1);
@@ -213,12 +219,12 @@ loop()
             mouse_begin_y = event.button.y;
             break;
         case SDL_MOUSEBUTTONUP:
-            if (event.button.button == 3)
-                add_line(mouse_begin_x, mouse_begin_y, event.button.x,
-                         event.button.y);
-            if (event.button.button == 1)
-                add_rect(mouse_begin_x, mouse_begin_y, event.button.x,
-                         event.button.y);
+            if (event.button.button == 3) {
+                add_line(mouse_begin_x, mouse_begin_y, event.button.x, event.button.y);
+            }
+            if (event.button.button == 1) {
+                add_rect(mouse_begin_x, mouse_begin_y, event.button.x, event.button.y);
+            }
             break;
         case SDL_KEYDOWN:
             switch (event.key.keysym.sym) {
@@ -244,8 +250,9 @@ loop()
     }
     for (i = 0; i < state->num_windows; ++i) {
         SDL_Renderer *renderer = state->renderers[i];
-        if (state->windows[i] == NULL)
+        if (state->windows[i] == NULL) {
             continue;
+        }
         SDL_SetRenderDrawColor(renderer, 0xA0, 0xA0, 0xA0, 0xFF);
         SDL_RenderClear(renderer);
 
@@ -278,7 +285,7 @@ main(int argc, char *argv[])
 
     /* Initialize test framework */
     state = SDLTest_CommonCreateState(argv, SDL_INIT_VIDEO);
-    if (!state) {
+    if (state == NULL) {
         return 1;
     }
     for (i = 1; i < argc;) {
diff --git a/test/testjoystick.c b/test/testjoystick.c
index f058979dd..e20618ca6 100644
--- a/test/testjoystick.c
+++ b/test/testjoystick.c
@@ -118,7 +118,7 @@ loop(void *arg)
 
         case SDL_JOYDEVICEADDED:
             SDL_Log("Joystick device %d added.\n", (int) event.jdevice.which);
-            if (!joystick) {
+            if (joystick == NULL) {
                 joystick = SDL_JoystickOpen(event.jdevice.which);
                 if (joystick) {
                     PrintJoystick(joystick);
@@ -144,16 +144,21 @@ loop(void *arg)
         case SDL_JOYHATMOTION:
             SDL_Log("Joystick %" SDL_PRIs32 " hat %d value:",
                     event.jhat.which, event.jhat.hat);
-            if (event.jhat.value == SDL_HAT_CENTERED)
+            if (event.jhat.value == SDL_HAT_CENTERED) {
                 SDL_Log(" centered");
-            if (event.jhat.value & SDL_HAT_UP)
+            }
+            if (event.jhat.value & SDL_HAT_UP) {
                 SDL_Log(" up");
-            if (event.jhat.value & SDL_HAT_RIGHT)
+            }
+            if (event.jhat.value & SDL_HAT_RIGHT) {
                 SDL_Log(" right");
-            if (event.jhat.value & SDL_HAT_DOWN)
+            }
+            if (event.jhat.value & SDL_HAT_DOWN) {
                 SDL_Log(" down");
-            if (event.jhat.value & SDL_HAT_LEFT)
+            }
+            if (event.jhat.value & SDL_HAT_LEFT) {
                 SDL_Log(" left");
+            }
             SDL_Log("\n");
             break;
         case SDL_JOYBALLMOTION:
diff --git a/test/testkeys.c b/test/testkeys.c
index 7561eb041..e52935981 100644
--- a/test/testkeys.c
+++ b/test/testkeys.c
@@ -36,5 +36,5 @@ main(int argc, char *argv[])
                SDL_GetScancodeName(scancode));
     }
     SDL_Quit();
-    return (0);
+    return 0;
 }
diff --git a/test/testlock.c b/test/testlock.c
index 121059608..b0e7f0c6e 100644
--- a/test/testlock.c
+++ b/test/testlock.c
@@ -55,8 +55,9 @@ closemutex(int sig)
     int i;
     SDL_Log("Process %lu:  Cleaning up...\n", id == mainthread ? 0 : id);
     SDL_AtomicSet(&doterminate, 1);
-    for (i = 0; i < 6; ++i)
+    for (i = 0; i < 6; ++i) {
         SDL_WaitThread(threads[i], NULL);
+    }
     SDL_DestroyMutex(mutex);
     exit(sig);
 }
@@ -64,8 +65,9 @@ closemutex(int sig)
 int SDLCALL
 Run(void *data)
 {
-    if (SDL_ThreadID() == mainthread)
+    if (SDL_ThreadID() == mainthread) {
         signal(SIGTERM, closemutex);
+    }
     while (!SDL_AtomicGet(&doterminate)) {
         SDL_Log("Process %lu ready to work\n", SDL_ThreadID());
         if (SDL_LockMutex(mutex) < 0) {
@@ -86,7 +88,7 @@ Run(void *data)
         SDL_Log("Process %lu:  raising SIGTERM\n", SDL_ThreadID());
         raise(SIGTERM);
     }
-    return (0);
+    return 0;
 }
 
 int
@@ -118,11 +120,12 @@ main(int argc, char *argv[])
     for (i = 0; i < maxproc; ++i) {
         char name[64];
         SDL_snprintf(name, sizeof (name), "Worker%d", i);
-        if ((threads[i] = SDL_CreateThread(Run, name, NULL)) == NULL)
+        if ((threads[i] = SDL_CreateThread(Run, name, NULL)) == NULL) {
             SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Couldn't create thread!\n");
+        }
     }
     signal(SIGINT, terminate);
     Run(NULL);
 
-    return (0);                 /* Never reached */
+    return 0;                 /* Never reached */
 }
diff --git a/test/testmessage.c b/test/testmessage.c
index c30c18df4..88c672576 100644
--- a/test/testmessage.c
+++ b/test/testmessage.c
@@ -164,7 +164,7 @@ main(int argc, char *argv[])
      */
     if (SDL_Init(SDL_INIT_VIDEO) < 0) {
         SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Couldn't initialize SDL video subsystem: %s\n", SDL_GetError());
-        return (1);
+        return 1;
     }
     {
         int status = 0;
@@ -172,8 +172,7 @@ main(int argc, char *argv[])
         intptr_t eventNumber = SDL_RegisterEvents(1);
         SDL_Thread* thread = SDL_CreateThread(&button_messagebox, "MessageBox", (void*)eventNumber);
 
-        while (SDL_WaitEvent(&event))
-        {
+        while (SDL_WaitEvent(&event)) {
             if (event.type == eventNumber) {
                 break;
             }
@@ -204,8 +203,7 @@ main(int argc, char *argv[])
             quit(1);
         }
 
-        while (SDL_WaitEvent(&event))
-        {
+        while (SDL_WaitEvent(&event)) {
             if (event.type == SDL_QUIT || event.type == SDL_KEYUP) {
                 break;
             }
@@ -213,5 +211,5 @@ main(int argc, char *argv[])
     }
 
     SDL_Quit();
-    return (0);
+    return 0;
 }
diff --git a/test/testmouse.c b/test/testmouse.c
index b8fc440b9..6b3f4ce27 100644
--- a/test/testmouse.c
+++ b/test/testmouse.c
@@ -133,15 +133,16 @@ loop(void *arg)
                 break;
 
         case SDL_MOUSEMOTION:
-            if (!active)
+            if (active == NULL) {
                 break;
+            }
 
             active->x2 = event.motion.x;
             active->y2 = event.motion.y;
             break;
 
         case SDL_MOUSEBUTTONDOWN:
-            if (!active) {
+            if (active == NULL) {
                 active = SDL_calloc(1, sizeof(*active));
                 active->x1 = active->x2 = event.button.x;
                 active->y1 = active->y2 = event.button.y;
@@ -158,8 +159,9 @@ loop(void *arg)
             break;
 
         case SDL_MOUSEBUTTONUP:
-            if (!active)
+            if (active == NULL) {
                 break;
+            }
 
             switch (event.button.button) {
             case SDL_BUTTON_LEFT:   buttons &= ~SDL_BUTTON_LMASK; break;
@@ -210,8 +212,9 @@ loop(void *arg)
 
     /* Objects from mouse clicks */
     DrawObjects(renderer);
-    if (active)
+    if (active) {
         DrawObject(renderer, active);
+    }
 
     SDL_RenderPresent(renderer);
 
diff --git a/test/testmultiaudio.c b/test/testmultiaudio.c
index 1154b83af..e4de22861 100644
--- a/test/testmultiaudio.c
+++ b/test/testmultiaudio.c
@@ -39,8 +39,9 @@ play_through_once(void *arg, Uint8 * stream, int len)
     Uint8 *waveptr = sound + cbdata->soundpos;
     int waveleft = soundlen - cbdata->soundpos;
     int cpy = len;
-    if (cpy > waveleft)
+    if (cpy > waveleft) {
         cpy = waveleft;
+    }
 
     SDL_memcpy(stream, waveptr, cpy);
     len -= cpy;
@@ -105,7 +106,7 @@ test_multi_audio(int devcount)
             while (!SDL_AtomicGet(&cbd[0].done)) {
                 #ifdef __ANDROID__                
                 /* Empty queue, some application events would prevent pause. */
-                while (SDL_PollEvent(&event)){}
+                while (SDL_PollEvent(&event)) {}
                 #endif                
                 SDL_Delay(100);
             }
@@ -143,7 +144,7 @@ test_multi_audio(int devcount)
         }
         #ifdef __ANDROID__        
         /* Empty queue, some application events would prevent pause. */
-        while (SDL_PollEvent(&event)){}
+        while (SDL_PollEvent(&event)) {}
         #endif        
 
         SDL_Delay(100);
@@ -173,7 +174,7 @@ main(int argc, char **argv)
     /* Load the SDL library */
     if (SDL_Init(SDL_INIT_AUDIO) < 0) {
         SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Couldn't initialize SDL: %s\n", SDL_GetError());
-        return (1);
+        return 1;
     }
 
     SDL_Log("Using audio driver: %s\n", SDL_GetCurrentAudioDriver());
diff --git a/test/testnative.c b/test/testnative.c
index e115089d5..7cb28a3b0 100644
--- a/test/testnative.c
+++ b/test/testnative.c
@@ -121,19 +121,19 @@ main(int argc, char *argv[])
             break;
         }
     }
-    if (!factory) {
+    if (factory == NULL) {
         SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Couldn't find native window code for %s driver\n",
                 driver);
         quit(2);
     }
     SDL_Log("Creating native window for %s driver\n", driver);
     native_window = factory->CreateNativeWindow(WINDOW_W, WINDOW_H);
-    if (!native_window) {
+    if (native_window == NULL) {
         SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Couldn't create native window\n");
         quit(3);
     }
     window = SDL_CreateWindowFrom(native_window);
-    if (!window) {
+    if (window == NULL) {
         SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Couldn't create SDL window: %s\n", SDL_GetError());
         quit(4);
     }
@@ -141,7 +141,7 @@ main(int argc, char *argv[])
 
     /* Create the renderer */
     renderer = SDL_CreateRenderer(window, -1, 0);
-    if (!renderer) {
+    if (renderer == NULL) {
         SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Couldn't create renderer: %s\n", SDL_GetError());
         quit(5);
     }
@@ -151,7 +151,7 @@ main(int argc, char *argv[])
     SDL_RenderClear(renderer);
 
     sprite = LoadTexture(renderer, "icon.bmp", SDL_TRUE, NULL, NULL);
-    if (!sprite) {
+    if (sprite == NULL) {
         quit(6);
     }
 
@@ -160,7 +160,7 @@ main(int argc, char *argv[])
     SDL_QueryTexture(sprite, NULL, NULL, &sprite_w, &sprite_h);
     positions = (SDL_Rect *) SDL_malloc(NUM_SPRITES * sizeof(SDL_Rect));
     velocities = (SDL_Rect *) SDL_malloc(NUM_SPRITES * sizeof(SDL_Rect));
-    if (!positions || !velocities) {
+    if (positions == NULL || velocities == NULL) {
         SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Out of memory!\n");
         quit(2);
     }
diff --git a/test/testoffscreen.c b/test/testoffscreen.c
index e2a8f4b68..64219df19 100644
--- a/test/testoffscreen.c
+++ b/test/testoffscreen.c
@@ -119,7 +119,7 @@ main(int argc, char *argv[])
                  SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,
                  width, height, 0);
 
-    if (!window) {
+    if (window == NULL) {
         SDL_Log("Couldn't create window: %s\n",
             SDL_GetError());
         return SDL_FALSE;
@@ -127,7 +127,7 @@ main(int argc, char *argv[])
 
     renderer = SDL_CreateRenderer(window, -1, 0);
 
-    if (!renderer) {
+    if (renderer == NULL) {
         SDL_Log("Couldn't create renderer: %s\n",
             SDL_GetError());
         return SDL_FALSE;
diff --git a/test/testoverlay2.c b/test/testoverlay2.c
index ab0fd82db..c57c1604f 100644
--- a/test/testoverlay2.c
+++ b/test/testoverlay2.c
@@ -342,21 +342,21 @@ main(int argc, char **argv)
                               SDL_WINDOWPOS_UNDEFINED,
                               window_w, window_h,
                               SDL_WINDOW_RESIZABLE);
-    if (!window) {
+    if (window == NULL) {
         SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Couldn't set create window: %s\n", SDL_GetError());
         SDL_free(RawMooseData);
         quit(4);
     }
 
     renderer = SDL_CreateRenderer(window, -1, 0);
-    if (!renderer) {
+    if (renderer == NULL) {
         SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Couldn't set create renderer: %s\n", SDL_GetError());
         SDL_free(RawMooseData);
         quit(4);
     }
 
     MooseTexture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING, MOOSEPIC_W, MOOSEPIC_H);
-    if (!MooseTexture) {
+    if (MooseTexture == NULL) {
         SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Couldn't set create texture: %s\n", SDL_GetError());
         SDL_free(RawMooseData);
         quit(5);
diff --git a/test/testplatform.c b/test/testplatform.c
index 5eec9f9d1..bed1af684 100644
--- a/test/testplatform.c
+++ b/test/testplatform.c
@@ -51,33 +51,34 @@ TestTypes(SDL_bool verbose)
     int error = 0;
 
     if (badsize(sizeof(Uint8), 1)) {
-        if (verbose)
-            SDL_Log("sizeof(Uint8) != 1, instead = %u\n",
-                   (unsigned int)sizeof(Uint8));
+        if (verbose) {
+            SDL_Log("sizeof(Uint8) != 1, instead = %u\n", (unsigned int)sizeof(Uint8));
+        }
         ++error;
     }
     if (badsize(sizeof(Uint16), 2)) {
-        if (verbose)
-            SDL_Log("sizeof(Uint16) != 2, instead = %u\n",
-                   (unsigned int)sizeof(Uint16));
+        if (verbose) {
+            SDL_Log("sizeof(Uint16) != 2, instead = %u\n", (unsigned int)sizeof(Uint16));
+        }
         ++error;
     }
     if (badsize(sizeof(Uint32), 4)) {
-        if (verbose)
-            SDL_Log("sizeof(Uint32) != 4, instead = %u\n",
-                   (unsigned int)sizeof(Uint32));
+        if (verbose) {
+            SDL_Log("sizeof(Uint32) != 4, instead = %u\n", (unsigned int)sizeof(Uint32));
+        }
         ++error;
     }
     if (badsize(sizeof(Uint64), 8)) {
-        if (verbose)
-            SDL_Log("sizeof(Uint64) != 8, instead = %u\n",
-                   (unsigned int)sizeof(Uint64));
+        if (verbose) {
+            SDL_Log("sizeof(Uint64) != 8, instead = %u\n", (unsigned int)sizeof(Uint64));
+        }
         ++error;
     }
-    if (verbose && !error)
+    if (verbose && !error) {
         SDL_Log("All data types are the expected size.\n");
+    }
 
-    return (error ? 1 : 0);
+    return error ? 1 : 0;
 }
 
 int
@@ -169,7 +170,7 @@ TestEndian(SDL_bool verbose)
         }
         ++error;
     }
-    return (error ? 1 : 0);
+    return error ? 1 : 0;
 }
 
 static int TST_allmul (void *a, void *b, int arg, void *result, void *expected)
@@ -376,15 +377,17 @@ Test64Bit (SDL_bool verbose)
         unsigned int *rl = (unsigned int *)&result;
 
         if (!t->routine(&t->a, &t->b, t->arg, &result, &t->expected_result)) {
-            if (verbose)
-                SDL_Log("%s(0x%08X%08X, 0x%08X%08X, %3d, produced: 0x%08X%08X, expected: 0x%08X%08X\n",
-                        t->operation, al[1], al[0], bl[1], bl[0], t->arg, rl[1], rl[0], el[1], el[0]);
+            if (verbose) {
+                SDL_Log("%s(0x%08X%08X, 0x%08X%08X, %3d, produced: 0x%08X%08X, expected: 0x%08X%08X\n", t->operation, al[1], al[0], bl[1], bl[0],
+                        t->arg, rl[1], rl[0], el[1], el[0]);
+            }
             ++failed;
         }
     }
-    if (verbose && (failed == 0))
+    if (verbose && (failed == 0)) {
         SDL_Log("All 64bit instrinsic tests passed\n");
-    return (failed ? 1 : 0);
+    }
+    return failed ? 1 : 0;
 }
 
 int
@@ -411,7 +414,7 @@ TestCPUInfo(SDL_bool verbose)
         SDL_Log("LASX %s\n", SDL_HasLASX()? "detected" : "not detected");
         SDL_Log("System RAM %d MB\n", SDL_GetSystemRAM());
     }
-    return (0);
+    return 0;
 }
 
 int
@@ -440,7 +443,7 @@ TestAssertions(SDL_bool verbose)
             item = item->next;
         }
     }
-    return (0);
+    return 0;
 }
 
 int
diff --git a/test/testqsort.c b/test/testqsort.c
index 29ea05627..0bee0f4a3 100644
--- a/test/testqsort.c
+++ b/test/testqsort.c
@@ -49,8 +49,7 @@ main(int argc, char *argv[])
     int iteration;
     SDLTest_RandomContext rndctx;
 
-    if (argc > 1)
-    {
+    if (argc > 1) {
         int success;
         Uint64 seed = 0;
         if (argv[1][0] == '0' && argv[1][1] == 'x')
@@ -66,9 +65,7 @@ main(int argc, char *argv[])
             return 1;
         }
         SDLTest_RandomInit(&rndctx, (unsigned int)(seed >> 32), (unsigned int)(seed & 0xffffffff));
-    }
-    else
-    {
+    } else {
         SDLTest_RandomInitTime(&rndctx);
     }
     SDL_Log("Using random seed 0x%08x%08x\n", rndctx.x, rndctx.c);
diff --git a/test/testrelative.c b/test/testrelative.c
index 40c670bc9..c058b8228 100644
--- a/test/testrelative.c
+++ b/test/testrelative.c
@@ -35,7 +35,7 @@ DrawRects(SDL_Renderer * renderer)
 }
 
 static void
-loop(){
+loop() {
     /* Check for events */
     while (SDL_PollEvent(&event)) {
         SDLTest_CommonEvent(state, &event, &done);
@@ -51,17 +51,26 @@ loop(){
     for (i = 0; i < state->num_windows; ++i) {
         SDL_Rect viewport;
         SDL_Renderer *renderer = state->renderers[i];
-        if (state->windows[i] == NULL)
+        if (state->windows[i] == NULL) {
             continue;
+        }
         SDL_SetRenderDrawColor(renderer, 0x00, 0x00, 0x00, 0xFF);
         SDL_RenderClear(renderer);
 
         /* Wrap the cursor rectangle at the screen edges to keep it visible */
         SDL_RenderGetViewport(renderer, &viewport);
-        if (rect.x < viewport.x) rect.x += viewport.w;
-        if (rect.y < viewport.y) rect.y += viewport.h;
-        if (rect.x > viewport.x + viewport.w) rect.x -= viewport.w;
-        if (rect.y > viewport.y + viewport.h) rect.y -= viewport.h;
+        if (rect.x < viewport.x) {
+            rect.x += viewport.w;
+        }
+        if (rect.y < viewport.y) {
+            rect.y += viewport.h;
+        }
+        if (rect.x > viewport.x + viewport.w) {
+            rect.x -= viewport.w;
+        }
+        if (rect.y > viewport.y + viewport.h) {
+            rect.y -= viewport.h;
+        }
 
         DrawRects(renderer);
 
@@ -83,7 +92,7 @@ main(int argc, char *argv[])
 
     /* Initialize test framework */
     state = SDLTest_CommonCreateState(argv, SDL_INIT_VIDEO);
-    if (!state) {
+    if (state == NULL) {
         return 1;
     }
     for (i = 1; i < argc; ++i) {
@@ -102,7 +111,7 @@ main(int argc, char *argv[])
     }
 
     srand((unsigned int)time(NULL));
-    if(SDL_SetRelativeMouseMode(SDL_TRUE) < 0) {
+    if (SDL_SetRelativeMouseMode(SDL_TRUE) < 0) {
         return 3;
     }
 
diff --git a/test/testrendercopyex.c b/test/testrendercopyex.c
index b954499e3..8d7ed3a2c 100644
--- a/test/testrendercopyex.c
+++ b/test/testrendercopyex.c
@@ -98,8 +98,9 @@ void loop()
         SDLTest_CommonEvent(state, &event, &done);
     }
     for (i = 0; i < state->num_windows; ++i) {
-        if (state->windows[i] == NULL)
+        if (state->windows[i] == NULL) {
             continue;
+        }
         Draw(&drawstates[i]);
     }
 #ifdef __EMSCRIPTEN__
@@ -121,7 +122,7 @@ main(int argc, char *argv[])
 
     /* Initialize test framework */
     state = SDLTest_CommonCreateState(argv, SDL_INIT_VIDEO);
-    if (!state) {
+    if (state == NULL) {
         return 1;
     }
 
diff --git a/test/testrendertarget.c b/test/testrendertarget.c
index 0848beb36..7143336d9 100644
--- a/test/testrendertarget.c
+++ b/test/testrendertarget.c
@@ -137,7 +137,7 @@ Draw(DrawState *s)
     SDL_RenderGetViewport(s->renderer, &viewport);
 
     target = SDL_CreateTexture(s->renderer, SDL_PIXELFORMAT_ARGB8888, SDL_TEXTUREACCESS_TARGET, viewport.w, viewport.h);
-    if (!target) {
+    if (target == NULL) {
         SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Couldn't create render target texture: %s\n", SDL_GetError());
         return SDL_FALSE;
     }
@@ -183,12 +183,17 @@ loop()
         SDLTest_CommonEvent(state, &event, &done);
     }
     for (i = 0; i < state->num_windows; ++i) {
-        if (state->windows[i] == NULL)
+        if (state->windows[i] == NULL) {
             continue;
+        }
         if (test_composite) {
-            if (!DrawComposite(&drawstates[i])) done = 1;
+            if (!DrawComposite(&drawstates[i])) {
+                done = 1;
+            }
         } else {
-            if (!Draw(&drawstates[i])) done = 1;
+            if (!Draw(&drawstates[i])) {
+                done = 1;
+            }
         }
     }
 #ifdef __EMSCRIPTEN__
@@ -210,7 +215,7 @@ main(int argc, char *argv[])
 
     /* Initialize test framework */
     state = SDLTest_CommonCreateState(argv, SDL_INIT_VIDEO);
-    if (!state) {
+    if (state == NULL) {
         return 1;
     }
     for (i = 1; i < argc;) {
diff --git a/test/testrumble.c b/test/testrumble.c
index 07fc89c58..694e940c8 100644
--- a/test/testrumble.c
+++ b/test/testrumble.c
@@ -79,8 +79,9 @@ main(int argc, char **argv)
         /* Try to find matching device */
         else {
             for (i = 0; i < SDL_NumHaptics(); i++) {
-                if (SDL_strstr(SDL_HapticName(i), name) != NULL)
+                if (SDL_strstr(SDL_HapticName(i), name) != NULL) {
                     break;
+                }
             }
 
             if (i >= SDL_NumHaptics()) {
@@ -130,8 +131,9 @@ main(int argc, char **argv)
     SDL_Delay(2000);
 
     /* Quit */
-    if (haptic != NULL)
+    if (haptic != NULL) {
         SDL_HapticClose(haptic);
+    }
     SDL_Quit();
 
     return 0;
diff --git a/test/testscale.c b/test/testscale.c
index 0f1d21bfe..b9a442463 100644
--- a/test/testscale.c
+++ b/test/testscale.c
@@ -89,8 +89,9 @@ loop()
         SDLTest_CommonEvent(state, &event, &done);
     }
     for (i = 0; i < state->num_windows; ++i) {
-        if (state->windows[i] == NULL)
+        if (state->windows[i] == NULL) {
             continue;
+        }
         Draw(&drawstates[i]);
     }
 #ifdef __EMSCRIPTEN__
@@ -112,7 +113,7 @@ main(int argc, char *argv[])
 
     /* Initialize test framework */
     state = SDLTest_CommonCreateState(argv, SDL_INIT_VIDEO);
-    if (!state) {
+    if (state == NULL) {
         return 1;
     }
 
diff --git a/test/testsem.c b/test/testsem.c
index bac51279d..23d2f514e 100644
--- a/test/testsem.c
+++ b/test/testsem.c
@@ -117,8 +117,9 @@ TestWaitTimeout(void)
     SDL_Log("Wait took %" SDL_PRIu32 " milliseconds\n\n", duration);
 
     /* Check to make sure the return value indicates timed out */
-    if (retval != SDL_MUTEX_TIMEDOUT)
+    if (retval != SDL_MUTEX_TIMEDOUT) {
         SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "SDL_SemWaitTimeout returned: %d; expected: %d\n\n", retval, SDL_MUTEX_TIMEDOUT);
+    }
 
     SDL_DestroySemaphore(sem);
 }
@@ -135,7 +136,7 @@ TestOverheadUncontended(void)
     SDL_Log("Doing %d uncontended Post/Wait operations on semaphore\n", NUM_OVERHEAD_OPS * NUM_OVERHEAD_OPS_MULT);
 
     start_ticks = SDL_GetTicks();
-    for (i = 0; i < NUM_OVERHEAD_OPS_MULT; i++){
+    for (i = 0; i < NUM_OVERHEAD_OPS_MULT; i++) {
         for (j = 0; j < NUM_OVERHEAD_OPS; j++) {
             SDL_SemPost(sem);
         }
@@ -157,14 +158,14 @@ ThreadFuncOverheadContended(void *data)
     Thread_State *state = (Thread_State *) data;
 
     if (state->flag) {
-        while(alive) {
+        while (alive) {
             if (SDL_SemTryWait(sem) == SDL_MUTEX_TIMEDOUT) {
                 ++state->content_count;
             }
             ++state->loop_count;
         }
     } else {
-        while(alive) {
+        while (alive) {
             /* Timeout needed to allow check on alive flag */
             if (SDL_SemWaitTimeout(sem, 50) == SDL_MUTEX_TIMEDOUT) {
                 ++state->content_count;
@@ -251,13 +252,13 @@ main(int argc, char **argv)
 
     if (argc < 2) {
         SDL_Log("Usage: %s init_value\n", argv[0]);
-        return (1);
+        return 1;
     }
 
     /* Load the SDL library */
     if (SDL_Init(0) < 0) {
         SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Couldn't initialize SDL: %s\n", SDL_GetError());
-        return (1);
+        return 1;
     }
     signal(SIGTERM, killed);
     signal(SIGINT, killed);
@@ -276,5 +277,5 @@ main(int argc, char **argv)
     TestOverheadContended(SDL_TRUE);
 
     SDL_Quit();
-    return (0);
+    return 0;
 }
diff --git a/test/testsensor.c b/test/testsensor.c
index 73dd317f9..441460302 100644
--- a/test/testsensor.c
+++ b/test/testsensor.c
@@ -37,7 +37,7 @@ static const char *GetSensorTypeString(SDL_SensorType type)
 static void HandleSensorEvent(SDL_SensorEvent *event)
 {
     SDL_Sensor *sensor = SDL_SensorFromInstanceID(event->which);
-    if (!sensor) {
+    if (sensor == NULL) {
         SDL_Log("Couldn't get sensor for sensor event\n");
         return;
     }
@@ -64,7 +64,7 @@ main(int argc, char **argv)
     /* Load the SDL library */
     if (SDL_Init(SDL_INIT_SENSOR) < 0) {
         SDL_Log("Couldn't initialize SDL: %s\n", SDL_GetError());
-        return (1);
+        return 1;
     }
 
     num_sensors = SDL_NumSensors();
@@ -117,5 +117,5 @@ main(int argc, char **argv)
     }
 
     SDL_Quit();
-    return (0);
+    return 0;
 }
diff --git a/test/testshader.c b/test/testshader.c
index 3c2da590f..3b757e2a7 100644
--- a/test/testshader.c
+++ b/test/testshader.c
@@ -137,7 +137,7 @@ static SDL_bool CompileShader(GLhandleARB shader, const char *source)
 
         glGetObjectParameterivARB(shader, GL_OBJECT_INFO_LOG_LENGTH_ARB, &length);
         info = (char *) SDL_malloc(length + 1);
-        if (!info) {
+        if (info == NULL) {
             SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Out of memory!");
         } else {
             glGetInfoLogARB(shader, length, NULL, info);
@@ -165,7 +165,7 @@ static SDL_bool LinkProgram(ShaderData *data)
 
         glGetObjectParameterivARB(data->program, GL_OBJECT_INFO_LOG_LENGTH_ARB, &length);
         info = (char *) SDL_malloc(length + 1);
-        if (!info) {
+        if (info == NULL) {
             SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Out of memory!");
         } else {
             glGetInfoLogARB(data->program, length, NULL, info);
@@ -463,7 +463,7 @@ int main(int argc, char **argv)
 
     /* Create a 640x480 OpenGL screen */
     window = SDL_CreateWindow( "Shader Demo", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, 640, 480, SDL_WINDOW_OPENGL );
-    if ( !window ) {
+    if (window == NULL) {
         SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Unable to create OpenGL window: %s\n", SDL_GetError());
         SDL_Quit();
         exit(2);
@@ -476,7 +476,7 @@ int main(int argc, char **argv)
     }
 
     surface = SDL_LoadBMP("icon.bmp");
-    if ( ! surface ) {
+    if (surface == NULL) {
         SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Unable to load icon.bmp: %s\n", SDL_GetError());
         SDL_Quit();
         exit(3);
diff --git a/test/testshape.c b/test/testshape.c
index 1497528a9..67fa6f74f 100644
--- a/test/testshape.c
+++ b/test/testshape.c
@@ -58,30 +58,32 @@ int main(int argc,char** argv)
     /* Enable standard application logging */
     SDL_LogSetPriority(SDL_LOG_CATEGORY_APPLICATION, SDL_LOG_PRIORITY_INFO);
 
-    if(argc < 2) {
+    if (argc < 2) {
         SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "SDL_Shape requires at least one bitmap file as argument.");
         exit(-1);
     }
 
-    if(SDL_VideoInit(NULL) == -1) {
+    if (SDL_VideoInit(NULL) == -1) {
         SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not initialize SDL video.");
         exit(-2);
     }
 
     num_pictures = argc - 1;
     pictures = (LoadedPicture *)SDL_malloc(sizeof(LoadedPicture)*num_pictures);
-    if (!pictures) {
+    if (pictures == NULL) {
         SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not allocate memory.");
         exit(1);
     }
-    for(i=0;i<num_pictures;i++)
+    for (i = 0; i < num_pictures; i++) {
         pictures[i].surface = NULL;
-    for(i=0;i<num_pictures;i++) {
+    }
+    for (i=0;i<num_pictures;i++) {
         pictures[i].surface = SDL_LoadBMP(argv[i+1]);
         pictures[i].name = argv[i+1];
-        if(pictures[i].surface == NULL) {
-            for(j=0;j<num_pictures;j++)
+        if (pictures[i].surface == NULL) {
+            for (j = 0; j < num_pictures; j++) {
                 SDL_FreeSurface(pictures[j].surface);
+            }
             SDL_free(pictures);
             SDL_VideoQuit();
             SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not load surface from named bitmap file: %s", argv[i+1]);
@@ -89,11 +91,10 @@ int main(int argc,char** argv)
         }
 
         format = pictures[i].surface->format;
-        if(SDL_ISPIXELFORMAT_ALPHA(format->format)) {
+        if (SDL_ISPIXELFORMAT_ALPHA(format->format)) {
             pictures[i].mode.mode = ShapeModeBinarizeAlpha;
             pictures[i].mode.parameters.binarizationCutoff = 255;
-        }
-        else {
+        } else {
             pictures[i].mode.mode = ShapeModeColorKey;
             pictures[i].mode.parameters.colorKey = black;
         }
@@ -104,35 +105,41 @@ int main(int argc,char** argv)
         SHAPED_WINDOW_DIMENSION,SHAPED_WINDOW_DIMENSION,
         0);
     SDL_SetWindowPosition(window, SHAPED_WINDOW_X, SHAPED_WINDOW_Y);
-    if(window == NULL) {
-        for(i=0;i<num_pictures;i++)
+    if (window == NULL) {
+        for (i = 0; i < num_pictures; i++) {
             SDL_FreeSurface(pictures[i].surface);
+        }
         SDL_free(pictures);
         SDL_VideoQuit();
         SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not create shaped window for SDL_Shape.");
         exit(-4);
     }
     renderer = SDL_CreateRenderer(window,-1,0);
-    if (!renderer) {
+    if (renderer == NULL) {
         SDL_DestroyWindow(window);
-        for(i=0;i<num_pictures;i++)
+        for (i = 0; i < num_pictures; i++) {
             SDL_FreeSurface(pictures[i].surface);
+        }
         SDL_free(pictures);
         SDL_VideoQuit();
         SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not create rendering context for SDL_Shape window.");
         exit(-5);
     }
 
-    for(i=0;i<num_pictures;i++)
+    for (i = 0; i < num_pictures; i++) {
         pictures[i].texture = NULL;
-    for(i=0;i<num_pictures;i++) {
+    }
+    for (i=0;i<num_pictures;i++) {
         pictures[i].texture = SDL_CreateTextureFromSurface(renderer,pictures[i].surface);
-        if(pictures[i].texture == NULL) {
-            for(i=0;i<num_pictures;i++)
-                if(pictures[i].texture != NULL)
+        if (pictures[i].texture == NULL) {
+            for (i=0;i<num_pictures;i++) {
+                if (pictures[i].texture != NULL) {
                     SDL_DestroyTexture(pictures[i].texture);
-            for(i=0;i<num_pictures;i++)
+                }
+            }
+            for (i = 0; i < num_pictures; i++) {
                 SDL_FreeSurface(pictures[i].surface);
+            }
             SDL_free(pictures);
             SDL_DestroyRenderer(renderer);
             SDL_DestroyWindow(window);
@@ -153,20 +160,21 @@ int main(int argc,char** argv)
     SDL_QueryTexture(pictures[current_picture].texture,(Uint32 *)&pixelFormat,(int *)&access,&texture_dimensions.w,&texture_dimensions.h);
     SDL_SetWindowSize(window,texture_dimensions.w,texture_dimensions.h);
     SDL_SetWindowShape(window,pictures[current_picture].surface,&pictures[current_picture].mode);
-    while(should_exit == 0) {
+    while (should_exit == 0) {
         while (SDL_PollEvent(&event)) {
-            if(event.type == SDL_KEYDOWN) {
+            if (event.type == SDL_KEYDOWN) {
                 button_down = 1;
-                if(event.key.keysym.sym == SDLK_ESCAPE) {
+                if (event.key.keysym.sym == SDLK_ESCAPE) {
                     should_exit = 1;
                     break;
                 }
             }
-            if(button_down && event.type == SDL_KEYUP) {
+            if (button_down && event.type == SDL_KEYUP) {
                 button_down = 0;
                 current_picture += 1;
-                if(current_picture >= num_pictures)
+                if (current_picture >= num_pictures) {
                     current_picture = 0;
+                }
                 SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "Changing to shaped bmp: %s", pictures[current_picture].name);
                 SDL_QueryTexture(pictures[current_picture].texture,(Uint32 *)&pixelFormat,(int *)&access,&texture_dimensions.w,&texture_dimensions.h);
                 SDL_SetWindowSize(window,texture_dimensions.w,texture_dimensions.h);
@@ -182,14 +190,16 @@ int main(int argc,char** argv)
     }
 
     /* Free the textures. */
-    for(i=0;i<num_pictures;i++)
+    for (i = 0; i < num_pictures; i++) {
         SDL_DestroyTexture(pictures[i].texture);
+    }
     SDL_DestroyRenderer(renderer);
     /* Destroy the window. */
     SDL_DestroyWindow(window);
     /* Free the original surfaces backing the textures. */
-    for(i=0;i<num_pictures;i++)
+    for (i = 0; i < num_pictures; i++) {
         SDL_FreeSurface(pictures[i].surface);
+    }
     SDL_free(pictures);
     /* Call SDL_VideoQuit() before quitting. */
     SDL_VideoQuit();
diff --git a/test/testsprite2.c b/test/testsprite2.c
index a91ddd86e..5b63bead3 100644
--- a/test/testsprite2.c
+++ b/test/testsprite2.c
@@ -73,17 +73,17 @@ LoadSprite(const char *file)
         /* This does the SDL_LoadBMP step repeatedly, but that's OK for test code. */
         sprites[i] = LoadTexture(state->renderers[i], file, SDL_TRUE, &sprite_w, &sprite_h);
         if (!sprites[i]) {
-            return (-1);
+            return -1;
         }
         if (SDL_SetTextureBlendMode(sprites[i], blendMode) < 0) {
             SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Couldn't set blend mode: %s\n", SDL_GetError());
             SDL_DestroyTexture(sprites[i]);
-            return (-1);
+            return -1;
         }
     }
 
     /* We're ready to roll. :) */
-    return (0);
+    return 0;
 }
 
 void
@@ -407,8 +407,9 @@ loop()
         SDLTest_CommonEvent(state, &event, &done);
     }
     for (i = 0; i < state->num_windows; ++i) {
-        if (state->windows[i] == NULL)
+        if (state->windows[i] == NULL) {
             continue;
+        }
         MoveSprites(state->renderers[i], sprites[i]);
     }
 #ifdef __EMSCRIPTEN__
@@ -442,7 +443,7 @@ main(int argc, char *argv[])
 
     /* Initialize test framework */
     state = SDLTest_CommonCreateState(argv, SDL_INIT_VIDEO);
-    if (!state) {
+    if (state == NULL) {
         return 1;
     }
 
@@ -474,7 +475,9 @@ main(int argc, char *argv[])
             } else if (SDL_strcasecmp(argv[i], "--iterations") == 0) {
                 if (argv[i + 1]) {
                     iterations = SDL_atoi(argv[i + 1]);
-                    if (iterations < -1) iterations = -1;
+                    if (iterations < -1) {
+                        iterations = -1;
+                    }
                     consumed = 2;
                 }
             } else if (SDL_strcasecmp(argv[i], "--cyclecolor") == 0) {
@@ -527,7 +530,7 @@ main(int argc, char *argv[])
     /* Create the windows, initialize the renderers, and load the textures */
     sprites =
         (SDL_Texture **) SDL_malloc(state->num_windows * sizeof(*sprites));
-    if (!sprites) {
+    if (sprites == NULL) {
         SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Out of memory!\n");
         quit(2);
     }
@@ -543,7 +546,7 @@ main(int argc, char *argv[])
     /* Allocate memory for the sprite info */
     positions = (SDL_Rect *) SDL_malloc(num_sprites * sizeof(SDL_Rect));
     velocities = (SDL_Rect *) SDL_malloc(num_sprites * sizeof(SDL_Rect));
-    if (!positions || !velocities) {
+    if (positions == NULL || velocities == NULL) {
         SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Out of memory!\n");
         quit(2);
     }
diff --git a/test/teststreaming.c b/test/teststreaming.c
index dc3ae61d6..e2ad9c180 100644
--- a/test/teststreaming.c
+++ b/test/teststreaming.c
@@ -161,19 +161,19 @@ main(int argc, char **argv)
                               SDL_WINDOWPOS_UNDEFINED,
                               MOOSEPIC_W*4, MOOSEPIC_H*4,
                               SDL_WINDOW_RESIZABLE);
-    if (!window) {
+    if (window == NULL) {
         SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Couldn't set create window: %s\n", SDL_GetError());
         quit(3);
     }
 
     renderer = SDL_CreateRenderer(window, -1, 0);
-    if (!renderer) {
+    if (renderer == NULL) {
         SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Couldn't set create renderer: %s\n", SDL_GetError());
         quit(4);
     }
 
     MooseTexture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_ARGB8888, SDL_TEXTUREACCESS_STREAMING, MOOSEPIC_W, MOOSEPIC_H);
-    if (!MooseTexture) {
+    if (MooseTexture == NULL) {
         SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Couldn't set create texture: %s\n", SDL_GetError());
         quit(5);
     }
diff --git a/test/testthread.c b/test/testthread.c
index ea94dfb2e..894f994c4 100644
--- a/test/testthread.c
+++ b/test/testthread.c
@@ -57,14 +57,15 @@ ThreadFunc(void *data)
 
         if (testprio) {
             SDL_Log("SDL_SetThreadPriority(%s):%d\n", getprioritystr(prio), SDL_SetThreadPriority(prio));
-            if (++prio > SDL_THREAD_PRIORITY_TIME_CRITICAL)
+            if (++prio > SDL_THREAD_PRIORITY_TIME_CRITICAL) {
                 prio = SDL_THREAD_PRIORITY_LOW;
+            }
         }
 
         SDL_Delay(1 * 1000);
     }
     SDL_Log("Thread '%s' exiting!\n", (char *) data);
-    return (0);
+    return 0;
 }
 
 static void
@@ -88,7 +89,7 @@ main(int argc, char *argv[])
     /* Load the SDL library */
     if (SDL_Init(0) < 0) {
         SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Couldn't initialize SDL: %s\n", SDL_GetError());
-        return (1);
+        return 1;
     }
 
     if (SDL_getenv("SDL_TESTS_QUICK") != NULL) {
@@ -132,5 +133,5 @@ main(int argc, char *argv[])
     raise(SIGTERM);
 
     SDL_Quit();                 /* Never reached */
-    return (0);                 /* Never reached */
+    return 0;                 /* Never reached */
 }
diff --git a/test/testtimer.c b/test/testtimer.c
index 126ba3be2..5dd17abf2 100644
--- a/test/testtimer.c
+++ b/test/testtimer.c
@@ -27,7 +27,7 @@ static Uint32 SDLCALL
 ticktock(Uint32 interval, void *param)
 {
     ++ticks;
-    return (interval);
+    return interval;
 }
 
 static Uint32 SDLCALL
@@ -51,7 +51,7 @@ main(int argc, char *argv[])
 
     if (SDL_Init(SDL_INIT_TIMER) < 0) {
         SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Couldn't initialize SDL: %s\n", SDL_GetError());
-        return (1);
+        return 1;
     }
 
     if (SDL_getenv("SDL_TESTS_QUICK") != NULL) {
@@ -101,14 +101,17 @@ main(int argc, char *argv[])
     /* Test multiple timers */
     SDL_Log("Testing multiple timers...\n");
     t1 = SDL_AddTimer(100, callback, (void *) 1);
-    if (!t1)
-        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION,"Could not create timer 1: %s\n", SDL_GetError());
+    if (!t1) {
+        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not create timer 1: %s\n", SDL_GetError());
+    }
     t2 = SDL_AddTimer(50, callback, (void *) 2);
-    if (!t2)
-        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION,"Could not create timer 2: %s\n", SDL_GetError());
+    if (!t2) {
+        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not create timer 2: %s\n", SDL_GetError());
+    }
     t3 = SDL_AddTimer(233, callback, (void *) 3);
-    if (!t3)
-        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION,"Could not create timer 3: %s\n", SDL_GetError());
+    if (!t3) {
+        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not create timer 3: %s\n", SDL_GetError());
+    }
 
     /* Wait 10 seconds */
     SDL_Log("Waiting 10 seconds\n");
@@ -140,7 +143,7 @@ main(int argc, char *argv[])
     SDL_Log("Delay 1 second = %d ms in ticks, %d ms in ticks64, %f ms according to performance counter\n", (int) (now32-start32), (int) (now64-start64), (double)((now - start)*1000) / SDL_GetPerformanceFrequency());
 
     SDL_Quit();
-    return (0);
+    return 0;
 }
 
 /* vi: set ts=4 sw=4 expandtab: */
diff --git a/test/testutils.c b/test/testutils.c
index a93afc1ad..765340b5f 100644
--- a/test/testutils.c
+++ b/test/testutils.c
@@ -139,7 +139,7 @@ LoadTexture(SDL_Renderer *renderer, const char *file, SDL_bool transparent,
         }
 
         texture = SDL_CreateTextureFromSurface(renderer, temp);
-        if (!texture) {
+        if (texture == NULL) {
             SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Couldn't create texture: %s\n", SDL_GetError());
         }
     }
diff --git a/test/testver.c b/test/testver.c
index cbbba7ec6..f452b9c2b 100644
--- a/test/testver.c
+++ b/test/testver.c
@@ -43,5 +43,5 @@ main(int argc, char *argv[])
            linked.major, linked.minor, linked.patch,
            SDL_GetRevision());
     SDL_Quit();
-    return (0);
+    return 0;
 }
diff --git a/test/testviewport.c b/test/testviewport.c
index ad5faf77a..ecdb4307f 100644
--- a/test/testviewport.c
+++ b/test/testviewport.c
@@ -103,8 +103,9 @@ loop()
     int i;
 #ifdef __EMSCRIPTEN__
     /* Avoid using delays */
-    if(SDL_GetTicks() - wait_start < 1000)
+    if (SDL_GetTicks() - wait_start < 1000) {
         return;
+    }
     wait_start = SDL_GetTicks();
 #endif
     /* Check for events */
@@ -121,8 +122,9 @@ loop()
     SDL_Log("Current Viewport x=%i y=%i w=%i h=%i", viewport.x, viewport.y, viewport.w, viewport.h);
 
     for (i = 0; i < state->num_windows; ++i) {
-        if (state->windows[i] == NULL)
+        if (state->windows[i] == NULL) {
             continue;
+        }
 
         /* Draw using viewport */
         DrawOnViewport(state->renderers[i]);
@@ -153,7 +155,7 @@ main(int argc, char *argv[])
 
     /* Initialize test framework */
     state = SDLTest_CommonCreateState(argv, SDL_INIT_VIDEO);
-    if (!state) {
+    if (state == NULL) {
         return 1;
     }
 
diff --git a/test/testvulkan.c b/test/testvulkan.c
index 4b65179c1..4fe2c10be 100644
--- a/test/testvulkan.c
+++ b/test/testvulkan.c
@@ -233,7 +233,7 @@ static void createInstance(void)
         quit(2);
     }
     extensions = (const char **) SDL_malloc(sizeof(const char *) * extensionCount);
-    if (!extensions) {
+    if (extensions == NULL) {
         SDL_OutOfMemory();
         quit(2);
     }
@@ -309,7 +309,7 @@ static void findPhysicalDevice(void)
         quit(2);
     }
     physicalDevices = (VkPhysicalDevice *) SDL_malloc(sizeof(VkPhysicalDevice) * physicalDeviceCount);
-    if (!physicalDevices) {
+    if (physicalDevices == NULL) {
         SDL_OutOfMemory();
         quit(2);
     }
@@ -331,7 +331,7 @@ static void findPhysicalDevice(void)
 
         VkPhysicalDevice physicalDevice = physicalDevices[physicalDeviceIndex];
         vkGetPhysicalDeviceProperties(physicalDevice, &vulkanContext->physicalDeviceProperties);
-        if(VK_VERSION_MAJOR(vulkanContext->physicalDeviceProperties.apiVersion) < 1) {
+        if (VK_VERSION_MAJOR(vulkanContext->physicalDeviceProperties.apiVersion) < 1) {
             continue;
         }
         vkGetPhysicalDeviceFeatures(physicalDevice, &vulkanContext->physicalDeviceFeatures);
@@ -343,7 +343,7 @@ static void findPhysicalDevice(void)
             SDL_free(queueFamiliesProperties);
             queueFamiliesPropertiesAllocatedSize = queueFamiliesCount;
             queueFamiliesProperties = (VkQueueFamilyProperties *) SDL_malloc(sizeof(VkQueueFamilyProperties) * queueFamiliesPropertiesAllocatedSize);
-            if (!queueFamiliesProperties) {
+            if (queueFamiliesProperties == NULL) {
                 SDL_free(physicalDevices);
                 SDL_free(deviceExtensions);
                 SDL_OutOfMemory();
@@ -389,8 +389,7 @@ static void findPhysicalDevice(void)
             continue;
         }
         result = vkEnumerateDeviceExtensionProperties(physicalDevice, NULL, &deviceExtensionCount, NULL);
-        if (result != VK_SUCCESS)
-        {
+        if (result != VK_SUCCESS) {
             SDL_free(physicalDevices);
             SDL_free(queueFamiliesProperties);
             SDL_free(deviceExtensions);
@@ -406,7 +405,7 @@ static void findPhysicalDevice(void)
             SDL_free(deviceExtensions);
             deviceExtensionsAllocatedSize = deviceExtensionCount;
             deviceExtensions = SDL_malloc(sizeof(VkExtensionProperties) * deviceExtensionsAllocatedSize);
-            if (!deviceExtensions) {
+            if (deviceExtensions == NULL) {
                 SDL_free(physicalDevices);
                 SDL_free(queueFamiliesProperties);
                 SDL_OutOfMemory();
@@ -424,7 +423,7 @@ static void findPhysicalDevice(void)
             quit(2);
         }
         for (i = 0; i < deviceExtensionCount; i++) {
-            if(SDL_strcmp(deviceExtensions[i].extensionName, VK_KHR_SWAPCHAIN_EXTENSION_NAME) == 0) {
+            if (SDL_strcmp(deviceExtensions[i].extensionName, VK_KHR_SWAPCHAIN_EXTENSION_NAME) == 0) {
                 hasSwapchainExtension = SDL_TRUE;
                 break;
             }
@@ -641,7 +640,7 @@ static SDL_bool createSwapchain(void)
     } else {
         vulkanContext->surfaceFormat = vulkanContext->surfaceFormats[0];
         for (i = 0; i < vulkanContext->surfaceFormatsCount; i++) {
-            if(vulkanContext->surfaceFormats[i].format == VK_FORMAT_R8G8B8A8_UNORM) {
+            if (vulkanContext->surfaceFormats[i].format == VK_FORMAT_R8G8B8A8_UNORM) {
                 vulkanContext->surfaceFormat = vulkanContext->surfaceFormats[i];
                 break;
             }
@@ -687,7 +686,7 @@ static SDL_bool createSwapchain(void)
         vkDestroySwapchainKHR(vulkanContext->device, createInfo.oldSwapchain, NULL);
     }
 
-    if(result != VK_SUCCESS) {
+    if (result != VK_SUCCESS) {
         vulkanContext->swapchain = VK_NULL_HANDLE;
         SDL_LogError(SDL_LOG_CATEGORY_APPLICATION,
                      "vkCreateSwapchainKHR(): %s\n",
@@ -756,7 +755,7 @@ static void createCommandBuffers(void)
     allocateInfo.commandBufferCount = vulkanContext->swapchainImageCount;
     vulkanContext->commandBuffers = (VkCommandBuffer *) SDL_malloc(sizeof(VkCommandBuffer) * vulkanContext->swapchainImageCount);
     result = vkAllocateCommandBuffers(vulkanContext->device, &allocateInfo, vulkanContext->commandBuffers);
-    if(result != VK_SUCCESS) {
+    if (result != VK_SUCCESS) {
         SDL_free(vulkanContext->commandBuffers);
         vulkanContext->commandBuffers = NULL;
         SDL_LogError(SDL_LOG_CATEGORY_APPLICATION,
@@ -781,8 +780,8 @@ static void createFences(void)
         createInfo.sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;
         createInfo.flags = VK_FENCE_CREATE_SIGNALED_BIT;
         result = vkCreateFence(vulkanContext->device, &createInfo, NULL, &vulkanContext->fences[i]);
-        if(result != VK_SUCCESS) {
-            for(; i > 0; i--) {
+        if (result != VK_SUCCESS) {
+            for (; i > 0; i--) {
                 vkDestroyFence(vulkanContext->device, vulkanContext->fences[i - 1], NULL);
             }
             SDL_free(vulkanContext->fences);
@@ -851,7 +850,7 @@ static void rerecordCommandBuffer(uint32_t frameIndex, const VkClearColorValue *
     VkImageSubresourceRange clearRange = {0};
 
     VkResult result = vkResetCommandBuffer(commandBuffer, 0);
-    if(result != VK_SUCCESS) {
+    if (result != VK_SUCCESS) {
         SDL_LogError(SDL_LOG_CATEGORY_APPLICATION,
                      "vkResetCommandBuffer(): %s\n",
                      getVulkanResultString(result));
@@ -909,7 +908,7 @@ static SDL_bool createNewSwapchainAndSwapchainSpecificStuff(void)
     destroySwapchainAndSwapchainSpecificStuff(SDL_FALSE);
     getSurfaceCaps();
     getSurfaceFormats();
-    if(!createSwapchain()) {
+    if (!createSwapchain()) {
         return SDL_FALSE;
     }
     createCommandPool();
@@ -925,7 +924,7 @@ static void initVulkan(void)
     SDL_Vulkan_LoadLibrary(NULL);
 
     vulkanContexts = (VulkanContext *) SDL_calloc(state->num_windows, sizeof (VulkanContext));
-    if (!vulkanContexts) {
+    if (vulkanContexts == NULL) {
         SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Out of memory!");
         quit(2);
     }
@@ -1000,8 +999,9 @@ static SDL_bool render(void)
 
     if (!vulkanContext->swapchain) {
         SDL_bool retval = createNewSwapchainAndSwapchainSpecificStuff();
-        if(!retval)
+        if (!retval) {
             SDL_Delay(100);
+        }
         return retval;
     }
     result = vkAcquireNextImageKHR(vulkanContext->device,
@@ -1068,7 +1068,7 @@ static SDL_bool render(void)
         quit(2);
     }
     SDL_Vulkan_GetDrawableSize(vulkanContext->window, &w, &h);
-    if(w != (int)vulkanContext->swapchainSize.width || h != (int)vulkanContext->swapchainSize.height) {
+    if (w != (int)vulkanContext->swapchainSize.width || h != (int)vulkanContext->swapchainSize.height) {
         return createNewSwapchainAndSwapchainSpecificStuff();
     }
     return SDL_TRUE;
@@ -1087,7 +1087,7 @@ int main(int argc, char **argv)
 
     /* Initialize test framework */
     state = SDLTest_CommonCreateState(argv, SDL_INIT_VIDEO);
-    if(!state) {
+    if (state == NULL) {
         return 1;
     }
 
@@ -1117,7 +1117,7 @@ int main(int argc, char **argv)
     while (!done) {
         /* Check for events */
         frames++;
-        while(SDL_PollEvent(&event)) {
+        while (SDL_PollEvent(&event)) {
             /* Need to destroy the swapchain before the window created
              * by SDL.
              */
diff --git a/test/testwm2.c b/test/testwm2.c
index eeb8d8e51..7fe8238f1 100644
--- a/test/testwm2.c
+++ b/test/testwm2.c
@@ -264,7 +264,7 @@ main(int argc, char *argv[])
 
     /* Initialize test framework */
     state = SDLTest_CommonCreateState(argv, SDL_INIT_VIDEO);
-    if (!state) {
+    if (state == NULL) {
         return 1;
     }
 
@@ -295,7 +295,7 @@ main(int argc, char *argv[])
 
     quit(0);
     /* keep the compiler happy ... */
-    return(0);
+    return 0;
 }
 
 /* vi: set ts=4 sw=4 expandtab: */
diff --git a/test/testyuv.c b/test/testyuv.c
index df0d94381..a09490637 100644
--- a/test/testyuv.c
+++ b/test/testyuv.c
@@ -25,9 +25,7 @@
 /* Return true if the YUV format is packed pixels */
 static SDL_bool is_packed_yuv_format(Uint32 format)
 {
-    return (format == SDL_PIXELFORMAT_YUY2 ||
-            format == SDL_PIXELFORMAT_UYVY ||
-            format == SDL_PIXELFORMAT_YVYU);
+    return format == SDL_PIXELFORMAT_YUY2 || format == SDL_PIXELFORMAT_UYVY || format == SDL_PIXELFORMAT_YVYU;
 }
 
 /* Create a surface with a good pattern for verifying YUV conversion */
@@ -79,7 +77,7 @@ static SDL_bool verify_yuv_data(Uint32 format, const Uint8 *yuv, int yuv_pitch,
     SDL_bool result = SDL_FALSE;
 
     rgb = (Uint8 *)SDL_malloc(size);
-    if (!rgb) {
+    if (rgb == NULL) {
         SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Out of memory");
         return SDL_FALSE;
     }
@@ -130,7 +128,7 @@ static int run_automated_tests(int pattern_size, int extra_pitch)
     int yuv1_pitch, yuv2_pitch;
     int result = -1;
     
-    if (!pattern || !yuv1 || !yuv2) {
+    if (pattern == NULL || yuv1 == NULL || yuv2 == NULL) {
         SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Couldn't allocate test surfaces");
         goto done;
     }
@@ -332,7 +330,7 @@ main(int argc, char **argv)
         filename = "testyuv.bmp";
     }
     original = SDL_ConvertSurfaceFormat(SDL_LoadBMP(filename), SDL_PIXELFORMAT_RGB24, 0);
-    if (!original) {
+    if (original == NULL) {
         SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Couldn't load %s: %s\n", filename, SDL_GetError());
         return 3;
     }
@@ -344,7 +342,7 @@ main(int argc, char **argv)
     pitch = CalculateYUVPitch(yuv_format, original->w);
 
     converted = SDL_CreateRGBSurfaceWithFormat(0, original->w, original->h, 0, rgb_format);
-    if (!converted) {
+    if (converted == NULL) {
         SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Couldn't create converted surface: %s\n", SDL_GetError());
         return 3;
     }
@@ -361,13 +359,13 @@ main(int argc, char **argv)
                               SDL_WINDOWPOS_UNDEFINED,
                               original->w, original->h,
                               0);
-    if (!window) {
+    if (window == NULL) {
         SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Couldn't create window: %s\n", SDL_GetError());
         return 4;
     }
 
     renderer = SDL_CreateRenderer(window, -1, 0);
-    if (!renderer) {
+    if (renderer == NULL) {
         SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Couldn't create renderer: %s\n", SDL_GetError());
         return 4;
     }
@@ -402,8 +400,7 @@ main(int argc, char **argv)
     }
 
     { int done = 0;
-        while ( !done )
-        {
+        while ( !done ) {
             SDL_Event event;
             while (SDL_PollEvent(&event) > 0) {
                 if (event.type == SDL_QUIT) {
diff --git a/test/testyuv_cvt.c b/test/testyuv_cvt.c
index ed354d8ac..f058f5c54 100644
--- a/test/testyuv_cvt.c
+++ b/test/testyuv_cvt.c
@@ -17,7 +17,7 @@
 
 static float clip3(float x, float y, float z)
 {
-    return ((z < x) ? x : ((z > y) ? y : z));
+    return (z < x) ? x : ((z > y) ? y : z);
 }
 
 static void RGBtoYUV(Uint8 * rgb, int *yuv, SDL_YUV_CONVERSION_MODE mode, int monochrome, int luminance)
@@ -68,8 +68,9 @@ static void RGBtoYUV(Uint8 * rgb, int *yuv, SDL_YUV_CONVERSION_MODE mode, int mo
 
     if (luminance != 100) {
         yuv[0] = yuv[0] * luminance / 100;
-        if (yuv[0] > 255)
+        if (yuv[0] > 255) {
             yuv[0] = 255;
+        }
     }
 }
 
@@ -291,7 +292,7 @@ int CalculateYUVPitch(Uint32 format, int width)
     case SDL_PIXELFORMAT_YUY2:
     case SDL_PIXELFORMAT_UYVY:
     case SDL_PIXELFORMAT_YVYU:
-        return 4*((width + 1)/2);
+        return 4 * ((width + 1) / 2);
     default:
         return 0;
     }
diff --git a/test/torturethread.c b/test/torturethread.c
index d76f07755..8c67569d6 100644
--- a/test/torturethread.c
+++ b/test/torturethread.c
@@ -85,7 +85,7 @@ main(int argc, char *argv[])
     /* Load the SDL library */
     if (SDL_Init(0) < 0) {
         SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Couldn't initialize SDL: %s\n", SDL_GetError());
-        return (1);
+        return 1;
     }
 
     signal(SIGSEGV, SIG_DFL);
@@ -109,5 +109,5 @@ main(int argc, char *argv[])
         SDL_WaitThread(threads[i], NULL);
     }
     SDL_Quit();
-    return (0);
+    return 0;
 }
-- 
2.17.1

